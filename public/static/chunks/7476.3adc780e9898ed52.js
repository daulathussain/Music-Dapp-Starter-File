(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
    [7476, 4578, 5857, 6808, 2014, 4276], {
        16158: function(r, l, C) {
            "use strict";
            l._O = l.Jq = l.KB = l.u8 = l.cv = void 0, l.Ik = l.A9 = l.n_ = l.gM = void 0;
            let U = C(97115);

            function checkUint8Array(r) {
                if (!(r instanceof Uint8Array)) throw TypeError("b must be a Uint8Array")
            }

            function uint8ArrayToBuffer(r) {
                return checkUint8Array(r), U.Buffer.from(r.buffer, r.byteOffset, r.length)
            }
            let Layout = class Layout {
                constructor(r, l) {
                    if (!Number.isInteger(r)) throw TypeError("span must be an integer");
                    this.span = r, this.property = l
                }
                makeDestinationObject() {
                    return {}
                }
                getSpan(r, l) {
                    if (0 > this.span) throw RangeError("indeterminate span");
                    return this.span
                }
                replicate(r) {
                    let l = Object.create(this.constructor.prototype);
                    return Object.assign(l, this), l.property = r, l
                }
                fromArray(r) {}
            };

            function nameWithProperty(r, l) {
                return l.property ? r + "[" + l.property + "]" : r
            }
            let ExternalLayout = class ExternalLayout extends Layout {
                isCount() {
                    throw Error("ExternalLayout is abstract")
                }
            };
            let OffsetLayout = class OffsetLayout extends ExternalLayout {
                constructor(r, l = 0, C) {
                    if (!(r instanceof Layout)) throw TypeError("layout must be a Layout");
                    if (!Number.isInteger(l)) throw TypeError("offset must be integer or undefined");
                    super(r.span, C || r.property), this.layout = r, this.offset = l
                }
                isCount() {
                    return this.layout instanceof UInt || this.layout instanceof UIntBE
                }
                decode(r, l = 0) {
                    return this.layout.decode(r, l + this.offset)
                }
                encode(r, l, C = 0) {
                    return this.layout.encode(r, l, C + this.offset)
                }
            };
            let UInt = class UInt extends Layout {
                constructor(r, l) {
                    if (super(r, l), 6 < this.span) throw RangeError("span must not exceed 6 bytes")
                }
                decode(r, l = 0) {
                    return uint8ArrayToBuffer(r).readUIntLE(l, this.span)
                }
                encode(r, l, C = 0) {
                    return uint8ArrayToBuffer(l).writeUIntLE(r, C, this.span), this.span
                }
            };
            let UIntBE = class UIntBE extends Layout {
                constructor(r, l) {
                    if (super(r, l), 6 < this.span) throw RangeError("span must not exceed 6 bytes")
                }
                decode(r, l = 0) {
                    return uint8ArrayToBuffer(r).readUIntBE(l, this.span)
                }
                encode(r, l, C = 0) {
                    return uint8ArrayToBuffer(l).writeUIntBE(r, C, this.span), this.span
                }
            };

            function divmodInt64(r) {
                let l = Math.floor(r / 4294967296);
                return {
                    hi32: l,
                    lo32: r - 4294967296 * l
                }
            }

            function roundedInt64(r, l) {
                return 4294967296 * r + l
            }
            let NearUInt64 = class NearUInt64 extends Layout {
                constructor(r) {
                    super(8, r)
                }
                decode(r, l = 0) {
                    let C = uint8ArrayToBuffer(r),
                        U = C.readUInt32LE(l),
                        et = C.readUInt32LE(l + 4);
                    return roundedInt64(et, U)
                }
                encode(r, l, C = 0) {
                    let U = divmodInt64(r),
                        et = uint8ArrayToBuffer(l);
                    return et.writeUInt32LE(U.lo32, C), et.writeUInt32LE(U.hi32, C + 4), 8
                }
            };
            let NearInt64 = class NearInt64 extends Layout {
                constructor(r) {
                    super(8, r)
                }
                decode(r, l = 0) {
                    let C = uint8ArrayToBuffer(r),
                        U = C.readUInt32LE(l),
                        et = C.readInt32LE(l + 4);
                    return roundedInt64(et, U)
                }
                encode(r, l, C = 0) {
                    let U = divmodInt64(r),
                        et = uint8ArrayToBuffer(l);
                    return et.writeUInt32LE(U.lo32, C), et.writeInt32LE(U.hi32, C + 4), 8
                }
            };
            let Sequence = class Sequence extends Layout {
                constructor(r, l, C) {
                    if (!(r instanceof Layout)) throw TypeError("elementLayout must be a Layout");
                    if (!(l instanceof ExternalLayout && l.isCount() || Number.isInteger(l) && 0 <= l)) throw TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
                    let U = -1;
                    l instanceof ExternalLayout || !(0 < r.span) || (U = l * r.span), super(U, C), this.elementLayout = r, this.count = l
                }
                getSpan(r, l = 0) {
                    if (0 <= this.span) return this.span;
                    let C = 0,
                        U = this.count;
                    if (U instanceof ExternalLayout && (U = U.decode(r, l)), 0 < this.elementLayout.span) C = U * this.elementLayout.span;
                    else {
                        let et = 0;
                        for (; et < U;) C += this.elementLayout.getSpan(r, l + C), ++et
                    }
                    return C
                }
                decode(r, l = 0) {
                    let C = [],
                        U = 0,
                        et = this.count;
                    for (et instanceof ExternalLayout && (et = et.decode(r, l)); U < et;) C.push(this.elementLayout.decode(r, l)), l += this.elementLayout.getSpan(r, l), U += 1;
                    return C
                }
                encode(r, l, C = 0) {
                    let U = this.elementLayout,
                        et = r.reduce((r, et) => r + U.encode(et, l, C + r), 0);
                    return this.count instanceof ExternalLayout && this.count.encode(r.length, l, C), et
                }
            };
            let Structure = class Structure extends Layout {
                constructor(r, l, C) {
                    if (!(Array.isArray(r) && r.reduce((r, l) => r && l instanceof Layout, !0))) throw TypeError("fields must be array of Layout instances");
                    for (let U of ("boolean" == typeof l && void 0 === C && (C = l, l = void 0), r))
                        if (0 > U.span && void 0 === U.property) throw Error("fields cannot contain unnamed variable-length layout");
                    let U = -1;
                    try {
                        U = r.reduce((r, l) => r + l.getSpan(), 0)
                    } catch (r) {}
                    super(U, l), this.fields = r, this.decodePrefixes = !!C
                }
                getSpan(r, l = 0) {
                    if (0 <= this.span) return this.span;
                    let C = 0;
                    try {
                        C = this.fields.reduce((C, U) => {
                            let et = U.getSpan(r, l);
                            return l += et, C + et
                        }, 0)
                    } catch (r) {
                        throw RangeError("indeterminate span")
                    }
                    return C
                }
                decode(r, l = 0) {
                    checkUint8Array(r);
                    let C = this.makeDestinationObject();
                    for (let U of this.fields)
                        if (void 0 !== U.property && (C[U.property] = U.decode(r, l)), l += U.getSpan(r, l), this.decodePrefixes && r.length === l) break;
                    return C
                }
                encode(r, l, C = 0) {
                    let U = C,
                        et = 0,
                        eo = 0;
                    for (let U of this.fields) {
                        let es = U.span;
                        if (eo = 0 < es ? es : 0, void 0 !== U.property) {
                            let et = r[U.property];
                            void 0 !== et && (eo = U.encode(et, l, C), 0 > es && (es = U.getSpan(l, C)))
                        }
                        et = C, C += es
                    }
                    return et + eo - U
                }
                fromArray(r) {
                    let l = this.makeDestinationObject();
                    for (let C of this.fields) void 0 !== C.property && 0 < r.length && (l[C.property] = r.shift());
                    return l
                }
                layoutFor(r) {
                    if ("string" != typeof r) throw TypeError("property must be string");
                    for (let l of this.fields)
                        if (l.property === r) return l
                }
                offsetOf(r) {
                    if ("string" != typeof r) throw TypeError("property must be string");
                    let l = 0;
                    for (let C of this.fields) {
                        if (C.property === r) return l;
                        0 > C.span ? l = -1 : 0 <= l && (l += C.span)
                    }
                }
            };
            let UnionDiscriminator = class UnionDiscriminator {
                constructor(r) {
                    this.property = r
                }
                decode(r, l) {
                    throw Error("UnionDiscriminator is abstract")
                }
                encode(r, l, C) {
                    throw Error("UnionDiscriminator is abstract")
                }
            };
            let UnionLayoutDiscriminator = class UnionLayoutDiscriminator extends UnionDiscriminator {
                constructor(r, l) {
                    if (!(r instanceof ExternalLayout && r.isCount())) throw TypeError("layout must be an unsigned integer ExternalLayout");
                    super(l || r.property || "variant"), this.layout = r
                }
                decode(r, l) {
                    return this.layout.decode(r, l)
                }
                encode(r, l, C) {
                    return this.layout.encode(r, l, C)
                }
            };
            let Union = class Union extends Layout {
                constructor(r, l, C) {
                    let U;
                    if (r instanceof UInt || r instanceof UIntBE) U = new UnionLayoutDiscriminator(new OffsetLayout(r));
                    else if (r instanceof ExternalLayout && r.isCount()) U = new UnionLayoutDiscriminator(r);
                    else if (r instanceof UnionDiscriminator) U = r;
                    else throw TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
                    if (void 0 === l && (l = null), !(null === l || l instanceof Layout)) throw TypeError("defaultLayout must be null or a Layout");
                    if (null !== l) {
                        if (0 > l.span) throw Error("defaultLayout must have constant span");
                        void 0 === l.property && (l = l.replicate("content"))
                    }
                    let et = -1;
                    l && 0 <= (et = l.span) && (r instanceof UInt || r instanceof UIntBE) && (et += U.layout.span), super(et, C), this.discriminator = U, this.usesPrefixDiscriminator = r instanceof UInt || r instanceof UIntBE, this.defaultLayout = l, this.registry = {};
                    let eo = this.defaultGetSourceVariant.bind(this);
                    this.getSourceVariant = function(r) {
                        return eo(r)
                    }, this.configGetSourceVariant = function(r) {
                        eo = r.bind(this)
                    }
                }
                getSpan(r, l = 0) {
                    if (0 <= this.span) return this.span;
                    let C = this.getVariant(r, l);
                    if (!C) throw Error("unable to determine span for unrecognized variant");
                    return C.getSpan(r, l)
                }
                defaultGetSourceVariant(r) {
                    if (Object.prototype.hasOwnProperty.call(r, this.discriminator.property)) {
                        if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(r, this.defaultLayout.property)) return;
                        let l = this.registry[r[this.discriminator.property]];
                        if (l && (!l.layout || l.property && Object.prototype.hasOwnProperty.call(r, l.property))) return l
                    } else
                        for (let l in this.registry) {
                            let C = this.registry[l];
                            if (C.property && Object.prototype.hasOwnProperty.call(r, C.property)) return C
                        }
                    throw Error("unable to infer src variant")
                }
                decode(r, l = 0) {
                    let C;
                    let U = this.discriminator,
                        et = U.decode(r, l),
                        eo = this.registry[et];
                    if (void 0 === eo) {
                        let eo = this.defaultLayout,
                            es = 0;
                        this.usesPrefixDiscriminator && (es = U.layout.span), (C = this.makeDestinationObject())[U.property] = et, C[eo.property] = eo.decode(r, l + es)
                    } else C = eo.decode(r, l);
                    return C
                }
                encode(r, l, C = 0) {
                    let U = this.getSourceVariant(r);
                    if (void 0 === U) {
                        let U = this.discriminator,
                            et = this.defaultLayout,
                            eo = 0;
                        return this.usesPrefixDiscriminator && (eo = U.layout.span), U.encode(r[U.property], l, C), eo + et.encode(r[et.property], l, C + eo)
                    }
                    return U.encode(r, l, C)
                }
                addVariant(r, l, C) {
                    let U = new VariantLayout(this, r, l, C);
                    return this.registry[r] = U, U
                }
                getVariant(r, l = 0) {
                    let C;
                    return C = r instanceof Uint8Array ? this.discriminator.decode(r, l) : r, this.registry[C]
                }
            };
            let VariantLayout = class VariantLayout extends Layout {
                constructor(r, l, C, U) {
                    if (!(r instanceof Union)) throw TypeError("union must be a Union");
                    if (!Number.isInteger(l) || 0 > l) throw TypeError("variant must be a (non-negative) integer");
                    if ("string" == typeof C && void 0 === U && (U = C, C = null), C) {
                        if (!(C instanceof Layout)) throw TypeError("layout must be a Layout");
                        if (null !== r.defaultLayout && 0 <= C.span && C.span > r.defaultLayout.span) throw Error("variant span exceeds span of containing union");
                        if ("string" != typeof U) throw TypeError("variant must have a String property")
                    }
                    let et = r.span;
                    0 > r.span && 0 <= (et = C ? C.span : 0) && r.usesPrefixDiscriminator && (et += r.discriminator.layout.span), super(et, U), this.union = r, this.variant = l, this.layout = C || null
                }
                getSpan(r, l = 0) {
                    if (0 <= this.span) return this.span;
                    let C = 0;
                    this.union.usesPrefixDiscriminator && (C = this.union.discriminator.layout.span);
                    let U = 0;
                    return this.layout && (U = this.layout.getSpan(r, l + C)), C + U
                }
                decode(r, l = 0) {
                    let C = this.makeDestinationObject();
                    if (this !== this.union.getVariant(r, l)) throw Error("variant mismatch");
                    let U = 0;
                    return this.union.usesPrefixDiscriminator && (U = this.union.discriminator.layout.span), this.layout ? C[this.property] = this.layout.decode(r, l + U) : this.property ? C[this.property] = !0 : this.union.usesPrefixDiscriminator && (C[this.union.discriminator.property] = this.variant), C
                }
                encode(r, l, C = 0) {
                    let U = 0;
                    if (this.union.usesPrefixDiscriminator && (U = this.union.discriminator.layout.span), this.layout && !Object.prototype.hasOwnProperty.call(r, this.property)) throw TypeError("variant lacks property " + this.property);
                    this.union.discriminator.encode(this.variant, l, C);
                    let et = U;
                    if (this.layout && (this.layout.encode(r[this.property], l, C + U), et += this.layout.getSpan(l, C + U), 0 <= this.union.span && et > this.union.span)) throw Error("encoded variant overruns containing union");
                    return et
                }
                fromArray(r) {
                    if (this.layout) return this.layout.fromArray(r)
                }
            };

            function fixBitwiseResult(r) {
                return 0 > r && (r += 4294967296), r
            }
            let BitStructure = class BitStructure extends Layout {
                constructor(r, l, C) {
                    if (!(r instanceof UInt || r instanceof UIntBE)) throw TypeError("word must be a UInt or UIntBE layout");
                    if ("string" == typeof l && void 0 === C && (C = l, l = !1), 4 < r.span) throw RangeError("word cannot exceed 32 bits");
                    super(r.span, C), this.word = r, this.msb = !!l, this.fields = [];
                    let U = 0;
                    this._packedSetValue = function(r) {
                        return U = fixBitwiseResult(r), this
                    }, this._packedGetValue = function() {
                        return U
                    }
                }
                decode(r, l = 0) {
                    let C = this.makeDestinationObject(),
                        U = this.word.decode(r, l);
                    for (let l of (this._packedSetValue(U), this.fields)) void 0 !== l.property && (C[l.property] = l.decode(r));
                    return C
                }
                encode(r, l, C = 0) {
                    let U = this.word.decode(l, C);
                    for (let l of (this._packedSetValue(U), this.fields))
                        if (void 0 !== l.property) {
                            let C = r[l.property];
                            void 0 !== C && l.encode(C)
                        }
                    return this.word.encode(this._packedGetValue(), l, C)
                }
                addField(r, l) {
                    let C = new BitField(this, r, l);
                    return this.fields.push(C), C
                }
                addBoolean(r) {
                    let l = new Boolean(this, r);
                    return this.fields.push(l), l
                }
                fieldFor(r) {
                    if ("string" != typeof r) throw TypeError("property must be string");
                    for (let l of this.fields)
                        if (l.property === r) return l
                }
            };
            let BitField = class BitField {
                constructor(r, l, C) {
                    if (!(r instanceof BitStructure)) throw TypeError("container must be a BitStructure");
                    if (!Number.isInteger(l) || 0 >= l) throw TypeError("bits must be positive integer");
                    let U = 8 * r.span,
                        et = r.fields.reduce((r, l) => r + l.bits, 0);
                    if (l + et > U) throw Error("bits too long for span remainder (" + (U - et) + " of " + U + " remain)");
                    this.container = r, this.bits = l, this.valueMask = (1 << l) - 1, 32 === l && (this.valueMask = 4294967295), this.start = et, this.container.msb && (this.start = U - et - l), this.wordMask = fixBitwiseResult(this.valueMask << this.start), this.property = C
                }
                decode(r, l) {
                    let C = this.container._packedGetValue(),
                        U = fixBitwiseResult(C & this.wordMask),
                        et = U >>> this.start;
                    return et
                }
                encode(r) {
                    if ("number" != typeof r || !Number.isInteger(r) || r !== fixBitwiseResult(r & this.valueMask)) throw TypeError(nameWithProperty("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
                    let l = this.container._packedGetValue(),
                        C = fixBitwiseResult(r << this.start);
                    this.container._packedSetValue(fixBitwiseResult(l & ~this.wordMask) | C)
                }
            };
            let Boolean = class Boolean extends BitField {
                constructor(r, l) {
                    super(r, 1, l)
                }
                decode(r, l) {
                    return !!super.decode(r, l)
                }
                encode(r) {
                    "boolean" == typeof r && (r = +r), super.encode(r)
                }
            };
            let Blob = class Blob extends Layout {
                constructor(r, l) {
                    if (!(r instanceof ExternalLayout && r.isCount() || Number.isInteger(r) && 0 <= r)) throw TypeError("length must be positive integer or an unsigned integer ExternalLayout");
                    let C = -1;
                    r instanceof ExternalLayout || (C = r), super(C, l), this.length = r
                }
                getSpan(r, l) {
                    let C = this.span;
                    return 0 > C && (C = this.length.decode(r, l)), C
                }
                decode(r, l = 0) {
                    let C = this.span;
                    return 0 > C && (C = this.length.decode(r, l)), uint8ArrayToBuffer(r).slice(l, l + C)
                }
                encode(r, l, C) {
                    let U = this.length;
                    if (this.length instanceof ExternalLayout && (U = r.length), !(r instanceof Uint8Array && U === r.length)) throw TypeError(nameWithProperty("Blob.encode", this) + " requires (length " + U + ") Uint8Array as src");
                    if (C + U > l.length) throw RangeError("encoding overruns Uint8Array");
                    let et = uint8ArrayToBuffer(r);
                    return uint8ArrayToBuffer(l).write(et.toString("hex"), C, U, "hex"), this.length instanceof ExternalLayout && this.length.encode(U, l, C), U
                }
            };
            l.cv = (r, l, C) => new OffsetLayout(r, l, C), l.u8 = r => new UInt(1, r), l.KB = r => new UInt(2, r), l.Jq = r => new UInt(4, r), l._O = r => new NearUInt64(r), l.gM = r => new NearInt64(r), l.n_ = (r, l, C) => new Structure(r, l, C), l.A9 = (r, l, C) => new Sequence(r, l, C), l.Ik = (r, l) => new Blob(r, l)
        },
        31622: function(r, l) {
            "use strict";
            l.DF = {
                prefix: "far",
                iconName: "bell",
                icon: [448, 512, [128276, 61602], "f0f3", "M256 32V49.88C328.5 61.39 384 124.2 384 200V233.4C384 278.8 399.5 322.9 427.8 358.4L442.7 377C448.5 384.2 449.6 394.1 445.6 402.4C441.6 410.7 433.2 416 424 416H24C14.77 416 6.365 410.7 2.369 402.4C-1.628 394.1-.504 384.2 5.26 377L20.17 358.4C48.54 322.9 64 278.8 64 233.4V200C64 124.2 119.5 61.39 192 49.88V32C192 14.33 206.3 0 224 0C241.7 0 256 14.33 256 32V32zM216 96C158.6 96 112 142.6 112 200V233.4C112 281.3 98.12 328 72.31 368H375.7C349.9 328 336 281.3 336 233.4V200C336 142.6 289.4 96 232 96H216zM288 448C288 464.1 281.3 481.3 269.3 493.3C257.3 505.3 240.1 512 224 512C207 512 190.7 505.3 178.7 493.3C166.7 481.3 160 464.1 160 448H288z"]
            }, l.qm = l.DF
        },
        29767: function(r, l) {
            "use strict";
            l.DF = {
                prefix: "far",
                iconName: "circle-check",
                icon: [512, 512, [61533, "check-circle"], "f058", "M243.8 339.8C232.9 350.7 215.1 350.7 204.2 339.8L140.2 275.8C129.3 264.9 129.3 247.1 140.2 236.2C151.1 225.3 168.9 225.3 179.8 236.2L224 280.4L332.2 172.2C343.1 161.3 360.9 161.3 371.8 172.2C382.7 183.1 382.7 200.9 371.8 211.8L243.8 339.8zM512 256C512 397.4 397.4 512 256 512C114.6 512 0 397.4 0 256C0 114.6 114.6 0 256 0C397.4 0 512 114.6 512 256zM256 48C141.1 48 48 141.1 48 256C48 370.9 141.1 464 256 464C370.9 464 464 370.9 464 256C464 141.1 370.9 48 256 48z"]
            }, l.fV = l.DF
        },
        83831: function(r, l) {
            "use strict";
            Object.defineProperty(l, "__esModule", {
                value: !0
            });
            var C = "circle-exclamation",
                U = ["exclamation-circle"],
                et = "f06a",
                eo = "M256 0C114.6 0 0 114.6 0 256s114.6 256 256 256s256-114.6 256-256S397.4 0 256 0zM256 464c-114.7 0-208-93.31-208-208S141.3 48 256 48s208 93.31 208 208S370.7 464 256 464zM256 304c13.25 0 24-10.75 24-24v-128C280 138.8 269.3 128 256 128S232 138.8 232 152v128C232 293.3 242.8 304 256 304zM256 337.1c-17.36 0-31.44 14.08-31.44 31.44C224.6 385.9 238.6 400 256 400s31.44-14.08 31.44-31.44C287.4 351.2 273.4 337.1 256 337.1z";
            l.definition = {
                prefix: "far",
                iconName: C,
                icon: [512, 512, U, et, eo]
            }, l.faCircleExclamation = l.definition, l.prefix = "far", l.iconName = C, l.width = 512, l.height = 512, l.ligatures = U, l.unicode = et, l.svgPathData = eo, l.aliases = U
        },
        14095: function(r, l) {
            "use strict";
            l.DF = {
                prefix: "far",
                iconName: "circle-info",
                icon: [512, 512, ["info-circle"], "f05a", "M256 0C114.6 0 0 114.6 0 256s114.6 256 256 256s256-114.6 256-256S397.4 0 256 0zM256 464c-114.7 0-208-93.31-208-208S141.3 48 256 48s208 93.31 208 208S370.7 464 256 464zM296 336h-16V248C280 234.8 269.3 224 256 224H224C210.8 224 200 234.8 200 248S210.8 272 224 272h8v64h-16C202.8 336 192 346.8 192 360S202.8 384 216 384h80c13.25 0 24-10.75 24-24S309.3 336 296 336zM256 192c17.67 0 32-14.33 32-32c0-17.67-14.33-32-32-32S224 142.3 224 160C224 177.7 238.3 192 256 192z"]
            }, l.DB = l.DF
        },
        53106: function(r, l, C) {
            "use strict";
            var U = C(83831);
            l.DF = {
                prefix: U.prefix,
                iconName: U.iconName,
                icon: [U.width, U.height, U.aliases, U.unicode, U.svgPathData]
            }, l.RL = l.DF, U.prefix, U.iconName, U.width, U.height, U.aliases, U.unicode, U.svgPathData, U.aliases
        },
        91485: function(r, l) {
            "use strict";
            l.DF = {
                prefix: "fas",
                iconName: "lock-keyhole",
                icon: [448, 512, ["lock-alt"], "f30d", "M224 64c44.2 0 80 35.8 80 80v48H144V144c0-44.2 35.8-80 80-80zM80 144v48H64c-35.3 0-64 28.7-64 64V448c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V256c0-35.3-28.7-64-64-64H368V144C368 64.5 303.5 0 224 0S80 64.5 80 144zM256 320v64c0 17.7-14.3 32-32 32s-32-14.3-32-32V320c0-17.7 14.3-32 32-32s32 14.3 32 32z"]
            }, l.HI = l.DF
        },
        11794: function(r, l) {
            "use strict";
            l.DF = {
                prefix: "fas",
                iconName: "pause",
                icon: [320, 512, [9208], "f04c", "M48 64C21.5 64 0 85.5 0 112V400c0 26.5 21.5 48 48 48H80c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48H48zm192 0c-26.5 0-48 21.5-48 48V400c0 26.5 21.5 48 48 48h32c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48H240z"]
            }, l.XQ = l.DF
        },
        82287: function(r, l) {
            "use strict";
            l.DF = {
                prefix: "fas",
                iconName: "play",
                icon: [384, 512, [9654], "f04b", "M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"]
            }, l.zc = l.DF
        },
        66871: function(r, l) {
            "use strict";
            l.DF = {
                prefix: "fass",
                iconName: "trash",
                icon: [448, 512, [], "f1f8", "M144 0L128 32H0V96H448V32H320L304 0H144zM416 128H32L56 512H392l24-384z"]
            }, l.$ = l.DF
        },
        34996: function(r, l, C) {
            "use strict";
            Object.defineProperty(l, "__esModule", {
                value: !0
            });
            var U = C(91835);

            function writeUint16BE(r, l, C) {
                return void 0 === l && (l = new Uint8Array(2)), void 0 === C && (C = 0), l[C + 0] = r >>> 8, l[C + 1] = r >>> 0, l
            }

            function writeUint16LE(r, l, C) {
                return void 0 === l && (l = new Uint8Array(2)), void 0 === C && (C = 0), l[C + 0] = r >>> 0, l[C + 1] = r >>> 8, l
            }

            function readInt32BE(r, l) {
                return void 0 === l && (l = 0), r[l] << 24 | r[l + 1] << 16 | r[l + 2] << 8 | r[l + 3]
            }

            function readUint32BE(r, l) {
                return void 0 === l && (l = 0), (r[l] << 24 | r[l + 1] << 16 | r[l + 2] << 8 | r[l + 3]) >>> 0
            }

            function readInt32LE(r, l) {
                return void 0 === l && (l = 0), r[l + 3] << 24 | r[l + 2] << 16 | r[l + 1] << 8 | r[l]
            }

            function readUint32LE(r, l) {
                return void 0 === l && (l = 0), (r[l + 3] << 24 | r[l + 2] << 16 | r[l + 1] << 8 | r[l]) >>> 0
            }

            function writeUint32BE(r, l, C) {
                return void 0 === l && (l = new Uint8Array(4)), void 0 === C && (C = 0), l[C + 0] = r >>> 24, l[C + 1] = r >>> 16, l[C + 2] = r >>> 8, l[C + 3] = r >>> 0, l
            }

            function writeUint32LE(r, l, C) {
                return void 0 === l && (l = new Uint8Array(4)), void 0 === C && (C = 0), l[C + 0] = r >>> 0, l[C + 1] = r >>> 8, l[C + 2] = r >>> 16, l[C + 3] = r >>> 24, l
            }

            function writeUint64BE(r, l, C) {
                return void 0 === l && (l = new Uint8Array(8)), void 0 === C && (C = 0), writeUint32BE(r / 4294967296 >>> 0, l, C), writeUint32BE(r >>> 0, l, C + 4), l
            }

            function writeUint64LE(r, l, C) {
                return void 0 === l && (l = new Uint8Array(8)), void 0 === C && (C = 0), writeUint32LE(r >>> 0, l, C), writeUint32LE(r / 4294967296 >>> 0, l, C + 4), l
            }
            l.readInt16BE = function(r, l) {
                return void 0 === l && (l = 0), (r[l + 0] << 8 | r[l + 1]) << 16 >> 16
            }, l.readUint16BE = function(r, l) {
                return void 0 === l && (l = 0), (r[l + 0] << 8 | r[l + 1]) >>> 0
            }, l.readInt16LE = function(r, l) {
                return void 0 === l && (l = 0), (r[l + 1] << 8 | r[l]) << 16 >> 16
            }, l.readUint16LE = function(r, l) {
                return void 0 === l && (l = 0), (r[l + 1] << 8 | r[l]) >>> 0
            }, l.writeUint16BE = writeUint16BE, l.writeInt16BE = writeUint16BE, l.writeUint16LE = writeUint16LE, l.writeInt16LE = writeUint16LE, l.readInt32BE = readInt32BE, l.readUint32BE = readUint32BE, l.readInt32LE = readInt32LE, l.readUint32LE = readUint32LE, l.writeUint32BE = writeUint32BE, l.writeInt32BE = writeUint32BE, l.writeUint32LE = writeUint32LE, l.writeInt32LE = writeUint32LE, l.readInt64BE = function(r, l) {
                void 0 === l && (l = 0);
                var C = readInt32BE(r, l),
                    U = readInt32BE(r, l + 4);
                return 4294967296 * C + U - (U >> 31) * 4294967296
            }, l.readUint64BE = function(r, l) {
                return void 0 === l && (l = 0), 4294967296 * readUint32BE(r, l) + readUint32BE(r, l + 4)
            }, l.readInt64LE = function(r, l) {
                void 0 === l && (l = 0);
                var C = readInt32LE(r, l);
                return 4294967296 * readInt32LE(r, l + 4) + C - (C >> 31) * 4294967296
            }, l.readUint64LE = function(r, l) {
                void 0 === l && (l = 0);
                var C = readUint32LE(r, l);
                return 4294967296 * readUint32LE(r, l + 4) + C
            }, l.writeUint64BE = writeUint64BE, l.writeInt64BE = writeUint64BE, l.writeUint64LE = writeUint64LE, l.writeInt64LE = writeUint64LE, l.readUintBE = function(r, l, C) {
                if (void 0 === C && (C = 0), r % 8 != 0) throw Error("readUintBE supports only bitLengths divisible by 8");
                if (r / 8 > l.length - C) throw Error("readUintBE: array is too short for the given bitLength");
                for (var U = 0, et = 1, eo = r / 8 + C - 1; eo >= C; eo--) U += l[eo] * et, et *= 256;
                return U
            }, l.readUintLE = function(r, l, C) {
                if (void 0 === C && (C = 0), r % 8 != 0) throw Error("readUintLE supports only bitLengths divisible by 8");
                if (r / 8 > l.length - C) throw Error("readUintLE: array is too short for the given bitLength");
                for (var U = 0, et = 1, eo = C; eo < C + r / 8; eo++) U += l[eo] * et, et *= 256;
                return U
            }, l.writeUintBE = function(r, l, C, et) {
                if (void 0 === C && (C = new Uint8Array(r / 8)), void 0 === et && (et = 0), r % 8 != 0) throw Error("writeUintBE supports only bitLengths divisible by 8");
                if (!U.isSafeInteger(l)) throw Error("writeUintBE value must be an integer");
                for (var eo = 1, es = r / 8 + et - 1; es >= et; es--) C[es] = l / eo & 255, eo *= 256;
                return C
            }, l.writeUintLE = function(r, l, C, et) {
                if (void 0 === C && (C = new Uint8Array(r / 8)), void 0 === et && (et = 0), r % 8 != 0) throw Error("writeUintLE supports only bitLengths divisible by 8");
                if (!U.isSafeInteger(l)) throw Error("writeUintLE value must be an integer");
                for (var eo = 1, es = et; es < et + r / 8; es++) C[es] = l / eo & 255, eo *= 256;
                return C
            }, l.readFloat32BE = function(r, l) {
                return void 0 === l && (l = 0), new DataView(r.buffer, r.byteOffset, r.byteLength).getFloat32(l)
            }, l.readFloat32LE = function(r, l) {
                return void 0 === l && (l = 0), new DataView(r.buffer, r.byteOffset, r.byteLength).getFloat32(l, !0)
            }, l.readFloat64BE = function(r, l) {
                return void 0 === l && (l = 0), new DataView(r.buffer, r.byteOffset, r.byteLength).getFloat64(l)
            }, l.readFloat64LE = function(r, l) {
                return void 0 === l && (l = 0), new DataView(r.buffer, r.byteOffset, r.byteLength).getFloat64(l, !0)
            }, l.writeFloat32BE = function(r, l, C) {
                return void 0 === l && (l = new Uint8Array(4)), void 0 === C && (C = 0), new DataView(l.buffer, l.byteOffset, l.byteLength).setFloat32(C, r), l
            }, l.writeFloat32LE = function(r, l, C) {
                return void 0 === l && (l = new Uint8Array(4)), void 0 === C && (C = 0), new DataView(l.buffer, l.byteOffset, l.byteLength).setFloat32(C, r, !0), l
            }, l.writeFloat64BE = function(r, l, C) {
                return void 0 === l && (l = new Uint8Array(8)), void 0 === C && (C = 0), new DataView(l.buffer, l.byteOffset, l.byteLength).setFloat64(C, r), l
            }, l.writeFloat64LE = function(r, l, C) {
                return void 0 === l && (l = new Uint8Array(8)), void 0 === C && (C = 0), new DataView(l.buffer, l.byteOffset, l.byteLength).setFloat64(C, r, !0), l
            }
        },
        58564: function(r, l, C) {
            "use strict";
            var U = C(73315),
                et = C(47173),
                eo = C(97393),
                es = C(34996),
                el = C(36955);
            l.Cv = 32, l.WH = 12, l.pg = 16;
            var ec = new Uint8Array(16),
                ed = function() {
                    function ChaCha20Poly1305(r) {
                        if (this.nonceLength = l.WH, this.tagLength = l.pg, r.length !== l.Cv) throw Error("ChaCha20Poly1305 needs 32-byte key");
                        this._key = new Uint8Array(r)
                    }
                    return ChaCha20Poly1305.prototype.seal = function(r, l, C, et) {
                        if (r.length > 16) throw Error("ChaCha20Poly1305: incorrect nonce length");
                        var es, el = new Uint8Array(16);
                        el.set(r, el.length - r.length);
                        var ec = new Uint8Array(32);
                        U.stream(this._key, el, ec, 4);
                        var ed = l.length + this.tagLength;
                        if (et) {
                            if (et.length !== ed) throw Error("ChaCha20Poly1305: incorrect destination length");
                            es = et
                        } else es = new Uint8Array(ed);
                        return U.streamXOR(this._key, el, l, es, 4), this._authenticate(es.subarray(es.length - this.tagLength, es.length), ec, es.subarray(0, es.length - this.tagLength), C), eo.wipe(el), es
                    }, ChaCha20Poly1305.prototype.open = function(r, l, C, et) {
                        if (r.length > 16) throw Error("ChaCha20Poly1305: incorrect nonce length");
                        if (l.length < this.tagLength) return null;
                        var es, ec = new Uint8Array(16);
                        ec.set(r, ec.length - r.length);
                        var ed = new Uint8Array(32);
                        U.stream(this._key, ec, ed, 4);
                        var eh = new Uint8Array(this.tagLength);
                        if (this._authenticate(eh, ed, l.subarray(0, l.length - this.tagLength), C), !el.equal(eh, l.subarray(l.length - this.tagLength, l.length))) return null;
                        var ef = l.length - this.tagLength;
                        if (et) {
                            if (et.length !== ef) throw Error("ChaCha20Poly1305: incorrect destination length");
                            es = et
                        } else es = new Uint8Array(ef);
                        return U.streamXOR(this._key, ec, l.subarray(0, l.length - this.tagLength), es, 4), eo.wipe(ec), es
                    }, ChaCha20Poly1305.prototype.clean = function() {
                        return eo.wipe(this._key), this
                    }, ChaCha20Poly1305.prototype._authenticate = function(r, l, C, U) {
                        var el = new et.Poly1305(l);
                        U && (el.update(U), U.length % 16 > 0 && el.update(ec.subarray(U.length % 16))), el.update(C), C.length % 16 > 0 && el.update(ec.subarray(C.length % 16));
                        var ed = new Uint8Array(8);
                        U && es.writeUint64LE(U.length, ed), el.update(ed), es.writeUint64LE(C.length, ed), el.update(ed);
                        for (var eh = el.digest(), ef = 0; ef < eh.length; ef++) r[ef] = eh[ef];
                        el.clean(), eo.wipe(eh), eo.wipe(ed)
                    }, ChaCha20Poly1305
                }();
            l.OK = ed
        },
        73315: function(r, l, C) {
            "use strict";
            Object.defineProperty(l, "__esModule", {
                value: !0
            });
            var U = C(34996),
                et = C(97393);

            function streamXOR(r, l, C, eo, es) {
                if (void 0 === es && (es = 0), 32 !== r.length) throw Error("ChaCha: key size must be 32 bytes");
                if (eo.length < C.length) throw Error("ChaCha: destination is shorter than source");
                if (0 === es) {
                    if (8 !== l.length && 12 !== l.length) throw Error("ChaCha nonce must be 8 or 12 bytes");
                    ec = (el = new Uint8Array(16)).length - l.length, el.set(l, ec)
                } else {
                    if (16 !== l.length) throw Error("ChaCha nonce with counter must be 16 bytes");
                    el = l, ec = es
                }
                for (var el, ec, ed = new Uint8Array(64), eh = 0; eh < C.length; eh += 64) {
                    ! function(r, l, C) {
                        for (var et = C[3] << 24 | C[2] << 16 | C[1] << 8 | C[0], eo = C[7] << 24 | C[6] << 16 | C[5] << 8 | C[4], es = C[11] << 24 | C[10] << 16 | C[9] << 8 | C[8], el = C[15] << 24 | C[14] << 16 | C[13] << 8 | C[12], ec = C[19] << 24 | C[18] << 16 | C[17] << 8 | C[16], ed = C[23] << 24 | C[22] << 16 | C[21] << 8 | C[20], eh = C[27] << 24 | C[26] << 16 | C[25] << 8 | C[24], ef = C[31] << 24 | C[30] << 16 | C[29] << 8 | C[28], ep = l[3] << 24 | l[2] << 16 | l[1] << 8 | l[0], eg = l[7] << 24 | l[6] << 16 | l[5] << 8 | l[4], ey = l[11] << 24 | l[10] << 16 | l[9] << 8 | l[8], em = l[15] << 24 | l[14] << 16 | l[13] << 8 | l[12], e_ = 1634760805, eb = 857760878, ew = 2036477234, eE = 1797285236, eI = et, eS = eo, ex = es, eA = el, eP = ec, eC = ed, ek = eh, eN = ef, eO = ep, eT = eg, eR = ey, eD = em, eB = 0; eB < 20; eB += 2) eO ^= e_ = e_ + eI | 0, eI ^= eP = eP + (eO = eO >>> 16 | eO << 16) | 0, eI = eI >>> 20 | eI << 12, eT ^= eb = eb + eS | 0, eS ^= eC = eC + (eT = eT >>> 16 | eT << 16) | 0, eS = eS >>> 20 | eS << 12, eR ^= ew = ew + ex | 0, ex ^= ek = ek + (eR = eR >>> 16 | eR << 16) | 0, ex = ex >>> 20 | ex << 12, eD ^= eE = eE + eA | 0, eA ^= eN = eN + (eD = eD >>> 16 | eD << 16) | 0, eA = eA >>> 20 | eA << 12, eR ^= ew = ew + ex | 0, ex ^= ek = ek + (eR = eR >>> 24 | eR << 8) | 0, ex = ex >>> 25 | ex << 7, eD ^= eE = eE + eA | 0, eA ^= eN = eN + (eD = eD >>> 24 | eD << 8) | 0, eA = eA >>> 25 | eA << 7, eT ^= eb = eb + eS | 0, eS ^= eC = eC + (eT = eT >>> 24 | eT << 8) | 0, eS = eS >>> 25 | eS << 7, eO ^= e_ = e_ + eI | 0, eI ^= eP = eP + (eO = eO >>> 24 | eO << 8) | 0, eI = eI >>> 25 | eI << 7, eD ^= e_ = e_ + eS | 0, eS ^= ek = ek + (eD = eD >>> 16 | eD << 16) | 0, eS = eS >>> 20 | eS << 12, eO ^= eb = eb + ex | 0, ex ^= eN = eN + (eO = eO >>> 16 | eO << 16) | 0, ex = ex >>> 20 | ex << 12, eT ^= ew = ew + eA | 0, eA ^= eP = eP + (eT = eT >>> 16 | eT << 16) | 0, eA = eA >>> 20 | eA << 12, eR ^= eE = eE + eI | 0, eI ^= eC = eC + (eR = eR >>> 16 | eR << 16) | 0, eI = eI >>> 20 | eI << 12, eT ^= ew = ew + eA | 0, eA ^= eP = eP + (eT = eT >>> 24 | eT << 8) | 0, eA = eA >>> 25 | eA << 7, eR ^= eE = eE + eI | 0, eI ^= eC = eC + (eR = eR >>> 24 | eR << 8) | 0, eI = eI >>> 25 | eI << 7, eO ^= eb = eb + ex | 0, ex ^= eN = eN + (eO = eO >>> 24 | eO << 8) | 0, ex = ex >>> 25 | ex << 7, eD ^= e_ = e_ + eS | 0, eS ^= ek = ek + (eD = eD >>> 24 | eD << 8) | 0, eS = eS >>> 25 | eS << 7;
                        U.writeUint32LE(e_ + 1634760805 | 0, r, 0), U.writeUint32LE(eb + 857760878 | 0, r, 4), U.writeUint32LE(ew + 2036477234 | 0, r, 8), U.writeUint32LE(eE + 1797285236 | 0, r, 12), U.writeUint32LE(eI + et | 0, r, 16), U.writeUint32LE(eS + eo | 0, r, 20), U.writeUint32LE(ex + es | 0, r, 24), U.writeUint32LE(eA + el | 0, r, 28), U.writeUint32LE(eP + ec | 0, r, 32), U.writeUint32LE(eC + ed | 0, r, 36), U.writeUint32LE(ek + eh | 0, r, 40), U.writeUint32LE(eN + ef | 0, r, 44), U.writeUint32LE(eO + ep | 0, r, 48), U.writeUint32LE(eT + eg | 0, r, 52), U.writeUint32LE(eR + ey | 0, r, 56), U.writeUint32LE(eD + em | 0, r, 60)
                    }(ed, el, r);
                    for (var ef = eh; ef < eh + 64 && ef < C.length; ef++) eo[ef] = C[ef] ^ ed[ef - eh];
                    ! function(r, l, C) {
                        for (var U = 1; C--;) U = U + (255 & r[l]) | 0, r[l] = 255 & U, U >>>= 8, l++;
                        if (U > 0) throw Error("ChaCha: counter overflow")
                    }(el, 0, ec)
                }
                return et.wipe(ed), 0 === es && et.wipe(el), eo
            }
            l.streamXOR = streamXOR, l.stream = function(r, l, C, U) {
                return void 0 === U && (U = 0), et.wipe(C), streamXOR(r, l, C, C, U)
            }
        },
        36955: function(r, l) {
            "use strict";

            function compare(r, l) {
                if (r.length !== l.length) return 0;
                for (var C = 0, U = 0; U < r.length; U++) C |= r[U] ^ l[U];
                return 1 & C - 1 >>> 8
            }
            Object.defineProperty(l, "__esModule", {
                value: !0
            }), l.select = function(r, l, C) {
                return ~(r - 1) & l | r - 1 & C
            }, l.lessOrEqual = function(r, l) {
                return (0 | r) - (0 | l) - 1 >>> 31 & 1
            }, l.compare = compare, l.equal = function(r, l) {
                return 0 !== r.length && 0 !== l.length && 0 !== compare(r, l)
            }
        },
        51133: function(r, l, C) {
            "use strict";
            l.Xx = l._w = l.aP = l.KS = l.jQ = void 0, C(42532);
            let U = C(13483);

            function gf(r) {
                let l = new Float64Array(16);
                if (r)
                    for (let C = 0; C < r.length; C++) l[C] = r[C];
                return l
            }
            C(97393), l.jQ = 64, l.KS = 64, l.aP = 32;
            let et = new Uint8Array(32);
            et[0] = 9;
            let eo = gf(),
                es = gf([1]),
                el = (gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222])),
                ec = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]),
                ed = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]);

            function set25519(r, l) {
                for (let C = 0; C < 16; C++) r[C] = 0 | l[C]
            }

            function car25519(r) {
                let l = 1;
                for (let C = 0; C < 16; C++) {
                    let U = r[C] + l + 65535;
                    l = Math.floor(U / 65536), r[C] = U - 65536 * l
                }
                r[0] += l - 1 + 37 * (l - 1)
            }

            function sel25519(r, l, C) {
                let U = ~(C - 1);
                for (let C = 0; C < 16; C++) {
                    let et = U & (r[C] ^ l[C]);
                    r[C] ^= et, l[C] ^= et
                }
            }

            function pack25519(r, l) {
                let C = gf(),
                    U = gf();
                for (let r = 0; r < 16; r++) U[r] = l[r];
                car25519(U), car25519(U), car25519(U);
                for (let r = 0; r < 2; r++) {
                    C[0] = U[0] - 65517;
                    for (let r = 1; r < 15; r++) C[r] = U[r] - 65535 - (C[r - 1] >> 16 & 1), C[r - 1] &= 65535;
                    C[15] = U[15] - 32767 - (C[14] >> 16 & 1);
                    let r = C[15] >> 16 & 1;
                    C[14] &= 65535, sel25519(U, C, 1 - r)
                }
                for (let l = 0; l < 16; l++) r[2 * l] = 255 & U[l], r[2 * l + 1] = U[l] >> 8
            }
            gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);

            function add(r, l, C) {
                for (let U = 0; U < 16; U++) r[U] = l[U] + C[U]
            }

            function sub(r, l, C) {
                for (let U = 0; U < 16; U++) r[U] = l[U] - C[U]
            }

            function mul(r, l, C) {
                let U, et, eo = 0,
                    es = 0,
                    el = 0,
                    ec = 0,
                    ed = 0,
                    eh = 0,
                    ef = 0,
                    ep = 0,
                    eg = 0,
                    ey = 0,
                    em = 0,
                    e_ = 0,
                    eb = 0,
                    ew = 0,
                    eE = 0,
                    eI = 0,
                    eS = 0,
                    ex = 0,
                    eA = 0,
                    eP = 0,
                    eC = 0,
                    ek = 0,
                    eN = 0,
                    eO = 0,
                    eT = 0,
                    eR = 0,
                    eD = 0,
                    eB = 0,
                    eU = 0,
                    eL = 0,
                    eM = 0,
                    ej = C[0],
                    e$ = C[1],
                    ez = C[2],
                    eH = C[3],
                    eF = C[4],
                    eW = C[5],
                    eV = C[6],
                    eK = C[7],
                    eG = C[8],
                    eJ = C[9],
                    eY = C[10],
                    eZ = C[11],
                    eX = C[12],
                    eQ = C[13],
                    e0 = C[14],
                    e1 = C[15];
                eo += (U = l[0]) * ej, es += U * e$, el += U * ez, ec += U * eH, ed += U * eF, eh += U * eW, ef += U * eV, ep += U * eK, eg += U * eG, ey += U * eJ, em += U * eY, e_ += U * eZ, eb += U * eX, ew += U * eQ, eE += U * e0, eI += U * e1, es += (U = l[1]) * ej, el += U * e$, ec += U * ez, ed += U * eH, eh += U * eF, ef += U * eW, ep += U * eV, eg += U * eK, ey += U * eG, em += U * eJ, e_ += U * eY, eb += U * eZ, ew += U * eX, eE += U * eQ, eI += U * e0, eS += U * e1, el += (U = l[2]) * ej, ec += U * e$, ed += U * ez, eh += U * eH, ef += U * eF, ep += U * eW, eg += U * eV, ey += U * eK, em += U * eG, e_ += U * eJ, eb += U * eY, ew += U * eZ, eE += U * eX, eI += U * eQ, eS += U * e0, ex += U * e1, ec += (U = l[3]) * ej, ed += U * e$, eh += U * ez, ef += U * eH, ep += U * eF, eg += U * eW, ey += U * eV, em += U * eK, e_ += U * eG, eb += U * eJ, ew += U * eY, eE += U * eZ, eI += U * eX, eS += U * eQ, ex += U * e0, eA += U * e1, ed += (U = l[4]) * ej, eh += U * e$, ef += U * ez, ep += U * eH, eg += U * eF, ey += U * eW, em += U * eV, e_ += U * eK, eb += U * eG, ew += U * eJ, eE += U * eY, eI += U * eZ, eS += U * eX, ex += U * eQ, eA += U * e0, eP += U * e1, eh += (U = l[5]) * ej, ef += U * e$, ep += U * ez, eg += U * eH, ey += U * eF, em += U * eW, e_ += U * eV, eb += U * eK, ew += U * eG, eE += U * eJ, eI += U * eY, eS += U * eZ, ex += U * eX, eA += U * eQ, eP += U * e0, eC += U * e1, ef += (U = l[6]) * ej, ep += U * e$, eg += U * ez, ey += U * eH, em += U * eF, e_ += U * eW, eb += U * eV, ew += U * eK, eE += U * eG, eI += U * eJ, eS += U * eY, ex += U * eZ, eA += U * eX, eP += U * eQ, eC += U * e0, ek += U * e1, ep += (U = l[7]) * ej, eg += U * e$, ey += U * ez, em += U * eH, e_ += U * eF, eb += U * eW, ew += U * eV, eE += U * eK, eI += U * eG, eS += U * eJ, ex += U * eY, eA += U * eZ, eP += U * eX, eC += U * eQ, ek += U * e0, eN += U * e1, eg += (U = l[8]) * ej, ey += U * e$, em += U * ez, e_ += U * eH, eb += U * eF, ew += U * eW, eE += U * eV, eI += U * eK, eS += U * eG, ex += U * eJ, eA += U * eY, eP += U * eZ, eC += U * eX, ek += U * eQ, eN += U * e0, eO += U * e1, ey += (U = l[9]) * ej, em += U * e$, e_ += U * ez, eb += U * eH, ew += U * eF, eE += U * eW, eI += U * eV, eS += U * eK, ex += U * eG, eA += U * eJ, eP += U * eY, eC += U * eZ, ek += U * eX, eN += U * eQ, eO += U * e0, eT += U * e1, em += (U = l[10]) * ej, e_ += U * e$, eb += U * ez, ew += U * eH, eE += U * eF, eI += U * eW, eS += U * eV, ex += U * eK, eA += U * eG, eP += U * eJ, eC += U * eY, ek += U * eZ, eN += U * eX, eO += U * eQ, eT += U * e0, eR += U * e1, e_ += (U = l[11]) * ej, eb += U * e$, ew += U * ez, eE += U * eH, eI += U * eF, eS += U * eW, ex += U * eV, eA += U * eK, eP += U * eG, eC += U * eJ, ek += U * eY, eN += U * eZ, eO += U * eX, eT += U * eQ, eR += U * e0, eD += U * e1, eb += (U = l[12]) * ej, ew += U * e$, eE += U * ez, eI += U * eH, eS += U * eF, ex += U * eW, eA += U * eV, eP += U * eK, eC += U * eG, ek += U * eJ, eN += U * eY, eO += U * eZ, eT += U * eX, eR += U * eQ, eD += U * e0, eB += U * e1, ew += (U = l[13]) * ej, eE += U * e$, eI += U * ez, eS += U * eH, ex += U * eF, eA += U * eW, eP += U * eV, eC += U * eK, ek += U * eG, eN += U * eJ, eO += U * eY, eT += U * eZ, eR += U * eX, eD += U * eQ, eB += U * e0, eU += U * e1, eE += (U = l[14]) * ej, eI += U * e$, eS += U * ez, ex += U * eH, eA += U * eF, eP += U * eW, eC += U * eV, ek += U * eK, eN += U * eG, eO += U * eJ, eT += U * eY, eR += U * eZ, eD += U * eX, eB += U * eQ, eU += U * e0, eL += U * e1, eI += (U = l[15]) * ej, eS += U * e$, ex += U * ez, eA += U * eH, eP += U * eF, eC += U * eW, ek += U * eV, eN += U * eK, eO += U * eG, eT += U * eJ, eR += U * eY, eD += U * eZ, eB += U * eX, eU += U * eQ, eL += U * e0, eM += U * e1, eo += 38 * eS, es += 38 * ex, el += 38 * eA, ec += 38 * eP, ed += 38 * eC, eh += 38 * ek, ef += 38 * eN, ep += 38 * eO, eg += 38 * eT, ey += 38 * eR, em += 38 * eD, e_ += 38 * eB, eb += 38 * eU, ew += 38 * eL, eE += 38 * eM, et = Math.floor((U = eo + (et = 1) + 65535) / 65536), eo = U - 65536 * et, et = Math.floor((U = es + et + 65535) / 65536), es = U - 65536 * et, et = Math.floor((U = el + et + 65535) / 65536), el = U - 65536 * et, et = Math.floor((U = ec + et + 65535) / 65536), ec = U - 65536 * et, et = Math.floor((U = ed + et + 65535) / 65536), ed = U - 65536 * et, et = Math.floor((U = eh + et + 65535) / 65536), eh = U - 65536 * et, et = Math.floor((U = ef + et + 65535) / 65536), ef = U - 65536 * et, et = Math.floor((U = ep + et + 65535) / 65536), ep = U - 65536 * et, et = Math.floor((U = eg + et + 65535) / 65536), eg = U - 65536 * et, et = Math.floor((U = ey + et + 65535) / 65536), ey = U - 65536 * et, et = Math.floor((U = em + et + 65535) / 65536), em = U - 65536 * et, et = Math.floor((U = e_ + et + 65535) / 65536), e_ = U - 65536 * et, et = Math.floor((U = eb + et + 65535) / 65536), eb = U - 65536 * et, et = Math.floor((U = ew + et + 65535) / 65536), ew = U - 65536 * et, et = Math.floor((U = eE + et + 65535) / 65536), eE = U - 65536 * et, et = Math.floor((U = eI + et + 65535) / 65536), eI = U - 65536 * et, eo += et - 1 + 37 * (et - 1), et = Math.floor((U = eo + (et = 1) + 65535) / 65536), eo = U - 65536 * et, et = Math.floor((U = es + et + 65535) / 65536), es = U - 65536 * et, et = Math.floor((U = el + et + 65535) / 65536), el = U - 65536 * et, et = Math.floor((U = ec + et + 65535) / 65536), ec = U - 65536 * et, et = Math.floor((U = ed + et + 65535) / 65536), ed = U - 65536 * et, et = Math.floor((U = eh + et + 65535) / 65536), eh = U - 65536 * et, et = Math.floor((U = ef + et + 65535) / 65536), ef = U - 65536 * et, et = Math.floor((U = ep + et + 65535) / 65536), ep = U - 65536 * et, et = Math.floor((U = eg + et + 65535) / 65536), eg = U - 65536 * et, et = Math.floor((U = ey + et + 65535) / 65536), ey = U - 65536 * et, et = Math.floor((U = em + et + 65535) / 65536), em = U - 65536 * et, et = Math.floor((U = e_ + et + 65535) / 65536), e_ = U - 65536 * et, et = Math.floor((U = eb + et + 65535) / 65536), eb = U - 65536 * et, et = Math.floor((U = ew + et + 65535) / 65536), ew = U - 65536 * et, et = Math.floor((U = eE + et + 65535) / 65536), eE = U - 65536 * et, et = Math.floor((U = eI + et + 65535) / 65536), eI = U - 65536 * et, eo += et - 1 + 37 * (et - 1), r[0] = eo, r[1] = es, r[2] = el, r[3] = ec, r[4] = ed, r[5] = eh, r[6] = ef, r[7] = ep, r[8] = eg, r[9] = ey, r[10] = em, r[11] = e_, r[12] = eb, r[13] = ew, r[14] = eE, r[15] = eI
            }

            function edadd(r, l) {
                let C = gf(),
                    U = gf(),
                    et = gf(),
                    eo = gf(),
                    es = gf(),
                    ec = gf(),
                    ed = gf(),
                    eh = gf(),
                    ef = gf();
                sub(C, r[1], r[0]), sub(ef, l[1], l[0]), mul(C, C, ef), add(U, r[0], r[1]), add(ef, l[0], l[1]), mul(U, U, ef), mul(et, r[3], l[3]), mul(et, et, el), mul(eo, r[2], l[2]), add(eo, eo, eo), sub(es, U, C), sub(ec, eo, et), add(ed, eo, et), add(eh, U, C), mul(r[0], es, ec), mul(r[1], eh, ed), mul(r[2], ed, ec), mul(r[3], es, eh)
            }

            function cswap(r, l, C) {
                for (let U = 0; U < 4; U++) sel25519(r[U], l[U], C)
            }

            function pack(r, l) {
                let C = gf(),
                    U = gf(),
                    et = gf();
                (function(r, l) {
                    let C;
                    let U = gf();
                    for (C = 0; C < 16; C++) U[C] = l[C];
                    for (C = 253; C >= 0; C--) mul(U, U, U), 2 !== C && 4 !== C && mul(U, U, l);
                    for (C = 0; C < 16; C++) r[C] = U[C]
                })(et, l[2]), mul(C, l[0], et), mul(U, l[1], et), pack25519(r, U), r[31] ^= function(r) {
                    let l = new Uint8Array(32);
                    return pack25519(l, r), 1 & l[0]
                }(C) << 7
            }

            function scalarbase(r, l) {
                let C = [gf(), gf(), gf(), gf()];
                set25519(C[0], ec), set25519(C[1], ed), set25519(C[2], es), mul(C[3], ec, ed),
                    function(r, l, C) {
                        set25519(r[0], eo), set25519(r[1], es), set25519(r[2], es), set25519(r[3], eo);
                        for (let U = 255; U >= 0; --U) {
                            let et = C[U / 8 | 0] >> (7 & U) & 1;
                            cswap(r, l, et), edadd(l, r), edadd(r, r), cswap(r, l, et)
                        }
                    }(r, C, l)
            }
            l._w = function(r) {
                if (r.length !== l.aP) throw Error(`ed25519: seed must be ${l.aP} bytes`);
                let C = (0, U.hash)(r);
                C[0] &= 248, C[31] &= 127, C[31] |= 64;
                let et = new Uint8Array(32),
                    eo = [gf(), gf(), gf(), gf()];
                scalarbase(eo, C), pack(et, eo);
                let es = new Uint8Array(64);
                return es.set(r), es.set(et, 32), {
                    publicKey: et,
                    secretKey: es
                }
            };
            let eh = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);

            function modL(r, l) {
                let C, U, et, eo;
                for (U = 63; U >= 32; --U) {
                    for (C = 0, et = U - 32, eo = U - 12; et < eo; ++et) l[et] += C - 16 * l[U] * eh[et - (U - 32)], C = Math.floor((l[et] + 128) / 256), l[et] -= 256 * C;
                    l[et] += C, l[U] = 0
                }
                for (et = 0, C = 0; et < 32; et++) l[et] += C - (l[31] >> 4) * eh[et], C = l[et] >> 8, l[et] &= 255;
                for (et = 0; et < 32; et++) l[et] -= C * eh[et];
                for (U = 0; U < 32; U++) l[U + 1] += l[U] >> 8, r[U] = 255 & l[U]
            }

            function reduce(r) {
                let l = new Float64Array(64);
                for (let C = 0; C < 64; C++) l[C] = r[C];
                for (let l = 0; l < 64; l++) r[l] = 0;
                modL(r, l)
            }
            l.Xx = function(r, l) {
                let C = new Float64Array(64),
                    et = [gf(), gf(), gf(), gf()],
                    eo = (0, U.hash)(r.subarray(0, 32));
                eo[0] &= 248, eo[31] &= 127, eo[31] |= 64;
                let es = new Uint8Array(64);
                es.set(eo.subarray(32), 32);
                let el = new U.SHA512;
                el.update(es.subarray(32)), el.update(l);
                let ec = el.digest();
                el.clean(), reduce(ec), scalarbase(et, ec), pack(es, et), el.reset(), el.update(es.subarray(0, 32)), el.update(r.subarray(32)), el.update(l);
                let ed = el.digest();
                reduce(ed);
                for (let r = 0; r < 32; r++) C[r] = ec[r];
                for (let r = 0; r < 32; r++)
                    for (let l = 0; l < 32; l++) C[r + l] += ed[r] * eo[l];
                return modL(es.subarray(32), C), es
            }
        },
        35840: function(r, l) {
            "use strict";
            Object.defineProperty(l, "__esModule", {
                value: !0
            }), l.isSerializableHash = function(r) {
                return void 0 !== r.saveState && void 0 !== r.restoreState && void 0 !== r.cleanSavedState
            }
        },
        13028: function(r, l, C) {
            "use strict";
            var U = C(29774),
                et = C(97393),
                eo = function() {
                    function HKDF(r, l, C, et) {
                        void 0 === C && (C = new Uint8Array(0)), this._counter = new Uint8Array(1), this._hash = r, this._info = et;
                        var eo = U.hmac(this._hash, C, l);
                        this._hmac = new U.HMAC(r, eo), this._buffer = new Uint8Array(this._hmac.digestLength), this._bufpos = this._buffer.length
                    }
                    return HKDF.prototype._fillBuffer = function() {
                        this._counter[0]++;
                        var r = this._counter[0];
                        if (0 === r) throw Error("hkdf: cannot expand more");
                        this._hmac.reset(), r > 1 && this._hmac.update(this._buffer), this._info && this._hmac.update(this._info), this._hmac.update(this._counter), this._hmac.finish(this._buffer), this._bufpos = 0
                    }, HKDF.prototype.expand = function(r) {
                        for (var l = new Uint8Array(r), C = 0; C < l.length; C++) this._bufpos === this._buffer.length && this._fillBuffer(), l[C] = this._buffer[this._bufpos++];
                        return l
                    }, HKDF.prototype.clean = function() {
                        this._hmac.clean(), et.wipe(this._buffer), et.wipe(this._counter), this._bufpos = 0
                    }, HKDF
                }();
            l.t = eo
        },
        29774: function(r, l, C) {
            "use strict";
            Object.defineProperty(l, "__esModule", {
                value: !0
            });
            var U = C(35840),
                et = C(36955),
                eo = C(97393),
                es = function() {
                    function HMAC(r, l) {
                        this._finished = !1, this._inner = new r, this._outer = new r, this.blockSize = this._outer.blockSize, this.digestLength = this._outer.digestLength;
                        var C = new Uint8Array(this.blockSize);
                        l.length > this.blockSize ? this._inner.update(l).finish(C).clean() : C.set(l);
                        for (var et = 0; et < C.length; et++) C[et] ^= 54;
                        this._inner.update(C);
                        for (var et = 0; et < C.length; et++) C[et] ^= 106;
                        this._outer.update(C), U.isSerializableHash(this._inner) && U.isSerializableHash(this._outer) && (this._innerKeyedState = this._inner.saveState(), this._outerKeyedState = this._outer.saveState()), eo.wipe(C)
                    }
                    return HMAC.prototype.reset = function() {
                        if (!U.isSerializableHash(this._inner) || !U.isSerializableHash(this._outer)) throw Error("hmac: can't reset() because hash doesn't implement restoreState()");
                        return this._inner.restoreState(this._innerKeyedState), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this
                    }, HMAC.prototype.clean = function() {
                        U.isSerializableHash(this._inner) && this._inner.cleanSavedState(this._innerKeyedState), U.isSerializableHash(this._outer) && this._outer.cleanSavedState(this._outerKeyedState), this._inner.clean(), this._outer.clean()
                    }, HMAC.prototype.update = function(r) {
                        return this._inner.update(r), this
                    }, HMAC.prototype.finish = function(r) {
                        return this._finished ? this._outer.finish(r) : (this._inner.finish(r), this._outer.update(r.subarray(0, this.digestLength)).finish(r), this._finished = !0), this
                    }, HMAC.prototype.digest = function() {
                        var r = new Uint8Array(this.digestLength);
                        return this.finish(r), r
                    }, HMAC.prototype.saveState = function() {
                        if (!U.isSerializableHash(this._inner)) throw Error("hmac: can't saveState() because hash doesn't implement it");
                        return this._inner.saveState()
                    }, HMAC.prototype.restoreState = function(r) {
                        if (!U.isSerializableHash(this._inner) || !U.isSerializableHash(this._outer)) throw Error("hmac: can't restoreState() because hash doesn't implement it");
                        return this._inner.restoreState(r), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this
                    }, HMAC.prototype.cleanSavedState = function(r) {
                        if (!U.isSerializableHash(this._inner)) throw Error("hmac: can't cleanSavedState() because hash doesn't implement it");
                        this._inner.cleanSavedState(r)
                    }, HMAC
                }();
            l.HMAC = es, l.hmac = function(r, l, C) {
                var U = new es(r, l);
                U.update(C);
                var et = U.digest();
                return U.clean(), et
            }, l.equal = et.equal
        },
        91835: function(r, l) {
            "use strict";
            Object.defineProperty(l, "__esModule", {
                value: !0
            }), l.mul = Math.imul || function(r, l) {
                var C = 65535 & r,
                    U = 65535 & l;
                return C * U + ((r >>> 16 & 65535) * U + C * (l >>> 16 & 65535) << 16 >>> 0) | 0
            }, l.add = function(r, l) {
                return r + l | 0
            }, l.sub = function(r, l) {
                return r - l | 0
            }, l.rotl = function(r, l) {
                return r << l | r >>> 32 - l
            }, l.rotr = function(r, l) {
                return r << 32 - l | r >>> l
            }, l.isInteger = Number.isInteger || function(r) {
                return "number" == typeof r && isFinite(r) && Math.floor(r) === r
            }, l.MAX_SAFE_INTEGER = 9007199254740991, l.isSafeInteger = function(r) {
                return l.isInteger(r) && r >= -l.MAX_SAFE_INTEGER && r <= l.MAX_SAFE_INTEGER
            }
        },
        47173: function(r, l, C) {
            "use strict";
            Object.defineProperty(l, "__esModule", {
                value: !0
            });
            var U = C(36955),
                et = C(97393);
            l.DIGEST_LENGTH = 16;
            var eo = function() {
                function Poly1305(r) {
                    this.digestLength = l.DIGEST_LENGTH, this._buffer = new Uint8Array(16), this._r = new Uint16Array(10), this._h = new Uint16Array(10), this._pad = new Uint16Array(8), this._leftover = 0, this._fin = 0, this._finished = !1;
                    var C = r[0] | r[1] << 8;
                    this._r[0] = 8191 & C;
                    var U = r[2] | r[3] << 8;
                    this._r[1] = (C >>> 13 | U << 3) & 8191;
                    var et = r[4] | r[5] << 8;
                    this._r[2] = (U >>> 10 | et << 6) & 7939;
                    var eo = r[6] | r[7] << 8;
                    this._r[3] = (et >>> 7 | eo << 9) & 8191;
                    var es = r[8] | r[9] << 8;
                    this._r[4] = (eo >>> 4 | es << 12) & 255, this._r[5] = es >>> 1 & 8190;
                    var el = r[10] | r[11] << 8;
                    this._r[6] = (es >>> 14 | el << 2) & 8191;
                    var ec = r[12] | r[13] << 8;
                    this._r[7] = (el >>> 11 | ec << 5) & 8065;
                    var ed = r[14] | r[15] << 8;
                    this._r[8] = (ec >>> 8 | ed << 8) & 8191, this._r[9] = ed >>> 5 & 127, this._pad[0] = r[16] | r[17] << 8, this._pad[1] = r[18] | r[19] << 8, this._pad[2] = r[20] | r[21] << 8, this._pad[3] = r[22] | r[23] << 8, this._pad[4] = r[24] | r[25] << 8, this._pad[5] = r[26] | r[27] << 8, this._pad[6] = r[28] | r[29] << 8, this._pad[7] = r[30] | r[31] << 8
                }
                return Poly1305.prototype._blocks = function(r, l, C) {
                    for (var U = this._fin ? 0 : 2048, et = this._h[0], eo = this._h[1], es = this._h[2], el = this._h[3], ec = this._h[4], ed = this._h[5], eh = this._h[6], ef = this._h[7], ep = this._h[8], eg = this._h[9], ey = this._r[0], em = this._r[1], e_ = this._r[2], eb = this._r[3], ew = this._r[4], eE = this._r[5], eI = this._r[6], eS = this._r[7], ex = this._r[8], eA = this._r[9]; C >= 16;) {
                        var eP, eC = r[l + 0] | r[l + 1] << 8;
                        et += 8191 & eC;
                        var ek = r[l + 2] | r[l + 3] << 8;
                        eo += (eC >>> 13 | ek << 3) & 8191;
                        var eN = r[l + 4] | r[l + 5] << 8;
                        es += (ek >>> 10 | eN << 6) & 8191;
                        var eO = r[l + 6] | r[l + 7] << 8;
                        el += (eN >>> 7 | eO << 9) & 8191;
                        var eT = r[l + 8] | r[l + 9] << 8;
                        ec += (eO >>> 4 | eT << 12) & 8191, ed += eT >>> 1 & 8191;
                        var eR = r[l + 10] | r[l + 11] << 8;
                        eh += (eT >>> 14 | eR << 2) & 8191;
                        var eD = r[l + 12] | r[l + 13] << 8;
                        ef += (eR >>> 11 | eD << 5) & 8191;
                        var eB = r[l + 14] | r[l + 15] << 8;
                        ep += (eD >>> 8 | eB << 8) & 8191, eg += eB >>> 5 | U;
                        var eU = 0;
                        eU = (eP = 0 + et * ey + eo * (5 * eA) + es * (5 * ex) + el * (5 * eS) + ec * (5 * eI)) >>> 13, eP &= 8191, eP += ed * (5 * eE) + eh * (5 * ew) + ef * (5 * eb) + ep * (5 * e_) + eg * (5 * em), eU += eP >>> 13, eP &= 8191;
                        var eL = eU;
                        eL += et * em + eo * ey + es * (5 * eA) + el * (5 * ex) + ec * (5 * eS), eU = eL >>> 13, eL &= 8191, eL += ed * (5 * eI) + eh * (5 * eE) + ef * (5 * ew) + ep * (5 * eb) + eg * (5 * e_), eU += eL >>> 13, eL &= 8191;
                        var eM = eU;
                        eM += et * e_ + eo * em + es * ey + el * (5 * eA) + ec * (5 * ex), eU = eM >>> 13, eM &= 8191, eM += ed * (5 * eS) + eh * (5 * eI) + ef * (5 * eE) + ep * (5 * ew) + eg * (5 * eb), eU += eM >>> 13, eM &= 8191;
                        var ej = eU;
                        ej += et * eb + eo * e_ + es * em + el * ey + ec * (5 * eA), eU = ej >>> 13, ej &= 8191, ej += ed * (5 * ex) + eh * (5 * eS) + ef * (5 * eI) + ep * (5 * eE) + eg * (5 * ew), eU += ej >>> 13, ej &= 8191;
                        var e$ = eU;
                        e$ += et * ew + eo * eb + es * e_ + el * em + ec * ey, eU = e$ >>> 13, e$ &= 8191, e$ += ed * (5 * eA) + eh * (5 * ex) + ef * (5 * eS) + ep * (5 * eI) + eg * (5 * eE), eU += e$ >>> 13, e$ &= 8191;
                        var ez = eU;
                        ez += et * eE + eo * ew + es * eb + el * e_ + ec * em, eU = ez >>> 13, ez &= 8191, ez += ed * ey + eh * (5 * eA) + ef * (5 * ex) + ep * (5 * eS) + eg * (5 * eI), eU += ez >>> 13, ez &= 8191;
                        var eH = eU;
                        eH += et * eI + eo * eE + es * ew + el * eb + ec * e_, eU = eH >>> 13, eH &= 8191, eH += ed * em + eh * ey + ef * (5 * eA) + ep * (5 * ex) + eg * (5 * eS), eU += eH >>> 13, eH &= 8191;
                        var eF = eU;
                        eF += et * eS + eo * eI + es * eE + el * ew + ec * eb, eU = eF >>> 13, eF &= 8191, eF += ed * e_ + eh * em + ef * ey + ep * (5 * eA) + eg * (5 * ex), eU += eF >>> 13, eF &= 8191;
                        var eW = eU;
                        eW += et * ex + eo * eS + es * eI + el * eE + ec * ew, eU = eW >>> 13, eW &= 8191, eW += ed * eb + eh * e_ + ef * em + ep * ey + eg * (5 * eA), eU += eW >>> 13, eW &= 8191;
                        var eV = eU;
                        eV += et * eA + eo * ex + es * eS + el * eI + ec * eE, eU = eV >>> 13, eV &= 8191, eV += ed * ew + eh * eb + ef * e_ + ep * em + eg * ey, eU += eV >>> 13, eV &= 8191, eP = 8191 & (eU = (eU = (eU << 2) + eU | 0) + eP | 0), eU >>>= 13, eL += eU, et = eP, eo = eL, es = eM, el = ej, ec = e$, ed = ez, eh = eH, ef = eF, ep = eW, eg = eV, l += 16, C -= 16
                    }
                    this._h[0] = et, this._h[1] = eo, this._h[2] = es, this._h[3] = el, this._h[4] = ec, this._h[5] = ed, this._h[6] = eh, this._h[7] = ef, this._h[8] = ep, this._h[9] = eg
                }, Poly1305.prototype.finish = function(r, l) {
                    void 0 === l && (l = 0);
                    var C, U, et, eo, es = new Uint16Array(10);
                    if (this._leftover) {
                        for (eo = this._leftover, this._buffer[eo++] = 1; eo < 16; eo++) this._buffer[eo] = 0;
                        this._fin = 1, this._blocks(this._buffer, 0, 16)
                    }
                    for (C = this._h[1] >>> 13, this._h[1] &= 8191, eo = 2; eo < 10; eo++) this._h[eo] += C, C = this._h[eo] >>> 13, this._h[eo] &= 8191;
                    for (this._h[0] += 5 * C, C = this._h[0] >>> 13, this._h[0] &= 8191, this._h[1] += C, C = this._h[1] >>> 13, this._h[1] &= 8191, this._h[2] += C, es[0] = this._h[0] + 5, C = es[0] >>> 13, es[0] &= 8191, eo = 1; eo < 10; eo++) es[eo] = this._h[eo] + C, C = es[eo] >>> 13, es[eo] &= 8191;
                    for (es[9] -= 8192, U = (1 ^ C) - 1, eo = 0; eo < 10; eo++) es[eo] &= U;
                    for (eo = 0, U = ~U; eo < 10; eo++) this._h[eo] = this._h[eo] & U | es[eo];
                    for (eo = 1, this._h[0] = (this._h[0] | this._h[1] << 13) & 65535, this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535, this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535, this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535, this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535, this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535, this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535, this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535, et = this._h[0] + this._pad[0], this._h[0] = 65535 & et; eo < 8; eo++) et = (this._h[eo] + this._pad[eo] | 0) + (et >>> 16) | 0, this._h[eo] = 65535 & et;
                    return r[l + 0] = this._h[0] >>> 0, r[l + 1] = this._h[0] >>> 8, r[l + 2] = this._h[1] >>> 0, r[l + 3] = this._h[1] >>> 8, r[l + 4] = this._h[2] >>> 0, r[l + 5] = this._h[2] >>> 8, r[l + 6] = this._h[3] >>> 0, r[l + 7] = this._h[3] >>> 8, r[l + 8] = this._h[4] >>> 0, r[l + 9] = this._h[4] >>> 8, r[l + 10] = this._h[5] >>> 0, r[l + 11] = this._h[5] >>> 8, r[l + 12] = this._h[6] >>> 0, r[l + 13] = this._h[6] >>> 8, r[l + 14] = this._h[7] >>> 0, r[l + 15] = this._h[7] >>> 8, this._finished = !0, this
                }, Poly1305.prototype.update = function(r) {
                    var l, C = 0,
                        U = r.length;
                    if (this._leftover) {
                        (l = 16 - this._leftover) > U && (l = U);
                        for (var et = 0; et < l; et++) this._buffer[this._leftover + et] = r[C + et];
                        if (U -= l, C += l, this._leftover += l, this._leftover < 16) return this;
                        this._blocks(this._buffer, 0, 16), this._leftover = 0
                    }
                    if (U >= 16 && (l = U - U % 16, this._blocks(r, C, l), C += l, U -= l), U) {
                        for (var et = 0; et < U; et++) this._buffer[this._leftover + et] = r[C + et];
                        this._leftover += U
                    }
                    return this
                }, Poly1305.prototype.digest = function() {
                    if (this._finished) throw Error("Poly1305 was finished");
                    var r = new Uint8Array(16);
                    return this.finish(r), r
                }, Poly1305.prototype.clean = function() {
                    return et.wipe(this._buffer), et.wipe(this._r), et.wipe(this._h), et.wipe(this._pad), this._leftover = 0, this._fin = 0, this._finished = !0, this
                }, Poly1305
            }();
            l.Poly1305 = eo, l.oneTimeAuth = function(r, l) {
                var C = new eo(r);
                C.update(l);
                var U = C.digest();
                return C.clean(), U
            }, l.equal = function(r, C) {
                return r.length === l.DIGEST_LENGTH && C.length === l.DIGEST_LENGTH && U.equal(r, C)
            }
        },
        42532: function(r, l, C) {
            "use strict";
            Object.defineProperty(l, "__esModule", {
                value: !0
            }), l.randomStringForEntropy = l.randomString = l.randomUint32 = l.randomBytes = l.defaultRandomSource = void 0;
            let U = C(38104),
                et = C(34996),
                eo = C(97393);

            function randomBytes(r, C = l.defaultRandomSource) {
                return C.randomBytes(r)
            }
            l.defaultRandomSource = new U.SystemRandomSource, l.randomBytes = randomBytes, l.randomUint32 = function(r = l.defaultRandomSource) {
                let C = randomBytes(4, r),
                    U = (0, et.readUint32LE)(C);
                return (0, eo.wipe)(C), U
            };
            let es = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

            function randomString(r, C = es, U = l.defaultRandomSource) {
                if (C.length < 2) throw Error("randomString charset is too short");
                if (C.length > 256) throw Error("randomString charset is too long");
                let et = "",
                    el = C.length,
                    ec = 256 - 256 % el;
                for (; r > 0;) {
                    let l = randomBytes(Math.ceil(256 * r / ec), U);
                    for (let U = 0; U < l.length && r > 0; U++) {
                        let eo = l[U];
                        eo < ec && (et += C.charAt(eo % el), r--)
                    }(0, eo.wipe)(l)
                }
                return et
            }
            l.randomString = randomString, l.randomStringForEntropy = function(r, C = es, U = l.defaultRandomSource) {
                let et = Math.ceil(r / (Math.log(C.length) / Math.LN2));
                return randomString(et, C, U)
            }
        },
        10778: function(r, l) {
            "use strict";
            Object.defineProperty(l, "__esModule", {
                value: !0
            }), l.BrowserRandomSource = void 0, l.BrowserRandomSource = class {
                constructor() {
                    this.isAvailable = !1, this.isInstantiated = !1;
                    let r = "undefined" != typeof self ? self.crypto || self.msCrypto : null;
                    r && void 0 !== r.getRandomValues && (this._crypto = r, this.isAvailable = !0, this.isInstantiated = !0)
                }
                randomBytes(r) {
                    if (!this.isAvailable || !this._crypto) throw Error("Browser random byte generator is not available.");
                    let l = new Uint8Array(r);
                    for (let r = 0; r < l.length; r += 65536) this._crypto.getRandomValues(l.subarray(r, r + Math.min(l.length - r, 65536)));
                    return l
                }
            }
        },
        96581: function(r, l, C) {
            "use strict";
            Object.defineProperty(l, "__esModule", {
                value: !0
            }), l.NodeRandomSource = void 0;
            let U = C(97393);
            l.NodeRandomSource = class {
                constructor() {
                    this.isAvailable = !1, this.isInstantiated = !1; {
                        let r = C(73804);
                        r && r.randomBytes && (this._crypto = r, this.isAvailable = !0, this.isInstantiated = !0)
                    }
                }
                randomBytes(r) {
                    if (!this.isAvailable || !this._crypto) throw Error("Node.js random byte generator is not available.");
                    let l = this._crypto.randomBytes(r);
                    if (l.length !== r) throw Error("NodeRandomSource: got fewer bytes than requested");
                    let C = new Uint8Array(r);
                    for (let r = 0; r < C.length; r++) C[r] = l[r];
                    return (0, U.wipe)(l), C
                }
            }
        },
        38104: function(r, l, C) {
            "use strict";
            Object.defineProperty(l, "__esModule", {
                value: !0
            }), l.SystemRandomSource = void 0;
            let U = C(10778),
                et = C(96581);
            l.SystemRandomSource = class {
                constructor() {
                    if (this.isAvailable = !1, this.name = "", this._source = new U.BrowserRandomSource, this._source.isAvailable) {
                        this.isAvailable = !0, this.name = "Browser";
                        return
                    }
                    if (this._source = new et.NodeRandomSource, this._source.isAvailable) {
                        this.isAvailable = !0, this.name = "Node";
                        return
                    }
                }
                randomBytes(r) {
                    if (!this.isAvailable) throw Error("System random byte generator is not available.");
                    return this._source.randomBytes(r)
                }
            }
        },
        15086: function(r, l, C) {
            "use strict";
            var U = C(34996),
                et = C(97393);
            l.k = 32, l.cn = 64;
            var eo = function() {
                function SHA256() {
                    this.digestLength = l.k, this.blockSize = l.cn, this._state = new Int32Array(8), this._temp = new Int32Array(64), this._buffer = new Uint8Array(128), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset()
                }
                return SHA256.prototype._initState = function() {
                    this._state[0] = 1779033703, this._state[1] = 3144134277, this._state[2] = 1013904242, this._state[3] = 2773480762, this._state[4] = 1359893119, this._state[5] = 2600822924, this._state[6] = 528734635, this._state[7] = 1541459225
                }, SHA256.prototype.reset = function() {
                    return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this
                }, SHA256.prototype.clean = function() {
                    et.wipe(this._buffer), et.wipe(this._temp), this.reset()
                }, SHA256.prototype.update = function(r, l) {
                    if (void 0 === l && (l = r.length), this._finished) throw Error("SHA256: can't update because hash was finished.");
                    var C = 0;
                    if (this._bytesHashed += l, this._bufferLength > 0) {
                        for (; this._bufferLength < this.blockSize && l > 0;) this._buffer[this._bufferLength++] = r[C++], l--;
                        this._bufferLength === this.blockSize && (hashBlocks(this._temp, this._state, this._buffer, 0, this.blockSize), this._bufferLength = 0)
                    }
                    for (l >= this.blockSize && (C = hashBlocks(this._temp, this._state, r, C, l), l %= this.blockSize); l > 0;) this._buffer[this._bufferLength++] = r[C++], l--;
                    return this
                }, SHA256.prototype.finish = function(r) {
                    if (!this._finished) {
                        var l = this._bytesHashed,
                            C = this._bufferLength,
                            et = l % 64 < 56 ? 64 : 128;
                        this._buffer[C] = 128;
                        for (var eo = C + 1; eo < et - 8; eo++) this._buffer[eo] = 0;
                        U.writeUint32BE(l / 536870912 | 0, this._buffer, et - 8), U.writeUint32BE(l << 3, this._buffer, et - 4), hashBlocks(this._temp, this._state, this._buffer, 0, et), this._finished = !0
                    }
                    for (var eo = 0; eo < this.digestLength / 4; eo++) U.writeUint32BE(this._state[eo], r, 4 * eo);
                    return this
                }, SHA256.prototype.digest = function() {
                    var r = new Uint8Array(this.digestLength);
                    return this.finish(r), r
                }, SHA256.prototype.saveState = function() {
                    if (this._finished) throw Error("SHA256: cannot save finished state");
                    return {
                        state: new Int32Array(this._state),
                        buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
                        bufferLength: this._bufferLength,
                        bytesHashed: this._bytesHashed
                    }
                }, SHA256.prototype.restoreState = function(r) {
                    return this._state.set(r.state), this._bufferLength = r.bufferLength, r.buffer && this._buffer.set(r.buffer), this._bytesHashed = r.bytesHashed, this._finished = !1, this
                }, SHA256.prototype.cleanSavedState = function(r) {
                    et.wipe(r.state), r.buffer && et.wipe(r.buffer), r.bufferLength = 0, r.bytesHashed = 0
                }, SHA256
            }();
            l.mE = eo;
            var es = new Int32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);

            function hashBlocks(r, l, C, et, eo) {
                for (; eo >= 64;) {
                    for (var el = l[0], ec = l[1], ed = l[2], eh = l[3], ef = l[4], ep = l[5], eg = l[6], ey = l[7], em = 0; em < 16; em++) {
                        var e_ = et + 4 * em;
                        r[em] = U.readUint32BE(C, e_)
                    }
                    for (var em = 16; em < 64; em++) {
                        var eb = r[em - 2],
                            ew = (eb >>> 17 | eb << 15) ^ (eb >>> 19 | eb << 13) ^ eb >>> 10,
                            eE = ((eb = r[em - 15]) >>> 7 | eb << 25) ^ (eb >>> 18 | eb << 14) ^ eb >>> 3;
                        r[em] = (ew + r[em - 7] | 0) + (eE + r[em - 16] | 0)
                    }
                    for (var em = 0; em < 64; em++) {
                        var ew = (((ef >>> 6 | ef << 26) ^ (ef >>> 11 | ef << 21) ^ (ef >>> 25 | ef << 7)) + (ef & ep ^ ~ef & eg) | 0) + (ey + (es[em] + r[em] | 0) | 0) | 0,
                            eE = ((el >>> 2 | el << 30) ^ (el >>> 13 | el << 19) ^ (el >>> 22 | el << 10)) + (el & ec ^ el & ed ^ ec & ed) | 0;
                        ey = eg, eg = ep, ep = ef, ef = eh + ew | 0, eh = ed, ed = ec, ec = el, el = ew + eE | 0
                    }
                    l[0] += el, l[1] += ec, l[2] += ed, l[3] += eh, l[4] += ef, l[5] += ep, l[6] += eg, l[7] += ey, et += 64, eo -= 64
                }
                return et
            }
            l.vp = function(r) {
                var l = new eo;
                l.update(r);
                var C = l.digest();
                return l.clean(), C
            }
        },
        13483: function(r, l, C) {
            "use strict";
            Object.defineProperty(l, "__esModule", {
                value: !0
            });
            var U = C(34996),
                et = C(97393);
            l.DIGEST_LENGTH = 64, l.BLOCK_SIZE = 128;
            var eo = function() {
                function SHA512() {
                    this.digestLength = l.DIGEST_LENGTH, this.blockSize = l.BLOCK_SIZE, this._stateHi = new Int32Array(8), this._stateLo = new Int32Array(8), this._tempHi = new Int32Array(16), this._tempLo = new Int32Array(16), this._buffer = new Uint8Array(256), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset()
                }
                return SHA512.prototype._initState = function() {
                    this._stateHi[0] = 1779033703, this._stateHi[1] = 3144134277, this._stateHi[2] = 1013904242, this._stateHi[3] = 2773480762, this._stateHi[4] = 1359893119, this._stateHi[5] = 2600822924, this._stateHi[6] = 528734635, this._stateHi[7] = 1541459225, this._stateLo[0] = 4089235720, this._stateLo[1] = 2227873595, this._stateLo[2] = 4271175723, this._stateLo[3] = 1595750129, this._stateLo[4] = 2917565137, this._stateLo[5] = 725511199, this._stateLo[6] = 4215389547, this._stateLo[7] = 327033209
                }, SHA512.prototype.reset = function() {
                    return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this
                }, SHA512.prototype.clean = function() {
                    et.wipe(this._buffer), et.wipe(this._tempHi), et.wipe(this._tempLo), this.reset()
                }, SHA512.prototype.update = function(r, C) {
                    if (void 0 === C && (C = r.length), this._finished) throw Error("SHA512: can't update because hash was finished.");
                    var U = 0;
                    if (this._bytesHashed += C, this._bufferLength > 0) {
                        for (; this._bufferLength < l.BLOCK_SIZE && C > 0;) this._buffer[this._bufferLength++] = r[U++], C--;
                        this._bufferLength === this.blockSize && (hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize), this._bufferLength = 0)
                    }
                    for (C >= this.blockSize && (U = hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, r, U, C), C %= this.blockSize); C > 0;) this._buffer[this._bufferLength++] = r[U++], C--;
                    return this
                }, SHA512.prototype.finish = function(r) {
                    if (!this._finished) {
                        var l = this._bytesHashed,
                            C = this._bufferLength,
                            et = l % 128 < 112 ? 128 : 256;
                        this._buffer[C] = 128;
                        for (var eo = C + 1; eo < et - 8; eo++) this._buffer[eo] = 0;
                        U.writeUint32BE(l / 536870912 | 0, this._buffer, et - 8), U.writeUint32BE(l << 3, this._buffer, et - 4), hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, et), this._finished = !0
                    }
                    for (var eo = 0; eo < this.digestLength / 8; eo++) U.writeUint32BE(this._stateHi[eo], r, 8 * eo), U.writeUint32BE(this._stateLo[eo], r, 8 * eo + 4);
                    return this
                }, SHA512.prototype.digest = function() {
                    var r = new Uint8Array(this.digestLength);
                    return this.finish(r), r
                }, SHA512.prototype.saveState = function() {
                    if (this._finished) throw Error("SHA256: cannot save finished state");
                    return {
                        stateHi: new Int32Array(this._stateHi),
                        stateLo: new Int32Array(this._stateLo),
                        buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
                        bufferLength: this._bufferLength,
                        bytesHashed: this._bytesHashed
                    }
                }, SHA512.prototype.restoreState = function(r) {
                    return this._stateHi.set(r.stateHi), this._stateLo.set(r.stateLo), this._bufferLength = r.bufferLength, r.buffer && this._buffer.set(r.buffer), this._bytesHashed = r.bytesHashed, this._finished = !1, this
                }, SHA512.prototype.cleanSavedState = function(r) {
                    et.wipe(r.stateHi), et.wipe(r.stateLo), r.buffer && et.wipe(r.buffer), r.bufferLength = 0, r.bytesHashed = 0
                }, SHA512
            }();
            l.SHA512 = eo;
            var es = new Int32Array([1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591]);

            function hashBlocks(r, l, C, et, eo, el, ec) {
                for (var ed, eh, ef, ep, eg, ey, em, e_, eb = C[0], ew = C[1], eE = C[2], eI = C[3], eS = C[4], ex = C[5], eA = C[6], eP = C[7], eC = et[0], ek = et[1], eN = et[2], eO = et[3], eT = et[4], eR = et[5], eD = et[6], eB = et[7]; ec >= 128;) {
                    for (var eU = 0; eU < 16; eU++) {
                        var eL = 8 * eU + el;
                        r[eU] = U.readUint32BE(eo, eL), l[eU] = U.readUint32BE(eo, eL + 4)
                    }
                    for (var eU = 0; eU < 80; eU++) {
                        var eM = eb,
                            ej = ew,
                            e$ = eE,
                            ez = eI,
                            eH = eS,
                            eF = ex,
                            eW = eA,
                            eV = eP,
                            eK = eC,
                            eG = ek,
                            eJ = eN,
                            eY = eO,
                            eZ = eT,
                            eX = eR,
                            eQ = eD,
                            e0 = eB;
                        if (ed = eP, eg = 65535 & (eh = eB), ey = eh >>> 16, em = 65535 & ed, e_ = ed >>> 16, ed = (eS >>> 14 | eT << 18) ^ (eS >>> 18 | eT << 14) ^ (eT >>> 9 | eS << 23), eg += 65535 & (eh = (eT >>> 14 | eS << 18) ^ (eT >>> 18 | eS << 14) ^ (eS >>> 9 | eT << 23)), ey += eh >>> 16, em += 65535 & ed, e_ += ed >>> 16, ed = eS & ex ^ ~eS & eA, eg += 65535 & (eh = eT & eR ^ ~eT & eD), ey += eh >>> 16, em += 65535 & ed, e_ += ed >>> 16, ed = es[2 * eU], eg += 65535 & (eh = es[2 * eU + 1]), ey += eh >>> 16, em += 65535 & ed, e_ += ed >>> 16, ed = r[eU % 16], eg += 65535 & (eh = l[eU % 16]), ey += eh >>> 16, em += 65535 & ed, e_ += ed >>> 16, ey += eg >>> 16, em += ey >>> 16, e_ += em >>> 16, ef = 65535 & em | e_ << 16, ep = 65535 & eg | ey << 16, ed = ef, eg = 65535 & (eh = ep), ey = eh >>> 16, em = 65535 & ed, e_ = ed >>> 16, ed = (eb >>> 28 | eC << 4) ^ (eC >>> 2 | eb << 30) ^ (eC >>> 7 | eb << 25), eg += 65535 & (eh = (eC >>> 28 | eb << 4) ^ (eb >>> 2 | eC << 30) ^ (eb >>> 7 | eC << 25)), ey += eh >>> 16, em += 65535 & ed, e_ += ed >>> 16, ed = eb & ew ^ eb & eE ^ ew & eE, eg += 65535 & (eh = eC & ek ^ eC & eN ^ ek & eN), ey += eh >>> 16, em += 65535 & ed, e_ += ed >>> 16, ey += eg >>> 16, em += ey >>> 16, e_ += em >>> 16, eV = 65535 & em | e_ << 16, e0 = 65535 & eg | ey << 16, ed = ez, eg = 65535 & (eh = eY), ey = eh >>> 16, em = 65535 & ed, e_ = ed >>> 16, ed = ef, eg += 65535 & (eh = ep), ey += eh >>> 16, em += 65535 & ed, e_ += ed >>> 16, ey += eg >>> 16, em += ey >>> 16, e_ += em >>> 16, ez = 65535 & em | e_ << 16, eY = 65535 & eg | ey << 16, ew = eM, eE = ej, eI = e$, eS = ez, ex = eH, eA = eF, eP = eW, eb = eV, ek = eK, eN = eG, eO = eJ, eT = eY, eR = eZ, eD = eX, eB = eQ, eC = e0, eU % 16 == 15)
                            for (var eL = 0; eL < 16; eL++) ed = r[eL], eg = 65535 & (eh = l[eL]), ey = eh >>> 16, em = 65535 & ed, e_ = ed >>> 16, ed = r[(eL + 9) % 16], eg += 65535 & (eh = l[(eL + 9) % 16]), ey += eh >>> 16, em += 65535 & ed, e_ += ed >>> 16, ed = ((ef = r[(eL + 1) % 16]) >>> 1 | (ep = l[(eL + 1) % 16]) << 31) ^ (ef >>> 8 | ep << 24) ^ ef >>> 7, eg += 65535 & (eh = (ep >>> 1 | ef << 31) ^ (ep >>> 8 | ef << 24) ^ (ep >>> 7 | ef << 25)), ey += eh >>> 16, em += 65535 & ed, e_ += ed >>> 16, ed = ((ef = r[(eL + 14) % 16]) >>> 19 | (ep = l[(eL + 14) % 16]) << 13) ^ (ep >>> 29 | ef << 3) ^ ef >>> 6, eg += 65535 & (eh = (ep >>> 19 | ef << 13) ^ (ef >>> 29 | ep << 3) ^ (ep >>> 6 | ef << 26)), ey += eh >>> 16, em += 65535 & ed, e_ += ed >>> 16, ey += eg >>> 16, em += ey >>> 16, e_ += em >>> 16, r[eL] = 65535 & em | e_ << 16, l[eL] = 65535 & eg | ey << 16
                    }
                    ed = eb, eg = 65535 & (eh = eC), ey = eh >>> 16, em = 65535 & ed, e_ = ed >>> 16, ed = C[0], eg += 65535 & (eh = et[0]), ey += eh >>> 16, em += 65535 & ed, e_ += ed >>> 16, ey += eg >>> 16, em += ey >>> 16, e_ += em >>> 16, C[0] = eb = 65535 & em | e_ << 16, et[0] = eC = 65535 & eg | ey << 16, ed = ew, eg = 65535 & (eh = ek), ey = eh >>> 16, em = 65535 & ed, e_ = ed >>> 16, ed = C[1], eg += 65535 & (eh = et[1]), ey += eh >>> 16, em += 65535 & ed, e_ += ed >>> 16, ey += eg >>> 16, em += ey >>> 16, e_ += em >>> 16, C[1] = ew = 65535 & em | e_ << 16, et[1] = ek = 65535 & eg | ey << 16, ed = eE, eg = 65535 & (eh = eN), ey = eh >>> 16, em = 65535 & ed, e_ = ed >>> 16, ed = C[2], eg += 65535 & (eh = et[2]), ey += eh >>> 16, em += 65535 & ed, e_ += ed >>> 16, ey += eg >>> 16, em += ey >>> 16, e_ += em >>> 16, C[2] = eE = 65535 & em | e_ << 16, et[2] = eN = 65535 & eg | ey << 16, ed = eI, eg = 65535 & (eh = eO), ey = eh >>> 16, em = 65535 & ed, e_ = ed >>> 16, ed = C[3], eg += 65535 & (eh = et[3]), ey += eh >>> 16, em += 65535 & ed, e_ += ed >>> 16, ey += eg >>> 16, em += ey >>> 16, e_ += em >>> 16, C[3] = eI = 65535 & em | e_ << 16, et[3] = eO = 65535 & eg | ey << 16, ed = eS, eg = 65535 & (eh = eT), ey = eh >>> 16, em = 65535 & ed, e_ = ed >>> 16, ed = C[4], eg += 65535 & (eh = et[4]), ey += eh >>> 16, em += 65535 & ed, e_ += ed >>> 16, ey += eg >>> 16, em += ey >>> 16, e_ += em >>> 16, C[4] = eS = 65535 & em | e_ << 16, et[4] = eT = 65535 & eg | ey << 16, ed = ex, eg = 65535 & (eh = eR), ey = eh >>> 16, em = 65535 & ed, e_ = ed >>> 16, ed = C[5], eg += 65535 & (eh = et[5]), ey += eh >>> 16, em += 65535 & ed, e_ += ed >>> 16, ey += eg >>> 16, em += ey >>> 16, e_ += em >>> 16, C[5] = ex = 65535 & em | e_ << 16, et[5] = eR = 65535 & eg | ey << 16, ed = eA, eg = 65535 & (eh = eD), ey = eh >>> 16, em = 65535 & ed, e_ = ed >>> 16, ed = C[6], eg += 65535 & (eh = et[6]), ey += eh >>> 16, em += 65535 & ed, e_ += ed >>> 16, ey += eg >>> 16, em += ey >>> 16, e_ += em >>> 16, C[6] = eA = 65535 & em | e_ << 16, et[6] = eD = 65535 & eg | ey << 16, ed = eP, eg = 65535 & (eh = eB), ey = eh >>> 16, em = 65535 & ed, e_ = ed >>> 16, ed = C[7], eg += 65535 & (eh = et[7]), ey += eh >>> 16, em += 65535 & ed, e_ += ed >>> 16, ey += eg >>> 16, em += ey >>> 16, e_ += em >>> 16, C[7] = eP = 65535 & em | e_ << 16, et[7] = eB = 65535 & eg | ey << 16, el += 128, ec -= 128
                }
                return el
            }
            l.hash = function(r) {
                var l = new eo;
                l.update(r);
                var C = l.digest();
                return l.clean(), C
            }
        },
        97393: function(r, l) {
            "use strict";
            Object.defineProperty(l, "__esModule", {
                value: !0
            }), l.wipe = function(r) {
                for (var l = 0; l < r.length; l++) r[l] = 0;
                return r
            }
        },
        66436: function(r, l, C) {
            "use strict";
            l.gi = l.Au = l.KS = l.kz = void 0;
            let U = C(42532),
                et = C(97393);

            function gf(r) {
                let l = new Float64Array(16);
                if (r)
                    for (let C = 0; C < r.length; C++) l[C] = r[C];
                return l
            }
            l.kz = 32, l.KS = 32;
            let eo = new Uint8Array(32);
            eo[0] = 9;
            let es = gf([56129, 1]);

            function car25519(r) {
                let l = 1;
                for (let C = 0; C < 16; C++) {
                    let U = r[C] + l + 65535;
                    l = Math.floor(U / 65536), r[C] = U - 65536 * l
                }
                r[0] += l - 1 + 37 * (l - 1)
            }

            function sel25519(r, l, C) {
                let U = ~(C - 1);
                for (let C = 0; C < 16; C++) {
                    let et = U & (r[C] ^ l[C]);
                    r[C] ^= et, l[C] ^= et
                }
            }

            function add(r, l, C) {
                for (let U = 0; U < 16; U++) r[U] = l[U] + C[U]
            }

            function sub(r, l, C) {
                for (let U = 0; U < 16; U++) r[U] = l[U] - C[U]
            }

            function mul(r, l, C) {
                let U, et, eo = 0,
                    es = 0,
                    el = 0,
                    ec = 0,
                    ed = 0,
                    eh = 0,
                    ef = 0,
                    ep = 0,
                    eg = 0,
                    ey = 0,
                    em = 0,
                    e_ = 0,
                    eb = 0,
                    ew = 0,
                    eE = 0,
                    eI = 0,
                    eS = 0,
                    ex = 0,
                    eA = 0,
                    eP = 0,
                    eC = 0,
                    ek = 0,
                    eN = 0,
                    eO = 0,
                    eT = 0,
                    eR = 0,
                    eD = 0,
                    eB = 0,
                    eU = 0,
                    eL = 0,
                    eM = 0,
                    ej = C[0],
                    e$ = C[1],
                    ez = C[2],
                    eH = C[3],
                    eF = C[4],
                    eW = C[5],
                    eV = C[6],
                    eK = C[7],
                    eG = C[8],
                    eJ = C[9],
                    eY = C[10],
                    eZ = C[11],
                    eX = C[12],
                    eQ = C[13],
                    e0 = C[14],
                    e1 = C[15];
                eo += (U = l[0]) * ej, es += U * e$, el += U * ez, ec += U * eH, ed += U * eF, eh += U * eW, ef += U * eV, ep += U * eK, eg += U * eG, ey += U * eJ, em += U * eY, e_ += U * eZ, eb += U * eX, ew += U * eQ, eE += U * e0, eI += U * e1, es += (U = l[1]) * ej, el += U * e$, ec += U * ez, ed += U * eH, eh += U * eF, ef += U * eW, ep += U * eV, eg += U * eK, ey += U * eG, em += U * eJ, e_ += U * eY, eb += U * eZ, ew += U * eX, eE += U * eQ, eI += U * e0, eS += U * e1, el += (U = l[2]) * ej, ec += U * e$, ed += U * ez, eh += U * eH, ef += U * eF, ep += U * eW, eg += U * eV, ey += U * eK, em += U * eG, e_ += U * eJ, eb += U * eY, ew += U * eZ, eE += U * eX, eI += U * eQ, eS += U * e0, ex += U * e1, ec += (U = l[3]) * ej, ed += U * e$, eh += U * ez, ef += U * eH, ep += U * eF, eg += U * eW, ey += U * eV, em += U * eK, e_ += U * eG, eb += U * eJ, ew += U * eY, eE += U * eZ, eI += U * eX, eS += U * eQ, ex += U * e0, eA += U * e1, ed += (U = l[4]) * ej, eh += U * e$, ef += U * ez, ep += U * eH, eg += U * eF, ey += U * eW, em += U * eV, e_ += U * eK, eb += U * eG, ew += U * eJ, eE += U * eY, eI += U * eZ, eS += U * eX, ex += U * eQ, eA += U * e0, eP += U * e1, eh += (U = l[5]) * ej, ef += U * e$, ep += U * ez, eg += U * eH, ey += U * eF, em += U * eW, e_ += U * eV, eb += U * eK, ew += U * eG, eE += U * eJ, eI += U * eY, eS += U * eZ, ex += U * eX, eA += U * eQ, eP += U * e0, eC += U * e1, ef += (U = l[6]) * ej, ep += U * e$, eg += U * ez, ey += U * eH, em += U * eF, e_ += U * eW, eb += U * eV, ew += U * eK, eE += U * eG, eI += U * eJ, eS += U * eY, ex += U * eZ, eA += U * eX, eP += U * eQ, eC += U * e0, ek += U * e1, ep += (U = l[7]) * ej, eg += U * e$, ey += U * ez, em += U * eH, e_ += U * eF, eb += U * eW, ew += U * eV, eE += U * eK, eI += U * eG, eS += U * eJ, ex += U * eY, eA += U * eZ, eP += U * eX, eC += U * eQ, ek += U * e0, eN += U * e1, eg += (U = l[8]) * ej, ey += U * e$, em += U * ez, e_ += U * eH, eb += U * eF, ew += U * eW, eE += U * eV, eI += U * eK, eS += U * eG, ex += U * eJ, eA += U * eY, eP += U * eZ, eC += U * eX, ek += U * eQ, eN += U * e0, eO += U * e1, ey += (U = l[9]) * ej, em += U * e$, e_ += U * ez, eb += U * eH, ew += U * eF, eE += U * eW, eI += U * eV, eS += U * eK, ex += U * eG, eA += U * eJ, eP += U * eY, eC += U * eZ, ek += U * eX, eN += U * eQ, eO += U * e0, eT += U * e1, em += (U = l[10]) * ej, e_ += U * e$, eb += U * ez, ew += U * eH, eE += U * eF, eI += U * eW, eS += U * eV, ex += U * eK, eA += U * eG, eP += U * eJ, eC += U * eY, ek += U * eZ, eN += U * eX, eO += U * eQ, eT += U * e0, eR += U * e1, e_ += (U = l[11]) * ej, eb += U * e$, ew += U * ez, eE += U * eH, eI += U * eF, eS += U * eW, ex += U * eV, eA += U * eK, eP += U * eG, eC += U * eJ, ek += U * eY, eN += U * eZ, eO += U * eX, eT += U * eQ, eR += U * e0, eD += U * e1, eb += (U = l[12]) * ej, ew += U * e$, eE += U * ez, eI += U * eH, eS += U * eF, ex += U * eW, eA += U * eV, eP += U * eK, eC += U * eG, ek += U * eJ, eN += U * eY, eO += U * eZ, eT += U * eX, eR += U * eQ, eD += U * e0, eB += U * e1, ew += (U = l[13]) * ej, eE += U * e$, eI += U * ez, eS += U * eH, ex += U * eF, eA += U * eW, eP += U * eV, eC += U * eK, ek += U * eG, eN += U * eJ, eO += U * eY, eT += U * eZ, eR += U * eX, eD += U * eQ, eB += U * e0, eU += U * e1, eE += (U = l[14]) * ej, eI += U * e$, eS += U * ez, ex += U * eH, eA += U * eF, eP += U * eW, eC += U * eV, ek += U * eK, eN += U * eG, eO += U * eJ, eT += U * eY, eR += U * eZ, eD += U * eX, eB += U * eQ, eU += U * e0, eL += U * e1, eI += (U = l[15]) * ej, eS += U * e$, ex += U * ez, eA += U * eH, eP += U * eF, eC += U * eW, ek += U * eV, eN += U * eK, eO += U * eG, eT += U * eJ, eR += U * eY, eD += U * eZ, eB += U * eX, eU += U * eQ, eL += U * e0, eM += U * e1, eo += 38 * eS, es += 38 * ex, el += 38 * eA, ec += 38 * eP, ed += 38 * eC, eh += 38 * ek, ef += 38 * eN, ep += 38 * eO, eg += 38 * eT, ey += 38 * eR, em += 38 * eD, e_ += 38 * eB, eb += 38 * eU, ew += 38 * eL, eE += 38 * eM, et = Math.floor((U = eo + (et = 1) + 65535) / 65536), eo = U - 65536 * et, et = Math.floor((U = es + et + 65535) / 65536), es = U - 65536 * et, et = Math.floor((U = el + et + 65535) / 65536), el = U - 65536 * et, et = Math.floor((U = ec + et + 65535) / 65536), ec = U - 65536 * et, et = Math.floor((U = ed + et + 65535) / 65536), ed = U - 65536 * et, et = Math.floor((U = eh + et + 65535) / 65536), eh = U - 65536 * et, et = Math.floor((U = ef + et + 65535) / 65536), ef = U - 65536 * et, et = Math.floor((U = ep + et + 65535) / 65536), ep = U - 65536 * et, et = Math.floor((U = eg + et + 65535) / 65536), eg = U - 65536 * et, et = Math.floor((U = ey + et + 65535) / 65536), ey = U - 65536 * et, et = Math.floor((U = em + et + 65535) / 65536), em = U - 65536 * et, et = Math.floor((U = e_ + et + 65535) / 65536), e_ = U - 65536 * et, et = Math.floor((U = eb + et + 65535) / 65536), eb = U - 65536 * et, et = Math.floor((U = ew + et + 65535) / 65536), ew = U - 65536 * et, et = Math.floor((U = eE + et + 65535) / 65536), eE = U - 65536 * et, et = Math.floor((U = eI + et + 65535) / 65536), eI = U - 65536 * et, eo += et - 1 + 37 * (et - 1), et = Math.floor((U = eo + (et = 1) + 65535) / 65536), eo = U - 65536 * et, et = Math.floor((U = es + et + 65535) / 65536), es = U - 65536 * et, et = Math.floor((U = el + et + 65535) / 65536), el = U - 65536 * et, et = Math.floor((U = ec + et + 65535) / 65536), ec = U - 65536 * et, et = Math.floor((U = ed + et + 65535) / 65536), ed = U - 65536 * et, et = Math.floor((U = eh + et + 65535) / 65536), eh = U - 65536 * et, et = Math.floor((U = ef + et + 65535) / 65536), ef = U - 65536 * et, et = Math.floor((U = ep + et + 65535) / 65536), ep = U - 65536 * et, et = Math.floor((U = eg + et + 65535) / 65536), eg = U - 65536 * et, et = Math.floor((U = ey + et + 65535) / 65536), ey = U - 65536 * et, et = Math.floor((U = em + et + 65535) / 65536), em = U - 65536 * et, et = Math.floor((U = e_ + et + 65535) / 65536), e_ = U - 65536 * et, et = Math.floor((U = eb + et + 65535) / 65536), eb = U - 65536 * et, et = Math.floor((U = ew + et + 65535) / 65536), ew = U - 65536 * et, et = Math.floor((U = eE + et + 65535) / 65536), eE = U - 65536 * et, et = Math.floor((U = eI + et + 65535) / 65536), eI = U - 65536 * et, eo += et - 1 + 37 * (et - 1), r[0] = eo, r[1] = es, r[2] = el, r[3] = ec, r[4] = ed, r[5] = eh, r[6] = ef, r[7] = ep, r[8] = eg, r[9] = ey, r[10] = em, r[11] = e_, r[12] = eb, r[13] = ew, r[14] = eE, r[15] = eI
            }

            function scalarMult(r, l) {
                let C = new Uint8Array(32),
                    U = new Float64Array(80),
                    et = gf(),
                    eo = gf(),
                    el = gf(),
                    ec = gf(),
                    ed = gf(),
                    eh = gf();
                for (let l = 0; l < 31; l++) C[l] = r[l];
                C[31] = 127 & r[31] | 64, C[0] &= 248,
                    function(r, l) {
                        for (let C = 0; C < 16; C++) r[C] = l[2 * C] + (l[2 * C + 1] << 8);
                        r[15] &= 32767
                    }(U, l);
                for (let r = 0; r < 16; r++) eo[r] = U[r];
                et[0] = ec[0] = 1;
                for (let r = 254; r >= 0; --r) {
                    let l = C[r >>> 3] >>> (7 & r) & 1;
                    sel25519(et, eo, l), sel25519(el, ec, l), add(ed, et, el), sub(et, et, el), add(el, eo, ec), sub(eo, eo, ec), mul(ec, ed, ed), mul(eh, et, et), mul(et, el, et), mul(el, eo, ed), add(ed, et, el), sub(et, et, el), mul(eo, et, et), sub(el, ec, eh), mul(et, el, es), add(et, et, ec), mul(el, el, et), mul(et, ec, eh), mul(ec, eo, U), mul(eo, ed, ed), sel25519(et, eo, l), sel25519(el, ec, l)
                }
                for (let r = 0; r < 16; r++) U[r + 16] = et[r], U[r + 32] = el[r], U[r + 48] = eo[r], U[r + 64] = ec[r];
                let ef = U.subarray(32),
                    ep = U.subarray(16);
                ! function(r, l) {
                    let C = gf();
                    for (let r = 0; r < 16; r++) C[r] = l[r];
                    for (let r = 253; r >= 0; r--) mul(C, C, C), 2 !== r && 4 !== r && mul(C, C, l);
                    for (let l = 0; l < 16; l++) r[l] = C[l]
                }(ef, ef), mul(ep, ep, ef);
                let eg = new Uint8Array(32);
                return ! function(r, l) {
                    let C = gf(),
                        U = gf();
                    for (let r = 0; r < 16; r++) U[r] = l[r];
                    car25519(U), car25519(U), car25519(U);
                    for (let r = 0; r < 2; r++) {
                        C[0] = U[0] - 65517;
                        for (let r = 1; r < 15; r++) C[r] = U[r] - 65535 - (C[r - 1] >> 16 & 1), C[r - 1] &= 65535;
                        C[15] = U[15] - 32767 - (C[14] >> 16 & 1);
                        let r = C[15] >> 16 & 1;
                        C[14] &= 65535, sel25519(U, C, 1 - r)
                    }
                    for (let l = 0; l < 16; l++) r[2 * l] = 255 & U[l], r[2 * l + 1] = U[l] >> 8
                }(eg, ep), eg
            }
            l.Au = function(r) {
                let C = (0, U.randomBytes)(32, r),
                    es = function(r) {
                        if (r.length !== l.KS) throw Error(`x25519: seed must be ${l.KS} bytes`);
                        let C = new Uint8Array(r),
                            U = scalarMult(C, eo);
                        return {
                            publicKey: U,
                            secretKey: C
                        }
                    }(C);
                return (0, et.wipe)(C), es
            }, l.gi = function(r, C, U = !1) {
                if (r.length !== l.kz) throw Error("X25519: incorrect secret key length");
                if (C.length !== l.kz) throw Error("X25519: incorrect public key length");
                let et = scalarMult(r, C);
                if (U) {
                    let r = 0;
                    for (let l = 0; l < et.length; l++) r |= et[l];
                    if (0 === r) throw Error("X25519: invalid shared key")
                }
                return et
            }
        },
        88124: function(r, l, C) {
            "use strict";
            C.d(l, {
                q: function() {
                    return IEvents
                }
            });
            let IEvents = class IEvents {}
        },
        34662: function(r, l, C) {
            "use strict";
            C.r(l), C.d(l, {
                IEvents: function() {
                    return U.q
                }
            });
            var U = C(88124)
        },
        99329: function(r, l, C) {
            "use strict";
            Object.defineProperty(l, "__esModule", {
                value: !0
            }), l.HEARTBEAT_EVENTS = l.HEARTBEAT_INTERVAL = void 0;
            let U = C(23672);
            l.HEARTBEAT_INTERVAL = U.FIVE_SECONDS, l.HEARTBEAT_EVENTS = {
                pulse: "heartbeat_pulse"
            }
        },
        47872: function(r, l, C) {
            "use strict";
            Object.defineProperty(l, "__esModule", {
                value: !0
            });
            let U = C(1702);
            U.__exportStar(C(99329), l)
        },
        52137: function(r, l, C) {
            "use strict";
            Object.defineProperty(l, "__esModule", {
                value: !0
            }), l.HeartBeat = void 0;
            let U = C(1702),
                et = C(17414),
                eo = C(23672),
                es = C(55182),
                el = C(47872);
            let HeartBeat = class HeartBeat extends es.IHeartBeat {
                constructor(r) {
                    super(r), this.events = new et.EventEmitter, this.interval = el.HEARTBEAT_INTERVAL, this.interval = (null == r ? void 0 : r.interval) || el.HEARTBEAT_INTERVAL
                }
                static init(r) {
                    return U.__awaiter(this, void 0, void 0, function*() {
                        let l = new HeartBeat(r);
                        return yield l.init(), l
                    })
                }
                init() {
                    return U.__awaiter(this, void 0, void 0, function*() {
                        yield this.initialize()
                    })
                }
                stop() {
                    clearInterval(this.intervalRef)
                }
                on(r, l) {
                    this.events.on(r, l)
                }
                once(r, l) {
                    this.events.once(r, l)
                }
                off(r, l) {
                    this.events.off(r, l)
                }
                removeListener(r, l) {
                    this.events.removeListener(r, l)
                }
                initialize() {
                    return U.__awaiter(this, void 0, void 0, function*() {
                        this.intervalRef = setInterval(() => this.pulse(), eo.toMiliseconds(this.interval))
                    })
                }
                pulse() {
                    this.events.emit(el.HEARTBEAT_EVENTS.pulse)
                }
            };
            l.HeartBeat = HeartBeat
        },
        96527: function(r, l, C) {
            "use strict";
            Object.defineProperty(l, "__esModule", {
                value: !0
            });
            let U = C(1702);
            U.__exportStar(C(52137), l), U.__exportStar(C(55182), l), U.__exportStar(C(47872), l)
        },
        68482: function(r, l, C) {
            "use strict";
            Object.defineProperty(l, "__esModule", {
                value: !0
            }), l.IHeartBeat = void 0;
            let U = C(34662);
            let IHeartBeat = class IHeartBeat extends U.IEvents {
                constructor(r) {
                    super()
                }
            };
            l.IHeartBeat = IHeartBeat
        },
        55182: function(r, l, C) {
            "use strict";
            Object.defineProperty(l, "__esModule", {
                value: !0
            });
            let U = C(1702);
            U.__exportStar(C(68482), l)
        },
        82442: function(r, l) {
            "use strict";
            Object.defineProperty(l, "__esModule", {
                value: !0
            }), l.PINO_CUSTOM_CONTEXT_KEY = l.PINO_LOGGER_DEFAULTS = void 0, l.PINO_LOGGER_DEFAULTS = {
                level: "info"
            }, l.PINO_CUSTOM_CONTEXT_KEY = "custom_context"
        },
        17731: function(r, l, C) {
            "use strict";
            Object.defineProperty(l, "__esModule", {
                value: !0
            }), l.pino = void 0;
            let U = C(1702),
                et = U.__importDefault(C(42878));
            Object.defineProperty(l, "pino", {
                enumerable: !0,
                get: function() {
                    return et.default
                }
            }), U.__exportStar(C(82442), l), U.__exportStar(C(36412), l)
        },
        36412: function(r, l, C) {
            "use strict";
            Object.defineProperty(l, "__esModule", {
                value: !0
            }), l.generateChildLogger = l.formatChildLoggerContext = l.getLoggerContext = l.setBrowserLoggerContext = l.getBrowserLoggerContext = l.getDefaultLoggerOptions = void 0;
            let U = C(82442);

            function getBrowserLoggerContext(r, l = U.PINO_CUSTOM_CONTEXT_KEY) {
                return r[l] || ""
            }

            function setBrowserLoggerContext(r, l, C = U.PINO_CUSTOM_CONTEXT_KEY) {
                return r[C] = l, r
            }

            function getLoggerContext(r, l = U.PINO_CUSTOM_CONTEXT_KEY) {
                return void 0 === r.bindings ? getBrowserLoggerContext(r, l) : r.bindings().context || ""
            }

            function formatChildLoggerContext(r, l, C = U.PINO_CUSTOM_CONTEXT_KEY) {
                let et = getLoggerContext(r, C),
                    eo = et.trim() ? `${et}/${l}` : l;
                return eo
            }
            l.getDefaultLoggerOptions = function(r) {
                return Object.assign(Object.assign({}, r), {
                    level: (null == r ? void 0 : r.level) || U.PINO_LOGGER_DEFAULTS.level
                })
            }, l.getBrowserLoggerContext = getBrowserLoggerContext, l.setBrowserLoggerContext = setBrowserLoggerContext, l.getLoggerContext = getLoggerContext, l.formatChildLoggerContext = formatChildLoggerContext, l.generateChildLogger = function(r, l, C = U.PINO_CUSTOM_CONTEXT_KEY) {
                let et = formatChildLoggerContext(r, l, C),
                    eo = r.child({
                        context: et
                    });
                return setBrowserLoggerContext(eo, et, C)
            }
        },
        66206: function() {},
        71782: function() {},
        48021: function(r, l, C) {
            "use strict";
            Object.defineProperty(l, "__esModule", {
                value: !0
            });
            let U = C(1702);
            U.__exportStar(C(10283), l), U.__exportStar(C(39249), l)
        },
        10283: function(r, l) {
            "use strict";
            Object.defineProperty(l, "__esModule", {
                value: !0
            }), l.ONE_THOUSAND = l.ONE_HUNDRED = void 0, l.ONE_HUNDRED = 100, l.ONE_THOUSAND = 1e3
        },
        39249: function(r, l) {
            "use strict";
            Object.defineProperty(l, "__esModule", {
                value: !0
            }), l.ONE_YEAR = l.FOUR_WEEKS = l.THREE_WEEKS = l.TWO_WEEKS = l.ONE_WEEK = l.THIRTY_DAYS = l.SEVEN_DAYS = l.FIVE_DAYS = l.THREE_DAYS = l.ONE_DAY = l.TWENTY_FOUR_HOURS = l.TWELVE_HOURS = l.SIX_HOURS = l.THREE_HOURS = l.ONE_HOUR = l.SIXTY_MINUTES = l.THIRTY_MINUTES = l.TEN_MINUTES = l.FIVE_MINUTES = l.ONE_MINUTE = l.SIXTY_SECONDS = l.THIRTY_SECONDS = l.TEN_SECONDS = l.FIVE_SECONDS = l.ONE_SECOND = void 0, l.ONE_SECOND = 1, l.FIVE_SECONDS = 5, l.TEN_SECONDS = 10, l.THIRTY_SECONDS = 30, l.SIXTY_SECONDS = 60, l.ONE_MINUTE = l.SIXTY_SECONDS, l.FIVE_MINUTES = 5 * l.ONE_MINUTE, l.TEN_MINUTES = 10 * l.ONE_MINUTE, l.THIRTY_MINUTES = 30 * l.ONE_MINUTE, l.SIXTY_MINUTES = 60 * l.ONE_MINUTE, l.ONE_HOUR = l.SIXTY_MINUTES, l.THREE_HOURS = 3 * l.ONE_HOUR, l.SIX_HOURS = 6 * l.ONE_HOUR, l.TWELVE_HOURS = 12 * l.ONE_HOUR, l.TWENTY_FOUR_HOURS = 24 * l.ONE_HOUR, l.ONE_DAY = l.TWENTY_FOUR_HOURS, l.THREE_DAYS = 3 * l.ONE_DAY, l.FIVE_DAYS = 5 * l.ONE_DAY, l.SEVEN_DAYS = 7 * l.ONE_DAY, l.THIRTY_DAYS = 30 * l.ONE_DAY, l.ONE_WEEK = l.SEVEN_DAYS, l.TWO_WEEKS = 2 * l.ONE_WEEK, l.THREE_WEEKS = 3 * l.ONE_WEEK, l.FOUR_WEEKS = 4 * l.ONE_WEEK, l.ONE_YEAR = 365 * l.ONE_DAY
        },
        23672: function(r, l, C) {
            "use strict";
            Object.defineProperty(l, "__esModule", {
                value: !0
            });
            let U = C(1702);
            U.__exportStar(C(29985), l), U.__exportStar(C(78666), l), U.__exportStar(C(69317), l), U.__exportStar(C(48021), l)
        },
        69317: function(r, l, C) {
            "use strict";
            Object.defineProperty(l, "__esModule", {
                value: !0
            });
            let U = C(1702);
            U.__exportStar(C(14216), l)
        },
        14216: function(r, l) {
            "use strict";
            Object.defineProperty(l, "__esModule", {
                value: !0
            }), l.IWatch = void 0, l.IWatch = class {}
        },
        67780: function(r, l, C) {
            "use strict";
            Object.defineProperty(l, "__esModule", {
                value: !0
            }), l.fromMiliseconds = l.toMiliseconds = void 0;
            let U = C(48021);
            l.toMiliseconds = function(r) {
                return r * U.ONE_THOUSAND
            }, l.fromMiliseconds = function(r) {
                return Math.floor(r / U.ONE_THOUSAND)
            }
        },
        99590: function(r, l) {
            "use strict";
            Object.defineProperty(l, "__esModule", {
                value: !0
            }), l.delay = void 0, l.delay = function(r) {
                return new Promise(l => {
                    setTimeout(() => {
                        l(!0)
                    }, r)
                })
            }
        },
        29985: function(r, l, C) {
            "use strict";
            Object.defineProperty(l, "__esModule", {
                value: !0
            });
            let U = C(1702);
            U.__exportStar(C(99590), l), U.__exportStar(C(67780), l)
        },
        78666: function(r, l) {
            "use strict";
            Object.defineProperty(l, "__esModule", {
                value: !0
            }), l.Watch = void 0;
            let Watch = class Watch {
                constructor() {
                    this.timestamps = new Map
                }
                start(r) {
                    if (this.timestamps.has(r)) throw Error(`Watch already started for label: ${r}`);
                    this.timestamps.set(r, {
                        started: Date.now()
                    })
                }
                stop(r) {
                    let l = this.get(r);
                    if (void 0 !== l.elapsed) throw Error(`Watch already stopped for label: ${r}`);
                    let C = Date.now() - l.started;
                    this.timestamps.set(r, {
                        started: l.started,
                        elapsed: C
                    })
                }
                get(r) {
                    let l = this.timestamps.get(r);
                    if (void 0 === l) throw Error(`No timestamp found for label: ${r}`);
                    return l
                }
                elapsed(r) {
                    let l = this.get(r),
                        C = l.elapsed || Date.now() - l.started;
                    return C
                }
            };
            l.Watch = Watch, l.default = Watch
        },
        69818: function(r, l, C) {
            "use strict";
            l.D = void 0;
            let U = C(27324);
            l.D = function() {
                let r, l, C;
                try {
                    r = U.getDocumentOrThrow(), l = U.getLocationOrThrow()
                } catch (r) {
                    return null
                }

                function getWindowMetadataOfAny(...l) {
                    let C = r.getElementsByTagName("meta");
                    for (let r = 0; r < C.length; r++) {
                        let U = C[r],
                            et = ["itemprop", "property", "name"].map(r => U.getAttribute(r)).filter(r => !!r && l.includes(r));
                        if (et.length && et) {
                            let r = U.getAttribute("content");
                            if (r) return r
                        }
                    }
                    return ""
                }
                let et = ((C = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title")) || (C = r.title), C),
                    eo = function() {
                        let r = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
                        return r
                    }(),
                    es = l.origin,
                    el = function() {
                        let C = r.getElementsByTagName("link"),
                            U = [];
                        for (let r = 0; r < C.length; r++) {
                            let et = C[r],
                                eo = et.getAttribute("rel");
                            if (eo && eo.toLowerCase().indexOf("icon") > -1) {
                                let r = et.getAttribute("href");
                                if (r) {
                                    if (-1 === r.toLowerCase().indexOf("https:") && -1 === r.toLowerCase().indexOf("http:") && 0 !== r.indexOf("//")) {
                                        let C = l.protocol + "//" + l.host;
                                        if (0 === r.indexOf("/")) C += r;
                                        else {
                                            let U = l.pathname.split("/");
                                            U.pop();
                                            let et = U.join("/");
                                            C += et + "/" + r
                                        }
                                        U.push(C)
                                    } else if (0 === r.indexOf("//")) {
                                        let C = l.protocol + r;
                                        U.push(C)
                                    } else U.push(r)
                                }
                            }
                        }
                        return U
                    }();
                return {
                    description: eo,
                    url: es,
                    icons: el,
                    name: et
                }
            }
        },
        11782: function(r) {
            "use strict";
            let {
                AbortController: l,
                AbortSignal: C
            } = "undefined" != typeof self ? self : "undefined" != typeof window ? window : void 0;
            r.exports = l, r.exports.AbortSignal = C, r.exports.default = l
        },
        3368: function(r, l, C) {
            "use strict";
            var U = C(80053).Buffer;
            r.exports = function(r) {
                if (r.length >= 255) throw TypeError("Alphabet too long");
                for (var l = new Uint8Array(256), C = 0; C < l.length; C++) l[C] = 255;
                for (var et = 0; et < r.length; et++) {
                    var eo = r.charAt(et),
                        es = eo.charCodeAt(0);
                    if (255 !== l[es]) throw TypeError(eo + " is ambiguous");
                    l[es] = et
                }
                var el = r.length,
                    ec = r.charAt(0),
                    ed = Math.log(el) / Math.log(256),
                    eh = Math.log(256) / Math.log(el);

                function decodeUnsafe(r) {
                    if ("string" != typeof r) throw TypeError("Expected String");
                    if (0 === r.length) return U.alloc(0);
                    for (var C = 0, et = 0, eo = 0; r[C] === ec;) et++, C++;
                    for (var es = (r.length - C) * ed + 1 >>> 0, eh = new Uint8Array(es); r[C];) {
                        var ef = l[r.charCodeAt(C)];
                        if (255 === ef) return;
                        for (var ep = 0, eg = es - 1;
                            (0 !== ef || ep < eo) && -1 !== eg; eg--, ep++) ef += el * eh[eg] >>> 0, eh[eg] = ef % 256 >>> 0, ef = ef / 256 >>> 0;
                        if (0 !== ef) throw Error("Non-zero carry");
                        eo = ep, C++
                    }
                    for (var ey = es - eo; ey !== es && 0 === eh[ey];) ey++;
                    var em = U.allocUnsafe(et + (es - ey));
                    em.fill(0, 0, et);
                    for (var e_ = et; ey !== es;) em[e_++] = eh[ey++];
                    return em
                }
                return {
                    encode: function(l) {
                        if ((Array.isArray(l) || l instanceof Uint8Array) && (l = U.from(l)), !U.isBuffer(l)) throw TypeError("Expected Buffer");
                        if (0 === l.length) return "";
                        for (var C = 0, et = 0, eo = 0, es = l.length; eo !== es && 0 === l[eo];) eo++, C++;
                        for (var ed = (es - eo) * eh + 1 >>> 0, ef = new Uint8Array(ed); eo !== es;) {
                            for (var ep = l[eo], eg = 0, ey = ed - 1;
                                (0 !== ep || eg < et) && -1 !== ey; ey--, eg++) ep += 256 * ef[ey] >>> 0, ef[ey] = ep % el >>> 0, ep = ep / el >>> 0;
                            if (0 !== ep) throw Error("Non-zero carry");
                            et = eg, eo++
                        }
                        for (var em = ed - et; em !== ed && 0 === ef[em];) em++;
                        for (var e_ = ec.repeat(C); em < ed; ++em) e_ += r.charAt(ef[em]);
                        return e_
                    },
                    decodeUnsafe: decodeUnsafe,
                    decode: function(r) {
                        var l = decodeUnsafe(r);
                        if (l) return l;
                        throw Error("Non-base" + el + " character")
                    }
                }
            }
        },
        46942: function(r, l, C) {
            "use strict";
            var U = C(97115).Buffer;
            l.oU = function(r) {
                {
                    let l = U.from(r);
                    l.reverse();
                    let C = l.toString("hex");
                    return 0 === C.length ? BigInt(0) : BigInt(`0x${C}`)
                }
            }, l.k$ = function(r, l) {
                {
                    let C = r.toString(16),
                        et = U.from(C.padStart(2 * l, "0").slice(0, 2 * l), "hex");
                    return et.reverse(), et
                }
            }
        },
        90323: function(r, l, C) {
            "use strict";
            var U = C(97115).Buffer,
                et = this && this.__createBinding || (Object.create ? function(r, l, C, U) {
                    void 0 === U && (U = C), Object.defineProperty(r, U, {
                        enumerable: !0,
                        get: function() {
                            return l[C]
                        }
                    })
                } : function(r, l, C, U) {
                    void 0 === U && (U = C), r[U] = l[C]
                }),
                eo = this && this.__setModuleDefault || (Object.create ? function(r, l) {
                    Object.defineProperty(r, "default", {
                        enumerable: !0,
                        value: l
                    })
                } : function(r, l) {
                    r.default = l
                }),
                es = this && this.__decorate || function(r, l, C, U) {
                    var et, eo = arguments.length,
                        es = eo < 3 ? l : null === U ? U = Object.getOwnPropertyDescriptor(l, C) : U;
                    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) es = Reflect.decorate(r, l, C, U);
                    else
                        for (var el = r.length - 1; el >= 0; el--)(et = r[el]) && (es = (eo < 3 ? et(es) : eo > 3 ? et(l, C, es) : et(l, C)) || es);
                    return eo > 3 && es && Object.defineProperty(l, C, es), es
                },
                el = this && this.__importStar || function(r) {
                    if (r && r.__esModule) return r;
                    var l = {};
                    if (null != r)
                        for (var C in r) "default" !== C && Object.hasOwnProperty.call(r, C) && et(l, r, C);
                    return eo(l, r), l
                },
                ec = this && this.__importDefault || function(r) {
                    return r && r.__esModule ? r : {
                        default: r
                    }
                };
            Object.defineProperty(l, "__esModule", {
                value: !0
            }), l.deserializeUnchecked = l.deserialize = l.serialize = l.BinaryReader = l.BinaryWriter = l.BorshError = l.baseDecode = l.baseEncode = void 0;
            let ed = ec(C(43907)),
                eh = ec(C(28592)),
                ef = el(C(88575)),
                ep = "function" != typeof TextDecoder ? ef.TextDecoder : TextDecoder,
                eg = new ep("utf-8", {
                    fatal: !0
                });
            l.baseEncode = function(r) {
                return "string" == typeof r && (r = U.from(r, "utf8")), eh.default.encode(U.from(r))
            }, l.baseDecode = function(r) {
                return U.from(eh.default.decode(r))
            };
            let BorshError = class BorshError extends Error {
                constructor(r) {
                    super(r), this.fieldPath = [], this.originalMessage = r
                }
                addToFieldPath(r) {
                    this.fieldPath.splice(0, 0, r), this.message = this.originalMessage + ": " + this.fieldPath.join(".")
                }
            };
            l.BorshError = BorshError;
            let BinaryWriter = class BinaryWriter {
                constructor() {
                    this.buf = U.alloc(1024), this.length = 0
                }
                maybeResize() {
                    this.buf.length < 16 + this.length && (this.buf = U.concat([this.buf, U.alloc(1024)]))
                }
                writeU8(r) {
                    this.maybeResize(), this.buf.writeUInt8(r, this.length), this.length += 1
                }
                writeU16(r) {
                    this.maybeResize(), this.buf.writeUInt16LE(r, this.length), this.length += 2
                }
                writeU32(r) {
                    this.maybeResize(), this.buf.writeUInt32LE(r, this.length), this.length += 4
                }
                writeU64(r) {
                    this.maybeResize(), this.writeBuffer(U.from(new ed.default(r).toArray("le", 8)))
                }
                writeU128(r) {
                    this.maybeResize(), this.writeBuffer(U.from(new ed.default(r).toArray("le", 16)))
                }
                writeU256(r) {
                    this.maybeResize(), this.writeBuffer(U.from(new ed.default(r).toArray("le", 32)))
                }
                writeU512(r) {
                    this.maybeResize(), this.writeBuffer(U.from(new ed.default(r).toArray("le", 64)))
                }
                writeBuffer(r) {
                    this.buf = U.concat([U.from(this.buf.subarray(0, this.length)), r, U.alloc(1024)]), this.length += r.length
                }
                writeString(r) {
                    this.maybeResize();
                    let l = U.from(r, "utf8");
                    this.writeU32(l.length), this.writeBuffer(l)
                }
                writeFixedArray(r) {
                    this.writeBuffer(U.from(r))
                }
                writeArray(r, l) {
                    for (let C of (this.maybeResize(), this.writeU32(r.length), r)) this.maybeResize(), l(C)
                }
                toArray() {
                    return this.buf.subarray(0, this.length)
                }
            };

            function handlingRangeError(r, l, C) {
                let U = C.value;
                C.value = function(...r) {
                    try {
                        return U.apply(this, r)
                    } catch (r) {
                        if (r instanceof RangeError) {
                            let l = r.code;
                            if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(l) >= 0) throw new BorshError("Reached the end of buffer when deserializing")
                        }
                        throw r
                    }
                }
            }
            l.BinaryWriter = BinaryWriter;
            let BinaryReader = class BinaryReader {
                constructor(r) {
                    this.buf = r, this.offset = 0
                }
                readU8() {
                    let r = this.buf.readUInt8(this.offset);
                    return this.offset += 1, r
                }
                readU16() {
                    let r = this.buf.readUInt16LE(this.offset);
                    return this.offset += 2, r
                }
                readU32() {
                    let r = this.buf.readUInt32LE(this.offset);
                    return this.offset += 4, r
                }
                readU64() {
                    let r = this.readBuffer(8);
                    return new ed.default(r, "le")
                }
                readU128() {
                    let r = this.readBuffer(16);
                    return new ed.default(r, "le")
                }
                readU256() {
                    let r = this.readBuffer(32);
                    return new ed.default(r, "le")
                }
                readU512() {
                    let r = this.readBuffer(64);
                    return new ed.default(r, "le")
                }
                readBuffer(r) {
                    if (this.offset + r > this.buf.length) throw new BorshError(`Expected buffer length ${r} isn't within bounds`);
                    let l = this.buf.slice(this.offset, this.offset + r);
                    return this.offset += r, l
                }
                readString() {
                    let r = this.readU32(),
                        l = this.readBuffer(r);
                    try {
                        return eg.decode(l)
                    } catch (r) {
                        throw new BorshError(`Error decoding UTF-8 string: ${r}`)
                    }
                }
                readFixedArray(r) {
                    return new Uint8Array(this.readBuffer(r))
                }
                readArray(r) {
                    let l = this.readU32(),
                        C = [];
                    for (let U = 0; U < l; ++U) C.push(r());
                    return C
                }
            };

            function capitalizeFirstLetter(r) {
                return r.charAt(0).toUpperCase() + r.slice(1)
            }

            function serializeField(r, l, C, U, et) {
                try {
                    if ("string" == typeof U) et[`write${capitalizeFirstLetter(U)}`](C);
                    else if (U instanceof Array) {
                        if ("number" == typeof U[0]) {
                            if (C.length !== U[0]) throw new BorshError(`Expecting byte array of length ${U[0]}, but got ${C.length} bytes`);
                            et.writeFixedArray(C)
                        } else if (2 === U.length && "number" == typeof U[1]) {
                            if (C.length !== U[1]) throw new BorshError(`Expecting byte array of length ${U[1]}, but got ${C.length} bytes`);
                            for (let l = 0; l < U[1]; l++) serializeField(r, null, C[l], U[0], et)
                        } else et.writeArray(C, C => {
                            serializeField(r, l, C, U[0], et)
                        })
                    } else if (void 0 !== U.kind) switch (U.kind) {
                        case "option":
                            null == C ? et.writeU8(0) : (et.writeU8(1), serializeField(r, l, C, U.type, et));
                            break;
                        case "map":
                            et.writeU32(C.size), C.forEach((C, eo) => {
                                serializeField(r, l, eo, U.key, et), serializeField(r, l, C, U.value, et)
                            });
                            break;
                        default:
                            throw new BorshError(`FieldType ${U} unrecognized`)
                    } else serializeStruct(r, C, et)
                } catch (r) {
                    throw r instanceof BorshError && r.addToFieldPath(l), r
                }
            }

            function serializeStruct(r, l, C) {
                if ("function" == typeof l.borshSerialize) {
                    l.borshSerialize(C);
                    return
                }
                let U = r.get(l.constructor);
                if (!U) throw new BorshError(`Class ${l.constructor.name} is missing in schema`);
                if ("struct" === U.kind) U.fields.map(([U, et]) => {
                    serializeField(r, U, l[U], et, C)
                });
                else if ("enum" === U.kind) {
                    let et = l[U.field];
                    for (let eo = 0; eo < U.values.length; ++eo) {
                        let [es, el] = U.values[eo];
                        if (es === et) {
                            C.writeU8(eo), serializeField(r, es, l[es], el, C);
                            break
                        }
                    }
                } else throw new BorshError(`Unexpected schema kind: ${U.kind} for ${l.constructor.name}`)
            }

            function deserializeField(r, l, C, U) {
                try {
                    if ("string" == typeof C) return U[`read${capitalizeFirstLetter(C)}`]();
                    if (C instanceof Array) {
                        if ("number" == typeof C[0]) return U.readFixedArray(C[0]);
                        if ("number" != typeof C[1]) return U.readArray(() => deserializeField(r, l, C[0], U)); {
                            let l = [];
                            for (let et = 0; et < C[1]; et++) l.push(deserializeField(r, null, C[0], U));
                            return l
                        }
                    }
                    if ("option" === C.kind) {
                        let et = U.readU8();
                        if (et) return deserializeField(r, l, C.type, U);
                        return
                    }
                    if ("map" === C.kind) {
                        let et = new Map,
                            eo = U.readU32();
                        for (let es = 0; es < eo; es++) {
                            let eo = deserializeField(r, l, C.key, U),
                                es = deserializeField(r, l, C.value, U);
                            et.set(eo, es)
                        }
                        return et
                    }
                    return deserializeStruct(r, C, U)
                } catch (r) {
                    throw r instanceof BorshError && r.addToFieldPath(l), r
                }
            }

            function deserializeStruct(r, l, C) {
                if ("function" == typeof l.borshDeserialize) return l.borshDeserialize(C);
                let U = r.get(l);
                if (!U) throw new BorshError(`Class ${l.name} is missing in schema`);
                if ("struct" === U.kind) {
                    let U = {};
                    for (let [et, eo] of r.get(l).fields) U[et] = deserializeField(r, et, eo, C);
                    return new l(U)
                }
                if ("enum" === U.kind) {
                    let et = C.readU8();
                    if (et >= U.values.length) throw new BorshError(`Enum index: ${et} is out of range`);
                    let [eo, es] = U.values[et], el = deserializeField(r, eo, es, C);
                    return new l({
                        [eo]: el
                    })
                }
                throw new BorshError(`Unexpected schema kind: ${U.kind} for ${l.constructor.name}`)
            }
            es([handlingRangeError], BinaryReader.prototype, "readU8", null), es([handlingRangeError], BinaryReader.prototype, "readU16", null), es([handlingRangeError], BinaryReader.prototype, "readU32", null), es([handlingRangeError], BinaryReader.prototype, "readU64", null), es([handlingRangeError], BinaryReader.prototype, "readU128", null), es([handlingRangeError], BinaryReader.prototype, "readU256", null), es([handlingRangeError], BinaryReader.prototype, "readU512", null), es([handlingRangeError], BinaryReader.prototype, "readString", null), es([handlingRangeError], BinaryReader.prototype, "readFixedArray", null), es([handlingRangeError], BinaryReader.prototype, "readArray", null), l.BinaryReader = BinaryReader, l.serialize = function(r, l, C = BinaryWriter) {
                let U = new C;
                return serializeStruct(r, l, U), U.toArray()
            }, l.deserialize = function(r, l, C, U = BinaryReader) {
                let et = new U(C),
                    eo = deserializeStruct(r, l, et);
                if (et.offset < C.length) throw new BorshError(`Unexpected ${C.length-et.offset} bytes after deserialized data`);
                return eo
            }, l.deserializeUnchecked = function(r, l, C, U = BinaryReader) {
                let et = new U(C);
                return deserializeStruct(r, l, et)
            }
        },
        28592: function(r, l, C) {
            var U = C(3368);
            r.exports = U("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz")
        },
        13846: function(r, l, C) {
            "use strict";
            /*!
             * The buffer module from node.js, for the browser.
             *
             * @author   Feross Aboukhadijeh <https://feross.org>
             * @license  MIT
             */
            let U = C(61699),
                et = C(94402),
                eo = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;

            function createBuffer(r) {
                if (r > 2147483647) throw RangeError('The value "' + r + '" is invalid for option "size"');
                let l = new Uint8Array(r);
                return Object.setPrototypeOf(l, Buffer.prototype), l
            }

            function Buffer(r, l, C) {
                if ("number" == typeof r) {
                    if ("string" == typeof l) throw TypeError('The "string" argument must be of type string. Received type number');
                    return allocUnsafe(r)
                }
                return from(r, l, C)
            }

            function from(r, l, C) {
                if ("string" == typeof r) return function(r, l) {
                    if (("string" != typeof l || "" === l) && (l = "utf8"), !Buffer.isEncoding(l)) throw TypeError("Unknown encoding: " + l);
                    let C = 0 | byteLength(r, l),
                        U = createBuffer(C),
                        et = U.write(r, l);
                    return et !== C && (U = U.slice(0, et)), U
                }(r, l);
                if (ArrayBuffer.isView(r)) return function(r) {
                    if (isInstance(r, Uint8Array)) {
                        let l = new Uint8Array(r);
                        return fromArrayBuffer(l.buffer, l.byteOffset, l.byteLength)
                    }
                    return fromArrayLike(r)
                }(r);
                if (null == r) throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof r);
                if (isInstance(r, ArrayBuffer) || r && isInstance(r.buffer, ArrayBuffer) || "undefined" != typeof SharedArrayBuffer && (isInstance(r, SharedArrayBuffer) || r && isInstance(r.buffer, SharedArrayBuffer))) return fromArrayBuffer(r, l, C);
                if ("number" == typeof r) throw TypeError('The "value" argument must not be of type number. Received type number');
                let U = r.valueOf && r.valueOf();
                if (null != U && U !== r) return Buffer.from(U, l, C);
                let et = function(r) {
                    var l;
                    if (Buffer.isBuffer(r)) {
                        let l = 0 | checked(r.length),
                            C = createBuffer(l);
                        return 0 === C.length || r.copy(C, 0, 0, l), C
                    }
                    return void 0 !== r.length ? "number" != typeof r.length || (l = r.length) != l ? createBuffer(0) : fromArrayLike(r) : "Buffer" === r.type && Array.isArray(r.data) ? fromArrayLike(r.data) : void 0
                }(r);
                if (et) return et;
                if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof r[Symbol.toPrimitive]) return Buffer.from(r[Symbol.toPrimitive]("string"), l, C);
                throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof r)
            }

            function assertSize(r) {
                if ("number" != typeof r) throw TypeError('"size" argument must be of type number');
                if (r < 0) throw RangeError('The value "' + r + '" is invalid for option "size"')
            }

            function allocUnsafe(r) {
                return assertSize(r), createBuffer(r < 0 ? 0 : 0 | checked(r))
            }

            function fromArrayLike(r) {
                let l = r.length < 0 ? 0 : 0 | checked(r.length),
                    C = createBuffer(l);
                for (let U = 0; U < l; U += 1) C[U] = 255 & r[U];
                return C
            }

            function fromArrayBuffer(r, l, C) {
                let U;
                if (l < 0 || r.byteLength < l) throw RangeError('"offset" is outside of buffer bounds');
                if (r.byteLength < l + (C || 0)) throw RangeError('"length" is outside of buffer bounds');
                return Object.setPrototypeOf(U = void 0 === l && void 0 === C ? new Uint8Array(r) : void 0 === C ? new Uint8Array(r, l) : new Uint8Array(r, l, C), Buffer.prototype), U
            }

            function checked(r) {
                if (r >= 2147483647) throw RangeError("Attempt to allocate Buffer larger than maximum size: 0x7fffffff bytes");
                return 0 | r
            }

            function byteLength(r, l) {
                if (Buffer.isBuffer(r)) return r.length;
                if (ArrayBuffer.isView(r) || isInstance(r, ArrayBuffer)) return r.byteLength;
                if ("string" != typeof r) throw TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof r);
                let C = r.length,
                    U = arguments.length > 2 && !0 === arguments[2];
                if (!U && 0 === C) return 0;
                let et = !1;
                for (;;) switch (l) {
                    case "ascii":
                    case "latin1":
                    case "binary":
                        return C;
                    case "utf8":
                    case "utf-8":
                        return utf8ToBytes(r).length;
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return 2 * C;
                    case "hex":
                        return C >>> 1;
                    case "base64":
                        return base64ToBytes(r).length;
                    default:
                        if (et) return U ? -1 : utf8ToBytes(r).length;
                        l = ("" + l).toLowerCase(), et = !0
                }
            }

            function slowToString(r, l, C) {
                let et = !1;
                if ((void 0 === l || l < 0) && (l = 0), l > this.length || ((void 0 === C || C > this.length) && (C = this.length), C <= 0 || (C >>>= 0) <= (l >>>= 0))) return "";
                for (r || (r = "utf8");;) switch (r) {
                    case "hex":
                        return function(r, l, C) {
                            let U = r.length;
                            (!l || l < 0) && (l = 0), (!C || C < 0 || C > U) && (C = U);
                            let et = "";
                            for (let U = l; U < C; ++U) et += ec[r[U]];
                            return et
                        }(this, l, C);
                    case "utf8":
                    case "utf-8":
                        return utf8Slice(this, l, C);
                    case "ascii":
                        return function(r, l, C) {
                            let U = "";
                            C = Math.min(r.length, C);
                            for (let et = l; et < C; ++et) U += String.fromCharCode(127 & r[et]);
                            return U
                        }(this, l, C);
                    case "latin1":
                    case "binary":
                        return function(r, l, C) {
                            let U = "";
                            C = Math.min(r.length, C);
                            for (let et = l; et < C; ++et) U += String.fromCharCode(r[et]);
                            return U
                        }(this, l, C);
                    case "base64":
                        var eo, es;
                        return eo = l, es = C, 0 === eo && es === this.length ? U.fromByteArray(this) : U.fromByteArray(this.slice(eo, es));
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return function(r, l, C) {
                            let U = r.slice(l, C),
                                et = "";
                            for (let r = 0; r < U.length - 1; r += 2) et += String.fromCharCode(U[r] + 256 * U[r + 1]);
                            return et
                        }(this, l, C);
                    default:
                        if (et) throw TypeError("Unknown encoding: " + r);
                        r = (r + "").toLowerCase(), et = !0
                }
            }

            function swap(r, l, C) {
                let U = r[l];
                r[l] = r[C], r[C] = U
            }

            function bidirectionalIndexOf(r, l, C, U, et) {
                var eo;
                if (0 === r.length) return -1;
                if ("string" == typeof C ? (U = C, C = 0) : C > 2147483647 ? C = 2147483647 : C < -2147483648 && (C = -2147483648), (eo = C = +C) != eo && (C = et ? 0 : r.length - 1), C < 0 && (C = r.length + C), C >= r.length) {
                    if (et) return -1;
                    C = r.length - 1
                } else if (C < 0) {
                    if (!et) return -1;
                    C = 0
                }
                if ("string" == typeof l && (l = Buffer.from(l, U)), Buffer.isBuffer(l)) return 0 === l.length ? -1 : arrayIndexOf(r, l, C, U, et);
                if ("number" == typeof l) return (l &= 255, "function" == typeof Uint8Array.prototype.indexOf) ? et ? Uint8Array.prototype.indexOf.call(r, l, C) : Uint8Array.prototype.lastIndexOf.call(r, l, C) : arrayIndexOf(r, [l], C, U, et);
                throw TypeError("val must be string, number or Buffer")
            }

            function arrayIndexOf(r, l, C, U, et) {
                let eo, es = 1,
                    el = r.length,
                    ec = l.length;
                if (void 0 !== U && ("ucs2" === (U = String(U).toLowerCase()) || "ucs-2" === U || "utf16le" === U || "utf-16le" === U)) {
                    if (r.length < 2 || l.length < 2) return -1;
                    es = 2, el /= 2, ec /= 2, C /= 2
                }

                function read(r, l) {
                    return 1 === es ? r[l] : r.readUInt16BE(l * es)
                }
                if (et) {
                    let U = -1;
                    for (eo = C; eo < el; eo++)
                        if (read(r, eo) === read(l, -1 === U ? 0 : eo - U)) {
                            if (-1 === U && (U = eo), eo - U + 1 === ec) return U * es
                        } else -1 !== U && (eo -= eo - U), U = -1
                } else
                    for (C + ec > el && (C = el - ec), eo = C; eo >= 0; eo--) {
                        let C = !0;
                        for (let U = 0; U < ec; U++)
                            if (read(r, eo + U) !== read(l, U)) {
                                C = !1;
                                break
                            }
                        if (C) return eo
                    }
                return -1
            }

            function utf8Slice(r, l, C) {
                C = Math.min(r.length, C);
                let U = [],
                    et = l;
                for (; et < C;) {
                    let l = r[et],
                        eo = null,
                        es = l > 239 ? 4 : l > 223 ? 3 : l > 191 ? 2 : 1;
                    if (et + es <= C) {
                        let C, U, el, ec;
                        switch (es) {
                            case 1:
                                l < 128 && (eo = l);
                                break;
                            case 2:
                                (192 & (C = r[et + 1])) == 128 && (ec = (31 & l) << 6 | 63 & C) > 127 && (eo = ec);
                                break;
                            case 3:
                                C = r[et + 1], U = r[et + 2], (192 & C) == 128 && (192 & U) == 128 && (ec = (15 & l) << 12 | (63 & C) << 6 | 63 & U) > 2047 && (ec < 55296 || ec > 57343) && (eo = ec);
                                break;
                            case 4:
                                C = r[et + 1], U = r[et + 2], el = r[et + 3], (192 & C) == 128 && (192 & U) == 128 && (192 & el) == 128 && (ec = (15 & l) << 18 | (63 & C) << 12 | (63 & U) << 6 | 63 & el) > 65535 && ec < 1114112 && (eo = ec)
                        }
                    }
                    null === eo ? (eo = 65533, es = 1) : eo > 65535 && (eo -= 65536, U.push(eo >>> 10 & 1023 | 55296), eo = 56320 | 1023 & eo), U.push(eo), et += es
                }
                return function(r) {
                    let l = r.length;
                    if (l <= 4096) return String.fromCharCode.apply(String, r);
                    let C = "",
                        U = 0;
                    for (; U < l;) C += String.fromCharCode.apply(String, r.slice(U, U += 4096));
                    return C
                }(U)
            }

            function checkOffset(r, l, C) {
                if (r % 1 != 0 || r < 0) throw RangeError("offset is not uint");
                if (r + l > C) throw RangeError("Trying to access beyond buffer length")
            }

            function checkInt(r, l, C, U, et, eo) {
                if (!Buffer.isBuffer(r)) throw TypeError('"buffer" argument must be a Buffer instance');
                if (l > et || l < eo) throw RangeError('"value" argument is out of bounds');
                if (C + U > r.length) throw RangeError("Index out of range")
            }

            function wrtBigUInt64LE(r, l, C, U, et) {
                checkIntBI(l, U, et, r, C, 7);
                let eo = Number(l & BigInt(4294967295));
                r[C++] = eo, eo >>= 8, r[C++] = eo, eo >>= 8, r[C++] = eo, eo >>= 8, r[C++] = eo;
                let es = Number(l >> BigInt(32) & BigInt(4294967295));
                return r[C++] = es, es >>= 8, r[C++] = es, es >>= 8, r[C++] = es, es >>= 8, r[C++] = es, C
            }

            function wrtBigUInt64BE(r, l, C, U, et) {
                checkIntBI(l, U, et, r, C, 7);
                let eo = Number(l & BigInt(4294967295));
                r[C + 7] = eo, eo >>= 8, r[C + 6] = eo, eo >>= 8, r[C + 5] = eo, eo >>= 8, r[C + 4] = eo;
                let es = Number(l >> BigInt(32) & BigInt(4294967295));
                return r[C + 3] = es, es >>= 8, r[C + 2] = es, es >>= 8, r[C + 1] = es, es >>= 8, r[C] = es, C + 8
            }

            function checkIEEE754(r, l, C, U, et, eo) {
                if (C + U > r.length || C < 0) throw RangeError("Index out of range")
            }

            function writeFloat(r, l, C, U, eo) {
                return l = +l, C >>>= 0, eo || checkIEEE754(r, l, C, 4, 34028234663852886e22, -34028234663852886e22), et.write(r, l, C, U, 23, 4), C + 4
            }

            function writeDouble(r, l, C, U, eo) {
                return l = +l, C >>>= 0, eo || checkIEEE754(r, l, C, 8, 17976931348623157e292, -17976931348623157e292), et.write(r, l, C, U, 52, 8), C + 8
            }
            l.lW = Buffer, l.h2 = 50, Buffer.TYPED_ARRAY_SUPPORT = function() {
                try {
                    let r = new Uint8Array(1),
                        l = {
                            foo: function() {
                                return 42
                            }
                        };
                    return Object.setPrototypeOf(l, Uint8Array.prototype), Object.setPrototypeOf(r, l), 42 === r.foo()
                } catch (r) {
                    return !1
                }
            }(), Buffer.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(Buffer.prototype, "parent", {
                enumerable: !0,
                get: function() {
                    if (Buffer.isBuffer(this)) return this.buffer
                }
            }), Object.defineProperty(Buffer.prototype, "offset", {
                enumerable: !0,
                get: function() {
                    if (Buffer.isBuffer(this)) return this.byteOffset
                }
            }), Buffer.poolSize = 8192, Buffer.from = function(r, l, C) {
                return from(r, l, C)
            }, Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype), Object.setPrototypeOf(Buffer, Uint8Array), Buffer.alloc = function(r, l, C) {
                return (assertSize(r), r <= 0) ? createBuffer(r) : void 0 !== l ? "string" == typeof C ? createBuffer(r).fill(l, C) : createBuffer(r).fill(l) : createBuffer(r)
            }, Buffer.allocUnsafe = function(r) {
                return allocUnsafe(r)
            }, Buffer.allocUnsafeSlow = function(r) {
                return allocUnsafe(r)
            }, Buffer.isBuffer = function(r) {
                return null != r && !0 === r._isBuffer && r !== Buffer.prototype
            }, Buffer.compare = function(r, l) {
                if (isInstance(r, Uint8Array) && (r = Buffer.from(r, r.offset, r.byteLength)), isInstance(l, Uint8Array) && (l = Buffer.from(l, l.offset, l.byteLength)), !Buffer.isBuffer(r) || !Buffer.isBuffer(l)) throw TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                if (r === l) return 0;
                let C = r.length,
                    U = l.length;
                for (let et = 0, eo = Math.min(C, U); et < eo; ++et)
                    if (r[et] !== l[et]) {
                        C = r[et], U = l[et];
                        break
                    }
                return C < U ? -1 : U < C ? 1 : 0
            }, Buffer.isEncoding = function(r) {
                switch (String(r).toLowerCase()) {
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "latin1":
                    case "binary":
                    case "base64":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return !0;
                    default:
                        return !1
                }
            }, Buffer.concat = function(r, l) {
                let C;
                if (!Array.isArray(r)) throw TypeError('"list" argument must be an Array of Buffers');
                if (0 === r.length) return Buffer.alloc(0);
                if (void 0 === l)
                    for (C = 0, l = 0; C < r.length; ++C) l += r[C].length;
                let U = Buffer.allocUnsafe(l),
                    et = 0;
                for (C = 0; C < r.length; ++C) {
                    let l = r[C];
                    if (isInstance(l, Uint8Array)) et + l.length > U.length ? (Buffer.isBuffer(l) || (l = Buffer.from(l)), l.copy(U, et)) : Uint8Array.prototype.set.call(U, l, et);
                    else if (Buffer.isBuffer(l)) l.copy(U, et);
                    else throw TypeError('"list" argument must be an Array of Buffers');
                    et += l.length
                }
                return U
            }, Buffer.byteLength = byteLength, Buffer.prototype._isBuffer = !0, Buffer.prototype.swap16 = function() {
                let r = this.length;
                if (r % 2 != 0) throw RangeError("Buffer size must be a multiple of 16-bits");
                for (let l = 0; l < r; l += 2) swap(this, l, l + 1);
                return this
            }, Buffer.prototype.swap32 = function() {
                let r = this.length;
                if (r % 4 != 0) throw RangeError("Buffer size must be a multiple of 32-bits");
                for (let l = 0; l < r; l += 4) swap(this, l, l + 3), swap(this, l + 1, l + 2);
                return this
            }, Buffer.prototype.swap64 = function() {
                let r = this.length;
                if (r % 8 != 0) throw RangeError("Buffer size must be a multiple of 64-bits");
                for (let l = 0; l < r; l += 8) swap(this, l, l + 7), swap(this, l + 1, l + 6), swap(this, l + 2, l + 5), swap(this, l + 3, l + 4);
                return this
            }, Buffer.prototype.toString = function() {
                let r = this.length;
                return 0 === r ? "" : 0 == arguments.length ? utf8Slice(this, 0, r) : slowToString.apply(this, arguments)
            }, Buffer.prototype.toLocaleString = Buffer.prototype.toString, Buffer.prototype.equals = function(r) {
                if (!Buffer.isBuffer(r)) throw TypeError("Argument must be a Buffer");
                return this === r || 0 === Buffer.compare(this, r)
            }, Buffer.prototype.inspect = function() {
                let r = "",
                    C = l.h2;
                return r = this.toString("hex", 0, C).replace(/(.{2})/g, "$1 ").trim(), this.length > C && (r += " ... "), "<Buffer " + r + ">"
            }, eo && (Buffer.prototype[eo] = Buffer.prototype.inspect), Buffer.prototype.compare = function(r, l, C, U, et) {
                if (isInstance(r, Uint8Array) && (r = Buffer.from(r, r.offset, r.byteLength)), !Buffer.isBuffer(r)) throw TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof r);
                if (void 0 === l && (l = 0), void 0 === C && (C = r ? r.length : 0), void 0 === U && (U = 0), void 0 === et && (et = this.length), l < 0 || C > r.length || U < 0 || et > this.length) throw RangeError("out of range index");
                if (U >= et && l >= C) return 0;
                if (U >= et) return -1;
                if (l >= C) return 1;
                if (l >>>= 0, C >>>= 0, U >>>= 0, et >>>= 0, this === r) return 0;
                let eo = et - U,
                    es = C - l,
                    el = Math.min(eo, es),
                    ec = this.slice(U, et),
                    ed = r.slice(l, C);
                for (let r = 0; r < el; ++r)
                    if (ec[r] !== ed[r]) {
                        eo = ec[r], es = ed[r];
                        break
                    }
                return eo < es ? -1 : es < eo ? 1 : 0
            }, Buffer.prototype.includes = function(r, l, C) {
                return -1 !== this.indexOf(r, l, C)
            }, Buffer.prototype.indexOf = function(r, l, C) {
                return bidirectionalIndexOf(this, r, l, C, !0)
            }, Buffer.prototype.lastIndexOf = function(r, l, C) {
                return bidirectionalIndexOf(this, r, l, C, !1)
            }, Buffer.prototype.write = function(r, l, C, U) {
                var et, eo, es, el, ec, ed, eh, ef;
                if (void 0 === l) U = "utf8", C = this.length, l = 0;
                else if (void 0 === C && "string" == typeof l) U = l, C = this.length, l = 0;
                else if (isFinite(l)) l >>>= 0, isFinite(C) ? (C >>>= 0, void 0 === U && (U = "utf8")) : (U = C, C = void 0);
                else throw Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                let ep = this.length - l;
                if ((void 0 === C || C > ep) && (C = ep), r.length > 0 && (C < 0 || l < 0) || l > this.length) throw RangeError("Attempt to write outside buffer bounds");
                U || (U = "utf8");
                let eg = !1;
                for (;;) switch (U) {
                    case "hex":
                        return function(r, l, C, U) {
                            let et;
                            C = Number(C) || 0;
                            let eo = r.length - C;
                            U ? (U = Number(U)) > eo && (U = eo) : U = eo;
                            let es = l.length;
                            for (U > es / 2 && (U = es / 2), et = 0; et < U; ++et) {
                                let U = parseInt(l.substr(2 * et, 2), 16);
                                if (U != U) break;
                                r[C + et] = U
                            }
                            return et
                        }(this, r, l, C);
                    case "utf8":
                    case "utf-8":
                        return et = l, eo = C, blitBuffer(utf8ToBytes(r, this.length - et), this, et, eo);
                    case "ascii":
                    case "latin1":
                    case "binary":
                        return es = l, el = C, blitBuffer(function(r) {
                            let l = [];
                            for (let C = 0; C < r.length; ++C) l.push(255 & r.charCodeAt(C));
                            return l
                        }(r), this, es, el);
                    case "base64":
                        return ec = l, ed = C, blitBuffer(base64ToBytes(r), this, ec, ed);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return eh = l, ef = C, blitBuffer(function(r, l) {
                            let C, U;
                            let et = [];
                            for (let eo = 0; eo < r.length && !((l -= 2) < 0); ++eo) U = (C = r.charCodeAt(eo)) >> 8, et.push(C % 256), et.push(U);
                            return et
                        }(r, this.length - eh), this, eh, ef);
                    default:
                        if (eg) throw TypeError("Unknown encoding: " + U);
                        U = ("" + U).toLowerCase(), eg = !0
                }
            }, Buffer.prototype.toJSON = function() {
                return {
                    type: "Buffer",
                    data: Array.prototype.slice.call(this._arr || this, 0)
                }
            }, Buffer.prototype.slice = function(r, l) {
                let C = this.length;
                r = ~~r, l = void 0 === l ? C : ~~l, r < 0 ? (r += C) < 0 && (r = 0) : r > C && (r = C), l < 0 ? (l += C) < 0 && (l = 0) : l > C && (l = C), l < r && (l = r);
                let U = this.subarray(r, l);
                return Object.setPrototypeOf(U, Buffer.prototype), U
            }, Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function(r, l, C) {
                r >>>= 0, l >>>= 0, C || checkOffset(r, l, this.length);
                let U = this[r],
                    et = 1,
                    eo = 0;
                for (; ++eo < l && (et *= 256);) U += this[r + eo] * et;
                return U
            }, Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function(r, l, C) {
                r >>>= 0, l >>>= 0, C || checkOffset(r, l, this.length);
                let U = this[r + --l],
                    et = 1;
                for (; l > 0 && (et *= 256);) U += this[r + --l] * et;
                return U
            }, Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function(r, l) {
                return r >>>= 0, l || checkOffset(r, 1, this.length), this[r]
            }, Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function(r, l) {
                return r >>>= 0, l || checkOffset(r, 2, this.length), this[r] | this[r + 1] << 8
            }, Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function(r, l) {
                return r >>>= 0, l || checkOffset(r, 2, this.length), this[r] << 8 | this[r + 1]
            }, Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function(r, l) {
                return r >>>= 0, l || checkOffset(r, 4, this.length), (this[r] | this[r + 1] << 8 | this[r + 2] << 16) + 16777216 * this[r + 3]
            }, Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function(r, l) {
                return r >>>= 0, l || checkOffset(r, 4, this.length), 16777216 * this[r] + (this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3])
            }, Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function(r) {
                validateNumber(r >>>= 0, "offset");
                let l = this[r],
                    C = this[r + 7];
                (void 0 === l || void 0 === C) && boundsError(r, this.length - 8);
                let U = l + 256 * this[++r] + 65536 * this[++r] + 16777216 * this[++r],
                    et = this[++r] + 256 * this[++r] + 65536 * this[++r] + 16777216 * C;
                return BigInt(U) + (BigInt(et) << BigInt(32))
            }), Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function(r) {
                validateNumber(r >>>= 0, "offset");
                let l = this[r],
                    C = this[r + 7];
                (void 0 === l || void 0 === C) && boundsError(r, this.length - 8);
                let U = 16777216 * l + 65536 * this[++r] + 256 * this[++r] + this[++r],
                    et = 16777216 * this[++r] + 65536 * this[++r] + 256 * this[++r] + C;
                return (BigInt(U) << BigInt(32)) + BigInt(et)
            }), Buffer.prototype.readIntLE = function(r, l, C) {
                r >>>= 0, l >>>= 0, C || checkOffset(r, l, this.length);
                let U = this[r],
                    et = 1,
                    eo = 0;
                for (; ++eo < l && (et *= 256);) U += this[r + eo] * et;
                return U >= (et *= 128) && (U -= Math.pow(2, 8 * l)), U
            }, Buffer.prototype.readIntBE = function(r, l, C) {
                r >>>= 0, l >>>= 0, C || checkOffset(r, l, this.length);
                let U = l,
                    et = 1,
                    eo = this[r + --U];
                for (; U > 0 && (et *= 256);) eo += this[r + --U] * et;
                return eo >= (et *= 128) && (eo -= Math.pow(2, 8 * l)), eo
            }, Buffer.prototype.readInt8 = function(r, l) {
                return (r >>>= 0, l || checkOffset(r, 1, this.length), 128 & this[r]) ? -((255 - this[r] + 1) * 1) : this[r]
            }, Buffer.prototype.readInt16LE = function(r, l) {
                r >>>= 0, l || checkOffset(r, 2, this.length);
                let C = this[r] | this[r + 1] << 8;
                return 32768 & C ? 4294901760 | C : C
            }, Buffer.prototype.readInt16BE = function(r, l) {
                r >>>= 0, l || checkOffset(r, 2, this.length);
                let C = this[r + 1] | this[r] << 8;
                return 32768 & C ? 4294901760 | C : C
            }, Buffer.prototype.readInt32LE = function(r, l) {
                return r >>>= 0, l || checkOffset(r, 4, this.length), this[r] | this[r + 1] << 8 | this[r + 2] << 16 | this[r + 3] << 24
            }, Buffer.prototype.readInt32BE = function(r, l) {
                return r >>>= 0, l || checkOffset(r, 4, this.length), this[r] << 24 | this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3]
            }, Buffer.prototype.readBigInt64LE = defineBigIntMethod(function(r) {
                validateNumber(r >>>= 0, "offset");
                let l = this[r],
                    C = this[r + 7];
                (void 0 === l || void 0 === C) && boundsError(r, this.length - 8);
                let U = this[r + 4] + 256 * this[r + 5] + 65536 * this[r + 6] + (C << 24);
                return (BigInt(U) << BigInt(32)) + BigInt(l + 256 * this[++r] + 65536 * this[++r] + 16777216 * this[++r])
            }), Buffer.prototype.readBigInt64BE = defineBigIntMethod(function(r) {
                validateNumber(r >>>= 0, "offset");
                let l = this[r],
                    C = this[r + 7];
                (void 0 === l || void 0 === C) && boundsError(r, this.length - 8);
                let U = (l << 24) + 65536 * this[++r] + 256 * this[++r] + this[++r];
                return (BigInt(U) << BigInt(32)) + BigInt(16777216 * this[++r] + 65536 * this[++r] + 256 * this[++r] + C)
            }), Buffer.prototype.readFloatLE = function(r, l) {
                return r >>>= 0, l || checkOffset(r, 4, this.length), et.read(this, r, !0, 23, 4)
            }, Buffer.prototype.readFloatBE = function(r, l) {
                return r >>>= 0, l || checkOffset(r, 4, this.length), et.read(this, r, !1, 23, 4)
            }, Buffer.prototype.readDoubleLE = function(r, l) {
                return r >>>= 0, l || checkOffset(r, 8, this.length), et.read(this, r, !0, 52, 8)
            }, Buffer.prototype.readDoubleBE = function(r, l) {
                return r >>>= 0, l || checkOffset(r, 8, this.length), et.read(this, r, !1, 52, 8)
            }, Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function(r, l, C, U) {
                if (r = +r, l >>>= 0, C >>>= 0, !U) {
                    let U = Math.pow(2, 8 * C) - 1;
                    checkInt(this, r, l, C, U, 0)
                }
                let et = 1,
                    eo = 0;
                for (this[l] = 255 & r; ++eo < C && (et *= 256);) this[l + eo] = r / et & 255;
                return l + C
            }, Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function(r, l, C, U) {
                if (r = +r, l >>>= 0, C >>>= 0, !U) {
                    let U = Math.pow(2, 8 * C) - 1;
                    checkInt(this, r, l, C, U, 0)
                }
                let et = C - 1,
                    eo = 1;
                for (this[l + et] = 255 & r; --et >= 0 && (eo *= 256);) this[l + et] = r / eo & 255;
                return l + C
            }, Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function(r, l, C) {
                return r = +r, l >>>= 0, C || checkInt(this, r, l, 1, 255, 0), this[l] = 255 & r, l + 1
            }, Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function(r, l, C) {
                return r = +r, l >>>= 0, C || checkInt(this, r, l, 2, 65535, 0), this[l] = 255 & r, this[l + 1] = r >>> 8, l + 2
            }, Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function(r, l, C) {
                return r = +r, l >>>= 0, C || checkInt(this, r, l, 2, 65535, 0), this[l] = r >>> 8, this[l + 1] = 255 & r, l + 2
            }, Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function(r, l, C) {
                return r = +r, l >>>= 0, C || checkInt(this, r, l, 4, 4294967295, 0), this[l + 3] = r >>> 24, this[l + 2] = r >>> 16, this[l + 1] = r >>> 8, this[l] = 255 & r, l + 4
            }, Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function(r, l, C) {
                return r = +r, l >>>= 0, C || checkInt(this, r, l, 4, 4294967295, 0), this[l] = r >>> 24, this[l + 1] = r >>> 16, this[l + 2] = r >>> 8, this[l + 3] = 255 & r, l + 4
            }, Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function(r, l = 0) {
                return wrtBigUInt64LE(this, r, l, BigInt(0), BigInt("0xffffffffffffffff"))
            }), Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function(r, l = 0) {
                return wrtBigUInt64BE(this, r, l, BigInt(0), BigInt("0xffffffffffffffff"))
            }), Buffer.prototype.writeIntLE = function(r, l, C, U) {
                if (r = +r, l >>>= 0, !U) {
                    let U = Math.pow(2, 8 * C - 1);
                    checkInt(this, r, l, C, U - 1, -U)
                }
                let et = 0,
                    eo = 1,
                    es = 0;
                for (this[l] = 255 & r; ++et < C && (eo *= 256);) r < 0 && 0 === es && 0 !== this[l + et - 1] && (es = 1), this[l + et] = (r / eo >> 0) - es & 255;
                return l + C
            }, Buffer.prototype.writeIntBE = function(r, l, C, U) {
                if (r = +r, l >>>= 0, !U) {
                    let U = Math.pow(2, 8 * C - 1);
                    checkInt(this, r, l, C, U - 1, -U)
                }
                let et = C - 1,
                    eo = 1,
                    es = 0;
                for (this[l + et] = 255 & r; --et >= 0 && (eo *= 256);) r < 0 && 0 === es && 0 !== this[l + et + 1] && (es = 1), this[l + et] = (r / eo >> 0) - es & 255;
                return l + C
            }, Buffer.prototype.writeInt8 = function(r, l, C) {
                return r = +r, l >>>= 0, C || checkInt(this, r, l, 1, 127, -128), r < 0 && (r = 255 + r + 1), this[l] = 255 & r, l + 1
            }, Buffer.prototype.writeInt16LE = function(r, l, C) {
                return r = +r, l >>>= 0, C || checkInt(this, r, l, 2, 32767, -32768), this[l] = 255 & r, this[l + 1] = r >>> 8, l + 2
            }, Buffer.prototype.writeInt16BE = function(r, l, C) {
                return r = +r, l >>>= 0, C || checkInt(this, r, l, 2, 32767, -32768), this[l] = r >>> 8, this[l + 1] = 255 & r, l + 2
            }, Buffer.prototype.writeInt32LE = function(r, l, C) {
                return r = +r, l >>>= 0, C || checkInt(this, r, l, 4, 2147483647, -2147483648), this[l] = 255 & r, this[l + 1] = r >>> 8, this[l + 2] = r >>> 16, this[l + 3] = r >>> 24, l + 4
            }, Buffer.prototype.writeInt32BE = function(r, l, C) {
                return r = +r, l >>>= 0, C || checkInt(this, r, l, 4, 2147483647, -2147483648), r < 0 && (r = 4294967295 + r + 1), this[l] = r >>> 24, this[l + 1] = r >>> 16, this[l + 2] = r >>> 8, this[l + 3] = 255 & r, l + 4
            }, Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function(r, l = 0) {
                return wrtBigUInt64LE(this, r, l, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
            }), Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function(r, l = 0) {
                return wrtBigUInt64BE(this, r, l, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
            }), Buffer.prototype.writeFloatLE = function(r, l, C) {
                return writeFloat(this, r, l, !0, C)
            }, Buffer.prototype.writeFloatBE = function(r, l, C) {
                return writeFloat(this, r, l, !1, C)
            }, Buffer.prototype.writeDoubleLE = function(r, l, C) {
                return writeDouble(this, r, l, !0, C)
            }, Buffer.prototype.writeDoubleBE = function(r, l, C) {
                return writeDouble(this, r, l, !1, C)
            }, Buffer.prototype.copy = function(r, l, C, U) {
                if (!Buffer.isBuffer(r)) throw TypeError("argument should be a Buffer");
                if (C || (C = 0), U || 0 === U || (U = this.length), l >= r.length && (l = r.length), l || (l = 0), U > 0 && U < C && (U = C), U === C || 0 === r.length || 0 === this.length) return 0;
                if (l < 0) throw RangeError("targetStart out of bounds");
                if (C < 0 || C >= this.length) throw RangeError("Index out of range");
                if (U < 0) throw RangeError("sourceEnd out of bounds");
                U > this.length && (U = this.length), r.length - l < U - C && (U = r.length - l + C);
                let et = U - C;
                return this === r && "function" == typeof Uint8Array.prototype.copyWithin ? this.copyWithin(l, C, U) : Uint8Array.prototype.set.call(r, this.subarray(C, U), l), et
            }, Buffer.prototype.fill = function(r, l, C, U) {
                let et;
                if ("string" == typeof r) {
                    if ("string" == typeof l ? (U = l, l = 0, C = this.length) : "string" == typeof C && (U = C, C = this.length), void 0 !== U && "string" != typeof U) throw TypeError("encoding must be a string");
                    if ("string" == typeof U && !Buffer.isEncoding(U)) throw TypeError("Unknown encoding: " + U);
                    if (1 === r.length) {
                        let l = r.charCodeAt(0);
                        ("utf8" === U && l < 128 || "latin1" === U) && (r = l)
                    }
                } else "number" == typeof r ? r &= 255 : "boolean" == typeof r && (r = Number(r));
                if (l < 0 || this.length < l || this.length < C) throw RangeError("Out of range index");
                if (C <= l) return this;
                if (l >>>= 0, C = void 0 === C ? this.length : C >>> 0, r || (r = 0), "number" == typeof r)
                    for (et = l; et < C; ++et) this[et] = r;
                else {
                    let eo = Buffer.isBuffer(r) ? r : Buffer.from(r, U),
                        es = eo.length;
                    if (0 === es) throw TypeError('The value "' + r + '" is invalid for argument "value"');
                    for (et = 0; et < C - l; ++et) this[et + l] = eo[et % es]
                }
                return this
            };
            let es = {};

            function E(r, l, C) {
                es[r] = class extends C {
                    constructor() {
                        super(), Object.defineProperty(this, "message", {
                            value: l.apply(this, arguments),
                            writable: !0,
                            configurable: !0
                        }), this.name = `${this.name} [${r}]`, this.stack, delete this.name
                    }
                    get code() {
                        return r
                    }
                    set code(r) {
                        Object.defineProperty(this, "code", {
                            configurable: !0,
                            enumerable: !0,
                            value: r,
                            writable: !0
                        })
                    }
                    toString() {
                        return `${this.name} [${r}]: ${this.message}`
                    }
                }
            }

            function addNumericalSeparator(r) {
                let l = "",
                    C = r.length,
                    U = "-" === r[0] ? 1 : 0;
                for (; C >= U + 4; C -= 3) l = `_${r.slice(C-3,C)}${l}`;
                return `${r.slice(0,C)}${l}`
            }

            function checkIntBI(r, l, C, U, et, eo) {
                if (r > C || r < l) {
                    let U;
                    let et = "bigint" == typeof l ? "n" : "";
                    throw U = eo > 3 ? 0 === l || l === BigInt(0) ? `>= 0${et} and < 2${et} ** ${(eo+1)*8}${et}` : `>= -(2${et} ** ${(eo+1)*8-1}${et}) and < 2 ** ${(eo+1)*8-1}${et}` : `>= ${l}${et} and <= ${C}${et}`, new es.ERR_OUT_OF_RANGE("value", U, r)
                }
                validateNumber(et, "offset"), (void 0 === U[et] || void 0 === U[et + eo]) && boundsError(et, U.length - (eo + 1))
            }

            function validateNumber(r, l) {
                if ("number" != typeof r) throw new es.ERR_INVALID_ARG_TYPE(l, "number", r)
            }

            function boundsError(r, l, C) {
                if (Math.floor(r) !== r) throw validateNumber(r, C), new es.ERR_OUT_OF_RANGE(C || "offset", "an integer", r);
                if (l < 0) throw new es.ERR_BUFFER_OUT_OF_BOUNDS;
                throw new es.ERR_OUT_OF_RANGE(C || "offset", `>= ${C?1:0} and <= ${l}`, r)
            }
            E("ERR_BUFFER_OUT_OF_BOUNDS", function(r) {
                return r ? `${r} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
            }, RangeError), E("ERR_INVALID_ARG_TYPE", function(r, l) {
                return `The "${r}" argument must be of type number. Received type ${typeof l}`
            }, TypeError), E("ERR_OUT_OF_RANGE", function(r, l, C) {
                let U = `The value of "${r}" is out of range.`,
                    et = C;
                return Number.isInteger(C) && Math.abs(C) > 4294967296 ? et = addNumericalSeparator(String(C)) : "bigint" == typeof C && (et = String(C), (C > BigInt(2) ** BigInt(32) || C < -(BigInt(2) ** BigInt(32))) && (et = addNumericalSeparator(et)), et += "n"), U += ` It must be ${l}. Received ${et}`
            }, RangeError);
            let el = /[^+/0-9A-Za-z-_]/g;

            function utf8ToBytes(r, l) {
                let C;
                l = l || 1 / 0;
                let U = r.length,
                    et = null,
                    eo = [];
                for (let es = 0; es < U; ++es) {
                    if ((C = r.charCodeAt(es)) > 55295 && C < 57344) {
                        if (!et) {
                            if (C > 56319 || es + 1 === U) {
                                (l -= 3) > -1 && eo.push(239, 191, 189);
                                continue
                            }
                            et = C;
                            continue
                        }
                        if (C < 56320) {
                            (l -= 3) > -1 && eo.push(239, 191, 189), et = C;
                            continue
                        }
                        C = (et - 55296 << 10 | C - 56320) + 65536
                    } else et && (l -= 3) > -1 && eo.push(239, 191, 189);
                    if (et = null, C < 128) {
                        if ((l -= 1) < 0) break;
                        eo.push(C)
                    } else if (C < 2048) {
                        if ((l -= 2) < 0) break;
                        eo.push(C >> 6 | 192, 63 & C | 128)
                    } else if (C < 65536) {
                        if ((l -= 3) < 0) break;
                        eo.push(C >> 12 | 224, C >> 6 & 63 | 128, 63 & C | 128)
                    } else if (C < 1114112) {
                        if ((l -= 4) < 0) break;
                        eo.push(C >> 18 | 240, C >> 12 & 63 | 128, C >> 6 & 63 | 128, 63 & C | 128)
                    } else throw Error("Invalid code point")
                }
                return eo
            }

            function base64ToBytes(r) {
                return U.toByteArray(function(r) {
                    if ((r = (r = r.split("=")[0]).trim().replace(el, "")).length < 2) return "";
                    for (; r.length % 4 != 0;) r += "=";
                    return r
                }(r))
            }

            function blitBuffer(r, l, C, U) {
                let et;
                for (et = 0; et < U && !(et + C >= l.length) && !(et >= r.length); ++et) l[et + C] = r[et];
                return et
            }

            function isInstance(r, l) {
                return r instanceof l || null != r && null != r.constructor && null != r.constructor.name && r.constructor.name === l.name
            }
            let ec = function() {
                let r = "0123456789abcdef",
                    l = Array(256);
                for (let C = 0; C < 16; ++C) {
                    let U = 16 * C;
                    for (let et = 0; et < 16; ++et) l[U + et] = r[C] + r[et]
                }
                return l
            }();

            function defineBigIntMethod(r) {
                return "undefined" == typeof BigInt ? BufferBigIntNotDefined : r
            }

            function BufferBigIntNotDefined() {
                throw Error("BigInt not supported")
            }
        },
        24180: function(r, l, C) {
            "use strict";

            function toInteger(r) {
                if (null === r || !0 === r || !1 === r) return NaN;
                var l = Number(r);
                return isNaN(l) ? l : l < 0 ? Math.ceil(l) : Math.floor(l)
            }
            C.d(l, {
                Z: function() {
                    return toInteger
                }
            })
        },
        66373: function(r, l, C) {
            "use strict";
            C.r(l), C.d(l, {
                default: function() {
                    return addHours
                }
            });
            var U = C(24180),
                et = C(91760),
                eo = C(37901);

            function addHours(r, l) {
                (0, eo.Z)(2, arguments);
                var C = (0, U.Z)(l);
                return (0, et.Z)(r, 36e5 * C)
            }
        },
        91760: function(r, l, C) {
            "use strict";
            C.d(l, {
                Z: function() {
                    return addMilliseconds
                }
            });
            var U = C(24180),
                et = C(68711),
                eo = C(37901);

            function addMilliseconds(r, l) {
                (0, eo.Z)(2, arguments);
                var C = (0, et.default)(r).getTime(),
                    es = (0, U.Z)(l);
                return new Date(C + es)
            }
        },
        90146: function(r, l, C) {
            "use strict";
            C.r(l), C.d(l, {
                default: function() {
                    return isBefore
                }
            });
            var U = C(68711),
                et = C(37901);

            function isBefore(r, l) {
                (0, et.Z)(2, arguments);
                var C = (0, U.default)(r),
                    eo = (0, U.default)(l);
                return C.getTime() < eo.getTime()
            }
        },
        24114: function(r, l, C) {
            "use strict";
            C.r(l), C.d(l, {
                default: function() {
                    return isEqual
                }
            });
            var U = C(68711),
                et = C(37901);

            function isEqual(r, l) {
                (0, et.Z)(2, arguments);
                var C = (0, U.default)(r),
                    eo = (0, U.default)(l);
                return C.getTime() === eo.getTime()
            }
        },
        56963: function(r) {
            "use strict";
            r.exports = function(r, l) {
                for (var C = {}, U = Object.keys(r), et = Array.isArray(l), eo = 0; eo < U.length; eo++) {
                    var es = U[eo],
                        el = r[es];
                    (et ? -1 !== l.indexOf(es) : l(es, el, r)) && (C[es] = el)
                }
                return C
            }
        },
        15375: function(r, l, C) {
            "use strict";
            let U = C(50250).v4,
                et = C(25476),
                ClientBrowser = function(r, l) {
                    if (!(this instanceof ClientBrowser)) return new ClientBrowser(r, l);
                    l || (l = {}), this.options = {
                        reviver: void 0 !== l.reviver ? l.reviver : null,
                        replacer: void 0 !== l.replacer ? l.replacer : null,
                        generator: void 0 !== l.generator ? l.generator : function() {
                            return U()
                        },
                        version: void 0 !== l.version ? l.version : 2,
                        notificationIdNull: "boolean" == typeof l.notificationIdNull && l.notificationIdNull
                    }, this.callServer = r
                };
            r.exports = ClientBrowser, ClientBrowser.prototype.request = function(r, l, C, U) {
                let eo;
                let es = this,
                    el = null,
                    ec = Array.isArray(r) && "function" == typeof l;
                if (1 === this.options.version && ec) throw TypeError("JSON-RPC 1.0 does not support batching");
                let ed = !ec && r && "object" == typeof r && "function" == typeof l;
                if (ec || ed) U = l, el = r;
                else {
                    "function" == typeof C && (U = C, C = void 0);
                    let eo = "function" == typeof U;
                    try {
                        el = et(r, l, C, {
                            generator: this.options.generator,
                            version: this.options.version,
                            notificationIdNull: this.options.notificationIdNull
                        })
                    } catch (r) {
                        if (eo) return U(r);
                        throw r
                    }
                    if (!eo) return el
                }
                try {
                    eo = JSON.stringify(el, this.options.replacer)
                } catch (r) {
                    return U(r)
                }
                return this.callServer(eo, function(r, l) {
                    es._parseResponse(r, l, U)
                }), el
            }, ClientBrowser.prototype._parseResponse = function(r, l, C) {
                let U;
                if (r) {
                    C(r);
                    return
                }
                if (!l) return C();
                try {
                    U = JSON.parse(l, this.options.reviver)
                } catch (r) {
                    return C(r)
                }
                if (3 === C.length) {
                    if (!Array.isArray(U)) return C(null, U.error, U.result); {
                        let isError = function(r) {
                            return void 0 !== r.error
                        };
                        return C(null, U.filter(isError), U.filter(function(r) {
                            return !isError(r)
                        }))
                    }
                }
                C(null, U)
            }
        },
        25476: function(r, l, C) {
            "use strict";
            let U = C(50250).v4;
            r.exports = function(r, l, C, et) {
                if ("string" != typeof r) throw TypeError(r + " must be a string");
                et = et || {};
                let eo = "number" == typeof et.version ? et.version : 2;
                if (1 !== eo && 2 !== eo) throw TypeError(eo + " must be 1 or 2");
                let es = {
                    method: r
                };
                if (2 === eo && (es.jsonrpc = "2.0"), l) {
                    if ("object" != typeof l && !Array.isArray(l)) throw TypeError(l + " must be an object, array or omitted");
                    es.params = l
                }
                if (void 0 === C) {
                    let r = "function" == typeof et.generator ? et.generator : function() {
                        return U()
                    };
                    es.id = r(es, et)
                } else 2 === eo && null === C ? et.notificationIdNull && (es.id = null) : es.id = C;
                return es
            }
        },
        12048: function(r, l, C) {
            "use strict";
            let U = C(50250).v4,
                et = C(23545),
                ClientBrowser = function(r, l) {
                    if (!(this instanceof ClientBrowser)) return new ClientBrowser(r, l);
                    l || (l = {}), this.options = {
                        reviver: void 0 !== l.reviver ? l.reviver : null,
                        replacer: void 0 !== l.replacer ? l.replacer : null,
                        generator: void 0 !== l.generator ? l.generator : function() {
                            return U()
                        },
                        version: void 0 !== l.version ? l.version : 2,
                        notificationIdNull: "boolean" == typeof l.notificationIdNull && l.notificationIdNull
                    }, this.callServer = r
                };
            r.exports = ClientBrowser, ClientBrowser.prototype.request = function(r, l, C, U) {
                let eo;
                let es = this,
                    el = null,
                    ec = Array.isArray(r) && "function" == typeof l;
                if (1 === this.options.version && ec) throw TypeError("JSON-RPC 1.0 does not support batching");
                let ed = !ec && r && "object" == typeof r && "function" == typeof l;
                if (ec || ed) U = l, el = r;
                else {
                    "function" == typeof C && (U = C, C = void 0);
                    let eo = "function" == typeof U;
                    try {
                        el = et(r, l, C, {
                            generator: this.options.generator,
                            version: this.options.version,
                            notificationIdNull: this.options.notificationIdNull
                        })
                    } catch (r) {
                        if (eo) return U(r);
                        throw r
                    }
                    if (!eo) return el
                }
                try {
                    eo = JSON.stringify(el, this.options.replacer)
                } catch (r) {
                    return U(r)
                }
                return this.callServer(eo, function(r, l) {
                    es._parseResponse(r, l, U)
                }), el
            }, ClientBrowser.prototype._parseResponse = function(r, l, C) {
                let U;
                if (r) {
                    C(r);
                    return
                }
                if (!l) return C();
                try {
                    U = JSON.parse(l, this.options.reviver)
                } catch (r) {
                    return C(r)
                }
                if (3 === C.length) {
                    if (!Array.isArray(U)) return C(null, U.error, U.result); {
                        let isError = function(r) {
                            return void 0 !== r.error
                        };
                        return C(null, U.filter(isError), U.filter(function(r) {
                            return !isError(r)
                        }))
                    }
                }
                C(null, U)
            }
        },
        23545: function(r, l, C) {
            "use strict";
            let U = C(50250).v4;
            r.exports = function(r, l, C, et) {
                if ("string" != typeof r) throw TypeError(r + " must be a string");
                et = et || {};
                let eo = "number" == typeof et.version ? et.version : 2;
                if (1 !== eo && 2 !== eo) throw TypeError(eo + " must be 1 or 2");
                let es = {
                    method: r
                };
                if (2 === eo && (es.jsonrpc = "2.0"), l) {
                    if ("object" != typeof l && !Array.isArray(l)) throw TypeError(l + " must be an object, array or omitted");
                    es.params = l
                }
                if (void 0 === C) {
                    let r = "function" == typeof et.generator ? et.generator : function() {
                        return U()
                    };
                    es.id = r(es, et)
                } else 2 === eo && null === C ? et.notificationIdNull && (es.id = null) : es.id = C;
                return es
            }
        },
        9414: function(r, l, C) {
            r = C.nmd(r);
            var U, et, eo, es = "__lodash_hash_undefined__",
                el = "[object Arguments]",
                ec = "[object Array]",
                ed = "[object Boolean]",
                eh = "[object Date]",
                ef = "[object Error]",
                ep = "[object Function]",
                eg = "[object Map]",
                ey = "[object Number]",
                em = "[object Object]",
                e_ = "[object Promise]",
                eb = "[object RegExp]",
                ew = "[object Set]",
                eE = "[object String]",
                eI = "[object WeakMap]",
                eS = "[object ArrayBuffer]",
                ex = "[object DataView]",
                eA = /^\[object .+?Constructor\]$/,
                eP = /^(?:0|[1-9]\d*)$/,
                eC = {};
            eC["[object Float32Array]"] = eC["[object Float64Array]"] = eC["[object Int8Array]"] = eC["[object Int16Array]"] = eC["[object Int32Array]"] = eC["[object Uint8Array]"] = eC["[object Uint8ClampedArray]"] = eC["[object Uint16Array]"] = eC["[object Uint32Array]"] = !0, eC[el] = eC[ec] = eC[eS] = eC[ed] = eC[ex] = eC[eh] = eC[ef] = eC[ep] = eC[eg] = eC[ey] = eC[em] = eC[eb] = eC[ew] = eC[eE] = eC[eI] = !1;
            var ek = "object" == typeof C.g && C.g && C.g.Object === Object && C.g,
                eN = "object" == typeof self && self && self.Object === Object && self,
                eO = ek || eN || Function("return this")(),
                eT = l && !l.nodeType && l,
                eR = eT && r && !r.nodeType && r,
                eD = eR && eR.exports === eT,
                eB = eD && ek.process,
                eU = function() {
                    try {
                        return eB && eB.binding && eB.binding("util")
                    } catch (r) {}
                }(),
                eL = eU && eU.isTypedArray;

            function mapToArray(r) {
                var l = -1,
                    C = Array(r.size);
                return r.forEach(function(r, U) {
                    C[++l] = [U, r]
                }), C
            }

            function setToArray(r) {
                var l = -1,
                    C = Array(r.size);
                return r.forEach(function(r) {
                    C[++l] = r
                }), C
            }
            var eM = Array.prototype,
                ej = Function.prototype,
                e$ = Object.prototype,
                ez = eO["__core-js_shared__"],
                eH = ej.toString,
                eF = e$.hasOwnProperty,
                eW = (U = /[^.]+$/.exec(ez && ez.keys && ez.keys.IE_PROTO || "")) ? "Symbol(src)_1." + U : "",
                eV = e$.toString,
                eK = RegExp("^" + eH.call(eF).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
                eG = eD ? eO.Buffer : void 0,
                eJ = eO.Symbol,
                eY = eO.Uint8Array,
                eZ = e$.propertyIsEnumerable,
                eX = eM.splice,
                eQ = eJ ? eJ.toStringTag : void 0,
                e0 = Object.getOwnPropertySymbols,
                e1 = eG ? eG.isBuffer : void 0,
                e2 = (et = Object.keys, eo = Object, function(r) {
                    return et(eo(r))
                }),
                e3 = getNative(eO, "DataView"),
                e5 = getNative(eO, "Map"),
                e6 = getNative(eO, "Promise"),
                e8 = getNative(eO, "Set"),
                e4 = getNative(eO, "WeakMap"),
                e9 = getNative(Object, "create"),
                e7 = toSource(e3),
                tn = toSource(e5),
                to = toSource(e6),
                ts = toSource(e8),
                ta = toSource(e4),
                tl = eJ ? eJ.prototype : void 0,
                tc = tl ? tl.valueOf : void 0;

            function Hash(r) {
                var l = -1,
                    C = null == r ? 0 : r.length;
                for (this.clear(); ++l < C;) {
                    var U = r[l];
                    this.set(U[0], U[1])
                }
            }

            function ListCache(r) {
                var l = -1,
                    C = null == r ? 0 : r.length;
                for (this.clear(); ++l < C;) {
                    var U = r[l];
                    this.set(U[0], U[1])
                }
            }

            function MapCache(r) {
                var l = -1,
                    C = null == r ? 0 : r.length;
                for (this.clear(); ++l < C;) {
                    var U = r[l];
                    this.set(U[0], U[1])
                }
            }

            function SetCache(r) {
                var l = -1,
                    C = null == r ? 0 : r.length;
                for (this.__data__ = new MapCache; ++l < C;) this.add(r[l])
            }

            function Stack(r) {
                var l = this.__data__ = new ListCache(r);
                this.size = l.size
            }

            function assocIndexOf(r, l) {
                for (var C = r.length; C--;)
                    if (eq(r[C][0], l)) return C;
                return -1
            }

            function baseGetTag(r) {
                return null == r ? void 0 === r ? "[object Undefined]" : "[object Null]" : eQ && eQ in Object(r) ? function(r) {
                    var l = eF.call(r, eQ),
                        C = r[eQ];
                    try {
                        r[eQ] = void 0;
                        var U = !0
                    } catch (r) {}
                    var et = eV.call(r);
                    return U && (l ? r[eQ] = C : delete r[eQ]), et
                }(r) : eV.call(r)
            }

            function baseIsArguments(r) {
                return isObjectLike(r) && baseGetTag(r) == el
            }

            function equalArrays(r, l, C, U, et, eo) {
                var es = 1 & C,
                    el = r.length,
                    ec = l.length;
                if (el != ec && !(es && ec > el)) return !1;
                var ed = eo.get(r);
                if (ed && eo.get(l)) return ed == l;
                var eh = -1,
                    ef = !0,
                    ep = 2 & C ? new SetCache : void 0;
                for (eo.set(r, l), eo.set(l, r); ++eh < el;) {
                    var eg = r[eh],
                        ey = l[eh];
                    if (U) var em = es ? U(ey, eg, eh, l, r, eo) : U(eg, ey, eh, r, l, eo);
                    if (void 0 !== em) {
                        if (em) continue;
                        ef = !1;
                        break
                    }
                    if (ep) {
                        if (! function(r, l) {
                                for (var C = -1, U = null == r ? 0 : r.length; ++C < U;)
                                    if (l(r[C], C, r)) return !0;
                                return !1
                            }(l, function(r, l) {
                                if (!ep.has(l) && (eg === r || et(eg, r, C, U, eo))) return ep.push(l)
                            })) {
                            ef = !1;
                            break
                        }
                    } else if (!(eg === ey || et(eg, ey, C, U, eo))) {
                        ef = !1;
                        break
                    }
                }
                return eo.delete(r), eo.delete(l), ef
            }

            function getAllKeys(r) {
                var l;
                return l = function(r) {
                    return null != r && isLength(r.length) && !isFunction(r) ? function(r, l) {
                        var C, U = tp(r),
                            et = !U && tf(r),
                            eo = !U && !et && tg(r),
                            es = !U && !et && !eo && ty(r),
                            el = U || et || eo || es,
                            ec = el ? function(r, l) {
                                for (var C = -1, U = Array(r); ++C < r;) U[C] = l(C);
                                return U
                            }(r.length, String) : [],
                            ed = ec.length;
                        for (var eh in r) eF.call(r, eh) && !(el && ("length" == eh || eo && ("offset" == eh || "parent" == eh) || es && ("buffer" == eh || "byteLength" == eh || "byteOffset" == eh) || (C = null == (C = ed) ? 9007199254740991 : C) && ("number" == typeof eh || eP.test(eh)) && eh > -1 && eh % 1 == 0 && eh < C)) && ec.push(eh);
                        return ec
                    }(r) : function(r) {
                        if (l = r && r.constructor, r !== ("function" == typeof l && l.prototype || e$)) return e2(r);
                        var l, C = [];
                        for (var U in Object(r)) eF.call(r, U) && "constructor" != U && C.push(U);
                        return C
                    }(r)
                }(r), tp(r) ? l : function(r, l) {
                    for (var C = -1, U = l.length, et = r.length; ++C < U;) r[et + C] = l[C];
                    return r
                }(l, td(r))
            }

            function getMapData(r, l) {
                var C, U = r.__data__;
                return ("string" == (C = typeof l) || "number" == C || "symbol" == C || "boolean" == C ? "__proto__" !== l : null === l) ? U["string" == typeof l ? "string" : "hash"] : U.map
            }

            function getNative(r, l) {
                var C = null == r ? void 0 : r[l];
                return !(!isObject(C) || eW && eW in C) && (isFunction(C) ? eK : eA).test(toSource(C)) ? C : void 0
            }
            Hash.prototype.clear = function() {
                this.__data__ = e9 ? e9(null) : {}, this.size = 0
            }, Hash.prototype.delete = function(r) {
                var l = this.has(r) && delete this.__data__[r];
                return this.size -= l ? 1 : 0, l
            }, Hash.prototype.get = function(r) {
                var l = this.__data__;
                if (e9) {
                    var C = l[r];
                    return C === es ? void 0 : C
                }
                return eF.call(l, r) ? l[r] : void 0
            }, Hash.prototype.has = function(r) {
                var l = this.__data__;
                return e9 ? void 0 !== l[r] : eF.call(l, r)
            }, Hash.prototype.set = function(r, l) {
                var C = this.__data__;
                return this.size += this.has(r) ? 0 : 1, C[r] = e9 && void 0 === l ? es : l, this
            }, ListCache.prototype.clear = function() {
                this.__data__ = [], this.size = 0
            }, ListCache.prototype.delete = function(r) {
                var l = this.__data__,
                    C = assocIndexOf(l, r);
                return !(C < 0) && (C == l.length - 1 ? l.pop() : eX.call(l, C, 1), --this.size, !0)
            }, ListCache.prototype.get = function(r) {
                var l = this.__data__,
                    C = assocIndexOf(l, r);
                return C < 0 ? void 0 : l[C][1]
            }, ListCache.prototype.has = function(r) {
                return assocIndexOf(this.__data__, r) > -1
            }, ListCache.prototype.set = function(r, l) {
                var C = this.__data__,
                    U = assocIndexOf(C, r);
                return U < 0 ? (++this.size, C.push([r, l])) : C[U][1] = l, this
            }, MapCache.prototype.clear = function() {
                this.size = 0, this.__data__ = {
                    hash: new Hash,
                    map: new(e5 || ListCache),
                    string: new Hash
                }
            }, MapCache.prototype.delete = function(r) {
                var l = getMapData(this, r).delete(r);
                return this.size -= l ? 1 : 0, l
            }, MapCache.prototype.get = function(r) {
                return getMapData(this, r).get(r)
            }, MapCache.prototype.has = function(r) {
                return getMapData(this, r).has(r)
            }, MapCache.prototype.set = function(r, l) {
                var C = getMapData(this, r),
                    U = C.size;
                return C.set(r, l), this.size += C.size == U ? 0 : 1, this
            }, SetCache.prototype.add = SetCache.prototype.push = function(r) {
                return this.__data__.set(r, es), this
            }, SetCache.prototype.has = function(r) {
                return this.__data__.has(r)
            }, Stack.prototype.clear = function() {
                this.__data__ = new ListCache, this.size = 0
            }, Stack.prototype.delete = function(r) {
                var l = this.__data__,
                    C = l.delete(r);
                return this.size = l.size, C
            }, Stack.prototype.get = function(r) {
                return this.__data__.get(r)
            }, Stack.prototype.has = function(r) {
                return this.__data__.has(r)
            }, Stack.prototype.set = function(r, l) {
                var C = this.__data__;
                if (C instanceof ListCache) {
                    var U = C.__data__;
                    if (!e5 || U.length < 199) return U.push([r, l]), this.size = ++C.size, this;
                    C = this.__data__ = new MapCache(U)
                }
                return C.set(r, l), this.size = C.size, this
            };
            var td = e0 ? function(r) {
                    return null == r ? [] : function(r, l) {
                        for (var C = -1, U = null == r ? 0 : r.length, et = 0, eo = []; ++C < U;) {
                            var es = r[C];
                            l(es, C, r) && (eo[et++] = es)
                        }
                        return eo
                    }(e0(r = Object(r)), function(l) {
                        return eZ.call(r, l)
                    })
                } : function() {
                    return []
                },
                th = baseGetTag;

            function toSource(r) {
                if (null != r) {
                    try {
                        return eH.call(r)
                    } catch (r) {}
                    try {
                        return r + ""
                    } catch (r) {}
                }
                return ""
            }

            function eq(r, l) {
                return r === l || r != r && l != l
            }(e3 && th(new e3(new ArrayBuffer(1))) != ex || e5 && th(new e5) != eg || e6 && th(e6.resolve()) != e_ || e8 && th(new e8) != ew || e4 && th(new e4) != eI) && (th = function(r) {
                var l = baseGetTag(r),
                    C = l == em ? r.constructor : void 0,
                    U = C ? toSource(C) : "";
                if (U) switch (U) {
                    case e7:
                        return ex;
                    case tn:
                        return eg;
                    case to:
                        return e_;
                    case ts:
                        return ew;
                    case ta:
                        return eI
                }
                return l
            });
            var tf = baseIsArguments(function() {
                    return arguments
                }()) ? baseIsArguments : function(r) {
                    return isObjectLike(r) && eF.call(r, "callee") && !eZ.call(r, "callee")
                },
                tp = Array.isArray,
                tg = e1 || function() {
                    return !1
                };

            function isFunction(r) {
                if (!isObject(r)) return !1;
                var l = baseGetTag(r);
                return l == ep || "[object GeneratorFunction]" == l || "[object AsyncFunction]" == l || "[object Proxy]" == l
            }

            function isLength(r) {
                return "number" == typeof r && r > -1 && r % 1 == 0 && r <= 9007199254740991
            }

            function isObject(r) {
                var l = typeof r;
                return null != r && ("object" == l || "function" == l)
            }

            function isObjectLike(r) {
                return null != r && "object" == typeof r
            }
            var ty = eL ? function(r) {
                return eL(r)
            } : function(r) {
                return isObjectLike(r) && isLength(r.length) && !!eC[baseGetTag(r)]
            };
            r.exports = function(r, l) {
                return function baseIsEqual(r, l, C, U, et) {
                    return r === l || (null != r && null != l && (isObjectLike(r) || isObjectLike(l)) ? function(r, l, C, U, et, eo) {
                        var es = tp(r),
                            ep = tp(l),
                            e_ = es ? ec : th(r),
                            eI = ep ? ec : th(l);
                        e_ = e_ == el ? em : e_, eI = eI == el ? em : eI;
                        var eA = e_ == em,
                            eP = eI == em,
                            eC = e_ == eI;
                        if (eC && tg(r)) {
                            if (!tg(l)) return !1;
                            es = !0, eA = !1
                        }
                        if (eC && !eA) return eo || (eo = new Stack), es || ty(r) ? equalArrays(r, l, C, U, et, eo) : function(r, l, C, U, et, eo, es) {
                            switch (C) {
                                case ex:
                                    if (r.byteLength != l.byteLength || r.byteOffset != l.byteOffset) break;
                                    r = r.buffer, l = l.buffer;
                                case eS:
                                    if (r.byteLength != l.byteLength || !eo(new eY(r), new eY(l))) break;
                                    return !0;
                                case ed:
                                case eh:
                                case ey:
                                    return eq(+r, +l);
                                case ef:
                                    return r.name == l.name && r.message == l.message;
                                case eb:
                                case eE:
                                    return r == l + "";
                                case eg:
                                    var el = mapToArray;
                                case ew:
                                    var ec = 1 & U;
                                    if (el || (el = setToArray), r.size != l.size && !ec) break;
                                    var ep = es.get(r);
                                    if (ep) return ep == l;
                                    U |= 2, es.set(r, l);
                                    var em = equalArrays(el(r), el(l), U, et, eo, es);
                                    return es.delete(r), em;
                                case "[object Symbol]":
                                    if (tc) return tc.call(r) == tc.call(l)
                            }
                            return !1
                        }(r, l, e_, C, U, et, eo);
                        if (!(1 & C)) {
                            var ek = eA && eF.call(r, "__wrapped__"),
                                eN = eP && eF.call(l, "__wrapped__");
                            if (ek || eN) {
                                var eO = ek ? r.value() : r,
                                    eT = eN ? l.value() : l;
                                return eo || (eo = new Stack), et(eO, eT, C, U, eo)
                            }
                        }
                        return !!eC && (eo || (eo = new Stack), function(r, l, C, U, et, eo) {
                            var es = 1 & C,
                                el = getAllKeys(r),
                                ec = el.length;
                            if (ec != getAllKeys(l).length && !es) return !1;
                            for (var ed = ec; ed--;) {
                                var eh = el[ed];
                                if (!(es ? eh in l : eF.call(l, eh))) return !1
                            }
                            var ef = eo.get(r);
                            if (ef && eo.get(l)) return ef == l;
                            var ep = !0;
                            eo.set(r, l), eo.set(l, r);
                            for (var eg = es; ++ed < ec;) {
                                var ey = r[eh = el[ed]],
                                    em = l[eh];
                                if (U) var e_ = es ? U(em, ey, eh, l, r, eo) : U(ey, em, eh, r, l, eo);
                                if (!(void 0 === e_ ? ey === em || et(ey, em, C, U, eo) : e_)) {
                                    ep = !1;
                                    break
                                }
                                eg || (eg = "constructor" == eh)
                            }
                            if (ep && !eg) {
                                var eb = r.constructor,
                                    ew = l.constructor;
                                eb != ew && "constructor" in r && "constructor" in l && !("function" == typeof eb && eb instanceof eb && "function" == typeof ew && ew instanceof ew) && (ep = !1)
                            }
                            return eo.delete(r), eo.delete(l), ep
                        }(r, l, C, U, et, eo))
                    }(r, l, C, U, baseIsEqual, et) : r != r && l != l)
                }(r, l)
            }
        },
        30240: function(r, l, C) {
            "use strict";
            let U = C(67475),
                et = C(31706),
                eo = C(97093),
                es = C(56963),
                isNullOrUndefined = r => null == r,
                el = Symbol("encodeFragmentIdentifier");

            function validateArrayFormatSeparator(r) {
                if ("string" != typeof r || 1 !== r.length) throw TypeError("arrayFormatSeparator must be single character string")
            }

            function encode(r, l) {
                return l.encode ? l.strict ? U(r) : encodeURIComponent(r) : r
            }

            function decode(r, l) {
                return l.decode ? et(r) : r
            }

            function removeHash(r) {
                let l = r.indexOf("#");
                return -1 !== l && (r = r.slice(0, l)), r
            }

            function extract(r) {
                r = removeHash(r);
                let l = r.indexOf("?");
                return -1 === l ? "" : r.slice(l + 1)
            }

            function parseValue(r, l) {
                return l.parseNumbers && !Number.isNaN(Number(r)) && "string" == typeof r && "" !== r.trim() ? r = Number(r) : l.parseBooleans && null !== r && ("true" === r.toLowerCase() || "false" === r.toLowerCase()) && (r = "true" === r.toLowerCase()), r
            }

            function parse(r, l) {
                validateArrayFormatSeparator((l = Object.assign({
                    decode: !0,
                    sort: !0,
                    arrayFormat: "none",
                    arrayFormatSeparator: ",",
                    parseNumbers: !1,
                    parseBooleans: !1
                }, l)).arrayFormatSeparator);
                let C = function(r) {
                        let l;
                        switch (r.arrayFormat) {
                            case "index":
                                return (r, C, U) => {
                                    if (l = /\[(\d*)\]$/.exec(r), r = r.replace(/\[\d*\]$/, ""), !l) {
                                        U[r] = C;
                                        return
                                    }
                                    void 0 === U[r] && (U[r] = {}), U[r][l[1]] = C
                                };
                            case "bracket":
                                return (r, C, U) => {
                                    if (l = /(\[\])$/.exec(r), r = r.replace(/\[\]$/, ""), !l) {
                                        U[r] = C;
                                        return
                                    }
                                    if (void 0 === U[r]) {
                                        U[r] = [C];
                                        return
                                    }
                                    U[r] = [].concat(U[r], C)
                                };
                            case "colon-list-separator":
                                return (r, C, U) => {
                                    if (l = /(:list)$/.exec(r), r = r.replace(/:list$/, ""), !l) {
                                        U[r] = C;
                                        return
                                    }
                                    if (void 0 === U[r]) {
                                        U[r] = [C];
                                        return
                                    }
                                    U[r] = [].concat(U[r], C)
                                };
                            case "comma":
                            case "separator":
                                return (l, C, U) => {
                                    let et = "string" == typeof C && C.includes(r.arrayFormatSeparator),
                                        eo = "string" == typeof C && !et && decode(C, r).includes(r.arrayFormatSeparator);
                                    C = eo ? decode(C, r) : C;
                                    let es = et || eo ? C.split(r.arrayFormatSeparator).map(l => decode(l, r)) : null === C ? C : decode(C, r);
                                    U[l] = es
                                };
                            case "bracket-separator":
                                return (l, C, U) => {
                                    let et = /(\[\])$/.test(l);
                                    if (l = l.replace(/\[\]$/, ""), !et) {
                                        U[l] = C ? decode(C, r) : C;
                                        return
                                    }
                                    let eo = null === C ? [] : C.split(r.arrayFormatSeparator).map(l => decode(l, r));
                                    if (void 0 === U[l]) {
                                        U[l] = eo;
                                        return
                                    }
                                    U[l] = [].concat(U[l], eo)
                                };
                            default:
                                return (r, l, C) => {
                                    if (void 0 === C[r]) {
                                        C[r] = l;
                                        return
                                    }
                                    C[r] = [].concat(C[r], l)
                                }
                        }
                    }(l),
                    U = Object.create(null);
                if ("string" != typeof r || !(r = r.trim().replace(/^[?#&]/, ""))) return U;
                for (let et of r.split("&")) {
                    if ("" === et) continue;
                    let [r, es] = eo(l.decode ? et.replace(/\+/g, " ") : et, "=");
                    es = void 0 === es ? null : ["comma", "separator", "bracket-separator"].includes(l.arrayFormat) ? es : decode(es, l), C(decode(r, l), es, U)
                }
                for (let r of Object.keys(U)) {
                    let C = U[r];
                    if ("object" == typeof C && null !== C)
                        for (let r of Object.keys(C)) C[r] = parseValue(C[r], l);
                    else U[r] = parseValue(C, l)
                }
                return !1 === l.sort ? U : (!0 === l.sort ? Object.keys(U).sort() : Object.keys(U).sort(l.sort)).reduce((r, l) => {
                    let C = U[l];
                    return C && "object" == typeof C && !Array.isArray(C) ? r[l] = function keysSorter(r) {
                        return Array.isArray(r) ? r.sort() : "object" == typeof r ? keysSorter(Object.keys(r)).sort((r, l) => Number(r) - Number(l)).map(l => r[l]) : r
                    }(C) : r[l] = C, r
                }, Object.create(null))
            }
            l.extract = extract, l.parse = parse, l.stringify = (r, l) => {
                if (!r) return "";
                validateArrayFormatSeparator((l = Object.assign({
                    encode: !0,
                    strict: !0,
                    arrayFormat: "none",
                    arrayFormatSeparator: ","
                }, l)).arrayFormatSeparator);
                let shouldFilter = C => l.skipNull && isNullOrUndefined(r[C]) || l.skipEmptyString && "" === r[C],
                    C = function(r) {
                        switch (r.arrayFormat) {
                            case "index":
                                return l => (C, U) => {
                                    let et = C.length;
                                    return void 0 === U || r.skipNull && null === U || r.skipEmptyString && "" === U ? C : null === U ? [...C, [encode(l, r), "[", et, "]"].join("")] : [...C, [encode(l, r), "[", encode(et, r), "]=", encode(U, r)].join("")]
                                };
                            case "bracket":
                                return l => (C, U) => void 0 === U || r.skipNull && null === U || r.skipEmptyString && "" === U ? C : null === U ? [...C, [encode(l, r), "[]"].join("")] : [...C, [encode(l, r), "[]=", encode(U, r)].join("")];
                            case "colon-list-separator":
                                return l => (C, U) => void 0 === U || r.skipNull && null === U || r.skipEmptyString && "" === U ? C : null === U ? [...C, [encode(l, r), ":list="].join("")] : [...C, [encode(l, r), ":list=", encode(U, r)].join("")];
                            case "comma":
                            case "separator":
                            case "bracket-separator":
                                {
                                    let l = "bracket-separator" === r.arrayFormat ? "[]=" : "=";
                                    return C => (U, et) => void 0 === et || r.skipNull && null === et || r.skipEmptyString && "" === et ? U : (et = null === et ? "" : et, 0 === U.length) ? [
                                        [encode(C, r), l, encode(et, r)].join("")
                                    ] : [
                                        [U, encode(et, r)].join(r.arrayFormatSeparator)
                                    ]
                                }
                            default:
                                return l => (C, U) => void 0 === U || r.skipNull && null === U || r.skipEmptyString && "" === U ? C : null === U ? [...C, encode(l, r)] : [...C, [encode(l, r), "=", encode(U, r)].join("")]
                        }
                    }(l),
                    U = {};
                for (let l of Object.keys(r)) shouldFilter(l) || (U[l] = r[l]);
                let et = Object.keys(U);
                return !1 !== l.sort && et.sort(l.sort), et.map(U => {
                    let et = r[U];
                    return void 0 === et ? "" : null === et ? encode(U, l) : Array.isArray(et) ? 0 === et.length && "bracket-separator" === l.arrayFormat ? encode(U, l) + "[]" : et.reduce(C(U), []).join("&") : encode(U, l) + "=" + encode(et, l)
                }).filter(r => r.length > 0).join("&")
            }, l.parseUrl = (r, l) => {
                l = Object.assign({
                    decode: !0
                }, l);
                let [C, U] = eo(r, "#");
                return Object.assign({
                    url: C.split("?")[0] || "",
                    query: parse(extract(r), l)
                }, l && l.parseFragmentIdentifier && U ? {
                    fragmentIdentifier: decode(U, l)
                } : {})
            }, l.stringifyUrl = (r, C) => {
                C = Object.assign({
                    encode: !0,
                    strict: !0,
                    [el]: !0
                }, C);
                let U = removeHash(r.url).split("?")[0] || "",
                    et = l.extract(r.url),
                    eo = l.parse(et, {
                        sort: !1
                    }),
                    es = Object.assign(eo, r.query),
                    ec = l.stringify(es, C);
                ec && (ec = `?${ec}`);
                let ed = function(r) {
                    let l = "",
                        C = r.indexOf("#");
                    return -1 !== C && (l = r.slice(C)), l
                }(r.url);
                return r.fragmentIdentifier && (ed = `#${C[el]?encode(r.fragmentIdentifier,C):r.fragmentIdentifier}`), `${U}${ec}${ed}`
            }, l.pick = (r, C, U) => {
                U = Object.assign({
                    parseFragmentIdentifier: !0,
                    [el]: !1
                }, U);
                let {
                    url: et,
                    query: eo,
                    fragmentIdentifier: ec
                } = l.parseUrl(r, U);
                return l.stringifyUrl({
                    url: et,
                    query: es(eo, C),
                    fragmentIdentifier: ec
                }, U)
            }, l.exclude = (r, C, U) => {
                let et = Array.isArray(C) ? r => !C.includes(r) : (r, l) => !C(r, l);
                return l.pick(r, et, U)
            }
        },
        17968: function(r) {
            "use strict";

            function tryStringify(r) {
                try {
                    return JSON.stringify(r)
                } catch (r) {
                    return '"[Circular]"'
                }
            }
            r.exports = function(r, l, C) {
                var U = C && C.stringify || tryStringify;
                if ("object" == typeof r && null !== r) {
                    var et = l.length + 1;
                    if (1 === et) return r;
                    var eo = Array(et);
                    eo[0] = U(r);
                    for (var es = 1; es < et; es++) eo[es] = U(l[es]);
                    return eo.join(" ")
                }
                if ("string" != typeof r) return r;
                var el = l.length;
                if (0 === el) return r;
                for (var ec = "", ed = 0, eh = -1, ef = r && r.length || 0, ep = 0; ep < ef;) {
                    if (37 === r.charCodeAt(ep) && ep + 1 < ef) {
                        switch (eh = eh > -1 ? eh : 0, r.charCodeAt(ep + 1)) {
                            case 100:
                            case 102:
                                if (ed >= el || null == l[ed]) break;
                                eh < ep && (ec += r.slice(eh, ep)), ec += Number(l[ed]), eh = ep + 2, ep++;
                                break;
                            case 105:
                                if (ed >= el || null == l[ed]) break;
                                eh < ep && (ec += r.slice(eh, ep)), ec += Math.floor(Number(l[ed])), eh = ep + 2, ep++;
                                break;
                            case 79:
                            case 111:
                            case 106:
                                if (ed >= el || void 0 === l[ed]) break;
                                eh < ep && (ec += r.slice(eh, ep));
                                var eg = typeof l[ed];
                                if ("string" === eg) {
                                    ec += "'" + l[ed] + "'", eh = ep + 2, ep++;
                                    break
                                }
                                if ("function" === eg) {
                                    ec += l[ed].name || "<anonymous>", eh = ep + 2, ep++;
                                    break
                                }
                                ec += U(l[ed]), eh = ep + 2, ep++;
                                break;
                            case 115:
                                if (ed >= el) break;
                                eh < ep && (ec += r.slice(eh, ep)), ec += String(l[ed]), eh = ep + 2, ep++;
                                break;
                            case 37:
                                eh < ep && (ec += r.slice(eh, ep)), ec += "%", eh = ep + 2, ep++, ed--
                        }++ed
                    }++ep
                }
                return -1 === eh ? r : (eh < ef && (ec += r.slice(eh)), ec)
            }
        },
        13769: function(r, l, C) {
            "use strict";
            var U = C(15350);
            l.K = void 0;
            var et = U(C(23826)),
                eo = U(C(83173)),
                es = U(C(95600)),
                el = U(C(33499)),
                ec = U(C(69149)),
                ed = U(C(5576)),
                eh = function(r) {
                    (0, es.default)(Client, r);
                    var l, C = (l = function() {
                        if ("undefined" == typeof Reflect || !Reflect.construct || Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), !0
                        } catch (r) {
                            return !1
                        }
                    }(), function() {
                        var r, C = (0, ec.default)(Client);
                        if (l) {
                            var U = (0, ec.default)(this).constructor;
                            r = Reflect.construct(C, arguments, U)
                        } else r = C.apply(this, arguments);
                        return (0, el.default)(this, r)
                    });

                    function Client() {
                        var r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "ws://localhost:8080",
                            l = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                            U = l.autoconnect,
                            et = l.reconnect,
                            es = l.reconnect_interval,
                            el = l.max_reconnects,
                            ec = arguments.length > 2 ? arguments[2] : void 0;
                        return (0, eo.default)(this, Client), C.call(this, ed.default, r, {
                            autoconnect: void 0 === U || U,
                            reconnect: void 0 === et || et,
                            reconnect_interval: void 0 === es ? 1e3 : es,
                            max_reconnects: void 0 === el ? 5 : el
                        }, ec)
                    }
                    return (0, et.default)(Client)
                }(U(C(15209)).default);
            l.K = eh
        },
        15209: function(r, l, C) {
            "use strict";
            var U = C(97115).Buffer,
                et = C(15350);
            Object.defineProperty(l, "__esModule", {
                value: !0
            }), l.default = void 0;
            var eo = et(C(89052)),
                es = et(C(55320)),
                el = et(C(80443)),
                ec = et(C(83173)),
                ed = et(C(23826)),
                eh = et(C(95600)),
                ef = et(C(33499)),
                ep = et(C(69149)),
                eg = C(83760),
                __rest = function(r, l) {
                    var C = {};
                    for (var U in r) Object.prototype.hasOwnProperty.call(r, U) && 0 > l.indexOf(U) && (C[U] = r[U]);
                    if (null != r && "function" == typeof Object.getOwnPropertySymbols)
                        for (var et = 0, U = Object.getOwnPropertySymbols(r); et < U.length; et++) 0 > l.indexOf(U[et]) && Object.prototype.propertyIsEnumerable.call(r, U[et]) && (C[U[et]] = r[U[et]]);
                    return C
                },
                ey = function(r) {
                    (0, eh.default)(CommonClient, r);
                    var l, C, et, eg, ey, em = (l = function() {
                        if ("undefined" == typeof Reflect || !Reflect.construct || Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), !0
                        } catch (r) {
                            return !1
                        }
                    }(), function() {
                        var r, C = (0, ep.default)(CommonClient);
                        if (l) {
                            var U = (0, ep.default)(this).constructor;
                            r = Reflect.construct(C, arguments, U)
                        } else r = C.apply(this, arguments);
                        return (0, ef.default)(this, r)
                    });

                    function CommonClient(r) {
                        var l, C = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "ws://localhost:8080",
                            U = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
                            et = arguments.length > 3 ? arguments[3] : void 0;
                        (0, ec.default)(this, CommonClient);
                        var eo = U.autoconnect,
                            es = U.reconnect,
                            el = U.reconnect_interval,
                            ed = U.max_reconnects,
                            eh = __rest(U, ["autoconnect", "reconnect", "reconnect_interval", "max_reconnects"]);
                        return (l = em.call(this)).webSocketFactory = r, l.queue = {}, l.rpc_id = 0, l.address = C, l.autoconnect = void 0 === eo || eo, l.ready = !1, l.reconnect = void 0 === es || es, l.reconnect_timer_id = void 0, l.reconnect_interval = void 0 === el ? 1e3 : el, l.max_reconnects = void 0 === ed ? 5 : ed, l.rest_options = eh, l.current_reconnects = 0, l.generate_request_id = et || function() {
                            return ++l.rpc_id
                        }, l.autoconnect && l._connect(l.address, Object.assign({
                            autoconnect: l.autoconnect,
                            reconnect: l.reconnect,
                            reconnect_interval: l.reconnect_interval,
                            max_reconnects: l.max_reconnects
                        }, l.rest_options)), l
                    }
                    return (0, ed.default)(CommonClient, [{
                        key: "connect",
                        value: function() {
                            this.socket || this._connect(this.address, Object.assign({
                                autoconnect: this.autoconnect,
                                reconnect: this.reconnect,
                                reconnect_interval: this.reconnect_interval,
                                max_reconnects: this.max_reconnects
                            }, this.rest_options))
                        }
                    }, {
                        key: "call",
                        value: function(r, l, C, U) {
                            var et = this;
                            return U || "object" !== (0, el.default)(C) || (U = C, C = null), new Promise(function(eo, es) {
                                if (!et.ready) return es(Error("socket not ready"));
                                var el = et.generate_request_id(r, l);
                                et.socket.send(JSON.stringify({
                                    jsonrpc: "2.0",
                                    method: r,
                                    params: l || null,
                                    id: el
                                }), U, function(r) {
                                    if (r) return es(r);
                                    et.queue[el] = {
                                        promise: [eo, es]
                                    }, C && (et.queue[el].timeout = setTimeout(function() {
                                        delete et.queue[el], es(Error("reply timeout"))
                                    }, C))
                                })
                            })
                        }
                    }, {
                        key: "login",
                        value: (C = (0, es.default)(eo.default.mark(function _callee(r) {
                            var l;
                            return eo.default.wrap(function(C) {
                                for (;;) switch (C.prev = C.next) {
                                    case 0:
                                        return C.next = 2, this.call("rpc.login", r);
                                    case 2:
                                        if (l = C.sent) {
                                            C.next = 5;
                                            break
                                        }
                                        throw Error("authentication failed");
                                    case 5:
                                        return C.abrupt("return", l);
                                    case 6:
                                    case "end":
                                        return C.stop()
                                }
                            }, _callee, this)
                        })), function(r) {
                            return C.apply(this, arguments)
                        })
                    }, {
                        key: "listMethods",
                        value: (et = (0, es.default)(eo.default.mark(function _callee2() {
                            return eo.default.wrap(function(r) {
                                for (;;) switch (r.prev = r.next) {
                                    case 0:
                                        return r.next = 2, this.call("__listMethods");
                                    case 2:
                                        return r.abrupt("return", r.sent);
                                    case 3:
                                    case "end":
                                        return r.stop()
                                }
                            }, _callee2, this)
                        })), function() {
                            return et.apply(this, arguments)
                        })
                    }, {
                        key: "notify",
                        value: function(r, l) {
                            var C = this;
                            return new Promise(function(U, et) {
                                if (!C.ready) return et(Error("socket not ready"));
                                C.socket.send(JSON.stringify({
                                    jsonrpc: "2.0",
                                    method: r,
                                    params: l || null
                                }), function(r) {
                                    if (r) return et(r);
                                    U()
                                })
                            })
                        }
                    }, {
                        key: "subscribe",
                        value: (eg = (0, es.default)(eo.default.mark(function _callee3(r) {
                            var l;
                            return eo.default.wrap(function(C) {
                                for (;;) switch (C.prev = C.next) {
                                    case 0:
                                        return "string" == typeof r && (r = [r]), C.next = 3, this.call("rpc.on", r);
                                    case 3:
                                        if (l = C.sent, !("string" == typeof r && "ok" !== l[r])) {
                                            C.next = 6;
                                            break
                                        }
                                        throw Error("Failed subscribing to an event '" + r + "' with: " + l[r]);
                                    case 6:
                                        return C.abrupt("return", l);
                                    case 7:
                                    case "end":
                                        return C.stop()
                                }
                            }, _callee3, this)
                        })), function(r) {
                            return eg.apply(this, arguments)
                        })
                    }, {
                        key: "unsubscribe",
                        value: (ey = (0, es.default)(eo.default.mark(function _callee4(r) {
                            var l;
                            return eo.default.wrap(function(C) {
                                for (;;) switch (C.prev = C.next) {
                                    case 0:
                                        return "string" == typeof r && (r = [r]), C.next = 3, this.call("rpc.off", r);
                                    case 3:
                                        if (l = C.sent, !("string" == typeof r && "ok" !== l[r])) {
                                            C.next = 6;
                                            break
                                        }
                                        throw Error("Failed unsubscribing from an event with: " + l);
                                    case 6:
                                        return C.abrupt("return", l);
                                    case 7:
                                    case "end":
                                        return C.stop()
                                }
                            }, _callee4, this)
                        })), function(r) {
                            return ey.apply(this, arguments)
                        })
                    }, {
                        key: "close",
                        value: function(r, l) {
                            this.socket.close(r || 1e3, l)
                        }
                    }, {
                        key: "_connect",
                        value: function(r, l) {
                            var C = this;
                            clearTimeout(this.reconnect_timer_id), this.socket = this.webSocketFactory(r, l), this.socket.addEventListener("open", function() {
                                C.ready = !0, C.emit("open"), C.current_reconnects = 0
                            }), this.socket.addEventListener("message", function(r) {
                                var l = r.data;
                                l instanceof ArrayBuffer && (l = U.from(l).toString());
                                try {
                                    l = JSON.parse(l)
                                } catch (r) {
                                    return
                                }
                                if (l.notification && C.listeners(l.notification).length) {
                                    if (!Object.keys(l.params).length) return C.emit(l.notification);
                                    var et = [l.notification];
                                    if (l.params.constructor === Object) et.push(l.params);
                                    else
                                        for (var eo = 0; eo < l.params.length; eo++) et.push(l.params[eo]);
                                    return Promise.resolve().then(function() {
                                        C.emit.apply(C, et)
                                    })
                                }
                                if (!C.queue[l.id]) return l.method && l.params ? Promise.resolve().then(function() {
                                    C.emit(l.method, l.params)
                                }) : void 0;
                                "error" in l == "result" in l && C.queue[l.id].promise[1](Error('Server response malformed. Response must include either "result" or "error", but not both.')), C.queue[l.id].timeout && clearTimeout(C.queue[l.id].timeout), l.error ? C.queue[l.id].promise[1](l.error) : C.queue[l.id].promise[0](l.result), delete C.queue[l.id]
                            }), this.socket.addEventListener("error", function(r) {
                                return C.emit("error", r)
                            }), this.socket.addEventListener("close", function(U) {
                                var et = U.code,
                                    eo = U.reason;
                                C.ready && setTimeout(function() {
                                    return C.emit("close", et, eo)
                                }, 0), C.ready = !1, C.socket = void 0, 1e3 !== et && (C.current_reconnects++, C.reconnect && (C.max_reconnects > C.current_reconnects || 0 === C.max_reconnects) && (C.reconnect_timer_id = setTimeout(function() {
                                    return C._connect(r, l)
                                }, C.reconnect_interval)))
                            })
                        }
                    }]), CommonClient
                }(eg.EventEmitter);
            l.default = ey
        },
        5576: function(r, l, C) {
            "use strict";
            var U = C(15350);
            Object.defineProperty(l, "__esModule", {
                value: !0
            }), l.default = function(r, l) {
                return new ed(r, l)
            };
            var et = U(C(83173)),
                eo = U(C(23826)),
                es = U(C(95600)),
                el = U(C(33499)),
                ec = U(C(69149)),
                ed = function(r) {
                    (0, es.default)(WebSocketBrowserImpl, r);
                    var l, C = (l = function() {
                        if ("undefined" == typeof Reflect || !Reflect.construct || Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), !0
                        } catch (r) {
                            return !1
                        }
                    }(), function() {
                        var r, C = (0, ec.default)(WebSocketBrowserImpl);
                        if (l) {
                            var U = (0, ec.default)(this).constructor;
                            r = Reflect.construct(C, arguments, U)
                        } else r = C.apply(this, arguments);
                        return (0, el.default)(this, r)
                    });

                    function WebSocketBrowserImpl(r, l, U) {
                        var eo;
                        return (0, et.default)(this, WebSocketBrowserImpl), (eo = C.call(this)).socket = new window.WebSocket(r, U), eo.socket.onopen = function() {
                            return eo.emit("open")
                        }, eo.socket.onmessage = function(r) {
                            return eo.emit("message", r.data)
                        }, eo.socket.onerror = function(r) {
                            return eo.emit("error", r)
                        }, eo.socket.onclose = function(r) {
                            eo.emit("close", r.code, r.reason)
                        }, eo
                    }
                    return (0, eo.default)(WebSocketBrowserImpl, [{
                        key: "send",
                        value: function(r, l, C) {
                            var U = C || l;
                            try {
                                this.socket.send(r), U()
                            } catch (r) {
                                U(r)
                            }
                        }
                    }, {
                        key: "close",
                        value: function(r, l) {
                            this.socket.close(r, l)
                        }
                    }, {
                        key: "addEventListener",
                        value: function(r, l, C) {
                            this.socket.addEventListener(r, l, C)
                        }
                    }]), WebSocketBrowserImpl
                }(C(83760).EventEmitter)
        },
        30915: function(r, l, C) {
            "use strict";
            var U, et = C(97115),
                eo = (U = C(71438)) && U.__esModule ? U : {
                    default: U
                },
                createHash = function(r) {
                    var l = r.allowedSizes,
                        C = r.defaultSize,
                        U = r.padding;
                    return function Hash() {
                        var r = this,
                            es = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : C;
                        if (!this || this.constructor !== Hash) return new Hash(es);
                        if (l && !l.includes(es)) throw Error("Unsupported hash length");
                        var el = new eo.default({
                            capacity: es
                        });
                        return this.update = function(l) {
                            var C = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "utf8";
                            if (et.Buffer.isBuffer(l)) return el.absorb(l), r;
                            if ("string" == typeof l) return r.update(et.Buffer.from(l, C));
                            throw TypeError("Not a string or buffer")
                        }, this.digest = function() {
                            var r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "binary",
                                l = "string" == typeof r ? {
                                    format: r
                                } : r,
                                C = el.squeeze({
                                    buffer: l.buffer,
                                    padding: l.padding || U
                                });
                            return l.format && "binary" !== l.format ? C.toString(l.format) : C
                        }, this.reset = function() {
                            return el.reset(), r
                        }, this
                    }
                },
                es = createHash({
                    allowedSizes: [224, 256, 384, 512],
                    defaultSize: 512,
                    padding: 1
                }),
                el = createHash({
                    allowedSizes: [224, 256, 384, 512],
                    defaultSize: 512,
                    padding: 6
                });
            createHash({
                allowedSizes: [128, 256],
                defaultSize: 256,
                padding: 31
            }), el.SHA3Hash = es
        },
        71438: function(r, l, C) {
            "use strict";
            Object.defineProperty(l, "__esModule", {
                value: !0
            }), l.default = void 0;
            var U, et = C(97115),
                eo = (U = C(57577)) && U.__esModule ? U : {
                    default: U
                },
                xorWords = function(r, l) {
                    for (var C = 0; C < r.length; C += 8) {
                        var U = C / 4;
                        l[U] ^= r[C + 7] << 24 | r[C + 6] << 16 | r[C + 5] << 8 | r[C + 4], l[U + 1] ^= r[C + 3] << 24 | r[C + 2] << 16 | r[C + 1] << 8 | r[C]
                    }
                    return l
                },
                readWords = function(r, l) {
                    for (var C = 0; C < l.length; C += 8) {
                        var U = C / 4;
                        l[C] = r[U + 1], l[C + 1] = r[U + 1] >>> 8, l[C + 2] = r[U + 1] >>> 16, l[C + 3] = r[U + 1] >>> 24, l[C + 4] = r[U], l[C + 5] = r[U] >>> 8, l[C + 6] = r[U] >>> 16, l[C + 7] = r[U] >>> 24
                    }
                    return l
                };
            l.default = function(r) {
                var l = this,
                    C = r.capacity,
                    U = r.padding,
                    es = (0, eo.default)(),
                    el = C / 8,
                    ec = 200 - C / 4,
                    ed = 0,
                    eh = new Uint32Array(50),
                    ef = et.Buffer.allocUnsafe(ec);
                return this.absorb = function(r) {
                    for (var C = 0; C < r.length; C++) ef[ed] = r[C], (ed += 1) >= ec && (xorWords(ef, eh), es(eh), ed = 0);
                    return l
                }, this.squeeze = function() {
                    var r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                        l = {
                            buffer: r.buffer || et.Buffer.allocUnsafe(el),
                            padding: r.padding || U,
                            queue: et.Buffer.allocUnsafe(ef.length),
                            state: new Uint32Array(eh.length)
                        };
                    ef.copy(l.queue);
                    for (var C = 0; C < eh.length; C++) l.state[C] = eh[C];
                    l.queue.fill(0, ed), l.queue[ed] |= l.padding, l.queue[ec - 1] |= 128, xorWords(l.queue, l.state);
                    for (var eo = 0; eo < l.buffer.length; eo += ec) es(l.state), readWords(l.state, l.buffer.slice(eo, eo + ec));
                    return l.buffer
                }, this.reset = function() {
                    return ef.fill(0), eh.fill(0), ed = 0, l
                }, this
            }
        },
        6668: function(r, l, C) {
            "use strict";
            Object.defineProperty(l, "__esModule", {
                value: !0
            }), l.default = void 0;
            var U, et = (U = C(18205)) && U.__esModule ? U : {
                default: U
            };
            l.default = function(r) {
                for (var l = r.A, C = r.C, U = 0; U < 25; U += 5) {
                    for (var eo = 0; eo < 5; eo++)(0, et.default)(l, U + eo)(C, eo);
                    for (var es = 0; es < 5; es++) {
                        var el = (U + es) * 2,
                            ec = (es + 1) % 5 * 2,
                            ed = (es + 2) % 5 * 2;
                        l[el] ^= ~C[ec] & C[ed], l[el + 1] ^= ~C[ec + 1] & C[ed + 1]
                    }
                }
            }
        },
        18205: function(r) {
            "use strict";
            r.exports = function(r, l) {
                return function(C, U) {
                    var et = 2 * U,
                        eo = 2 * l;
                    C[et] = r[eo], C[et + 1] = r[eo + 1]
                }
            }
        },
        57577: function(r, l, C) {
            "use strict";
            Object.defineProperty(l, "__esModule", {
                value: !0
            }), l.default = void 0;
            var U = _interopRequireDefault(C(6668)),
                et = _interopRequireDefault(C(78153)),
                eo = _interopRequireDefault(C(38167)),
                es = _interopRequireDefault(C(88446));

            function _interopRequireDefault(r) {
                return r && r.__esModule ? r : {
                    default: r
                }
            }
            l.default = function() {
                var r = new Uint32Array(10),
                    l = new Uint32Array(10),
                    C = new Uint32Array(2);
                return function(el) {
                    for (var ec = 0; ec < 24; ec++)(0, es.default)({
                        A: el,
                        C: r,
                        D: l,
                        W: C
                    }), (0, eo.default)({
                        A: el,
                        C: r,
                        W: C
                    }), (0, U.default)({
                        A: el,
                        C: r
                    }), (0, et.default)({
                        A: el,
                        roundIndex: ec
                    });
                    r.fill(0), l.fill(0), C.fill(0)
                }
            }
        },
        78153: function(r, l, C) {
            "use strict";
            Object.defineProperty(l, "__esModule", {
                value: !0
            }), l.default = void 0;
            var U, et = (U = C(60995)) && U.__esModule ? U : {
                default: U
            };
            l.default = function(r) {
                var l = r.A,
                    C = 2 * r.roundIndex;
                l[0] ^= et.default[C], l[1] ^= et.default[C + 1]
            }
        },
        60995: function(r, l) {
            "use strict";
            Object.defineProperty(l, "__esModule", {
                value: !0
            }), l.default = void 0;
            var C = new Uint32Array([0, 1, 0, 32898, 2147483648, 32906, 2147483648, 2147516416, 0, 32907, 0, 2147483649, 2147483648, 2147516545, 2147483648, 32777, 0, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 2147483648, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 0, 32778, 2147483648, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 0, 2147483649, 2147483648, 2147516424]);
            l.default = C
        },
        38167: function(r, l, C) {
            "use strict";
            Object.defineProperty(l, "__esModule", {
                value: !0
            }), l.default = void 0;
            var U = _interopRequireDefault(C(35954)),
                et = _interopRequireDefault(C(75218)),
                eo = _interopRequireDefault(C(18205));

            function _interopRequireDefault(r) {
                return r && r.__esModule ? r : {
                    default: r
                }
            }
            l.default = function(r) {
                var l = r.A,
                    C = r.C,
                    es = r.W;
                (0, eo.default)(l, 1)(es, 0);
                for (var el = 0, ec = 0, ed = 0, eh = 32, ef = 0; ef < 24; ef++) {
                    var ep = U.default[ef],
                        eg = et.default[ef];
                    (0, eo.default)(l, ep)(C, 0), el = es[0], ec = es[1], eh = 32 - eg, es[ed = eg < 32 ? 0 : 1] = el << eg | ec >>> eh, es[(ed + 1) % 2] = ec << eg | el >>> eh, (0, eo.default)(es, 0)(l, ep), (0, eo.default)(C, 0)(es, 0)
                }
            }
        },
        35954: function(r, l) {
            "use strict";
            Object.defineProperty(l, "__esModule", {
                value: !0
            }), l.default = void 0, l.default = [10, 7, 11, 17, 18, 3, 5, 16, 8, 21, 24, 4, 15, 23, 19, 13, 12, 2, 20, 14, 22, 9, 6, 1]
        },
        75218: function(r, l) {
            "use strict";
            Object.defineProperty(l, "__esModule", {
                value: !0
            }), l.default = void 0, l.default = [1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 2, 14, 27, 41, 56, 8, 25, 43, 62, 18, 39, 61, 20, 44]
        },
        88446: function(r, l, C) {
            "use strict";
            Object.defineProperty(l, "__esModule", {
                value: !0
            }), l.default = void 0;
            var U, et = (U = C(18205)) && U.__esModule ? U : {
                default: U
            };
            l.default = function(r) {
                for (var l = r.A, C = r.C, U = r.D, eo = r.W, es = 0, el = 0, ec = 0; ec < 5; ec++) {
                    var ed = 2 * ec,
                        eh = (ec + 5) * 2,
                        ef = (ec + 10) * 2,
                        ep = (ec + 15) * 2,
                        eg = (ec + 20) * 2;
                    C[ed] = l[ed] ^ l[eh] ^ l[ef] ^ l[ep] ^ l[eg], C[ed + 1] = l[ed + 1] ^ l[eh + 1] ^ l[ef + 1] ^ l[ep + 1] ^ l[eg + 1]
                }
                for (var ey = 0; ey < 5; ey++) {
                    (0, et.default)(C, (ey + 1) % 5)(eo, 0), es = eo[0], el = eo[1], eo[0] = es << 1 | el >>> 31, eo[1] = el << 1 | es >>> 31, U[2 * ey] = C[(ey + 4) % 5 * 2] ^ eo[0], U[2 * ey + 1] = C[(ey + 4) % 5 * 2 + 1] ^ eo[1];
                    for (var em = 0; em < 25; em += 5) l[(em + ey) * 2] ^= U[2 * ey], l[(em + ey) * 2 + 1] ^= U[2 * ey + 1]
                }
            }
        },
        39513: function(r, l, C) {
            "use strict";
            C.d(l, {
                F_: function() {
                    return useDeepCompareEffectNoCheck
                }
            });
            var U = C(97352),
                et = Object.prototype.hasOwnProperty;

            function find(r, l, C) {
                for (C of r.keys())
                    if (dequal(C, l)) return C
            }

            function dequal(r, l) {
                var C, U, eo;
                if (r === l) return !0;
                if (r && l && (C = r.constructor) === l.constructor) {
                    if (C === Date) return r.getTime() === l.getTime();
                    if (C === RegExp) return r.toString() === l.toString();
                    if (C === Array) {
                        if ((U = r.length) === l.length)
                            for (; U-- && dequal(r[U], l[U]););
                        return -1 === U
                    }
                    if (C === Set) {
                        if (r.size !== l.size) return !1;
                        for (U of r)
                            if ((eo = U) && "object" == typeof eo && !(eo = find(l, eo)) || !l.has(eo)) return !1;
                        return !0
                    }
                    if (C === Map) {
                        if (r.size !== l.size) return !1;
                        for (U of r)
                            if ((eo = U[0]) && "object" == typeof eo && !(eo = find(l, eo)) || !dequal(U[1], l.get(eo))) return !1;
                        return !0
                    }
                    if (C === ArrayBuffer) r = new Uint8Array(r), l = new Uint8Array(l);
                    else if (C === DataView) {
                        if ((U = r.byteLength) === l.byteLength)
                            for (; U-- && r.getInt8(U) === l.getInt8(U););
                        return -1 === U
                    }
                    if (ArrayBuffer.isView(r)) {
                        if ((U = r.byteLength) === l.byteLength)
                            for (; U-- && r[U] === l[U];);
                        return -1 === U
                    }
                    if (!C || "object" == typeof r) {
                        for (C in U = 0, r)
                            if (et.call(r, C) && ++U && !et.call(l, C) || !(C in l) || !dequal(r[C], l[C])) return !1;
                        return Object.keys(l).length === U
                    }
                }
                return r != r && l != l
            }

            function useDeepCompareEffectNoCheck(r, l) {
                var C, et;
                return U.useEffect(r, (C = U.useRef(l), et = U.useRef(0), dequal(l, C.current) || (C.current = l, et.current += 1), U.useMemo(function() {
                    return C.current
                }, [et.current])))
            }
        },
        85217: function(r) {
            "use strict";
            r.exports = function() {
                throw Error("ws does not work in the browser. Browser clients must use the native WebSocket object")
            }
        },
        51588: function(r) {
            r.exports = function(r) {
                if (void 0 === r) throw ReferenceError("this hasn't been initialised - super() hasn't been called");
                return r
            }, r.exports.__esModule = !0, r.exports.default = r.exports
        },
        55320: function(r) {
            function asyncGeneratorStep(r, l, C, U, et, eo, es) {
                try {
                    var el = r[eo](es),
                        ec = el.value
                } catch (r) {
                    C(r);
                    return
                }
                el.done ? l(ec) : Promise.resolve(ec).then(U, et)
            }
            r.exports = function(r) {
                return function() {
                    var l = this,
                        C = arguments;
                    return new Promise(function(U, et) {
                        var eo = r.apply(l, C);

                        function _next(r) {
                            asyncGeneratorStep(eo, U, et, _next, _throw, "next", r)
                        }

                        function _throw(r) {
                            asyncGeneratorStep(eo, U, et, _next, _throw, "throw", r)
                        }
                        _next(void 0)
                    })
                }
            }, r.exports.__esModule = !0, r.exports.default = r.exports
        },
        83173: function(r) {
            r.exports = function(r, l) {
                if (!(r instanceof l)) throw TypeError("Cannot call a class as a function")
            }, r.exports.__esModule = !0, r.exports.default = r.exports
        },
        23826: function(r, l, C) {
            var U = C(68021);

            function _defineProperties(r, l) {
                for (var C = 0; C < l.length; C++) {
                    var et = l[C];
                    et.enumerable = et.enumerable || !1, et.configurable = !0, "value" in et && (et.writable = !0), Object.defineProperty(r, U(et.key), et)
                }
            }
            r.exports = function(r, l, C) {
                return l && _defineProperties(r.prototype, l), C && _defineProperties(r, C), Object.defineProperty(r, "prototype", {
                    writable: !1
                }), r
            }, r.exports.__esModule = !0, r.exports.default = r.exports
        },
        69149: function(r) {
            function _getPrototypeOf(l) {
                return r.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
                    return r.__proto__ || Object.getPrototypeOf(r)
                }, r.exports.__esModule = !0, r.exports.default = r.exports, _getPrototypeOf(l)
            }
            r.exports = _getPrototypeOf, r.exports.__esModule = !0, r.exports.default = r.exports
        },
        95600: function(r, l, C) {
            var U = C(51721);
            r.exports = function(r, l) {
                if ("function" != typeof l && null !== l) throw TypeError("Super expression must either be null or a function");
                r.prototype = Object.create(l && l.prototype, {
                    constructor: {
                        value: r,
                        writable: !0,
                        configurable: !0
                    }
                }), Object.defineProperty(r, "prototype", {
                    writable: !1
                }), l && U(r, l)
            }, r.exports.__esModule = !0, r.exports.default = r.exports
        },
        15350: function(r) {
            r.exports = function(r) {
                return r && r.__esModule ? r : {
                    default: r
                }
            }, r.exports.__esModule = !0, r.exports.default = r.exports
        },
        33499: function(r, l, C) {
            var U = C(80443).default,
                et = C(51588);
            r.exports = function(r, l) {
                if (l && ("object" === U(l) || "function" == typeof l)) return l;
                if (void 0 !== l) throw TypeError("Derived constructors may only return object or undefined");
                return et(r)
            }, r.exports.__esModule = !0, r.exports.default = r.exports
        },
        5051: function(r, l, C) {
            var U = C(80443).default;

            function _regeneratorRuntime() {
                "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
                r.exports = _regeneratorRuntime = function() {
                    return C
                }, r.exports.__esModule = !0, r.exports.default = r.exports;
                var l, C = {},
                    et = Object.prototype,
                    eo = et.hasOwnProperty,
                    es = Object.defineProperty || function(r, l, C) {
                        r[l] = C.value
                    },
                    el = "function" == typeof Symbol ? Symbol : {},
                    ec = el.iterator || "@@iterator",
                    ed = el.asyncIterator || "@@asyncIterator",
                    eh = el.toStringTag || "@@toStringTag";

                function define(r, l, C) {
                    return Object.defineProperty(r, l, {
                        value: C,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }), r[l]
                }
                try {
                    define({}, "")
                } catch (r) {
                    define = function(r, l, C) {
                        return r[l] = C
                    }
                }

                function wrap(r, C, U, et) {
                    var eo, el, ec = Object.create((C && C.prototype instanceof Generator ? C : Generator).prototype);
                    return es(ec, "_invoke", {
                        value: (eo = new Context(et || []), el = ef, function(C, et) {
                            if (el === ep) throw Error("Generator is already running");
                            if (el === eg) {
                                if ("throw" === C) throw et;
                                return {
                                    value: l,
                                    done: !0
                                }
                            }
                            for (eo.method = C, eo.arg = et;;) {
                                var es = eo.delegate;
                                if (es) {
                                    var ec = function maybeInvokeDelegate(r, C) {
                                        var U = C.method,
                                            et = r.iterator[U];
                                        if (et === l) return C.delegate = null, "throw" === U && r.iterator.return && (C.method = "return", C.arg = l, maybeInvokeDelegate(r, C), "throw" === C.method) || "return" !== U && (C.method = "throw", C.arg = TypeError("The iterator does not provide a '" + U + "' method")), ey;
                                        var eo = tryCatch(et, r.iterator, C.arg);
                                        if ("throw" === eo.type) return C.method = "throw", C.arg = eo.arg, C.delegate = null, ey;
                                        var es = eo.arg;
                                        return es ? es.done ? (C[r.resultName] = es.value, C.next = r.nextLoc, "return" !== C.method && (C.method = "next", C.arg = l), C.delegate = null, ey) : es : (C.method = "throw", C.arg = TypeError("iterator result is not an object"), C.delegate = null, ey)
                                    }(es, eo);
                                    if (ec) {
                                        if (ec === ey) continue;
                                        return ec
                                    }
                                }
                                if ("next" === eo.method) eo.sent = eo._sent = eo.arg;
                                else if ("throw" === eo.method) {
                                    if (el === ef) throw el = eg, eo.arg;
                                    eo.dispatchException(eo.arg)
                                } else "return" === eo.method && eo.abrupt("return", eo.arg);
                                el = ep;
                                var ed = tryCatch(r, U, eo);
                                if ("normal" === ed.type) {
                                    if (el = eo.done ? eg : "suspendedYield", ed.arg === ey) continue;
                                    return {
                                        value: ed.arg,
                                        done: eo.done
                                    }
                                }
                                "throw" === ed.type && (el = eg, eo.method = "throw", eo.arg = ed.arg)
                            }
                        })
                    }), ec
                }

                function tryCatch(r, l, C) {
                    try {
                        return {
                            type: "normal",
                            arg: r.call(l, C)
                        }
                    } catch (r) {
                        return {
                            type: "throw",
                            arg: r
                        }
                    }
                }
                C.wrap = wrap;
                var ef = "suspendedStart",
                    ep = "executing",
                    eg = "completed",
                    ey = {};

                function Generator() {}

                function GeneratorFunction() {}

                function GeneratorFunctionPrototype() {}
                var em = {};
                define(em, ec, function() {
                    return this
                });
                var e_ = Object.getPrototypeOf,
                    eb = e_ && e_(e_(values([])));
                eb && eb !== et && eo.call(eb, ec) && (em = eb);
                var ew = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(em);

                function defineIteratorMethods(r) {
                    ["next", "throw", "return"].forEach(function(l) {
                        define(r, l, function(r) {
                            return this._invoke(l, r)
                        })
                    })
                }

                function AsyncIterator(r, l) {
                    var C;
                    es(this, "_invoke", {
                        value: function(et, es) {
                            function callInvokeWithMethodAndArg() {
                                return new l(function(C, el) {
                                    ! function invoke(C, et, es, el) {
                                        var ec = tryCatch(r[C], r, et);
                                        if ("throw" !== ec.type) {
                                            var ed = ec.arg,
                                                eh = ed.value;
                                            return eh && "object" == U(eh) && eo.call(eh, "__await") ? l.resolve(eh.__await).then(function(r) {
                                                invoke("next", r, es, el)
                                            }, function(r) {
                                                invoke("throw", r, es, el)
                                            }) : l.resolve(eh).then(function(r) {
                                                ed.value = r, es(ed)
                                            }, function(r) {
                                                return invoke("throw", r, es, el)
                                            })
                                        }
                                        el(ec.arg)
                                    }(et, es, C, el)
                                })
                            }
                            return C = C ? C.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg()
                        }
                    })
                }

                function pushTryEntry(r) {
                    var l = {
                        tryLoc: r[0]
                    };
                    1 in r && (l.catchLoc = r[1]), 2 in r && (l.finallyLoc = r[2], l.afterLoc = r[3]), this.tryEntries.push(l)
                }

                function resetTryEntry(r) {
                    var l = r.completion || {};
                    l.type = "normal", delete l.arg, r.completion = l
                }

                function Context(r) {
                    this.tryEntries = [{
                        tryLoc: "root"
                    }], r.forEach(pushTryEntry, this), this.reset(!0)
                }

                function values(r) {
                    if (r || "" === r) {
                        var C = r[ec];
                        if (C) return C.call(r);
                        if ("function" == typeof r.next) return r;
                        if (!isNaN(r.length)) {
                            var et = -1,
                                i = function next() {
                                    for (; ++et < r.length;)
                                        if (eo.call(r, et)) return next.value = r[et], next.done = !1, next;
                                    return next.value = l, next.done = !0, next
                                };
                            return i.next = i
                        }
                    }
                    throw TypeError(U(r) + " is not iterable")
                }
                return GeneratorFunction.prototype = GeneratorFunctionPrototype, es(ew, "constructor", {
                    value: GeneratorFunctionPrototype,
                    configurable: !0
                }), es(GeneratorFunctionPrototype, "constructor", {
                    value: GeneratorFunction,
                    configurable: !0
                }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, eh, "GeneratorFunction"), C.isGeneratorFunction = function(r) {
                    var l = "function" == typeof r && r.constructor;
                    return !!l && (l === GeneratorFunction || "GeneratorFunction" === (l.displayName || l.name))
                }, C.mark = function(r) {
                    return Object.setPrototypeOf ? Object.setPrototypeOf(r, GeneratorFunctionPrototype) : (r.__proto__ = GeneratorFunctionPrototype, define(r, eh, "GeneratorFunction")), r.prototype = Object.create(ew), r
                }, C.awrap = function(r) {
                    return {
                        __await: r
                    }
                }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, ed, function() {
                    return this
                }), C.AsyncIterator = AsyncIterator, C.async = function(r, l, U, et, eo) {
                    void 0 === eo && (eo = Promise);
                    var es = new AsyncIterator(wrap(r, l, U, et), eo);
                    return C.isGeneratorFunction(l) ? es : es.next().then(function(r) {
                        return r.done ? r.value : es.next()
                    })
                }, defineIteratorMethods(ew), define(ew, eh, "Generator"), define(ew, ec, function() {
                    return this
                }), define(ew, "toString", function() {
                    return "[object Generator]"
                }), C.keys = function(r) {
                    var l = Object(r),
                        C = [];
                    for (var U in l) C.push(U);
                    return C.reverse(),
                        function next() {
                            for (; C.length;) {
                                var r = C.pop();
                                if (r in l) return next.value = r, next.done = !1, next
                            }
                            return next.done = !0, next
                        }
                }, C.values = values, Context.prototype = {
                    constructor: Context,
                    reset: function(r) {
                        if (this.prev = 0, this.next = 0, this.sent = this._sent = l, this.done = !1, this.delegate = null, this.method = "next", this.arg = l, this.tryEntries.forEach(resetTryEntry), !r)
                            for (var C in this) "t" === C.charAt(0) && eo.call(this, C) && !isNaN(+C.slice(1)) && (this[C] = l)
                    },
                    stop: function() {
                        this.done = !0;
                        var r = this.tryEntries[0].completion;
                        if ("throw" === r.type) throw r.arg;
                        return this.rval
                    },
                    dispatchException: function(r) {
                        if (this.done) throw r;
                        var C = this;

                        function handle(U, et) {
                            return es.type = "throw", es.arg = r, C.next = U, et && (C.method = "next", C.arg = l), !!et
                        }
                        for (var U = this.tryEntries.length - 1; U >= 0; --U) {
                            var et = this.tryEntries[U],
                                es = et.completion;
                            if ("root" === et.tryLoc) return handle("end");
                            if (et.tryLoc <= this.prev) {
                                var el = eo.call(et, "catchLoc"),
                                    ec = eo.call(et, "finallyLoc");
                                if (el && ec) {
                                    if (this.prev < et.catchLoc) return handle(et.catchLoc, !0);
                                    if (this.prev < et.finallyLoc) return handle(et.finallyLoc)
                                } else if (el) {
                                    if (this.prev < et.catchLoc) return handle(et.catchLoc, !0)
                                } else {
                                    if (!ec) throw Error("try statement without catch or finally");
                                    if (this.prev < et.finallyLoc) return handle(et.finallyLoc)
                                }
                            }
                        }
                    },
                    abrupt: function(r, l) {
                        for (var C = this.tryEntries.length - 1; C >= 0; --C) {
                            var U = this.tryEntries[C];
                            if (U.tryLoc <= this.prev && eo.call(U, "finallyLoc") && this.prev < U.finallyLoc) {
                                var et = U;
                                break
                            }
                        }
                        et && ("break" === r || "continue" === r) && et.tryLoc <= l && l <= et.finallyLoc && (et = null);
                        var es = et ? et.completion : {};
                        return es.type = r, es.arg = l, et ? (this.method = "next", this.next = et.finallyLoc, ey) : this.complete(es)
                    },
                    complete: function(r, l) {
                        if ("throw" === r.type) throw r.arg;
                        return "break" === r.type || "continue" === r.type ? this.next = r.arg : "return" === r.type ? (this.rval = this.arg = r.arg, this.method = "return", this.next = "end") : "normal" === r.type && l && (this.next = l), ey
                    },
                    finish: function(r) {
                        for (var l = this.tryEntries.length - 1; l >= 0; --l) {
                            var C = this.tryEntries[l];
                            if (C.finallyLoc === r) return this.complete(C.completion, C.afterLoc), resetTryEntry(C), ey
                        }
                    },
                    catch: function(r) {
                        for (var l = this.tryEntries.length - 1; l >= 0; --l) {
                            var C = this.tryEntries[l];
                            if (C.tryLoc === r) {
                                var U = C.completion;
                                if ("throw" === U.type) {
                                    var et = U.arg;
                                    resetTryEntry(C)
                                }
                                return et
                            }
                        }
                        throw Error("illegal catch attempt")
                    },
                    delegateYield: function(r, C, U) {
                        return this.delegate = {
                            iterator: values(r),
                            resultName: C,
                            nextLoc: U
                        }, "next" === this.method && (this.arg = l), ey
                    }
                }, C
            }
            r.exports = _regeneratorRuntime, r.exports.__esModule = !0, r.exports.default = r.exports
        },
        51721: function(r) {
            function _setPrototypeOf(l, C) {
                return r.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, l) {
                    return r.__proto__ = l, r
                }, r.exports.__esModule = !0, r.exports.default = r.exports, _setPrototypeOf(l, C)
            }
            r.exports = _setPrototypeOf, r.exports.__esModule = !0, r.exports.default = r.exports
        },
        41376: function(r, l, C) {
            var U = C(80443).default;
            r.exports = function(r, l) {
                if ("object" != U(r) || !r) return r;
                var C = r[Symbol.toPrimitive];
                if (void 0 !== C) {
                    var et = C.call(r, l || "default");
                    if ("object" != U(et)) return et;
                    throw TypeError("@@toPrimitive must return a primitive value.")
                }
                return ("string" === l ? String : Number)(r)
            }, r.exports.__esModule = !0, r.exports.default = r.exports
        },
        68021: function(r, l, C) {
            var U = C(80443).default,
                et = C(41376);
            r.exports = function(r) {
                var l = et(r, "string");
                return "symbol" == U(l) ? l : String(l)
            }, r.exports.__esModule = !0, r.exports.default = r.exports
        },
        80443: function(r) {
            function _typeof(l) {
                return r.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(r) {
                    return typeof r
                } : function(r) {
                    return r && "function" == typeof Symbol && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r
                }, r.exports.__esModule = !0, r.exports.default = r.exports, _typeof(l)
            }
            r.exports = _typeof, r.exports.__esModule = !0, r.exports.default = r.exports
        },
        89052: function(r, l, C) {
            var U = C(5051)();
            r.exports = U;
            try {
                regeneratorRuntime = U
            } catch (r) {
                "object" == typeof globalThis ? globalThis.regeneratorRuntime = U : Function("r", "regeneratorRuntime = r")(U)
            }
        },
        42878: function(r, l, C) {
            "use strict";
            let U = C(17968);
            r.exports = pino;
            let et = function() {
                function defd(r) {
                    return void 0 !== r && r
                }
                try {
                    if ("undefined" != typeof globalThis) return globalThis;
                    return Object.defineProperty(Object.prototype, "globalThis", {
                        get: function() {
                            return delete Object.prototype.globalThis, this.globalThis = this
                        },
                        configurable: !0
                    }), globalThis
                } catch (r) {
                    return defd(self) || defd(window) || defd(this) || {}
                }
            }().console || {};

            function pino(r) {
                var l;
                (r = r || {}).browser = r.browser || {};
                let C = r.browser.transmit;
                if (C && "function" != typeof C.send) throw Error("pino: transmit option must have a send function");
                let U = r.browser.write || et;
                r.browser.write && (r.browser.asObject = !0);
                let eo = r.serializers || {},
                    es = function(r, l) {
                        if (Array.isArray(r)) {
                            let l = r.filter(function(r) {
                                return "!stdSerializers.err" !== r
                            });
                            return l
                        }
                        return !0 === r && Object.keys(l)
                    }(r.browser.serialize, eo),
                    el = r.browser.serialize;
                Array.isArray(r.browser.serialize) && r.browser.serialize.indexOf("!stdSerializers.err") > -1 && (el = !1), "function" == typeof U && (U.error = U.fatal = U.warn = U.info = U.debug = U.trace = U), !1 === r.enabled && (r.level = "silent");
                let ec = r.level || "info",
                    ed = Object.create(U);
                ed.log || (ed.log = noop), Object.defineProperty(ed, "levelVal", {
                    get: function() {
                        return "silent" === this.level ? 1 / 0 : this.levels.values[this.level]
                    }
                }), Object.defineProperty(ed, "level", {
                    get: function() {
                        return this._level
                    },
                    set: function(r) {
                        if ("silent" !== r && !this.levels.values[r]) throw Error("unknown level " + r);
                        this._level = r, set(eh, ed, "error", "log"), set(eh, ed, "fatal", "error"), set(eh, ed, "warn", "error"), set(eh, ed, "info", "log"), set(eh, ed, "debug", "log"), set(eh, ed, "trace", "log")
                    }
                });
                let eh = {
                    transmit: C,
                    serialize: es,
                    asObject: r.browser.asObject,
                    levels: ["error", "fatal", "warn", "info", "debug", "trace"],
                    timestamp: "function" == typeof(l = r).timestamp ? l.timestamp : !1 === l.timestamp ? nullTime : epochTime
                };
                return ed.levels = pino.levels, ed.level = ec, ed.setMaxListeners = ed.getMaxListeners = ed.emit = ed.addListener = ed.on = ed.prependListener = ed.once = ed.prependOnceListener = ed.removeListener = ed.removeAllListeners = ed.listeners = ed.listenerCount = ed.eventNames = ed.write = ed.flush = noop, ed.serializers = eo, ed._serialize = es, ed._stdErrSerialize = el, ed.child = function(l, U) {
                    if (!l) throw Error("missing bindings for child Pino");
                    U = U || {}, es && l.serializers && (U.serializers = l.serializers);
                    let et = U.serializers;
                    if (es && et) {
                        var el = Object.assign({}, eo, et),
                            ec = !0 === r.browser.serialize ? Object.keys(el) : es;
                        delete l.serializers, applySerializers([l], ec, el, this._stdErrSerialize)
                    }

                    function Child(r) {
                        this._childLevel = (0 | r._childLevel) + 1, this.error = bind(r, l, "error"), this.fatal = bind(r, l, "fatal"), this.warn = bind(r, l, "warn"), this.info = bind(r, l, "info"), this.debug = bind(r, l, "debug"), this.trace = bind(r, l, "trace"), el && (this.serializers = el, this._serialize = ec), C && (this._logEvent = createLogEventShape([].concat(r._logEvent.bindings, l)))
                    }
                    return Child.prototype = this, new Child(this)
                }, C && (ed._logEvent = createLogEventShape()), ed
            }

            function set(r, l, C, eo) {
                let es = Object.getPrototypeOf(l);
                l[C] = l.levelVal > l.levels.values[C] ? noop : es[C] ? es[C] : et[C] || et[eo] || noop,
                    function(r, l, C) {
                        if (r.transmit || l[C] !== noop) {
                            var eo;
                            l[C] = (eo = l[C], function() {
                                let es = r.timestamp(),
                                    el = Array(arguments.length),
                                    ec = Object.getPrototypeOf && Object.getPrototypeOf(this) === et ? et : this;
                                for (var ed = 0; ed < el.length; ed++) el[ed] = arguments[ed];
                                if (r.serialize && !r.asObject && applySerializers(el, this._serialize, this.serializers, this._stdErrSerialize), r.asObject ? eo.call(ec, function(r, l, C, et) {
                                        r._serialize && applySerializers(C, r._serialize, r.serializers, r._stdErrSerialize);
                                        let eo = C.slice(),
                                            es = eo[0],
                                            el = {};
                                        et && (el.time = et), el.level = pino.levels.values[l];
                                        let ec = (0 | r._childLevel) + 1;
                                        if (ec < 1 && (ec = 1), null !== es && "object" == typeof es) {
                                            for (; ec-- && "object" == typeof eo[0];) Object.assign(el, eo.shift());
                                            es = eo.length ? U(eo.shift(), eo) : void 0
                                        } else "string" == typeof es && (es = U(eo.shift(), eo));
                                        return void 0 !== es && (el.msg = es), el
                                    }(this, C, el, es)) : eo.apply(ec, el), r.transmit) {
                                    let U = r.transmit.level || l.level,
                                        et = pino.levels.values[U],
                                        eo = pino.levels.values[C];
                                    if (eo < et) return;
                                    (function(r, l, C) {
                                        let U = l.send,
                                            et = l.ts,
                                            eo = l.methodLevel,
                                            es = l.methodValue,
                                            el = l.val,
                                            ec = r._logEvent.bindings;
                                        applySerializers(C, r._serialize || Object.keys(r.serializers), r.serializers, void 0 === r._stdErrSerialize || r._stdErrSerialize), r._logEvent.ts = et, r._logEvent.messages = C.filter(function(r) {
                                            return -1 === ec.indexOf(r)
                                        }), r._logEvent.level.label = eo, r._logEvent.level.value = es, U(eo, r._logEvent, el), r._logEvent = createLogEventShape(ec)
                                    })(this, {
                                        ts: es,
                                        methodLevel: C,
                                        methodValue: eo,
                                        transmitLevel: U,
                                        transmitValue: pino.levels.values[r.transmit.level || l.level],
                                        send: r.transmit.send,
                                        val: l.levelVal
                                    }, el)
                                }
                            })
                        }
                    }(r, l, C)
            }

            function applySerializers(r, l, C, U) {
                for (let et in r)
                    if (U && r[et] instanceof Error) r[et] = pino.stdSerializers.err(r[et]);
                    else if ("object" == typeof r[et] && !Array.isArray(r[et]))
                    for (let U in r[et]) l && l.indexOf(U) > -1 && U in C && (r[et][U] = C[U](r[et][U]))
            }

            function bind(r, l, C) {
                return function() {
                    let U = Array(1 + arguments.length);
                    U[0] = l;
                    for (var et = 1; et < U.length; et++) U[et] = arguments[et - 1];
                    return r[C].apply(this, U)
                }
            }

            function createLogEventShape(r) {
                return {
                    ts: 0,
                    messages: [],
                    bindings: r || [],
                    level: {
                        label: "",
                        value: 0
                    }
                }
            }

            function mock() {
                return {}
            }

            function passthrough(r) {
                return r
            }

            function noop() {}

            function nullTime() {
                return !1
            }

            function epochTime() {
                return Date.now()
            }
            pino.levels = {
                values: {
                    fatal: 60,
                    error: 50,
                    warn: 40,
                    info: 30,
                    debug: 20,
                    trace: 10
                },
                labels: {
                    10: "trace",
                    20: "debug",
                    30: "info",
                    40: "warn",
                    50: "error",
                    60: "fatal"
                }
            }, pino.stdSerializers = {
                mapHttpRequest: mock,
                mapHttpResponse: mock,
                wrapRequestSerializer: passthrough,
                wrapResponseSerializer: passthrough,
                wrapErrorSerializer: passthrough,
                req: mock,
                res: mock,
                err: function(r) {
                    let l = {
                        type: r.constructor.name,
                        msg: r.message,
                        stack: r.stack
                    };
                    for (let C in r) void 0 === l[C] && (l[C] = r[C]);
                    return l
                }
            }, pino.stdTimeFunctions = Object.assign({}, {
                nullTime,
                epochTime,
                unixTime: function() {
                    return Math.round(Date.now() / 1e3)
                },
                isoTime: function() {
                    return new Date(Date.now()).toISOString()
                }
            })
        },
        37320: function(r, l, C) {
            "use strict";
            C.d(l, {
                f: function() {
                    return ec
                }
            });
            var U = C(84477),
                et = C(97352),
                eo = C(64353),
                es = C(26815);
            let el = (0, et.forwardRef)((r, l) => {
                    var C;
                    let {
                        container: el = null == globalThis ? void 0 : null === (C = globalThis.document) || void 0 === C ? void 0 : C.body,
                        ...ec
                    } = r;
                    return el ? eo.createPortal((0, et.createElement)(es.WV.div, (0, U.Z)({}, ec, {
                        ref: l
                    })), el) : null
                }),
                ec = el
        },
        62220: function(r, l, C) {
            "use strict";
            let U, et, eo;
            C.d(l, {
                Eh: function() {
                    return EthereumWalletConnectors
                }
            });
            var es, el, ec = {};
            C.r(ec), C.d(ec, {
                identity: function() {
                    return t2
                }
            });
            var ed = {};
            C.r(ed), C.d(ed, {
                base2: function() {
                    return t3
                }
            });
            var eh = {};
            C.r(eh), C.d(eh, {
                base8: function() {
                    return t5
                }
            });
            var ef = {};
            C.r(ef), C.d(ef, {
                base10: function() {
                    return t6
                }
            });
            var ep = {};
            C.r(ep), C.d(ep, {
                base16: function() {
                    return t8
                },
                base16upper: function() {
                    return t4
                }
            });
            var eg = {};
            C.r(eg), C.d(eg, {
                base32: function() {
                    return t9
                },
                base32hex: function() {
                    return ra
                },
                base32hexpad: function() {
                    return rc
                },
                base32hexpadupper: function() {
                    return rd
                },
                base32hexupper: function() {
                    return rl
                },
                base32pad: function() {
                    return ro
                },
                base32padupper: function() {
                    return rs
                },
                base32upper: function() {
                    return t7
                },
                base32z: function() {
                    return rh
                }
            });
            var ey = {};
            C.r(ey), C.d(ey, {
                base36: function() {
                    return rp
                },
                base36upper: function() {
                    return rg
                }
            });
            var em = {};
            C.r(em), C.d(em, {
                base58btc: function() {
                    return ry
                },
                base58flickr: function() {
                    return rm
                }
            });
            var e_ = {};
            C.r(e_), C.d(e_, {
                base64: function() {
                    return r_
                },
                base64pad: function() {
                    return rb
                },
                base64url: function() {
                    return rw
                },
                base64urlpad: function() {
                    return rE
                }
            });
            var eb = {};
            C.r(eb), C.d(eb, {
                base256emoji: function() {
                    return rA
                }
            });
            var ew = {};
            C.r(ew), C.d(ew, {
                sha256: function() {
                    return rC
                },
                sha512: function() {
                    return rk
                }
            });
            var eE = {};
            C.r(eE), C.d(eE, {
                identity: function() {
                    return rN
                }
            });
            var eI = {};
            C.r(eI), C.d(eI, {
                code: function() {
                    return rT
                },
                decode: function() {
                    return raw_decode
                },
                encode: function() {
                    return raw_encode
                },
                name: function() {
                    return rO
                }
            });
            var eS = {};
            C.r(eS), C.d(eS, {
                code: function() {
                    return rU
                },
                decode: function() {
                    return json_decode
                },
                encode: function() {
                    return json_encode
                },
                name: function() {
                    return rB
                }
            });
            var ex = C(97115);
            "undefined" != typeof window && (window.global = globalThis, Object.assign(window, {
                Buffer: ex.Buffer
            }));
            var eA = C(37943);

            function __awaiter(r, l, C, U) {
                return new(C || (C = Promise))(function(et, eo) {
                    function fulfilled(r) {
                        try {
                            step(U.next(r))
                        } catch (r) {
                            eo(r)
                        }
                    }

                    function rejected(r) {
                        try {
                            step(U.throw(r))
                        } catch (r) {
                            eo(r)
                        }
                    }

                    function step(r) {
                        var l;
                        r.done ? et(r.value) : ((l = r.value) instanceof C ? l : new C(function(r) {
                            r(l)
                        })).then(fulfilled, rejected)
                    }
                    step((U = U.apply(r, l || [])).next())
                })
            }
            "function" == typeof SuppressedError && SuppressedError;
            var eP = C(85031),
                eC = C(36875),
                ek = C(30274),
                eN = C(20886),
                eO = C(99792),
                eT = C(9891),
                eR = C(19550),
                eD = C(80479),
                eB = C(84086);
            let SHA2 = class SHA2 extends eB.kb {
                constructor(r, l, C, U) {
                    super(), this.blockLen = r, this.outputLen = l, this.padOffset = C, this.isLE = U, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(r), this.view = (0, eB.GL)(this.buffer)
                }
                update(r) {
                    (0, eD.Gg)(this);
                    let {
                        view: l,
                        buffer: C,
                        blockLen: U
                    } = this;
                    r = (0, eB.O0)(r);
                    let et = r.length;
                    for (let eo = 0; eo < et;) {
                        let es = Math.min(U - this.pos, et - eo);
                        if (es === U) {
                            let l = (0, eB.GL)(r);
                            for (; U <= et - eo; eo += U) this.process(l, eo);
                            continue
                        }
                        C.set(r.subarray(eo, eo + es), this.pos), this.pos += es, eo += es, this.pos === U && (this.process(l, 0), this.pos = 0)
                    }
                    return this.length += r.length, this.roundClean(), this
                }
                digestInto(r) {
                    (0, eD.Gg)(this), (0, eD.J8)(r, this), this.finished = !0;
                    let {
                        buffer: l,
                        view: C,
                        blockLen: U,
                        isLE: et
                    } = this, {
                        pos: eo
                    } = this;
                    l[eo++] = 128, this.buffer.subarray(eo).fill(0), this.padOffset > U - eo && (this.process(C, 0), eo = 0);
                    for (let r = eo; r < U; r++) l[r] = 0;
                    ! function(r, l, C, U) {
                        if ("function" == typeof r.setBigUint64) return r.setBigUint64(l, C, U);
                        let et = BigInt(32),
                            eo = BigInt(4294967295),
                            es = Number(C >> et & eo),
                            el = Number(C & eo),
                            ec = U ? 4 : 0,
                            ed = U ? 0 : 4;
                        r.setUint32(l + ec, es, U), r.setUint32(l + ed, el, U)
                    }(C, U - 8, BigInt(8 * this.length), et), this.process(C, 0);
                    let es = (0, eB.GL)(r),
                        el = this.outputLen;
                    if (el % 4) throw Error("_sha2: outputLen should be aligned to 32bit");
                    let ec = el / 4,
                        ed = this.get();
                    if (ec > ed.length) throw Error("_sha2: outputLen bigger than state");
                    for (let r = 0; r < ec; r++) es.setUint32(4 * r, ed[r], et)
                }
                digest() {
                    let {
                        buffer: r,
                        outputLen: l
                    } = this;
                    this.digestInto(r);
                    let C = r.slice(0, l);
                    return this.destroy(), C
                }
                _cloneInto(r) {
                    r || (r = new this.constructor), r.set(...this.get());
                    let {
                        blockLen: l,
                        buffer: C,
                        length: U,
                        finished: et,
                        destroyed: eo,
                        pos: es
                    } = this;
                    return r.length = U, r.pos = es, r.finished = et, r.destroyed = eo, U % l && r.buffer.set(C), r
                }
            };
            let Chi = (r, l, C) => r & l ^ ~r & C,
                Maj = (r, l, C) => r & l ^ r & C ^ l & C,
                eU = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]),
                eL = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]),
                eM = new Uint32Array(64);
            let SHA256 = class SHA256 extends SHA2 {
                constructor() {
                    super(64, 32, 8, !1), this.A = 0 | eL[0], this.B = 0 | eL[1], this.C = 0 | eL[2], this.D = 0 | eL[3], this.E = 0 | eL[4], this.F = 0 | eL[5], this.G = 0 | eL[6], this.H = 0 | eL[7]
                }
                get() {
                    let {
                        A: r,
                        B: l,
                        C,
                        D: U,
                        E: et,
                        F: eo,
                        G: es,
                        H: el
                    } = this;
                    return [r, l, C, U, et, eo, es, el]
                }
                set(r, l, C, U, et, eo, es, el) {
                    this.A = 0 | r, this.B = 0 | l, this.C = 0 | C, this.D = 0 | U, this.E = 0 | et, this.F = 0 | eo, this.G = 0 | es, this.H = 0 | el
                }
                process(r, l) {
                    for (let C = 0; C < 16; C++, l += 4) eM[C] = r.getUint32(l, !1);
                    for (let r = 16; r < 64; r++) {
                        let l = eM[r - 15],
                            C = eM[r - 2],
                            U = (0, eB.np)(l, 7) ^ (0, eB.np)(l, 18) ^ l >>> 3,
                            et = (0, eB.np)(C, 17) ^ (0, eB.np)(C, 19) ^ C >>> 10;
                        eM[r] = et + eM[r - 7] + U + eM[r - 16] | 0
                    }
                    let {
                        A: C,
                        B: U,
                        C: et,
                        D: eo,
                        E: es,
                        F: el,
                        G: ec,
                        H: ed
                    } = this;
                    for (let r = 0; r < 64; r++) {
                        let l = (0, eB.np)(es, 6) ^ (0, eB.np)(es, 11) ^ (0, eB.np)(es, 25),
                            eh = ed + l + Chi(es, el, ec) + eU[r] + eM[r] | 0,
                            ef = (0, eB.np)(C, 2) ^ (0, eB.np)(C, 13) ^ (0, eB.np)(C, 22),
                            ep = ef + Maj(C, U, et) | 0;
                        ed = ec, ec = el, el = es, es = eo + eh | 0, eo = et, et = U, U = C, C = eh + ep | 0
                    }
                    C = C + this.A | 0, U = U + this.B | 0, et = et + this.C | 0, eo = eo + this.D | 0, es = es + this.E | 0, el = el + this.F | 0, ec = ec + this.G | 0, ed = ed + this.H | 0, this.set(C, U, et, eo, es, el, ec, ed)
                }
                roundClean() {
                    eM.fill(0)
                }
                destroy() {
                    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0)
                }
            };
            let ej = (0, eB.hE)(() => new SHA256);
            var e$ = C(44848); /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
            let ez = BigInt(0),
                eH = BigInt(1),
                eF = BigInt(2),
                eW = BigInt(3),
                eV = BigInt(4),
                eK = BigInt(5),
                eG = BigInt(8);

            function modular_mod(r, l) {
                let C = r % l;
                return C >= ez ? C : l + C
            }

            function pow2(r, l, C) {
                let U = r;
                for (; l-- > ez;) U *= U, U %= C;
                return U
            }

            function invert(r, l) {
                if (r === ez || l <= ez) throw Error(`invert: expected positive integers, got n=${r} mod=${l}`);
                let C = modular_mod(r, l),
                    U = l,
                    et = ez,
                    eo = eH,
                    es = eH,
                    el = ez;
                for (; C !== ez;) {
                    let r = U / C,
                        l = U % C,
                        ec = et - es * r,
                        ed = eo - el * r;
                    U = C, C = l, et = es, eo = el, es = ec, el = ed
                }
                let ec = U;
                if (ec !== eH) throw Error("invert: does not exist");
                return modular_mod(et, l)
            }
            BigInt(9), BigInt(16);
            let eJ = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];

            function nLength(r, l) {
                let C = void 0 !== l ? l : r.toString(2).length,
                    U = Math.ceil(C / 8);
                return {
                    nBitLength: C,
                    nByteLength: U
                }
            }

            function getFieldBytesLength(r) {
                if ("bigint" != typeof r) throw Error("field order must be bigint");
                let l = r.toString(2).length;
                return Math.ceil(l / 8)
            }

            function getMinHashLength(r) {
                let l = getFieldBytesLength(r);
                return l + Math.ceil(l / 2)
            }
            let HMAC = class HMAC extends eB.kb {
                constructor(r, l) {
                    super(), this.finished = !1, this.destroyed = !1, (0, eD.vp)(r);
                    let C = (0, eB.O0)(l);
                    if (this.iHash = r.create(), "function" != typeof this.iHash.update) throw Error("Expected instance of class which extends utils.Hash");
                    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
                    let U = this.blockLen,
                        et = new Uint8Array(U);
                    et.set(C.length > U ? r.create().update(C).digest() : C);
                    for (let r = 0; r < et.length; r++) et[r] ^= 54;
                    this.iHash.update(et), this.oHash = r.create();
                    for (let r = 0; r < et.length; r++) et[r] ^= 106;
                    this.oHash.update(et), et.fill(0)
                }
                update(r) {
                    return (0, eD.Gg)(this), this.iHash.update(r), this
                }
                digestInto(r) {
                    (0, eD.Gg)(this), (0, eD.aI)(r, this.outputLen), this.finished = !0, this.iHash.digestInto(r), this.oHash.update(r), this.oHash.digestInto(r), this.destroy()
                }
                digest() {
                    let r = new Uint8Array(this.oHash.outputLen);
                    return this.digestInto(r), r
                }
                _cloneInto(r) {
                    r || (r = Object.create(Object.getPrototypeOf(this), {}));
                    let {
                        oHash: l,
                        iHash: C,
                        finished: U,
                        destroyed: et,
                        blockLen: eo,
                        outputLen: es
                    } = this;
                    return r.finished = U, r.destroyed = et, r.blockLen = eo, r.outputLen = es, r.oHash = l._cloneInto(r.oHash), r.iHash = C._cloneInto(r.iHash), r
                }
                destroy() {
                    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy()
                }
            };
            let hmac = (r, l, C) => new HMAC(r, l).update(C).digest();
            hmac.create = (r, l) => new HMAC(r, l); /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
            let eY = BigInt(0),
                eZ = BigInt(1);

            function validateBasic(r) {
                return ! function(r) {
                    let l = eJ.reduce((r, l) => (r[l] = "function", r), {
                        ORDER: "bigint",
                        MASK: "bigint",
                        BYTES: "isSafeInteger",
                        BITS: "isSafeInteger"
                    });
                    (0, e$.FF)(r, l)
                }(r.Fp), (0, e$.FF)(r, {
                    n: "bigint",
                    h: "bigint",
                    Gx: "field",
                    Gy: "field"
                }, {
                    nBitLength: "isSafeInteger",
                    nByteLength: "isSafeInteger"
                }), Object.freeze({ ...nLength(r.n, r.nBitLength),
                    ...r,
                    p: r.Fp.ORDER
                })
            }
            let {
                bytesToNumberBE: eX,
                hexToBytes: eQ
            } = e$, e0 = {
                Err: class extends Error {
                    constructor(r = "") {
                        super(r)
                    }
                },
                _parseInt(r) {
                    let {
                        Err: l
                    } = e0;
                    if (r.length < 2 || 2 !== r[0]) throw new l("Invalid signature integer tag");
                    let C = r[1],
                        U = r.subarray(2, C + 2);
                    if (!C || U.length !== C) throw new l("Invalid signature integer: wrong length");
                    if (128 & U[0]) throw new l("Invalid signature integer: negative");
                    if (0 === U[0] && !(128 & U[1])) throw new l("Invalid signature integer: unnecessary leading zero");
                    return {
                        d: eX(U),
                        l: r.subarray(C + 2)
                    }
                },
                toSig(r) {
                    let {
                        Err: l
                    } = e0, C = "string" == typeof r ? eQ(r) : r;
                    if (!(C instanceof Uint8Array)) throw Error("ui8a expected");
                    let U = C.length;
                    if (U < 2 || 48 != C[0]) throw new l("Invalid signature tag");
                    if (C[1] !== U - 2) throw new l("Invalid signature: incorrect length");
                    let {
                        d: et,
                        l: eo
                    } = e0._parseInt(C.subarray(2)), {
                        d: es,
                        l: el
                    } = e0._parseInt(eo);
                    if (el.length) throw new l("Invalid signature: left bytes after parsing");
                    return {
                        r: et,
                        s: es
                    }
                },
                hexFromSig(r) {
                    let slice = r => 8 & Number.parseInt(r[0], 16) ? "00" + r : r,
                        h = r => {
                            let l = r.toString(16);
                            return 1 & l.length ? `0${l}` : l
                        },
                        l = slice(h(r.s)),
                        C = slice(h(r.r)),
                        U = l.length / 2,
                        et = C.length / 2,
                        eo = h(U),
                        es = h(et);
                    return `30${h(et+U+4)}02${es}${C}02${eo}${l}`
                }
            }, e1 = BigInt(0), e2 = BigInt(1), e3 = (BigInt(2), BigInt(3));
            BigInt(4); /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
            let e5 = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
                e6 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
                e8 = BigInt(1),
                e4 = BigInt(2),
                divNearest = (r, l) => (r + l / e4) / l,
                e9 = function(r, l, C = !1, U = {}) {
                    if (r <= ez) throw Error(`Expected Field ORDER > 0, got ${r}`);
                    let {
                        nBitLength: et,
                        nByteLength: eo
                    } = nLength(r, l);
                    if (eo > 2048) throw Error("Field lengths over 2048 bytes are not supported");
                    let es = function(r) {
                            if (r % eV === eW) {
                                let l = (r + eH) / eV;
                                return function(r, C) {
                                    let U = r.pow(C, l);
                                    if (!r.eql(r.sqr(U), C)) throw Error("Cannot find square root");
                                    return U
                                }
                            }
                            if (r % eG === eK) {
                                let l = (r - eK) / eG;
                                return function(r, C) {
                                    let U = r.mul(C, eF),
                                        et = r.pow(U, l),
                                        eo = r.mul(C, et),
                                        es = r.mul(r.mul(eo, eF), et),
                                        el = r.mul(eo, r.sub(es, r.ONE));
                                    if (!r.eql(r.sqr(el), C)) throw Error("Cannot find square root");
                                    return el
                                }
                            }
                            return function(r) {
                                let l, C, U;
                                let et = (r - eH) / eF;
                                for (l = r - eH, C = 0; l % eF === ez; l /= eF, C++);
                                for (U = eF; U < r && function(r, l, C) {
                                        if (C <= ez || l < ez) throw Error("Expected power/modulo > 0");
                                        if (C === eH) return ez;
                                        let U = eH;
                                        for (; l > ez;) l & eH && (U = U * r % C), r = r * r % C, l >>= eH;
                                        return U
                                    }(U, et, r) !== r - eH; U++);
                                if (1 === C) {
                                    let l = (r + eH) / eV;
                                    return function(r, C) {
                                        let U = r.pow(C, l);
                                        if (!r.eql(r.sqr(U), C)) throw Error("Cannot find square root");
                                        return U
                                    }
                                }
                                let eo = (l + eH) / eF;
                                return function(r, es) {
                                    if (r.pow(es, et) === r.neg(r.ONE)) throw Error("Cannot find square root");
                                    let el = C,
                                        ec = r.pow(r.mul(r.ONE, U), l),
                                        ed = r.pow(es, eo),
                                        eh = r.pow(es, l);
                                    for (; !r.eql(eh, r.ONE);) {
                                        if (r.eql(eh, r.ZERO)) return r.ZERO;
                                        let l = 1;
                                        for (let C = r.sqr(eh); l < el && !r.eql(C, r.ONE); l++) C = r.sqr(C);
                                        let C = r.pow(ec, eH << BigInt(el - l - 1));
                                        ec = r.sqr(C), ed = r.mul(ed, C), eh = r.mul(eh, ec), el = l
                                    }
                                    return ed
                                }
                            }(r)
                        }(r),
                        el = Object.freeze({
                            ORDER: r,
                            BITS: et,
                            BYTES: eo,
                            MASK: (0, e$.dQ)(et),
                            ZERO: ez,
                            ONE: eH,
                            create: l => modular_mod(l, r),
                            isValid: l => {
                                if ("bigint" != typeof l) throw Error(`Invalid field element: expected bigint, got ${typeof l}`);
                                return ez <= l && l < r
                            },
                            is0: r => r === ez,
                            isOdd: r => (r & eH) === eH,
                            neg: l => modular_mod(-l, r),
                            eql: (r, l) => r === l,
                            sqr: l => modular_mod(l * l, r),
                            add: (l, C) => modular_mod(l + C, r),
                            sub: (l, C) => modular_mod(l - C, r),
                            mul: (l, C) => modular_mod(l * C, r),
                            pow: (r, l) => (function(r, l, C) {
                                if (C < ez) throw Error("Expected power > 0");
                                if (C === ez) return r.ONE;
                                if (C === eH) return l;
                                let U = r.ONE,
                                    et = l;
                                for (; C > ez;) C & eH && (U = r.mul(U, et)), et = r.sqr(et), C >>= eH;
                                return U
                            })(el, r, l),
                            div: (l, C) => modular_mod(l * invert(C, r), r),
                            sqrN: r => r * r,
                            addN: (r, l) => r + l,
                            subN: (r, l) => r - l,
                            mulN: (r, l) => r * l,
                            inv: l => invert(l, r),
                            sqrt: U.sqrt || (r => es(el, r)),
                            invertBatch: r => (function(r, l) {
                                let C = Array(l.length),
                                    U = l.reduce((l, U, et) => r.is0(U) ? l : (C[et] = l, r.mul(l, U)), r.ONE),
                                    et = r.inv(U);
                                return l.reduceRight((l, U, et) => r.is0(U) ? l : (C[et] = r.mul(l, C[et]), r.mul(l, U)), et), C
                            })(el, r),
                            cmov: (r, l, C) => C ? l : r,
                            toBytes: r => C ? (0, e$.S5)(r, eo) : (0, e$.tL)(r, eo),
                            fromBytes: r => {
                                if (r.length !== eo) throw Error(`Fp.fromBytes: expected ${eo}, got ${r.length}`);
                                return C ? (0, e$.ty)(r) : (0, e$.bytesToNumberBE)(r)
                            }
                        });
                    return Object.freeze(el)
                }(e5, void 0, void 0, {
                    sqrt: function(r) {
                        let l = BigInt(3),
                            C = BigInt(6),
                            U = BigInt(11),
                            et = BigInt(22),
                            eo = BigInt(23),
                            es = BigInt(44),
                            el = BigInt(88),
                            ec = r * r * r % e5,
                            ed = ec * ec * r % e5,
                            eh = pow2(ed, l, e5) * ed % e5,
                            ef = pow2(eh, l, e5) * ed % e5,
                            ep = pow2(ef, e4, e5) * ec % e5,
                            eg = pow2(ep, U, e5) * ep % e5,
                            ey = pow2(eg, et, e5) * eg % e5,
                            em = pow2(ey, es, e5) * ey % e5,
                            e_ = pow2(em, el, e5) * em % e5,
                            eb = pow2(e_, es, e5) * ey % e5,
                            ew = pow2(eb, l, e5) * ed % e5,
                            eE = pow2(ew, eo, e5) * eg % e5,
                            eI = pow2(eE, C, e5) * ec % e5,
                            eS = pow2(eI, e4, e5);
                        if (!e9.eql(e9.sqr(eS), r)) throw Error("Cannot find square root");
                        return eS
                    }
                }),
                e7 = function(r, l) {
                    let create = l => (function(r) {
                        let l = function(r) {
                                let l = validateBasic(r);
                                return e$.FF(l, {
                                    hash: "hash",
                                    hmac: "function",
                                    randomBytes: "function"
                                }, {
                                    bits2int: "function",
                                    bits2int_modN: "function",
                                    lowS: "boolean"
                                }), Object.freeze({
                                    lowS: !0,
                                    ...l
                                })
                            }(r),
                            {
                                Fp: C,
                                n: U
                            } = l,
                            et = C.BYTES + 1,
                            eo = 2 * C.BYTES + 1;

                        function modN(r) {
                            return modular_mod(r, U)
                        }
                        let {
                            ProjectivePoint: es,
                            normPrivateKeyToScalar: el,
                            weierstrassEquation: ec,
                            isWithinCurveOrder: ed
                        } = function(r) {
                            let l = /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function(r) {
                                    let l = validateBasic(r);
                                    e$.FF(l, {
                                        a: "field",
                                        b: "field"
                                    }, {
                                        allowedPrivateKeyLengths: "array",
                                        wrapPrivateKey: "boolean",
                                        isTorsionFree: "function",
                                        clearCofactor: "function",
                                        allowInfinityPoint: "boolean",
                                        fromBytes: "function",
                                        toBytes: "function"
                                    });
                                    let {
                                        endo: C,
                                        Fp: U,
                                        a: et
                                    } = l;
                                    if (C) {
                                        if (!U.eql(et, U.ZERO)) throw Error("Endomorphism can only be defined for Koblitz curves that have a=0");
                                        if ("object" != typeof C || "bigint" != typeof C.beta || "function" != typeof C.splitScalar) throw Error("Expected endomorphism with beta: bigint and splitScalar: function")
                                    }
                                    return Object.freeze({ ...l
                                    })
                                }(r),
                                {
                                    Fp: C
                                } = l,
                                U = l.toBytes || ((r, l, U) => {
                                    let et = l.toAffine();
                                    return e$.eV(Uint8Array.from([4]), C.toBytes(et.x), C.toBytes(et.y))
                                }),
                                et = l.fromBytes || (r => {
                                    let l = r.subarray(1),
                                        U = C.fromBytes(l.subarray(0, C.BYTES)),
                                        et = C.fromBytes(l.subarray(C.BYTES, 2 * C.BYTES));
                                    return {
                                        x: U,
                                        y: et
                                    }
                                });

                            function weierstrassEquation(r) {
                                let {
                                    a: U,
                                    b: et
                                } = l, eo = C.sqr(r), es = C.mul(eo, r);
                                return C.add(C.add(es, C.mul(r, U)), et)
                            }
                            if (!C.eql(C.sqr(l.Gy), weierstrassEquation(l.Gx))) throw Error("bad generator point: equation left != right");

                            function isWithinCurveOrder(r) {
                                return "bigint" == typeof r && e1 < r && r < l.n
                            }

                            function assertGE(r) {
                                if (!isWithinCurveOrder(r)) throw Error("Expected valid bigint: 0 < bigint < curve.n")
                            }

                            function normPrivateKeyToScalar(r) {
                                let C;
                                let {
                                    allowedPrivateKeyLengths: U,
                                    nByteLength: et,
                                    wrapPrivateKey: eo,
                                    n: es
                                } = l;
                                if (U && "bigint" != typeof r) {
                                    if (r instanceof Uint8Array && (r = e$.ci(r)), "string" != typeof r || !U.includes(r.length)) throw Error("Invalid key");
                                    r = r.padStart(2 * et, "0")
                                }
                                try {
                                    C = "bigint" == typeof r ? r : e$.bytesToNumberBE((0, e$.ql)("private key", r, et))
                                } catch (l) {
                                    throw Error(`private key must be ${et} bytes, hex or bigint, not ${typeof r}`)
                                }
                                return eo && (C = modular_mod(C, es)), assertGE(C), C
                            }
                            let eo = new Map;

                            function assertPrjPoint(r) {
                                if (!(r instanceof Point)) throw Error("ProjectivePoint expected")
                            }
                            let Point = class Point {
                                constructor(r, l, U) {
                                    if (this.px = r, this.py = l, this.pz = U, null == r || !C.isValid(r)) throw Error("x required");
                                    if (null == l || !C.isValid(l)) throw Error("y required");
                                    if (null == U || !C.isValid(U)) throw Error("z required")
                                }
                                static fromAffine(r) {
                                    let {
                                        x: l,
                                        y: U
                                    } = r || {};
                                    if (!r || !C.isValid(l) || !C.isValid(U)) throw Error("invalid affine point");
                                    if (r instanceof Point) throw Error("projective point not allowed");
                                    let is0 = r => C.eql(r, C.ZERO);
                                    return is0(l) && is0(U) ? Point.ZERO : new Point(l, U, C.ONE)
                                }
                                get x() {
                                    return this.toAffine().x
                                }
                                get y() {
                                    return this.toAffine().y
                                }
                                static normalizeZ(r) {
                                    let l = C.invertBatch(r.map(r => r.pz));
                                    return r.map((r, C) => r.toAffine(l[C])).map(Point.fromAffine)
                                }
                                static fromHex(r) {
                                    let l = Point.fromAffine(et((0, e$.ql)("pointHex", r)));
                                    return l.assertValidity(), l
                                }
                                static fromPrivateKey(r) {
                                    return Point.BASE.multiply(normPrivateKeyToScalar(r))
                                }
                                _setWindowSize(r) {
                                    this._WINDOW_SIZE = r, eo.delete(this)
                                }
                                assertValidity() {
                                    if (this.is0()) {
                                        if (l.allowInfinityPoint && !C.is0(this.py)) return;
                                        throw Error("bad point: ZERO")
                                    }
                                    let {
                                        x: r,
                                        y: U
                                    } = this.toAffine();
                                    if (!C.isValid(r) || !C.isValid(U)) throw Error("bad point: x or y not FE");
                                    let et = C.sqr(U),
                                        eo = weierstrassEquation(r);
                                    if (!C.eql(et, eo)) throw Error("bad point: equation left != right");
                                    if (!this.isTorsionFree()) throw Error("bad point: not in prime-order subgroup")
                                }
                                hasEvenY() {
                                    let {
                                        y: r
                                    } = this.toAffine();
                                    if (C.isOdd) return !C.isOdd(r);
                                    throw Error("Field doesn't support isOdd")
                                }
                                equals(r) {
                                    assertPrjPoint(r);
                                    let {
                                        px: l,
                                        py: U,
                                        pz: et
                                    } = this, {
                                        px: eo,
                                        py: es,
                                        pz: el
                                    } = r, ec = C.eql(C.mul(l, el), C.mul(eo, et)), ed = C.eql(C.mul(U, el), C.mul(es, et));
                                    return ec && ed
                                }
                                negate() {
                                    return new Point(this.px, C.neg(this.py), this.pz)
                                }
                                double() {
                                    let {
                                        a: r,
                                        b: U
                                    } = l, et = C.mul(U, e3), {
                                        px: eo,
                                        py: es,
                                        pz: el
                                    } = this, ec = C.ZERO, ed = C.ZERO, eh = C.ZERO, ef = C.mul(eo, eo), ep = C.mul(es, es), eg = C.mul(el, el), ey = C.mul(eo, es);
                                    return ey = C.add(ey, ey), eh = C.mul(eo, el), eh = C.add(eh, eh), ec = C.mul(r, eh), ed = C.mul(et, eg), ed = C.add(ec, ed), ec = C.sub(ep, ed), ed = C.add(ep, ed), ed = C.mul(ec, ed), ec = C.mul(ey, ec), eh = C.mul(et, eh), eg = C.mul(r, eg), ey = C.sub(ef, eg), ey = C.mul(r, ey), ey = C.add(ey, eh), eh = C.add(ef, ef), ef = C.add(eh, ef), ef = C.add(ef, eg), ef = C.mul(ef, ey), ed = C.add(ed, ef), eg = C.mul(es, el), eg = C.add(eg, eg), ef = C.mul(eg, ey), ec = C.sub(ec, ef), eh = C.mul(eg, ep), eh = C.add(eh, eh), eh = C.add(eh, eh), new Point(ec, ed, eh)
                                }
                                add(r) {
                                    assertPrjPoint(r);
                                    let {
                                        px: U,
                                        py: et,
                                        pz: eo
                                    } = this, {
                                        px: es,
                                        py: el,
                                        pz: ec
                                    } = r, ed = C.ZERO, eh = C.ZERO, ef = C.ZERO, ep = l.a, eg = C.mul(l.b, e3), ey = C.mul(U, es), em = C.mul(et, el), e_ = C.mul(eo, ec), eb = C.add(U, et), ew = C.add(es, el);
                                    eb = C.mul(eb, ew), ew = C.add(ey, em), eb = C.sub(eb, ew), ew = C.add(U, eo);
                                    let eE = C.add(es, ec);
                                    return ew = C.mul(ew, eE), eE = C.add(ey, e_), ew = C.sub(ew, eE), eE = C.add(et, eo), ed = C.add(el, ec), eE = C.mul(eE, ed), ed = C.add(em, e_), eE = C.sub(eE, ed), ef = C.mul(ep, ew), ed = C.mul(eg, e_), ef = C.add(ed, ef), ed = C.sub(em, ef), ef = C.add(em, ef), eh = C.mul(ed, ef), em = C.add(ey, ey), em = C.add(em, ey), e_ = C.mul(ep, e_), ew = C.mul(eg, ew), em = C.add(em, e_), e_ = C.sub(ey, e_), e_ = C.mul(ep, e_), ew = C.add(ew, e_), ey = C.mul(em, ew), eh = C.add(eh, ey), ey = C.mul(eE, ew), ed = C.mul(eb, ed), ed = C.sub(ed, ey), ey = C.mul(eb, em), ef = C.mul(eE, ef), ef = C.add(ef, ey), new Point(ed, eh, ef)
                                }
                                subtract(r) {
                                    return this.add(r.negate())
                                }
                                is0() {
                                    return this.equals(Point.ZERO)
                                }
                                wNAF(r) {
                                    return el.wNAFCached(this, eo, r, r => {
                                        let l = C.invertBatch(r.map(r => r.pz));
                                        return r.map((r, C) => r.toAffine(l[C])).map(Point.fromAffine)
                                    })
                                }
                                multiplyUnsafe(r) {
                                    let U = Point.ZERO;
                                    if (r === e1) return U;
                                    if (assertGE(r), r === e2) return this;
                                    let {
                                        endo: et
                                    } = l;
                                    if (!et) return el.unsafeLadder(this, r);
                                    let {
                                        k1neg: eo,
                                        k1: es,
                                        k2neg: ec,
                                        k2: ed
                                    } = et.splitScalar(r), eh = U, ef = U, ep = this;
                                    for (; es > e1 || ed > e1;) es & e2 && (eh = eh.add(ep)), ed & e2 && (ef = ef.add(ep)), ep = ep.double(), es >>= e2, ed >>= e2;
                                    return eo && (eh = eh.negate()), ec && (ef = ef.negate()), ef = new Point(C.mul(ef.px, et.beta), ef.py, ef.pz), eh.add(ef)
                                }
                                multiply(r) {
                                    let U, et;
                                    assertGE(r);
                                    let {
                                        endo: eo
                                    } = l;
                                    if (eo) {
                                        let {
                                            k1neg: l,
                                            k1: es,
                                            k2neg: ec,
                                            k2: ed
                                        } = eo.splitScalar(r), {
                                            p: eh,
                                            f: ef
                                        } = this.wNAF(es), {
                                            p: ep,
                                            f: eg
                                        } = this.wNAF(ed);
                                        eh = el.constTimeNegate(l, eh), ep = el.constTimeNegate(ec, ep), ep = new Point(C.mul(ep.px, eo.beta), ep.py, ep.pz), U = eh.add(ep), et = ef.add(eg)
                                    } else {
                                        let {
                                            p: l,
                                            f: C
                                        } = this.wNAF(r);
                                        U = l, et = C
                                    }
                                    return Point.normalizeZ([U, et])[0]
                                }
                                multiplyAndAddUnsafe(r, l, C) {
                                    let U = Point.BASE,
                                        mul = (r, l) => l !== e1 && l !== e2 && r.equals(U) ? r.multiply(l) : r.multiplyUnsafe(l),
                                        et = mul(this, l).add(mul(r, C));
                                    return et.is0() ? void 0 : et
                                }
                                toAffine(r) {
                                    let {
                                        px: l,
                                        py: U,
                                        pz: et
                                    } = this, eo = this.is0();
                                    null == r && (r = eo ? C.ONE : C.inv(et));
                                    let es = C.mul(l, r),
                                        el = C.mul(U, r),
                                        ec = C.mul(et, r);
                                    if (eo) return {
                                        x: C.ZERO,
                                        y: C.ZERO
                                    };
                                    if (!C.eql(ec, C.ONE)) throw Error("invZ was invalid");
                                    return {
                                        x: es,
                                        y: el
                                    }
                                }
                                isTorsionFree() {
                                    let {
                                        h: r,
                                        isTorsionFree: C
                                    } = l;
                                    if (r === e2) return !0;
                                    if (C) return C(Point, this);
                                    throw Error("isTorsionFree() has not been declared for the elliptic curve")
                                }
                                clearCofactor() {
                                    let {
                                        h: r,
                                        clearCofactor: C
                                    } = l;
                                    return r === e2 ? this : C ? C(Point, this) : this.multiplyUnsafe(l.h)
                                }
                                toRawBytes(r = !0) {
                                    return this.assertValidity(), U(Point, this, r)
                                }
                                toHex(r = !0) {
                                    return e$.ci(this.toRawBytes(r))
                                }
                            };
                            Point.BASE = new Point(l.Gx, l.Gy, C.ONE), Point.ZERO = new Point(C.ZERO, C.ONE, C.ZERO);
                            let es = l.nBitLength,
                                el = function(r, l) {
                                    let constTimeNegate = (r, l) => {
                                            let C = l.negate();
                                            return r ? C : l
                                        },
                                        opts = r => {
                                            let C = Math.ceil(l / r) + 1;
                                            return {
                                                windows: C,
                                                windowSize: 2 ** (r - 1)
                                            }
                                        };
                                    return {
                                        constTimeNegate,
                                        unsafeLadder(l, C) {
                                            let U = r.ZERO,
                                                et = l;
                                            for (; C > eY;) C & eZ && (U = U.add(et)), et = et.double(), C >>= eZ;
                                            return U
                                        },
                                        precomputeWindow(r, l) {
                                            let {
                                                windows: C,
                                                windowSize: U
                                            } = opts(l), et = [], eo = r, es = eo;
                                            for (let r = 0; r < C; r++) {
                                                es = eo, et.push(es);
                                                for (let r = 1; r < U; r++) es = es.add(eo), et.push(es);
                                                eo = es.double()
                                            }
                                            return et
                                        },
                                        wNAF(l, C, U) {
                                            let {
                                                windows: et,
                                                windowSize: eo
                                            } = opts(l), es = r.ZERO, el = r.BASE, ec = BigInt(2 ** l - 1), ed = 2 ** l, eh = BigInt(l);
                                            for (let r = 0; r < et; r++) {
                                                let l = r * eo,
                                                    et = Number(U & ec);
                                                U >>= eh, et > eo && (et -= ed, U += eZ);
                                                let ef = l + Math.abs(et) - 1,
                                                    ep = r % 2 != 0,
                                                    eg = et < 0;
                                                0 === et ? el = el.add(constTimeNegate(ep, C[l])) : es = es.add(constTimeNegate(eg, C[ef]))
                                            }
                                            return {
                                                p: es,
                                                f: el
                                            }
                                        },
                                        wNAFCached(r, l, C, U) {
                                            let et = r._WINDOW_SIZE || 1,
                                                eo = l.get(r);
                                            return eo || (eo = this.precomputeWindow(r, et), 1 !== et && l.set(r, U(eo))), this.wNAF(et, eo, C)
                                        }
                                    }
                                }(Point, l.endo ? Math.ceil(es / 2) : es);
                            return {
                                CURVE: l,
                                ProjectivePoint: Point,
                                normPrivateKeyToScalar,
                                weierstrassEquation,
                                isWithinCurveOrder
                            }
                        }({ ...l,
                            toBytes(r, l, U) {
                                let et = l.toAffine(),
                                    eo = C.toBytes(et.x),
                                    es = e$.eV;
                                return U ? es(Uint8Array.from([l.hasEvenY() ? 2 : 3]), eo) : es(Uint8Array.from([4]), eo, C.toBytes(et.y))
                            },
                            fromBytes(r) {
                                let l = r.length,
                                    U = r[0],
                                    es = r.subarray(1);
                                if (l === et && (2 === U || 3 === U)) {
                                    let r = e$.bytesToNumberBE(es);
                                    if (!(e1 < r && r < C.ORDER)) throw Error("Point is not on curve");
                                    let l = ec(r),
                                        et = C.sqrt(l),
                                        eo = (et & e2) === e2;
                                    return (1 & U) == 1 !== eo && (et = C.neg(et)), {
                                        x: r,
                                        y: et
                                    }
                                }
                                if (l === eo && 4 === U) {
                                    let r = C.fromBytes(es.subarray(0, C.BYTES)),
                                        l = C.fromBytes(es.subarray(C.BYTES, 2 * C.BYTES));
                                    return {
                                        x: r,
                                        y: l
                                    }
                                }
                                throw Error(`Point of length ${l} was invalid. Expected ${et} compressed bytes or ${eo} uncompressed bytes`)
                            }
                        }), numToNByteStr = r => e$.ci(e$.tL(r, l.nByteLength));

                        function isBiggerThanHalfOrder(r) {
                            let l = U >> e2;
                            return r > l
                        }
                        let slcNum = (r, l, C) => e$.bytesToNumberBE(r.slice(l, C));
                        let Signature = class Signature {
                            constructor(r, l, C) {
                                this.r = r, this.s = l, this.recovery = C, this.assertValidity()
                            }
                            static fromCompact(r) {
                                let C = l.nByteLength;
                                return r = (0, e$.ql)("compactSignature", r, 2 * C), new Signature(slcNum(r, 0, C), slcNum(r, C, 2 * C))
                            }
                            static fromDER(r) {
                                let {
                                    r: l,
                                    s: C
                                } = e0.toSig((0, e$.ql)("DER", r));
                                return new Signature(l, C)
                            }
                            assertValidity() {
                                if (!ed(this.r)) throw Error("r must be 0 < r < CURVE.n");
                                if (!ed(this.s)) throw Error("s must be 0 < s < CURVE.n")
                            }
                            addRecoveryBit(r) {
                                return new Signature(this.r, this.s, r)
                            }
                            recoverPublicKey(r) {
                                let {
                                    r: et,
                                    s: eo,
                                    recovery: el
                                } = this, ec = ef((0, e$.ql)("msgHash", r));
                                if (null == el || ![0, 1, 2, 3].includes(el)) throw Error("recovery id invalid");
                                let ed = 2 === el || 3 === el ? et + l.n : et;
                                if (ed >= C.ORDER) throw Error("recovery id 2 or 3 invalid");
                                let eh = (1 & el) == 0 ? "02" : "03",
                                    ep = es.fromHex(eh + numToNByteStr(ed)),
                                    eg = invert(ed, U),
                                    ey = modN(-ec * eg),
                                    em = modN(eo * eg),
                                    e_ = es.BASE.multiplyAndAddUnsafe(ep, ey, em);
                                if (!e_) throw Error("point at infinify");
                                return e_.assertValidity(), e_
                            }
                            hasHighS() {
                                return isBiggerThanHalfOrder(this.s)
                            }
                            normalizeS() {
                                return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this
                            }
                            toDERRawBytes() {
                                return e$.hexToBytes(this.toDERHex())
                            }
                            toDERHex() {
                                return e0.hexFromSig({
                                    r: this.r,
                                    s: this.s
                                })
                            }
                            toCompactRawBytes() {
                                return e$.hexToBytes(this.toCompactHex())
                            }
                            toCompactHex() {
                                return numToNByteStr(this.r) + numToNByteStr(this.s)
                            }
                        };

                        function isProbPub(r) {
                            let l = r instanceof Uint8Array,
                                C = "string" == typeof r,
                                U = (l || C) && r.length;
                            return l ? U === et || U === eo : C ? U === 2 * et || U === 2 * eo : r instanceof es
                        }
                        let eh = l.bits2int || function(r) {
                                let C = e$.bytesToNumberBE(r),
                                    U = 8 * r.length - l.nBitLength;
                                return U > 0 ? C >> BigInt(U) : C
                            },
                            ef = l.bits2int_modN || function(r) {
                                return modN(eh(r))
                            },
                            ep = e$.dQ(l.nBitLength);

                        function int2octets(r) {
                            if ("bigint" != typeof r) throw Error("bigint expected");
                            if (!(e1 <= r && r < ep)) throw Error(`bigint expected < 2^${l.nBitLength}`);
                            return e$.tL(r, l.nByteLength)
                        }
                        let eg = {
                                lowS: l.lowS,
                                prehash: !1
                            },
                            ey = {
                                lowS: l.lowS,
                                prehash: !1
                            };
                        return es.BASE._setWindowSize(8), {
                            CURVE: l,
                            getPublicKey: function(r, l = !0) {
                                return es.fromPrivateKey(r).toRawBytes(l)
                            },
                            getSharedSecret: function(r, l, C = !0) {
                                if (isProbPub(r)) throw Error("first arg must be private key");
                                if (!isProbPub(l)) throw Error("second arg must be public key");
                                let U = es.fromHex(l);
                                return U.multiply(el(r)).toRawBytes(C)
                            },
                            sign: function(r, et, eo = eg) {
                                let {
                                    seed: ec,
                                    k2sig: ep
                                } = function(r, et, eo = eg) {
                                    if (["recovered", "canonical"].some(r => r in eo)) throw Error("sign() legacy options not supported");
                                    let {
                                        hash: ec,
                                        randomBytes: ep
                                    } = l, {
                                        lowS: ey,
                                        prehash: em,
                                        extraEntropy: e_
                                    } = eo;
                                    null == ey && (ey = !0), r = (0, e$.ql)("msgHash", r), em && (r = (0, e$.ql)("prehashed msgHash", ec(r)));
                                    let eb = ef(r),
                                        ew = el(et),
                                        eE = [int2octets(ew), int2octets(eb)];
                                    if (null != e_) {
                                        let r = !0 === e_ ? ep(C.BYTES) : e_;
                                        eE.push((0, e$.ql)("extraEntropy", r))
                                    }
                                    let eI = e$.eV(...eE);
                                    return {
                                        seed: eI,
                                        k2sig: function(r) {
                                            let l = eh(r);
                                            if (!ed(l)) return;
                                            let C = invert(l, U),
                                                et = es.BASE.multiply(l).toAffine(),
                                                eo = modN(et.x);
                                            if (eo === e1) return;
                                            let el = modN(C * modN(eb + eo * ew));
                                            if (el === e1) return;
                                            let ec = (et.x === eo ? 0 : 2) | Number(et.y & e2),
                                                ef = el;
                                            return ey && isBiggerThanHalfOrder(el) && (ef = isBiggerThanHalfOrder(el) ? modN(-el) : el, ec ^= 1), new Signature(eo, ef, ec)
                                        }
                                    }
                                }(r, et, eo), ey = e$.n$(l.hash.outputLen, l.nByteLength, l.hmac);
                                return ey(ec, ep)
                            },
                            verify: function(r, C, et, eo = ey) {
                                let el, ec;
                                if (C = (0, e$.ql)("msgHash", C), et = (0, e$.ql)("publicKey", et), "strict" in eo) throw Error("options.strict was renamed to lowS");
                                let {
                                    lowS: ed,
                                    prehash: eh
                                } = eo;
                                try {
                                    if ("string" == typeof r || r instanceof Uint8Array) try {
                                        ec = Signature.fromDER(r)
                                    } catch (l) {
                                        if (!(l instanceof e0.Err)) throw l;
                                        ec = Signature.fromCompact(r)
                                    } else if ("object" == typeof r && "bigint" == typeof r.r && "bigint" == typeof r.s) {
                                        let {
                                            r: l,
                                            s: C
                                        } = r;
                                        ec = new Signature(l, C)
                                    } else throw Error("PARSE");
                                    el = es.fromHex(et)
                                } catch (r) {
                                    if ("PARSE" === r.message) throw Error("signature must be Signature instance, Uint8Array or hex string");
                                    return !1
                                }
                                if (ed && ec.hasHighS()) return !1;
                                eh && (C = l.hash(C));
                                let {
                                    r: ep,
                                    s: eg
                                } = ec, em = ef(C), e_ = invert(eg, U), eb = modN(em * e_), ew = modN(ep * e_), eE = es.BASE.multiplyAndAddUnsafe(el, eb, ew) ? .toAffine();
                                if (!eE) return !1;
                                let eI = modN(eE.x);
                                return eI === ep
                            },
                            ProjectivePoint: es,
                            Signature,
                            utils: {
                                isValidPrivateKey(r) {
                                    try {
                                        return el(r), !0
                                    } catch (r) {
                                        return !1
                                    }
                                },
                                normPrivateKeyToScalar: el,
                                randomPrivateKey: () => {
                                    let r = getMinHashLength(l.n);
                                    return function(r, l, C = !1) {
                                        let U = r.length,
                                            et = getFieldBytesLength(l),
                                            eo = getMinHashLength(l);
                                        if (U < 16 || U < eo || U > 1024) throw Error(`expected ${eo}-1024 bytes of input, got ${U}`);
                                        let es = C ? (0, e$.bytesToNumberBE)(r) : (0, e$.ty)(r),
                                            el = modular_mod(es, l - eH) + eH;
                                        return C ? (0, e$.S5)(el, et) : (0, e$.tL)(el, et)
                                    }(l.randomBytes(r), l.n)
                                },
                                precompute: (r = 8, l = es.BASE) => (l._setWindowSize(r), l.multiply(BigInt(3)), l)
                            }
                        }
                    })({ ...r,
                        hash: l,
                        hmac: (r, ...C) => hmac(l, r, (0, eB.eV)(...C)),
                        randomBytes: eB.O6
                    });
                    return Object.freeze({ ...create(l),
                        create
                    })
                }({
                    a: BigInt(0),
                    b: BigInt(7),
                    Fp: e9,
                    n: e6,
                    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
                    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
                    h: BigInt(1),
                    lowS: !0,
                    endo: {
                        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
                        splitScalar: r => {
                            let l = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
                                C = -e8 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
                                U = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
                                et = BigInt("0x100000000000000000000000000000000"),
                                eo = divNearest(l * r, e6),
                                es = divNearest(-C * r, e6),
                                el = modular_mod(r - eo * l - es * U, e6),
                                ec = modular_mod(-eo * C - es * l, e6),
                                ed = el > et,
                                eh = ec > et;
                            if (ed && (el = e6 - el), eh && (ec = e6 - ec), el > et || ec > et) throw Error("splitScalar: Endomorphism failed, k=" + r);
                            return {
                                k1neg: ed,
                                k1: el,
                                k2neg: eh,
                                k2: ec
                            }
                        }
                    }
                }, ej);
            BigInt(0), e7.ProjectivePoint;
            var tn = C(17114),
                to = C(19473),
                ts = C(67771),
                ta = C(11239);
            let tl = ta.fetch;

            function base64url_bufferToBase64url(r) {
                let l = new Uint8Array(r),
                    C = "";
                for (let r of l) C += String.fromCharCode(r);
                let U = btoa(C),
                    et = U.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
                return et
            }
            let tc = "copy",
                td = "convert";

            function derived(r, l) {
                return {
                    required: !0,
                    schema: r,
                    derive: l
                }
            }

            function required(r) {
                return {
                    required: !0,
                    schema: r
                }
            }

            function optional(r) {
                return {
                    required: !1,
                    schema: r
                }
            }
            let th = {
                    appid: optional(tc),
                    appidExclude: optional(tc),
                    credProps: optional(tc)
                },
                tf = {
                    type: required(tc),
                    id: required(tc),
                    rawId: required(td),
                    authenticatorAttachment: optional(tc),
                    response: required({
                        clientDataJSON: required(td),
                        attestationObject: required(td),
                        transports: derived(tc, r => r.getTransports ? .() || [])
                    }),
                    clientExtensionResults: derived(th, r => r.getClientExtensionResults())
                };
            async function create(r) {
                let l = await navigator.credentials.create(r);
                return l.toJSON = () => (function convert_convert(r, l, C) {
                    if (l === tc) return C;
                    if (l === td) return r(C);
                    if (l instanceof Array) return C.map(C => convert_convert(r, l[0], C));
                    if (l instanceof Object) {
                        let U = {};
                        for (let [et, eo] of Object.entries(l)) {
                            if (eo.derive) {
                                let r = eo.derive(C);
                                void 0 !== r && (C[et] = r)
                            }
                            if (!(et in C)) {
                                if (eo.required) throw Error(`Missing key: ${et}`);
                                continue
                            }
                            if (null == C[et]) {
                                U[et] = null;
                                continue
                            }
                            U[et] = convert_convert(r, eo.schema, C[et])
                        }
                        return U
                    }
                })(base64url_bufferToBase64url, tf, l), l
            }

            function protocolTransportEnumToInternalEnum(r) {
                switch (r) {
                    case "internal":
                        return "AUTHENTICATOR_TRANSPORT_INTERNAL";
                    case "usb":
                        return "AUTHENTICATOR_TRANSPORT_USB";
                    case "nfc":
                        return "AUTHENTICATOR_TRANSPORT_NFC";
                    case "ble":
                        return "AUTHENTICATOR_TRANSPORT_BLE";
                    case "hybrid":
                        return "AUTHENTICATOR_TRANSPORT_HYBRID";
                    default:
                        throw Error("unsupported transport format")
                }
            }
            async function getWebAuthnAttestation(r) {
                var l;
                let C = !!window.PublicKeyCredential;
                if (!C) throw Error("webauthn is not supported by this browser");
                let U = await create(r);
                return {
                    credentialId: (l = U.toJSON()).rawId,
                    attestationObject: l.response.attestationObject,
                    clientDataJson: l.response.clientDataJSON,
                    transports: l.response.transports.map(protocolTransportEnumToInternalEnum)
                }
            }
            required(tc), required(tc), required(td), optional(tc), required({
                clientDataJSON: required(td),
                authenticatorData: required(td),
                signature: required(td),
                userHandle: required(td)
            }), derived(th, r => r.getClientExtensionResults()), C(97115).Buffer;
            let TurnkeyRequestError = class TurnkeyRequestError extends Error {
                constructor(r) {
                    let l = `Turnkey error ${r.code}: ${r.message}`;
                    null != r.details && (l += ` (Details: ${JSON.stringify(r.details)})`), super(l), this.name = "TurnkeyRequestError", this.details = r.details ? ? null, this.code = r.code
                }
            };
            let public_api_client_TurnkeyClient = class public_api_client_TurnkeyClient {
                constructor(r, l) {
                    if (this.getActivity = async r => this.request("/public/v1/query/get_activity", r), this.stampGetActivity = async r => {
                            let l = this.config.baseUrl + "/public/v1/query/get_activity",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.getApiKey = async r => this.request("/public/v1/query/get_api_key", r), this.stampGetApiKey = async r => {
                            let l = this.config.baseUrl + "/public/v1/query/get_api_key",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.getApiKeys = async r => this.request("/public/v1/query/get_api_keys", r), this.stampGetApiKeys = async r => {
                            let l = this.config.baseUrl + "/public/v1/query/get_api_keys",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.getAuthenticator = async r => this.request("/public/v1/query/get_authenticator", r), this.stampGetAuthenticator = async r => {
                            let l = this.config.baseUrl + "/public/v1/query/get_authenticator",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.getAuthenticators = async r => this.request("/public/v1/query/get_authenticators", r), this.stampGetAuthenticators = async r => {
                            let l = this.config.baseUrl + "/public/v1/query/get_authenticators",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.getOrganization = async r => this.request("/public/v1/query/get_organization", r), this.stampGetOrganization = async r => {
                            let l = this.config.baseUrl + "/public/v1/query/get_organization",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.getPolicy = async r => this.request("/public/v1/query/get_policy", r), this.stampGetPolicy = async r => {
                            let l = this.config.baseUrl + "/public/v1/query/get_policy",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.getPrivateKey = async r => this.request("/public/v1/query/get_private_key", r), this.stampGetPrivateKey = async r => {
                            let l = this.config.baseUrl + "/public/v1/query/get_private_key",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.getUser = async r => this.request("/public/v1/query/get_user", r), this.stampGetUser = async r => {
                            let l = this.config.baseUrl + "/public/v1/query/get_user",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.getWallet = async r => this.request("/public/v1/query/get_wallet", r), this.stampGetWallet = async r => {
                            let l = this.config.baseUrl + "/public/v1/query/get_wallet",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.getActivities = async r => this.request("/public/v1/query/list_activities", r), this.stampGetActivities = async r => {
                            let l = this.config.baseUrl + "/public/v1/query/list_activities",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.getPolicies = async r => this.request("/public/v1/query/list_policies", r), this.stampGetPolicies = async r => {
                            let l = this.config.baseUrl + "/public/v1/query/list_policies",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.listPrivateKeyTags = async r => this.request("/public/v1/query/list_private_key_tags", r), this.stampListPrivateKeyTags = async r => {
                            let l = this.config.baseUrl + "/public/v1/query/list_private_key_tags",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.getPrivateKeys = async r => this.request("/public/v1/query/list_private_keys", r), this.stampGetPrivateKeys = async r => {
                            let l = this.config.baseUrl + "/public/v1/query/list_private_keys",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.listUserTags = async r => this.request("/public/v1/query/list_user_tags", r), this.stampListUserTags = async r => {
                            let l = this.config.baseUrl + "/public/v1/query/list_user_tags",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.getUsers = async r => this.request("/public/v1/query/list_users", r), this.stampGetUsers = async r => {
                            let l = this.config.baseUrl + "/public/v1/query/list_users",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.getWalletAccounts = async r => this.request("/public/v1/query/list_wallet_accounts", r), this.stampGetWalletAccounts = async r => {
                            let l = this.config.baseUrl + "/public/v1/query/list_wallet_accounts",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.getWallets = async r => this.request("/public/v1/query/list_wallets", r), this.stampGetWallets = async r => {
                            let l = this.config.baseUrl + "/public/v1/query/list_wallets",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.getWhoami = async r => this.request("/public/v1/query/whoami", r), this.stampGetWhoami = async r => {
                            let l = this.config.baseUrl + "/public/v1/query/whoami",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.approveActivity = async r => this.request("/public/v1/submit/approve_activity", r), this.stampApproveActivity = async r => {
                            let l = this.config.baseUrl + "/public/v1/submit/approve_activity",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.createApiKeys = async r => this.request("/public/v1/submit/create_api_keys", r), this.stampCreateApiKeys = async r => {
                            let l = this.config.baseUrl + "/public/v1/submit/create_api_keys",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.createApiOnlyUsers = async r => this.request("/public/v1/submit/create_api_only_users", r), this.stampCreateApiOnlyUsers = async r => {
                            let l = this.config.baseUrl + "/public/v1/submit/create_api_only_users",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.createAuthenticators = async r => this.request("/public/v1/submit/create_authenticators", r), this.stampCreateAuthenticators = async r => {
                            let l = this.config.baseUrl + "/public/v1/submit/create_authenticators",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.createInvitations = async r => this.request("/public/v1/submit/create_invitations", r), this.stampCreateInvitations = async r => {
                            let l = this.config.baseUrl + "/public/v1/submit/create_invitations",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.createPolicy = async r => this.request("/public/v1/submit/create_policy", r), this.stampCreatePolicy = async r => {
                            let l = this.config.baseUrl + "/public/v1/submit/create_policy",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.createPrivateKeyTag = async r => this.request("/public/v1/submit/create_private_key_tag", r), this.stampCreatePrivateKeyTag = async r => {
                            let l = this.config.baseUrl + "/public/v1/submit/create_private_key_tag",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.createPrivateKeys = async r => this.request("/public/v1/submit/create_private_keys", r), this.stampCreatePrivateKeys = async r => {
                            let l = this.config.baseUrl + "/public/v1/submit/create_private_keys",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.createSubOrganization = async r => this.request("/public/v1/submit/create_sub_organization", r), this.stampCreateSubOrganization = async r => {
                            let l = this.config.baseUrl + "/public/v1/submit/create_sub_organization",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.createUserTag = async r => this.request("/public/v1/submit/create_user_tag", r), this.stampCreateUserTag = async r => {
                            let l = this.config.baseUrl + "/public/v1/submit/create_user_tag",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.createUsers = async r => this.request("/public/v1/submit/create_users", r), this.stampCreateUsers = async r => {
                            let l = this.config.baseUrl + "/public/v1/submit/create_users",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.createWallet = async r => this.request("/public/v1/submit/create_wallet", r), this.stampCreateWallet = async r => {
                            let l = this.config.baseUrl + "/public/v1/submit/create_wallet",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.createWalletAccounts = async r => this.request("/public/v1/submit/create_wallet_accounts", r), this.stampCreateWalletAccounts = async r => {
                            let l = this.config.baseUrl + "/public/v1/submit/create_wallet_accounts",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.deleteApiKeys = async r => this.request("/public/v1/submit/delete_api_keys", r), this.stampDeleteApiKeys = async r => {
                            let l = this.config.baseUrl + "/public/v1/submit/delete_api_keys",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.deleteAuthenticators = async r => this.request("/public/v1/submit/delete_authenticators", r), this.stampDeleteAuthenticators = async r => {
                            let l = this.config.baseUrl + "/public/v1/submit/delete_authenticators",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.deleteInvitation = async r => this.request("/public/v1/submit/delete_invitation", r), this.stampDeleteInvitation = async r => {
                            let l = this.config.baseUrl + "/public/v1/submit/delete_invitation",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.deletePolicy = async r => this.request("/public/v1/submit/delete_policy", r), this.stampDeletePolicy = async r => {
                            let l = this.config.baseUrl + "/public/v1/submit/delete_policy",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.emailAuth = async r => this.request("/public/v1/submit/email_auth", r), this.stampEmailAuth = async r => {
                            let l = this.config.baseUrl + "/public/v1/submit/email_auth",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.exportPrivateKey = async r => this.request("/public/v1/submit/export_private_key", r), this.stampExportPrivateKey = async r => {
                            let l = this.config.baseUrl + "/public/v1/submit/export_private_key",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.exportWallet = async r => this.request("/public/v1/submit/export_wallet", r), this.stampExportWallet = async r => {
                            let l = this.config.baseUrl + "/public/v1/submit/export_wallet",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.exportWalletAccount = async r => this.request("/public/v1/submit/export_wallet_account", r), this.stampExportWalletAccount = async r => {
                            let l = this.config.baseUrl + "/public/v1/submit/export_wallet_account",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.initUserEmailRecovery = async r => this.request("/public/v1/submit/init_user_email_recovery", r), this.stampInitUserEmailRecovery = async r => {
                            let l = this.config.baseUrl + "/public/v1/submit/init_user_email_recovery",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.recoverUser = async r => this.request("/public/v1/submit/recover_user", r), this.stampRecoverUser = async r => {
                            let l = this.config.baseUrl + "/public/v1/submit/recover_user",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.rejectActivity = async r => this.request("/public/v1/submit/reject_activity", r), this.stampRejectActivity = async r => {
                            let l = this.config.baseUrl + "/public/v1/submit/reject_activity",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.removeOrganizationFeature = async r => this.request("/public/v1/submit/remove_organization_feature", r), this.stampRemoveOrganizationFeature = async r => {
                            let l = this.config.baseUrl + "/public/v1/submit/remove_organization_feature",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.setOrganizationFeature = async r => this.request("/public/v1/submit/set_organization_feature", r), this.stampSetOrganizationFeature = async r => {
                            let l = this.config.baseUrl + "/public/v1/submit/set_organization_feature",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.signRawPayload = async r => this.request("/public/v1/submit/sign_raw_payload", r), this.stampSignRawPayload = async r => {
                            let l = this.config.baseUrl + "/public/v1/submit/sign_raw_payload",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.signTransaction = async r => this.request("/public/v1/submit/sign_transaction", r), this.stampSignTransaction = async r => {
                            let l = this.config.baseUrl + "/public/v1/submit/sign_transaction",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.updatePolicy = async r => this.request("/public/v1/submit/update_policy", r), this.stampUpdatePolicy = async r => {
                            let l = this.config.baseUrl + "/public/v1/submit/update_policy",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.updatePrivateKeyTag = async r => this.request("/public/v1/submit/update_private_key_tag", r), this.stampUpdatePrivateKeyTag = async r => {
                            let l = this.config.baseUrl + "/public/v1/submit/update_private_key_tag",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.updateRootQuorum = async r => this.request("/public/v1/submit/update_root_quorum", r), this.stampUpdateRootQuorum = async r => {
                            let l = this.config.baseUrl + "/public/v1/submit/update_root_quorum",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.updateUser = async r => this.request("/public/v1/submit/update_user", r), this.stampUpdateUser = async r => {
                            let l = this.config.baseUrl + "/public/v1/submit/update_user",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, this.updateUserTag = async r => this.request("/public/v1/submit/update_user_tag", r), this.stampUpdateUserTag = async r => {
                            let l = this.config.baseUrl + "/public/v1/submit/update_user_tag",
                                C = JSON.stringify(r),
                                U = await this.stamper.stamp(C);
                            return {
                                body: C,
                                stamp: U,
                                url: l
                            }
                        }, !r.baseUrl) throw Error("Missing base URL. Please verify env vars.");
                    this.config = r, this.stamper = l
                }
                async request(r, l) {
                    let C = this.config.baseUrl + r,
                        U = JSON.stringify(l),
                        et = await this.stamper.stamp(U),
                        eo = await tl(C, {
                            method: "POST",
                            headers: {
                                [et.stampHeaderName]: et.stampHeaderValue,
                                "X-Client-Version": "@turnkey/http@2.6.2"
                            },
                            body: U,
                            redirect: "follow"
                        });
                    if (!eo.ok) {
                        let r;
                        try {
                            r = await eo.json()
                        } catch (r) {
                            throw Error(`${eo.status} ${eo.statusText}`)
                        }
                        throw new TurnkeyRequestError(r)
                    }
                    let es = await eo.json();
                    return es
                }
            };
            let shared_TurnkeyActivityError = class shared_TurnkeyActivityError extends Error {
                constructor(r) {
                    let {
                        message: l,
                        cause: C,
                        activityId: U,
                        activityStatus: et,
                        activityType: eo
                    } = r;
                    super(l), this.name = "TurnkeyActivityError", this.activityId = U ? ? null, this.activityStatus = et ? ? null, this.activityType = eo ? ? null, this.cause = C ? ? null
                }
            };
            async function createAccount(r) {
                let {
                    client: l,
                    organizationId: C,
                    signWith: U
                } = r, {
                    ethereumAddress: et
                } = r;
                if (!U) throw new shared_TurnkeyActivityError({
                    message: "Missing signWith parameter"
                });
                if ((0, eN.U)(U)) et = U;
                else if (!et) {
                    let r = await l.getPrivateKey({
                        privateKeyId: U,
                        organizationId: C
                    });
                    if ("string" != typeof(et = r.privateKey.addresses.find(r => "ADDRESS_FORMAT_ETHEREUM" === r.format) ? .address) || !et) throw new shared_TurnkeyActivityError({
                        message: `Unable to find Ethereum address for key ${U} under organization ${C}`
                    })
                }
                return (0, ts.A)({
                    address: et,
                    signMessage: function({
                        message: r
                    }) {
                        return signMessage(l, r, C, U)
                    },
                    signTransaction: function(r, et) {
                        let eo = et ? .serializer ? et.serializer : eO.D;
                        return dist_signTransaction(l, r, eo, C, U)
                    },
                    signTypedData: function(r) {
                        return signTypedData(l, r, C, U)
                    }
                })
            }
            async function signMessage(r, l, C, U) {
                let et = (0, eT.r)(l),
                    eo = await signMessageWithErrorWrapping(r, et, C, U);
                return `${eo}`
            }
            async function dist_signTransaction(r, l, C, U, et) {
                let eo = C(l),
                    es = eo.replace(/^0x/, "");
                return await signTransactionWithErrorWrapping(r, es, U, et)
            }
            async function signTypedData(r, l, C, U) {
                let et = (0, eR.J)(l);
                return await signMessageWithErrorWrapping(r, et, C, U)
            }
            async function signTransactionWithErrorWrapping(r, l, C, U) {
                let et;
                try {
                    et = await signTransactionImpl(r, l, C, U)
                } catch (r) {
                    if (r instanceof shared_TurnkeyActivityError) throw r;
                    throw new shared_TurnkeyActivityError({
                        message: `Failed to sign transaction: ${r.message}`,
                        cause: r
                    })
                }
                return `0x${et}`
            }
            async function signTransactionImpl(r, l, C, U) {
                let {
                    activity: et
                } = await r.signTransaction({
                    type: "ACTIVITY_TYPE_SIGN_TRANSACTION_V2",
                    organizationId: C,
                    parameters: {
                        signWith: U,
                        type: "TRANSACTION_TYPE_ETHEREUM",
                        unsignedTransaction: l
                    },
                    timestampMs: String(Date.now())
                }), {
                    id: eo,
                    status: es,
                    type: el
                } = et;
                if ("ACTIVITY_STATUS_COMPLETED" === et.status) return assertNonNull(et ? .result ? .signTransactionResult ? .signedTransaction);
                throw new shared_TurnkeyActivityError({
                    message: `Invalid activity status: ${et.status}`,
                    activityId: eo,
                    activityStatus: es,
                    activityType: el
                })
            }
            async function signMessageWithErrorWrapping(r, l, C, U) {
                let et;
                try {
                    et = await signMessageImpl(r, l, C, U)
                } catch (r) {
                    if (r instanceof shared_TurnkeyActivityError) throw r;
                    throw new shared_TurnkeyActivityError({
                        message: `Failed to sign: ${r.message}`,
                        cause: r
                    })
                }
                return et
            }
            async function signMessageImpl(r, l, C, U) {
                let {
                    activity: et
                } = await r.signRawPayload({
                    type: "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2",
                    organizationId: C,
                    parameters: {
                        signWith: U,
                        payload: l,
                        encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
                        hashFunction: "HASH_FUNCTION_NO_OP"
                    },
                    timestampMs: String(Date.now())
                }), {
                    id: eo,
                    status: es,
                    type: el
                } = et;
                if ("ACTIVITY_STATUS_COMPLETED" === et.status) {
                    let r = assertNonNull(et ? .result ? .signRawPayloadResult);
                    return assertNonNull(function({
                        r,
                        s: l,
                        v: C
                    }) {
                        return `0x${new e7.Signature((0,tn.y_)(r),(0,tn.y_)(l)).toCompactHex()}${(0,to.NC)(C).slice(2)}`
                    }({
                        r: `0x${r.r}`,
                        s: `0x${r.s}`,
                        v: "00" === r.v ? 27 n : 28 n
                    }))
                }
                throw new shared_TurnkeyActivityError({
                    message: `Invalid activity status: ${et.status}`,
                    activityId: eo,
                    activityStatus: es,
                    activityType: el
                })
            }

            function assertNonNull(r) {
                if (null == r) throw Error(`Got unexpected ${JSON.stringify(r)}`);
                return r
            }(es = el || (el = {})).PublicKeyReady = "PUBLIC_KEY_READY", es.InjectCredentialBundle = "INJECT_CREDENTIAL_BUNDLE", es.InjectKeyExportBundle = "INJECT_KEY_EXPORT_BUNDLE", es.InjectWalletExportBundle = "INJECT_WALLET_EXPORT_BUNDLE", es.BundleInjected = "BUNDLE_INJECTED", es.StampRequest = "STAMP_REQUEST", es.Stamp = "STAMP", es.Error = "ERROR";
            let IframeStamper = class IframeStamper {
                constructor(r) {
                    if ("undefined" == typeof window) throw Error("Cannot initialize iframe in non-browser environment");
                    if (!r.iframeContainer) throw Error("Iframe container cannot be found");
                    if (this.container = r.iframeContainer, this.container.querySelector(`#${r.iframeElementId}`)) throw Error(`Iframe element with ID ${r.iframeElementId} already exists`);
                    let l = window.document.createElement("iframe");
                    l.id = r.iframeElementId, l.src = r.iframeUrl, this.iframe = l;
                    let C = new URL(r.iframeUrl);
                    this.iframeOrigin = C.origin, this.iframePublicKey = null
                }
                async init() {
                    return this.container.appendChild(this.iframe), new Promise((r, l) => {
                        window.addEventListener("message", l => {
                            l.origin === this.iframeOrigin && l.data ? .type === el.PublicKeyReady && (this.iframePublicKey = l.data.value, r(l.data.value))
                        }, !1)
                    })
                }
                clear() {
                    this.iframe.remove()
                }
                publicKey() {
                    return this.iframePublicKey
                }
                async injectCredentialBundle(r) {
                    return new Promise((l, C) => {
                        this.iframe.contentWindow ? .postMessage({
                            type: el.InjectCredentialBundle,
                            value: r
                        }, "*"), window.addEventListener("message", r => {
                            r.origin === this.iframeOrigin && (r.data ? .type === el.BundleInjected && l(r.data.value), r.data ? .type === el.Error && C(r.data.value))
                        }, !1)
                    })
                }
                async injectKeyExportBundle(r) {
                    return this.iframe.contentWindow ? .postMessage({
                        type: el.InjectKeyExportBundle,
                        value: r
                    }, "*"), new Promise((r, l) => {
                        window.addEventListener("message", C => {
                            C.origin === this.iframeOrigin && (C.data ? .type === el.BundleInjected && r(C.data.value), C.data ? .type === el.Error && l(C.data.value))
                        }, !1)
                    })
                }
                async injectWalletExportBundle(r) {
                    return this.iframe.contentWindow ? .postMessage({
                        type: el.InjectWalletExportBundle,
                        value: r
                    }, "*"), new Promise((r, l) => {
                        window.addEventListener("message", C => {
                            C.origin === this.iframeOrigin && (C.data ? .type === el.BundleInjected && r(C.data.value), C.data ? .type === el.Error && l(C.data.value))
                        }, !1)
                    })
                }
                async stamp(r) {
                    if (null === this.iframePublicKey) throw Error("null iframe public key. Have you called/awaited .init()?");
                    let l = this.iframeOrigin;
                    return this.iframe.contentWindow ? .postMessage({
                        type: el.StampRequest,
                        value: r
                    }, "*"), new Promise(function(r, C) {
                        window.addEventListener("message", U => {
                            U.origin === l && (U.data ? .type === el.Stamp && r({
                                stampHeaderName: "X-Stamp",
                                stampHeaderValue: U.data.value
                            }), U.data ? .type === el.Error && C(U.data.value))
                        }, !1)
                    })
                }
            };

            function webauthn_json_base64url_bufferToBase64url(r) {
                let l = new Uint8Array(r),
                    C = "";
                for (let r of l) C += String.fromCharCode(r);
                let U = btoa(C),
                    et = U.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
                return et
            }
            let tp = "copy",
                tg = "convert";

            function convert_required(r) {
                return {
                    required: !0,
                    schema: r
                }
            }

            function convert_optional(r) {
                return {
                    required: !1,
                    schema: r
                }
            }
            let ty = {
                    appid: convert_optional(tp),
                    appidExclude: convert_optional(tp),
                    credProps: convert_optional(tp)
                },
                tm = {
                    type: convert_required(tp),
                    id: convert_required(tp),
                    rawId: convert_required(tg),
                    authenticatorAttachment: convert_optional(tp),
                    response: convert_required({
                        clientDataJSON: convert_required(tg),
                        authenticatorData: convert_required(tg),
                        signature: convert_required(tg),
                        userHandle: convert_required(tg)
                    }),
                    clientExtensionResults: {
                        required: !0,
                        schema: ty,
                        derive: r => r.getClientExtensionResults()
                    }
                };
            async function dist_webauthn_json_get(r) {
                let l = await navigator.credentials.get(r);
                return l.toJSON = () => (function webauthn_json_convert_convert(r, l, C) {
                    if (l === tp) return C;
                    if (l === tg) return r(C);
                    if (l instanceof Array) return C.map(C => webauthn_json_convert_convert(r, l[0], C));
                    if (l instanceof Object) {
                        let U = {};
                        for (let [et, eo] of Object.entries(l)) {
                            if (eo.derive) {
                                let r = eo.derive(C);
                                void 0 !== r && (C[et] = r)
                            }
                            if (!(et in C)) {
                                if (eo.required) throw Error(`Missing key: ${et}`);
                                continue
                            }
                            if (null == C[et]) {
                                U[et] = null;
                                continue
                            }
                            U[et] = webauthn_json_convert_convert(r, eo.schema, C[et])
                        }
                        return U
                    }
                })(webauthn_json_base64url_bufferToBase64url, tm, l), l
            }
            U = void 0 !== globalThis ? .Buffer ? globalThis.Buffer : ex.Buffer;
            var t_ = C(70697);
            let WebauthnStamper = class WebauthnStamper {
                constructor(r) {
                    this.rpId = r.rpId, this.timeout = r.timeout || 3e5, this.userVerification = r.userVerification || "preferred", this.allowCredentials = r.allowCredentials || []
                }
                async stamp(r) {
                    let l = function(r) {
                            let l = new TextEncoder().encode(r),
                                C = (0, t_.J)(l),
                                et = U.from(C).toString("hex"),
                                eo = U.from(et, "utf8");
                            return new Uint8Array(eo)
                        }(r),
                        C = {
                            publicKey: {
                                rpId: this.rpId,
                                challenge: l,
                                allowCredentials: this.allowCredentials,
                                timeout: this.timeout,
                                userVerification: this.userVerification
                            }
                        },
                        et = await dist_webauthn_json_get(C),
                        eo = et.toJSON(),
                        es = {
                            authenticatorData: eo.response.authenticatorData,
                            clientDataJson: eo.response.clientDataJSON,
                            credentialId: eo.id,
                            signature: eo.response.signature
                        };
                    return {
                        stampHeaderName: "X-Stamp-Webauthn",
                        stampHeaderValue: JSON.stringify(es)
                    }
                }
            };
            var tb = C(47969),
                tw = C(35749),
                tE = C(32663),
                tI = C(70769);
            let findTurnkeyVerifiedCredential = (r, l) => null == r ? void 0 : r.find(({
                    walletName: r,
                    chain: C
                }) => (null == r ? void 0 : r.startsWith("turnkey")) && l === C),
                tS = {
                    AUTHENTICATOR_TRANSPORT_BLE: eA.lfg.Ble,
                    AUTHENTICATOR_TRANSPORT_HYBRID: eA.lfg.Hybrid,
                    AUTHENTICATOR_TRANSPORT_INTERNAL: eA.lfg.Internal,
                    AUTHENTICATOR_TRANSPORT_NFC: eA.lfg.Nfc,
                    AUTHENTICATOR_TRANSPORT_USB: eA.lfg.Usb
                },
                convertAttestationTransports = r => r.map(r => tS[r]);
            var tx = C(77771),
                tA = C(20924),
                tP = C(97115).Buffer;
            let base64UrlEncode = r => tP.from(r).toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, ""),
                generateRandomBuffer = () => {
                    let r = new Uint8Array(32);
                    return crypto.getRandomValues(r), r.buffer
                },
                tC = new class {
                    constructor() {
                        this.isSessionActive = () => {
                            if (!this.__createdAt || "email" !== this.__recoveryType) return !1;
                            let r = this.isExpired(this.__createdAt, this.__sessionExpiration || 1800);
                            return !r || (this.clear(), !1)
                        }, this.isValidCode = r => __awaiter(this, void 0, void 0, function*() {
                            var l, C, U, et;
                            if (!r || !this.__turnkeyRecoveryUserId) throw new tE.kW("Cannot proceed with your request");
                            let eo = yield null === (l = this.__client) || void 0 === l ? void 0 : l.getUser({
                                organizationId: r,
                                userId: this.__turnkeyRecoveryUserId
                            }), es = {
                                email: "CREDENTIAL_TYPE_API_KEY_P256",
                                passkey: "CREDENTIAL_TYPE_RECOVER_USER_KEY_P256"
                            }, el = null === (et = null === (U = null === (C = null == eo ? void 0 : eo.user) || void 0 === C ? void 0 : C.apiKeys) || void 0 === U ? void 0 : U.filter(r => r.credential.type === es[this.__recoveryType])) || void 0 === et ? void 0 : et.pop();
                            if (!el) return !1;
                            let ec = this.isExpired(parseInt(el.createdAt.seconds, 10), 900);
                            return !ec && (this.__createdAt = parseInt(el.createdAt.seconds, 10), !0)
                        }), this.isExpired = (r, l) => {
                            let C = new Date(1e3 * (r + l));
                            return new Date >= C
                        }
                    }
                    get publicKey() {
                        return this.__publicKey
                    }
                    get client() {
                        return this.__client
                    }
                    get recoveryType() {
                        return this.__recoveryType
                    }
                    get recoveryUserId() {
                        return this.__turnkeyRecoveryUserId || ""
                    }
                    set recoveryUserId(r) {
                        this.__turnkeyRecoveryUserId = r
                    }
                    clear() {
                        var r;
                        null === (r = this.__iframeStamper) || void 0 === r || r.clear(), this.__recoveryType = void 0, this.__iframeStamper = void 0, this.__publicKey = void 0, this.__client = void 0, this.__turnkeyRecoveryUserId = void 0, this.__createdAt = void 0
                    }
                    initRecovery(r, l, C, U) {
                        return __awaiter(this, void 0, void 0, function*() {
                            return this.__recoveryType && this.clear(), this.__sessionExpiration = U, this.__recoveryType = r, this.__iframeStamper = new IframeStamper({
                                iframeContainer: l,
                                iframeElementId: C,
                                iframeUrl: "passkey" === r ? "https://recovery.turnkey.com" : "https://auth.turnkey.com"
                            }), yield this.__iframeStamper.init(), this.__publicKey = this.__iframeStamper.publicKey(), this.__publicKey
                        })
                    }
                    verifyRecoveryCode(r, l) {
                        return __awaiter(this, void 0, void 0, function*() {
                            if (!this.__iframeStamper) throw new tE.kW("Cannot proceed with your request");
                            try {
                                if (yield this.__iframeStamper.injectCredentialBundle(r), this.__client = new public_api_client_TurnkeyClient({
                                        baseUrl: "https://api.turnkey.com"
                                    }, this.__iframeStamper), !l || !this.__turnkeyRecoveryUserId) throw new tE.kW("Cannot proceed with your request");
                                if (!(yield this.isValidCode(l))) throw new tE.kW("The code is invalid or expired.")
                            } catch (r) {
                                if (tb.kg.error("Error while verifying recovery code", r), r instanceof tE.kW) throw r;
                                throw new tE.kW("The code is invalid or expired.")
                            }
                        })
                    }
                    completeRecovery({
                        attestation: r,
                        challenge: l,
                        organizationId: C
                    }) {
                        return __awaiter(this, void 0, void 0, function*() {
                            if (!this.__client || !this.__turnkeyRecoveryUserId) throw new tE.kW("Cannot proceed with your request");
                            try {
                                return this.__client.recoverUser({
                                    organizationId: C,
                                    parameters: {
                                        authenticator: {
                                            attestation: r,
                                            authenticatorName: "Passkey",
                                            challenge: l
                                        },
                                        userId: this.__turnkeyRecoveryUserId
                                    },
                                    timestampMs: String(Date.now()),
                                    type: "ACTIVITY_TYPE_RECOVER_USER"
                                })
                            } catch (r) {
                                throw tb.kg.error("Error while completing recovery process", r), r
                            }
                        })
                    }
                    addPasskeyAuthenticator({
                        attestation: r,
                        challenge: l,
                        organizationId: C
                    }) {
                        return __awaiter(this, void 0, void 0, function*() {
                            if (!this.__client || !this.__turnkeyRecoveryUserId) throw new tE.kW("Cannot proceed with your request");
                            try {
                                return this.__client.createAuthenticators({
                                    organizationId: C,
                                    parameters: {
                                        authenticators: [{
                                            attestation: r,
                                            authenticatorName: "Passkey",
                                            challenge: l
                                        }],
                                        userId: this.__turnkeyRecoveryUserId
                                    },
                                    timestampMs: String(Date.now()),
                                    type: "ACTIVITY_TYPE_CREATE_AUTHENTICATORS_V2"
                                })
                            } catch (r) {
                                throw tb.kg.error("Error while creating new authenticator", r), r
                            }
                        })
                    }
                };
            let ExportHandler = class ExportHandler {
                get publicKey() {
                    return this.__publicKey
                }
                clear() {
                    var r;
                    null === (r = this.__iframeStamper) || void 0 === r || r.clear(), this.__iframeStamper = void 0, this.__publicKey = void 0, this.__passKeyClient = void 0
                }
                initExport(r, l) {
                    return __awaiter(this, void 0, void 0, function*() {
                        this.__iframeStamper = new IframeStamper({
                            iframeContainer: r,
                            iframeElementId: l,
                            iframeUrl: "https://export.turnkey.com"
                        }), yield this.__iframeStamper.init(), this.__publicKey = this.__iframeStamper.publicKey();
                        let C = (0, tE.KT)();
                        C || (C = window.location.hostname);
                        let U = new WebauthnStamper({
                            rpId: C
                        });
                        return this.__passKeyClient = new public_api_client_TurnkeyClient({
                            baseUrl: "https://api.turnkey.com"
                        }, U), this.__publicKey
                    })
                }
                verifyExportWallet(r) {
                    return __awaiter(this, void 0, void 0, function*() {
                        if (!this.__iframeStamper) throw new tE.kW("Cannot proceed with your request");
                        try {
                            return yield this.__iframeStamper.injectWalletExportBundle(r)
                        } catch (r) {
                            throw tb.kg.error("Error while verifying export wallet", r), r
                        }
                    })
                }
                verifyExportPrivateKey(r) {
                    return __awaiter(this, void 0, void 0, function*() {
                        if (!this.__iframeStamper) throw new tE.kW("Cannot proceed with your request");
                        try {
                            return yield this.__iframeStamper.injectKeyExportBundle(r)
                        } catch (r) {
                            throw tb.kg.error("Error while verifying export private key", r), r
                        }
                    })
                }
                exportPrivateKey({
                    privateKeyId: r,
                    organizationId: l
                }) {
                    return __awaiter(this, void 0, void 0, function*() {
                        if (!this.__iframeStamper || !this.__publicKey || !this.__passKeyClient || !r) throw new tE.kW("Cannot proceed with your request");
                        try {
                            let C = yield this.__passKeyClient.exportPrivateKey({
                                organizationId: l,
                                parameters: {
                                    privateKeyId: r,
                                    targetPublicKey: this.__publicKey
                                },
                                timestampMs: String(Date.now()),
                                type: "ACTIVITY_TYPE_EXPORT_PRIVATE_KEY"
                            });
                            return C.activity
                        } catch (r) {
                            throw tb.kg.error("Error while completing export private key process", r), r
                        }
                    })
                }
                exportWallet({
                    walletId: r,
                    organizationId: l,
                    address: C
                }) {
                    return __awaiter(this, void 0, void 0, function*() {
                        if (!this.__iframeStamper || !this.__publicKey || !this.__passKeyClient || !r) throw new tE.kW("Cannot proceed with your request");
                        try {
                            if (C) {
                                let r = yield this.__passKeyClient.exportWalletAccount({
                                    organizationId: l,
                                    parameters: {
                                        address: C,
                                        targetPublicKey: this.__publicKey
                                    },
                                    timestampMs: String(Date.now()),
                                    type: "ACTIVITY_TYPE_EXPORT_WALLET_ACCOUNT"
                                });
                                return r.activity
                            }
                            let U = yield this.__passKeyClient.exportWallet({
                                organizationId: l,
                                parameters: {
                                    targetPublicKey: this.__publicKey,
                                    walletId: r
                                },
                                timestampMs: String(Date.now()),
                                type: "ACTIVITY_TYPE_EXPORT_WALLET"
                            });
                            return U.activity
                        } catch (r) {
                            throw tb.kg.error("Error while completing export wallet process", r), r
                        }
                    })
                }
            };
            let TurnkeyWalletConnectorBase = class TurnkeyWalletConnectorBase extends tb.VY {
                constructor(r, l) {
                    if (super(l), this.canConnectViaEmail = !1, this.isEmbeddedWallet = !0, !l.appName) throw Error("appName not set");
                    this.name = r.name, this.overrideKey = r.key, this.appName = l.appName, this.__authenticatorMethodHandler = tC, this.__exportHandler = new ExportHandler
                }
                getWebAuthnAttestation() {
                    return __awaiter(this, void 0, void 0, function*() {
                        let r;
                        let l = generateRandomBuffer(),
                            C = generateRandomBuffer(),
                            {
                                email: U
                            } = this;
                        if (!U) throw Error("Email not set");
                        let et = {
                            publicKey: {
                                authenticatorSelection: {
                                    authenticatorAttachment: void 0,
                                    requireResidentKey: !1,
                                    residentKey: "preferred",
                                    userVerification: "discouraged"
                                },
                                challenge: l,
                                pubKeyCredParams: [{
                                    alg: -7,
                                    type: "public-key"
                                }],
                                rp: {
                                    id: (0, tE.KT)(),
                                    name: this.appName
                                },
                                user: {
                                    displayName: U,
                                    id: C,
                                    name: U
                                }
                            }
                        };
                        try {
                            r = yield getWebAuthnAttestation(et)
                        } catch (l) {
                            tb.kg.warn(`Unable to register webauthn credential on the current page's TLD ${(0,tE.KT)()}. Falling back to using hostname. ${window.location.hostname}`, l), et.publicKey.rp.id = window.location.hostname, r = yield getWebAuthnAttestation(et)
                        }
                        return {
                            attestation: {
                                attestationObject: r.attestationObject,
                                clientDataJson: r.clientDataJson,
                                credentialId: r.credentialId,
                                transports: convertAttestationTransports(r.transports)
                            },
                            challenge: base64UrlEncode(l)
                        }
                    })
                }
                getAuthenticatorHandler() {
                    return this.__authenticatorMethodHandler
                }
                getExportHandler() {
                    return this.__exportHandler
                }
                get email() {
                    return this._email
                }
                setEmail(r) {
                    this._email = r
                }
                clearEmail() {
                    this._email = null
                }
                fetchPublicAddress() {
                    var r;
                    return __awaiter(this, void 0, void 0, function*() {
                        return null === (r = this.verifiedCredential) || void 0 === r ? void 0 : r.address
                    })
                }
                getConnectedAccounts() {
                    var r;
                    return __awaiter(this, void 0, void 0, function*() {
                        let l = null === (r = this.verifiedCredential) || void 0 === r ? void 0 : r.address;
                        return l ? [l] : []
                    })
                }
                getMobileOrInstalledWallet() {
                    return this
                }
                get turnkeyAddress() {
                    var r;
                    let {
                        address: l
                    } = null !== (r = this.verifiedCredential) && void 0 !== r ? r : {};
                    return l
                }
                get walletProperties() {
                    let {
                        walletProperties: r
                    } = this.verifiedCredential || {};
                    return r
                }
                set verifiedCredential(r) {
                    this._verifiedCredential = r
                }
                get verifiedCredential() {
                    return this._verifiedCredential
                }
            };
            let tk = "https://api.turnkey.com";
            let TurnkeyEVMWalletConnector = class TurnkeyEVMWalletConnector extends TurnkeyWalletConnectorBase {
                constructor(r, l) {
                    var C;
                    super(r, l), this.connectedChain = "EVM", this.supportedChains = ["ETH", "EVM"], this.verifiedCredentialChain = "eip155", this.evmNetworks = (0, tE.fu)(l.evmNetworks), this.walletUiUtils = l.walletUiUtils, this._turnkeyAccount = void 0, this._selectedChainId = this.getLastUsedChainId(), this.chainRpcProviders = l.chainRpcProviders, null === (C = this.chainRpcProviders) || void 0 === C || C.registerChainProviders(tI.r.EVM, r => {
                        let l = {};
                        return (null == r ? void 0 : r.evm) && (l.evm = (0, tE.fu)(r.evm).map(r => {
                            var l;
                            let C = (null === (l = r.privateCustomerRpcUrls) || void 0 === l ? void 0 : l[0]) || r.rpcUrls[0],
                                U = (0, eP.v)({
                                    chain: (0, tE.uy)(r),
                                    transport: (0, eC.d)(C)
                                });
                            return {
                                chainId: r.chainId,
                                chainName: r.name,
                                provider: U
                            }
                        })), l.evm
                    }), this.__turnkeyClient = this.getTurnkeyClient()
                }
                getLastUsedChainId() {
                    var r;
                    return this.lastUsedChainId ? this.lastUsedChainId : (null === (r = this.evmNetworks) || void 0 === r ? void 0 : r.length) ? this.evmNetworks[0].chainId : void 0
                }
                getNetwork() {
                    var r;
                    return __awaiter(this, void 0, void 0, function*() {
                        return null === (r = yield this.getSigner()) || void 0 === r ? void 0 : r.getChainId()
                    })
                }
                supportsNetworkSwitching() {
                    return !0
                }
                switchNetwork({
                    networkChainId: r
                }) {
                    return __awaiter(this, void 0, void 0, function*() {
                        this.lastUsedChainId = r, this._selectedChainId = r, yield this.refreshTurnkeyAccount(), this.emit("chainChange", {
                            chain: r.toString()
                        })
                    })
                }
                setVerifiedCredentials(r) {
                    let l = findTurnkeyVerifiedCredential(r, "eip155"),
                        C = JSON.stringify(this.verifiedCredential) !== JSON.stringify(l);
                    C && (this.verifiedCredential = l, this.refreshTurnkeyAccount())
                }
                getRpcUrl() {
                    let r = this._selectedChainId;
                    return (0, tb.GO)({
                        chainId: r,
                        networks: this.evmNetworks
                    })
                }
                getBalance() {
                    return __awaiter(this, void 0, void 0, function*() {
                        let r = this.turnkeyAddress;
                        if (!r) return;
                        let l = this.getRpcUrl();
                        if (!l) return;
                        let C = (0, eP.v)({
                                transport: (0, eC.d)(l)
                            }),
                            U = yield C.getBalance({
                                address: r
                            });
                        return (0, ek.d)(U)
                    })
                }
                signMessage(r) {
                    return __awaiter(this, void 0, void 0, function*() {
                        let l = yield this.getSigner();
                        if (!l) throw Error("Signer not found");
                        return l.signMessage({
                            message: r
                        })
                    })
                }
                getPublicClient() {
                    var r, l, C;
                    return __awaiter(this, void 0, void 0, function*() {
                        if (0 === this.evmNetworks.length) return;
                        let U = null !== (r = yield this.getNetwork()) && void 0 !== r ? r : 1,
                            et = {
                                cosmos: [],
                                evm: this.evmNetworks,
                                solana: [],
                                starknet: void 0
                            };
                        return null === (C = null === (l = this.chainRpcProviders) || void 0 === l ? void 0 : l.getEvmProviderByChainId(et, U)) || void 0 === C ? void 0 : C.provider
                    })
                }
                getSigner() {
                    return __awaiter(this, void 0, void 0, function*() {
                        return yield this.getTurnkeyAccount(), this.getWalletClient()
                    })
                }
                getTurnkeyClient() {
                    var r;
                    let l = (0, tE.KT)();
                    l || (l = window.location.hostname);
                    let C = new WebauthnStamper({
                        rpId: l
                    });
                    return this.__turnkeyClient = null !== (r = this.getAuthenticatorHandler().client) && void 0 !== r ? r : new public_api_client_TurnkeyClient({
                        baseUrl: tk
                    }, C), this.__turnkeyClient
                }
                getAccount() {
                    var r, l;
                    return __awaiter(this, void 0, void 0, function*() {
                        return ("passkey" === this.getAuthenticatorHandler().recoveryType && (null === (r = this.__turnkeyClient) || void 0 === r ? void 0 : r.stamper) instanceof IframeStamper || "email" === this.getAuthenticatorHandler().recoveryType && (null === (l = this.__turnkeyClient) || void 0 === l ? void 0 : l.stamper) instanceof WebauthnStamper || this.__turnkeyClient !== this.getAuthenticatorHandler().client) && (yield this.refreshTurnkeyAccount()), this._turnkeyAccount
                    })
                }
                getWalletClient() {
                    let r = this.networkRpcUrl,
                        l = this._turnkeyAccount,
                        C = this.currentEvmNetwork;
                    if (l && r && C) return (0, tw.No)({
                        account: this.getAccount.bind(this),
                        address: this.turnkeyAddress,
                        chain: (0, tE.uy)(C),
                        transport: (0, eC.d)(r),
                        walletUiUtils: this.walletUiUtils
                    })
                }
                refreshTurnkeyAccount() {
                    return __awaiter(this, void 0, void 0, function*() {
                        return this._turnkeyAccount = void 0, this.getTurnkeyAccount()
                    })
                }
                get currentChainId() {
                    var r, l, C;
                    return null !== (r = this._selectedChainId) && void 0 !== r ? r : null === (C = null === (l = this.evmNetworks) || void 0 === l ? void 0 : l[0]) || void 0 === C ? void 0 : C.chainId
                }
                get networkRpcUrl() {
                    let r = this.currentChainId,
                        l = this.evmNetworks.find(l => l.chainId === r);
                    if (!l) return;
                    let C = (0, tb.GO)({
                        chainId: r,
                        networks: this.evmNetworks
                    });
                    return C
                }
                get currentEvmNetwork() {
                    let r = this.currentChainId;
                    return this.evmNetworks.find(l => l.chainId === r)
                }
                getTurnkeyAccount() {
                    var r, l;
                    return __awaiter(this, void 0, void 0, function*() {
                        if (this._turnkeyAccount) return this._turnkeyAccount;
                        let {
                            turnkeySubOrganizationId: C
                        } = null !== (r = this.walletProperties) && void 0 !== r ? r : {}, {
                            address: U
                        } = null !== (l = this.verifiedCredential) && void 0 !== l ? l : {};
                        if (C && U) return this._turnkeyAccount = yield createAccount({
                            client: this.getTurnkeyClient(),
                            ethereumAddress: U,
                            organizationId: C,
                            signWith: U
                        }), this._turnkeyAccount
                    })
                }
                get lastUsedChainId() {
                    let r = localStorage.getItem(TurnkeyEVMWalletConnector.lastUsedChainIdStorageKey);
                    if (r) try {
                        let l = parseInt(r);
                        if (isNaN(l)) return;
                        let C = this.evmNetworks.some(r => r.chainId === l);
                        if (!C) {
                            let r = this.evmNetworks[0].chainId;
                            return this.lastUsedChainId = r, this.lastUsedChainId
                        }
                        return l
                    } catch (r) {
                        tb.kg.error(r);
                        return
                    }
                }
                set lastUsedChainId(r) {
                    void 0 === r ? localStorage.removeItem(TurnkeyEVMWalletConnector.lastUsedChainIdStorageKey) : localStorage.setItem(TurnkeyEVMWalletConnector.lastUsedChainIdStorageKey, r.toString())
                }
            };
            TurnkeyEVMWalletConnector.lastUsedChainIdStorageKey = "turnkey-last-used-chain-id";
            let tN = {
                Turnkey: {
                    key: "turnkey",
                    name: "Turnkey"
                },
                TurnkeyHD: {
                    key: "turnkeyhd",
                    name: "Turnkey HD"
                }
            };
            var tO = C(2660),
                tT = C(97115).Buffer;
            let TurnkeySigner = class TurnkeySigner {
                constructor(r) {
                    this.organizationId = r.organizationId, this.client = r.client
                }
                async addSignature(r, l) {
                    let C = new tO.nh(l),
                        U = r.serializeMessage(),
                        et = await this.signRawPayload(U.toString("hex"), l),
                        eo = `${et.signRawPayloadResult?.r}${et.signRawPayloadResult?.s}`;
                    r.addSignature(C, tT.from(eo, "hex"))
                }
                async signMessage(r, l) {
                    let C = await this.signRawPayload(tT.from(r).toString("hex"), l);
                    return tT.from(`${C.signRawPayloadResult?.r}${C.signRawPayloadResult?.s}`, "hex")
                }
                async signRawPayload(r, l) {
                    let C = await this.client.signRawPayload({
                            type: "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2",
                            organizationId: this.organizationId,
                            timestampMs: String(Date.now()),
                            parameters: {
                                signWith: l,
                                payload: r,
                                encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
                                hashFunction: "HASH_FUNCTION_NOT_APPLICABLE"
                            }
                        }),
                        {
                            id: U,
                            status: et,
                            type: eo,
                            result: es
                        } = C.activity;
                    if ("ACTIVITY_STATUS_COMPLETED" !== et) throw new shared_TurnkeyActivityError({
                        message: `Expected COMPLETED status, got ${et}`,
                        activityId: U,
                        activityStatus: et,
                        activityType: eo
                    });
                    return es
                }
            };
            let getTLD = () => {
                    let r = (0, tx.Qc)(window.location.hostname, {
                        allowPrivateDomains: !0
                    });
                    return r.domain || void 0
                },
                createSolanaConnection = (r, l) => {
                    if (!r) throw Error("rpcUrl is required");
                    return new tA.ew(r, l)
                };
            var tR = C(97115).Buffer;
            let TurnkeySolanaWalletConnector = class TurnkeySolanaWalletConnector extends TurnkeyWalletConnectorBase {
                constructor(r, l) {
                    var C;
                    super(r, l), this.connectedChain = "SOL", this.supportedChains = ["SOL"], this.verifiedCredentialChain = "solana", this.solNetworks = l.solNetworks, this.walletUiUtils = l.walletUiUtils, this._turnkeyAccount = void 0, this._connectionClient = void 0, this.chainRpcProviders = l.chainRpcProviders, null === (C = this.chainRpcProviders) || void 0 === C || C.registerChainProviders(tI.r.SOLANA, r => {
                        let l = {};
                        return (null == r ? void 0 : r.solana) && (l.solana = r.solana.map(r => {
                            var l;
                            let C = (null === (l = r.privateCustomerRpcUrls) || void 0 === l ? void 0 : l[0]) || r.rpcUrls[0],
                                U = createSolanaConnection(C);
                            return {
                                chainId: r.chainId.toString(),
                                chainName: r.name,
                                provider: U
                            }
                        })), l.solana
                    }), this.__turnkeyClient = this.getTurnkeyClient()
                }
                getRpcUrl() {
                    var r;
                    let [l] = this.solNetworks;
                    if (!l) throw new tE.kW("No enabled networks");
                    return (null === (r = l.privateCustomerRpcUrls) || void 0 === r ? void 0 : r[0]) || l.rpcUrls[0]
                }
                getConnection(r) {
                    if (!this._connectionClient) {
                        let l = this.getRpcUrl();
                        if (!l) throw new tE.kW("No rpcUrl");
                        this._connectionClient = createSolanaConnection(l, r)
                    }
                    return this._connectionClient
                }
                getWalletClient() {
                    return this.getConnection()
                }
                getNetwork() {
                    return __awaiter(this, void 0, void 0, function*() {
                        let r = this.getConnection(),
                            l = yield r.getGenesisHash();
                        return "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp" === (l = l.substring(0, 32)) ? "mainnet" : "EtWTRABZaYq6iMfeYKouRu166VU2xqa1" === l ? "devnet" : "testnet"
                    })
                }
                getPublicClient() {
                    var r, l;
                    return __awaiter(this, void 0, void 0, function*() {
                        if (0 === this.solNetworks.length) return;
                        let C = {
                            cosmos: [],
                            evm: void 0,
                            solana: this.solNetworks,
                            starknet: void 0
                        };
                        return null === (l = null === (r = this.chainRpcProviders) || void 0 === r ? void 0 : r.getSolanaRpcProviderByChainId(C, "101")) || void 0 === l ? void 0 : l.provider
                    })
                }
                supportsNetworkSwitching() {
                    return !1
                }
                setVerifiedCredentials(r) {
                    let l = findTurnkeyVerifiedCredential(r, tI.r.SOLANA),
                        C = JSON.stringify(this.verifiedCredential) !== JSON.stringify(l);
                    C && (this.verifiedCredential = l, this.refreshTurnkeyAccount())
                }
                getAccount() {
                    return this.turnkeyAddress
                }
                refreshTurnkeyAccount() {
                    return __awaiter(this, void 0, void 0, function*() {
                        return this._turnkeyAccount = void 0, this.getTurnkeyAccount()
                    })
                }
                getTurnkeyClient() {
                    var r;
                    let l = getTLD();
                    l || (l = window.location.hostname);
                    let C = new WebauthnStamper({
                        rpId: l
                    });
                    return this.__turnkeyClient = null !== (r = this.getAuthenticatorHandler().client) && void 0 !== r ? r : new public_api_client_TurnkeyClient({
                        baseUrl: tk
                    }, C), this.__turnkeyClient
                }
                createTurnkeyAccount({
                    organizationId: r
                }) {
                    return __awaiter(this, void 0, void 0, function*() {
                        let l = this.getTurnkeyClient(),
                            C = new TurnkeySigner({
                                client: l,
                                organizationId: r
                            });
                        return C
                    })
                }
                getTurnkeyAccount() {
                    var r, l, C, U;
                    return __awaiter(this, void 0, void 0, function*() {
                        if (this._turnkeyAccount && ("passkey" === this.getAuthenticatorHandler().recoveryType && (null === (r = this.__turnkeyClient) || void 0 === r ? void 0 : r.stamper) instanceof WebauthnStamper || "email" === this.getAuthenticatorHandler().recoveryType && (null === (l = this.__turnkeyClient) || void 0 === l ? void 0 : l.stamper) instanceof IframeStamper) && this.__turnkeyClient === this.getAuthenticatorHandler().client) return this._turnkeyAccount;
                        let {
                            turnkeySubOrganizationId: et
                        } = null !== (C = this.walletProperties) && void 0 !== C ? C : {}, {
                            address: eo
                        } = null !== (U = this.verifiedCredential) && void 0 !== U ? U : {};
                        if (et && eo) return this._turnkeyAccount = yield this.createTurnkeyAccount({
                            organizationId: et
                        }), this._turnkeyAccount
                    })
                }
                getSigner() {
                    return this.getTurnkeyAccount()
                }
                getBalance() {
                    return __awaiter(this, void 0, void 0, function*() {
                        let r = this.getAccount();
                        if (!r) return;
                        let l = this.getConnection(),
                            C = new tA.nh(r),
                            U = yield l.getBalance(C), et = this.lamportsToSol(U);
                        return et.toString()
                    })
                }
                signMessage(r) {
                    return __awaiter(this, void 0, void 0, function*() {
                        if (!this.turnkeyAddress) throw new tE.kW("No turnkey account");
                        let l = this.turnkeyAddress,
                            C = yield this.walletUiUtils.signMessage({
                                handler: () => __awaiter(this, void 0, void 0, function*() {
                                    var C;
                                    let U = new TextEncoder,
                                        et = U.encode(r),
                                        eo = yield null === (C = yield this.getTurnkeyAccount()) || void 0 === C ? void 0 : C.signMessage(et, l);
                                    return (0, tE.h$)(eo || tR.from([]))
                                }),
                                message: r
                            });
                        return C
                    })
                }
                signTransaction({
                    transaction: r
                }) {
                    return __awaiter(this, void 0, void 0, function*() {
                        let l = yield this.getTurnkeyAccount(), C = this.turnkeyAddress;
                        if (!l || !C) throw Error("No turnkey account");
                        return yield l.addSignature(r, C), r.serialize()
                    })
                }
                signAndSendTransaction({
                    transaction: r
                }) {
                    return __awaiter(this, void 0, void 0, function*() {
                        let l = yield this.signTransaction({
                            transaction: r
                        }), C = this.getConnection("confirmed"), U = yield(0, tA.go)(C, l, {
                            commitment: "confirmed"
                        });
                        return U
                    })
                }
                lamportsToSol(r) {
                    return r / tA.j5
                }
            };
            let TurnkeyWalletConnectors = (r, l = eA.AIv.Evm) => {
                var C, U;
                return (null === (C = r.apiProviders) || void 0 === C ? void 0 : C.turnkey) && l === eA.AIv.Evm ? [TurnkeyEVMWalletConnector.bind(null, tN.TurnkeyHD), TurnkeyEVMWalletConnector.bind(null, tN.Turnkey)] : (null === (U = r.apiProviders) || void 0 === U ? void 0 : U.turnkey) && l === eA.AIv.Sol ? [TurnkeySolanaWalletConnector.bind(null, tN.TurnkeyHD)] : []
            };

            function __rest(r, l) {
                var C = {};
                for (var U in r) Object.prototype.hasOwnProperty.call(r, U) && 0 > l.indexOf(U) && (C[U] = r[U]);
                if (null != r && "function" == typeof Object.getOwnPropertySymbols)
                    for (var et = 0, U = Object.getOwnPropertySymbols(r); et < U.length; et++) 0 > l.indexOf(U[et]) && Object.prototype.propertyIsEnumerable.call(r, U[et]) && (C[U[et]] = r[U[et]]);
                return C
            }

            function _tslib_awaiter(r, l, C, U) {
                return new(C || (C = Promise))(function(et, eo) {
                    function fulfilled(r) {
                        try {
                            step(U.next(r))
                        } catch (r) {
                            eo(r)
                        }
                    }

                    function rejected(r) {
                        try {
                            step(U.throw(r))
                        } catch (r) {
                            eo(r)
                        }
                    }

                    function step(r) {
                        var l;
                        r.done ? et(r.value) : ((l = r.value) instanceof C ? l : new C(function(r) {
                            r(l)
                        })).then(fulfilled, rejected)
                    }
                    step((U = U.apply(r, l || [])).next())
                })
            }
            "function" == typeof SuppressedError && SuppressedError;
            var tD = C(84310),
                tB = C(56218),
                tU = C(37491),
                tL = C(70278);
            let isEip9693Event = r => "eip6963:announceProvider" === r.type && void 0 !== r.detail;
            let Eip6963Provider = class Eip6963Provider {
                constructor() {
                    this.providers = []
                }
                registerProviders() {
                    "undefined" != typeof window && (window.addEventListener("eip6963:announceProvider", r => {
                        isEip9693Event(r) && this.providers.push(r.detail)
                    }), window.dispatchEvent(new Event("eip6963:requestProvider")))
                }
            };
            let Eip6963ProviderSingleton = class Eip6963ProviderSingleton {
                constructor() {
                    this.eip6963Provider = new Eip6963Provider
                }
                static get() {
                    var r;
                    return (null === (r = Eip6963ProviderSingleton.instance) || void 0 === r ? void 0 : r.eip6963Provider) || (Eip6963ProviderSingleton.instance = new Eip6963ProviderSingleton, Eip6963ProviderSingleton.instance.eip6963Provider.registerProviders()), Eip6963ProviderSingleton.instance.eip6963Provider
                }
            };
            let EthProviderHelper = class EthProviderHelper {
                constructor(r) {
                    this.wallet = r
                }
                getInstalledProvider() {
                    let r = this.getEip6963Config();
                    if (r) {
                        let l = this.eip6963ProviderLookup(r.rdns);
                        if (l) return l
                    }
                    let l = this.getInjectedConfig();
                    if (l && l.extensionLocators && l.extensionLocators.length) return this.installedProviderLookup(l.extensionLocators)
                }
                getEip6963Config() {
                    if (this.wallet && this.wallet.eip6963Config) return this.wallet.eip6963Config
                }
                getInjectedConfig() {
                    if (!this.wallet || !this.wallet.injectedConfig) return;
                    let {
                        injectedConfig: r
                    } = this.wallet;
                    return r.find(r => "evm" === r.chain)
                }
                installedProviders() {
                    let r = this.getInjectedConfig();
                    if (!r) return [];
                    let l = [];
                    if (r.windowLocations)
                        for (let C of r.windowLocations) {
                            let r = (0, tE.vj)(C);
                            r && r.length && l.push(...r)
                        }
                    return window.ethereum && (window.ethereum.providers && window.ethereum.providers.length ? window.ethereum.providers.forEach(r => l.push(r)) : l.push(window.ethereum)), l
                }
                installedProviderLookup(r) {
                    let l = this.installedProviders();
                    return (0, tb.VN)(l, r)
                }
                eip6963ProviderLookup(r) {
                    var l;
                    let {
                        providers: C
                    } = Eip6963ProviderSingleton.get();
                    return null === (l = C.find(l => l.info.rdns === r)) || void 0 === l ? void 0 : l.provider
                }
                isInstalledHelper() {
                    return void 0 !== this.findProvider()
                }
                findProvider() {
                    return this.getInstalledProvider()
                }
                findWalletClient() {
                    let r = this.findProvider();
                    if (r) return (0, tB.K)({
                        transport: (0, tU.P)(r)
                    })
                }
                fetchPublicAddress() {
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        let r = this.findWalletClient();
                        return r ? this.fetchPublicAddressWithProvider(r) : Promise.resolve(void 0)
                    })
                }
                fetchPublicAddressWithProvider(r) {
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        try {
                            let [l] = yield r.requestAddresses(), C = (0, tL.K)(l);
                            return C
                        } catch (r) {
                            return tb.kg.error(r), Promise.reject(r)
                        }
                    })
                }
                signMessage(r) {
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        let l = yield this.fetchPublicAddress();
                        if (!l) return Promise.resolve(void 0);
                        let C = this.findWalletClient();
                        if (!C) return Promise.resolve(void 0);
                        let U = yield C.signMessage({
                            account: l,
                            message: r
                        });
                        return U
                    })
                }
                _setupEventListeners(r) {
                    let l = this.findProvider();
                    if (!l) return {
                        tearDownEventListeners: () => {}
                    };
                    let {
                        handleAccountChange: C,
                        handleChainChange: U,
                        handleDisconnect: et
                    } = (0, tb.nb)(r);
                    return l.on("accountsChanged", C), l.on("chainChanged", U), l.on("disconnect", et), {
                        tearDownEventListeners: () => {
                            let r = this.findProvider();
                            r && (C && r.removeListener("accountsChanged", C), U && r.removeListener("chainChanged", U), et && r.removeListener("disconnect", et))
                        }
                    }
                }
            };
            let findEvmNetwork = ({
                chainId: r,
                name: l,
                networks: C
            }) => r || l ? r && l ? C.find(C => C.chainId === r && C.name === l) : r ? C.find(l => l.chainId === r) : C.find(r => r.name === l) : void 0;
            let EthWalletConnector = class EthWalletConnector extends tb.VY {
                getPublicClient() {
                    var r, l, C;
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        let U = null !== (r = yield this.getNetwork()) && void 0 !== r ? r : 1;
                        if (0 === this.evmNetworks.length) return;
                        let et = {
                            cosmos: [],
                            evm: this.evmNetworks,
                            solana: [],
                            starknet: void 0
                        };
                        return null === (C = null === (l = this.chainRpcProviders) || void 0 === l ? void 0 : l.getEvmProviderByChainId(et, U)) || void 0 === C ? void 0 : C.provider
                    })
                }
                constructor(r) {
                    var l;
                    super(r), this.evmNetworkRpcMap = () => this.evmNetworks.reduce((r, l) => {
                        var C;
                        return [r[l.chainId]] = (null === (C = null == l ? void 0 : l.privateCustomerRpcUrls) || void 0 === C ? void 0 : C.length) ? l.privateCustomerRpcUrls : l.rpcUrls, r
                    }, {}), this.evmNetworks = (0, tE.fu)(r.evmNetworks), this.chainRpcProviders = r.chainRpcProviders, null === (l = this.chainRpcProviders) || void 0 === l || l.registerChainProviders(tI.r.EVM, r => {
                        let l = {};
                        return (null == r ? void 0 : r.evm) && (l.evm = (0, tE.fu)(r.evm).map(r => {
                            var l;
                            let C = (null === (l = r.privateCustomerRpcUrls) || void 0 === l ? void 0 : l[0]) || r.rpcUrls[0],
                                U = (0, eP.v)({
                                    chain: (0, tE.uy)(r),
                                    transport: (0, eC.d)(C)
                                });
                            return {
                                chainId: r.chainId,
                                chainName: r.name,
                                provider: U
                            }
                        })), l.evm
                    })
                }
                getNetwork() {
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        let r = this.getWalletClient();
                        return this.supportsNetworkSwitching && r ? (0, tE.MB)(r.getChainId, {
                            fallbackValue: tE.yR,
                            timeoutMs: 1e3
                        }) : Promise.resolve(void 0)
                    })
                }
                getNameService() {
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        let [
                            [r], l
                        ] = yield Promise.all([this.getConnectedAccounts(), this.getPublicClient()]);
                        if (!r || !l) return;
                        let C = yield l.getEnsName({
                            address: r
                        }), U = C ? yield l.getEnsAvatar({
                            name: C
                        }): void 0;
                        return {
                            avatar: null != U ? U : void 0,
                            name: null != C ? C : void 0
                        }
                    })
                }
                getSigner() {
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        return this.getWalletClient()
                    })
                }
                getBalance() {
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        let [r] = yield this.getConnectedAccounts();
                        if (!r) return;
                        let l = yield this.getPublicClient(), C = yield null == l ? void 0 : l.getBalance({
                            address: r
                        });
                        if (C || C === BigInt(0)) return (0, ek.d)(C)
                    })
                }
                supportsNetworkSwitching() {
                    return !0
                }
                switchNetwork({
                    networkName: r,
                    networkChainId: l
                }) {
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        let C = findEvmNetwork({
                            chainId: l,
                            name: r,
                            networks: this.evmNetworks
                        });
                        if (!C) throw new tE.kW(`Could not find network mapping for chain ${r||l}`);
                        if (!this.supportsNetworkSwitching()) throw new tE.kW("Network switching is not supported");
                        let U = this.getWalletClient();
                        if (!U) throw new tE.kW("Provider not found");
                        return this.providerSwitchNetwork({
                            network: C,
                            provider: U
                        })
                    })
                }
                getConnectedAccounts() {
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        let r = this.getWalletClient();
                        return r ? (0, tE.MB)(r.getAddresses, {
                            fallbackValue: [],
                            timeoutMs: 300
                        }) : []
                    })
                }
                providerSwitchNetwork({
                    network: r,
                    provider: l
                }) {
                    var C, U, et, eo;
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        let {
                            chainId: es
                        } = r, el = yield this.getNetwork();
                        if (!el || el !== es) try {
                            if (!this.supportsNetworkSwitching()) throw new tE.kW("Network switching is not supported");
                            return yield l.switchChain((0, tE.uy)(r))
                        } catch (es) {
                            if (4902 === es.code || (null === (C = es.message) || void 0 === C ? void 0 : C.includes("Unrecognized chain")) || (null === (et = null === (U = es.data) || void 0 === U ? void 0 : U.orginalError) || void 0 === et ? void 0 : et.code) === 4902) return this.providerAddNetwork({
                                network: r,
                                provider: l
                            });
                            if ((null === (eo = es.message) || void 0 === eo ? void 0 : eo.includes("rejected")) || "string" == typeof es && es.includes("rejected")) throw new tE.kW("User rejected the wallet's request to switch network");
                            throw es
                        }
                    })
                }
                providerAddNetwork({
                    network: r,
                    provider: l
                }) {
                    var C;
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        try {
                            return yield l.addChain({
                                chain: (0, tE.uy)(r)
                            })
                        } catch (r) {
                            if ((null === (C = r.message) || void 0 === C ? void 0 : C.includes("rejected")) || "string" == typeof r && r.includes("rejected")) throw new tE.kW("User rejected the wallet's request to add network");
                            throw r
                        }
                    })
                }
            };
            var tM = C(17414),
                tj = C.n(tM);
            let tq = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/,
                t$ = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/,
                tz = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;

            function jsonParseTransform(r, l) {
                if ("__proto__" === r || "constructor" === r && l && "object" == typeof l && "prototype" in l) {
                    console.warn(`[destr] Dropping "${r}" key to prevent prototype pollution.`);
                    return
                }
                return l
            }

            function destr(r, l = {}) {
                if ("string" != typeof r) return r;
                let C = r.trim();
                if ('"' === r[0] && '"' === r.at(-1) && !r.includes("\\")) return C.slice(1, -1);
                if (C.length <= 9) {
                    let r = C.toLowerCase();
                    if ("true" === r) return !0;
                    if ("false" === r) return !1;
                    if ("undefined" === r) return;
                    if ("null" === r) return null;
                    if ("nan" === r) return Number.NaN;
                    if ("infinity" === r) return Number.POSITIVE_INFINITY;
                    if ("-infinity" === r) return Number.NEGATIVE_INFINITY
                }
                if (!tz.test(r)) {
                    if (l.strict) throw SyntaxError("[destr] Invalid JSON");
                    return r
                }
                try {
                    if (tq.test(r) || t$.test(r)) {
                        if (l.strict) throw Error("[destr] Possible prototype pollution");
                        return JSON.parse(r, jsonParseTransform)
                    }
                    return JSON.parse(r)
                } catch (C) {
                    if (l.strict) throw C;
                    return r
                }
            }
            var tH = C(97115).Buffer;

            function asyncCall(r, ...l) {
                try {
                    var C;
                    return (C = r(...l)) && "function" == typeof C.then ? C : Promise.resolve(C)
                } catch (r) {
                    return Promise.reject(r)
                }
            }

            function stringify(r) {
                if (function(r) {
                        let l = typeof r;
                        return null === r || "object" !== l && "function" !== l
                    }(r)) return String(r);
                if (function(r) {
                        let l = Object.getPrototypeOf(r);
                        return !l || l.isPrototypeOf(Object)
                    }(r) || Array.isArray(r)) return JSON.stringify(r);
                if ("function" == typeof r.toJSON) return stringify(r.toJSON());
                throw Error("[unstorage] Cannot stringify value!")
            }
            let tF = "base64:";

            function normalizeKey(r) {
                return r ? r.split("?")[0].replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "") : ""
            }

            function unstorage_8581f561_normalizeBaseKey(r) {
                return (r = normalizeKey(r)) ? r + ":" : ""
            }
            let memory = () => {
                let r = new Map;
                return {
                    name: "memory",
                    options: {},
                    hasItem: l => r.has(l),
                    getItem: l => r.get(l) ? ? null,
                    getItemRaw: l => r.get(l) ? ? null,
                    setItem(l, C) {
                        r.set(l, C)
                    },
                    setItemRaw(l, C) {
                        r.set(l, C)
                    },
                    removeItem(l) {
                        r.delete(l)
                    },
                    getKeys: () => Array.from(r.keys()),
                    clear() {
                        r.clear()
                    },
                    dispose() {
                        r.clear()
                    }
                }
            };

            function watch(r, l, C) {
                return r.watch ? r.watch((r, U) => l(r, C + U)) : () => {}
            }
            async function dispose(r) {
                "function" == typeof r.dispose && await asyncCall(r.dispose)
            }

            function promisifyRequest(r) {
                return new Promise((l, C) => {
                    r.oncomplete = r.onsuccess = () => l(r.result), r.onabort = r.onerror = () => C(r.error)
                })
            }

            function createStore(r, l) {
                let C = indexedDB.open(r);
                C.onupgradeneeded = () => C.result.createObjectStore(l);
                let U = promisifyRequest(C);
                return (r, C) => U.then(U => C(U.transaction(l, r).objectStore(l)))
            }

            function defaultGetStore() {
                return et || (et = createStore("keyval-store", "keyval")), et
            }

            function dist_get(r, l = defaultGetStore()) {
                return l("readonly", l => promisifyRequest(l.get(r)))
            }
            var tW = C(50376),
                z = (r = {}) => {
                    let l;
                    let C = r.base && r.base.length > 0 ? `${r.base}:` : "",
                        e = r => C + r;
                    return r.dbName && r.storeName && (l = createStore(r.dbName, r.storeName)), {
                        name: "idb-keyval",
                        options: r,
                        hasItem: async r => !(typeof await dist_get(e(r), l) > "u"),
                        getItem: async r => await dist_get(e(r), l) ? ? null,
                        setItem: (r, C) => (function(r, l, C = defaultGetStore()) {
                            return C("readwrite", C => (C.put(l, r), promisifyRequest(C.transaction)))
                        })(e(r), C, l),
                        removeItem: r => (function(r, l = defaultGetStore()) {
                            return l("readwrite", l => (l.delete(r), promisifyRequest(l.transaction)))
                        })(e(r), l),
                        getKeys: () => (function(r = defaultGetStore()) {
                            return r("readonly", r => {
                                var l;
                                if (r.getAllKeys) return promisifyRequest(r.getAllKeys());
                                let C = [];
                                return (l = r => C.push(r.key), r.openCursor().onsuccess = function() {
                                    this.result && (l(this.result), this.result.continue())
                                }, promisifyRequest(r.transaction)).then(() => C)
                            })
                        })(l),
                        clear: () => (function(r = defaultGetStore()) {
                            return r("readwrite", r => (r.clear(), promisifyRequest(r.transaction)))
                        })(l)
                    }
                };
            let _ = class _ {
                constructor() {
                    this.indexedDb = function(r = {}) {
                        let l = {
                                mounts: {
                                    "": r.driver || memory()
                                },
                                mountpoints: [""],
                                watching: !1,
                                watchListeners: [],
                                unwatch: {}
                            },
                            getMount = r => {
                                for (let C of l.mountpoints)
                                    if (r.startsWith(C)) return {
                                        base: C,
                                        relativeKey: r.slice(C.length),
                                        driver: l.mounts[C]
                                    };
                                return {
                                    base: "",
                                    relativeKey: r,
                                    driver: l.mounts[""]
                                }
                            },
                            getMounts = (r, C) => l.mountpoints.filter(l => l.startsWith(r) || C && r.startsWith(l)).map(C => ({
                                relativeBase: r.length > C.length ? r.slice(C.length) : void 0,
                                mountpoint: C,
                                driver: l.mounts[C]
                            })),
                            onChange = (r, C) => {
                                if (l.watching)
                                    for (let U of (C = normalizeKey(C), l.watchListeners)) U(r, C)
                            },
                            startWatch = async () => {
                                if (!l.watching)
                                    for (let r in l.watching = !0, l.mounts) l.unwatch[r] = await watch(l.mounts[r], onChange, r)
                            },
                            stopWatch = async () => {
                                if (l.watching) {
                                    for (let r in l.unwatch) await l.unwatch[r]();
                                    l.unwatch = {}, l.watching = !1
                                }
                            },
                            runBatch = (r, l, C) => {
                                let U = new Map,
                                    getBatch = r => {
                                        let l = U.get(r.base);
                                        return l || (l = {
                                            driver: r.driver,
                                            base: r.base,
                                            items: []
                                        }, U.set(r.base, l)), l
                                    };
                                for (let C of r) {
                                    let r = "string" == typeof C,
                                        U = normalizeKey(r ? C : C.key),
                                        et = r ? void 0 : C.value,
                                        eo = r || !C.options ? l : { ...l,
                                            ...C.options
                                        },
                                        es = getMount(U);
                                    getBatch(es).items.push({
                                        key: U,
                                        value: et,
                                        relativeKey: es.relativeKey,
                                        options: eo
                                    })
                                }
                                return Promise.all([...U.values()].map(r => C(r))).then(r => r.flat())
                            },
                            C = {
                                hasItem(r, l = {}) {
                                    r = normalizeKey(r);
                                    let {
                                        relativeKey: C,
                                        driver: U
                                    } = getMount(r);
                                    return asyncCall(U.hasItem, C, l)
                                },
                                getItem(r, l = {}) {
                                    r = normalizeKey(r);
                                    let {
                                        relativeKey: C,
                                        driver: U
                                    } = getMount(r);
                                    return asyncCall(U.getItem, C, l).then(r => destr(r))
                                },
                                getItems: (r, l) => runBatch(r, l, r => r.driver.getItems ? asyncCall(r.driver.getItems, r.items.map(r => ({
                                    key: r.relativeKey,
                                    options: r.options
                                })), l).then(l => l.map(l => ({
                                    key: function(...r) {
                                        return normalizeKey(r.join(":"))
                                    }(r.base, l.key),
                                    value: destr(l.value)
                                }))) : Promise.all(r.items.map(l => asyncCall(r.driver.getItem, l.relativeKey, l.options).then(r => ({
                                    key: l.key,
                                    value: destr(r)
                                }))))),
                                getItemRaw(r, l = {}) {
                                    r = normalizeKey(r);
                                    let {
                                        relativeKey: C,
                                        driver: U
                                    } = getMount(r);
                                    return U.getItemRaw ? asyncCall(U.getItemRaw, C, l) : asyncCall(U.getItem, C, l).then(r => "string" == typeof r && r.startsWith(tF) ? tH.from(r.slice(tF.length), "base64") : r)
                                },
                                async setItem(r, l, U = {}) {
                                    if (void 0 === l) return C.removeItem(r);
                                    r = normalizeKey(r);
                                    let {
                                        relativeKey: et,
                                        driver: eo
                                    } = getMount(r);
                                    eo.setItem && (await asyncCall(eo.setItem, et, stringify(l), U), eo.watch || onChange("update", r))
                                },
                                async setItems(r, l) {
                                    await runBatch(r, l, async r => {
                                        r.driver.setItems && await asyncCall(r.driver.setItems, r.items.map(r => ({
                                            key: r.relativeKey,
                                            value: stringify(r.value),
                                            options: r.options
                                        })), l), r.driver.setItem && await Promise.all(r.items.map(l => asyncCall(r.driver.setItem, l.relativeKey, stringify(l.value), l.options)))
                                    })
                                },
                                async setItemRaw(r, l, U = {}) {
                                    if (void 0 === l) return C.removeItem(r, U);
                                    r = normalizeKey(r);
                                    let {
                                        relativeKey: et,
                                        driver: eo
                                    } = getMount(r);
                                    if (eo.setItemRaw) await asyncCall(eo.setItemRaw, et, l, U);
                                    else {
                                        if (!eo.setItem) return;
                                        await asyncCall(eo.setItem, et, function(r) {
                                            if ("string" == typeof r) return r;
                                            let l = tH.from(r).toString("base64");
                                            return tF + l
                                        }(l), U)
                                    }
                                    eo.watch || onChange("update", r)
                                },
                                async removeItem(r, l = {}) {
                                    "boolean" == typeof l && (l = {
                                        removeMeta: l
                                    }), r = normalizeKey(r);
                                    let {
                                        relativeKey: C,
                                        driver: U
                                    } = getMount(r);
                                    U.removeItem && (await asyncCall(U.removeItem, C, l), (l.removeMeta || l.removeMata) && await asyncCall(U.removeItem, C + "$", l), U.watch || onChange("remove", r))
                                },
                                async getMeta(r, l = {}) {
                                    "boolean" == typeof l && (l = {
                                        nativeOnly: l
                                    }), r = normalizeKey(r);
                                    let {
                                        relativeKey: C,
                                        driver: U
                                    } = getMount(r), et = Object.create(null);
                                    if (U.getMeta && Object.assign(et, await asyncCall(U.getMeta, C, l)), !l.nativeOnly) {
                                        let r = await asyncCall(U.getItem, C + "$", l).then(r => destr(r));
                                        r && "object" == typeof r && ("string" == typeof r.atime && (r.atime = new Date(r.atime)), "string" == typeof r.mtime && (r.mtime = new Date(r.mtime)), Object.assign(et, r))
                                    }
                                    return et
                                },
                                setMeta(r, l, C = {}) {
                                    return this.setItem(r + "$", l, C)
                                },
                                removeMeta(r, l = {}) {
                                    return this.removeItem(r + "$", l)
                                },
                                async getKeys(r, l = {}) {
                                    r = unstorage_8581f561_normalizeBaseKey(r);
                                    let C = getMounts(r, !0),
                                        U = [],
                                        et = [];
                                    for (let r of C) {
                                        let C = await asyncCall(r.driver.getKeys, r.relativeBase, l),
                                            eo = C.map(l => r.mountpoint + normalizeKey(l)).filter(r => !U.some(l => r.startsWith(l)));
                                        et.push(...eo), U = [r.mountpoint, ...U.filter(l => !l.startsWith(r.mountpoint))]
                                    }
                                    return r ? et.filter(l => l.startsWith(r) && !l.endsWith("$")) : et.filter(r => !r.endsWith("$"))
                                },
                                async clear(r, l = {}) {
                                    r = unstorage_8581f561_normalizeBaseKey(r), await Promise.all(getMounts(r, !1).map(async r => {
                                        if (r.driver.clear) return asyncCall(r.driver.clear, r.relativeBase, l);
                                        if (r.driver.removeItem) {
                                            let C = await r.driver.getKeys(r.relativeBase || "", l);
                                            return Promise.all(C.map(C => r.driver.removeItem(C, l)))
                                        }
                                    }))
                                },
                                async dispose() {
                                    await Promise.all(Object.values(l.mounts).map(r => dispose(r)))
                                },
                                watch: async r => (await startWatch(), l.watchListeners.push(r), async () => {
                                    l.watchListeners = l.watchListeners.filter(l => l !== r), 0 === l.watchListeners.length && await stopWatch()
                                }),
                                async unwatch() {
                                    l.watchListeners = [], await stopWatch()
                                },
                                mount(r, U) {
                                    if ((r = unstorage_8581f561_normalizeBaseKey(r)) && l.mounts[r]) throw Error(`already mounted at ${r}`);
                                    return r && (l.mountpoints.push(r), l.mountpoints.sort((r, l) => l.length - r.length)), l.mounts[r] = U, l.watching && Promise.resolve(watch(U, onChange, r)).then(C => {
                                        l.unwatch[r] = C
                                    }).catch(console.error), C
                                },
                                async unmount(r, C = !0) {
                                    (r = unstorage_8581f561_normalizeBaseKey(r)) && l.mounts[r] && (l.watching && r in l.unwatch && (l.unwatch[r](), delete l.unwatch[r]), C && await dispose(l.mounts[r]), l.mountpoints = l.mountpoints.filter(l => l !== r), delete l.mounts[r])
                                },
                                getMount(r = "") {
                                    r = normalizeKey(r) + ":";
                                    let l = getMount(r);
                                    return {
                                        driver: l.driver,
                                        base: l.base
                                    }
                                },
                                getMounts(r = "", l = {}) {
                                    r = normalizeKey(r);
                                    let C = getMounts(r, l.parents);
                                    return C.map(r => ({
                                        driver: r.driver,
                                        base: r.mountpoint
                                    }))
                                }
                            };
                        return C
                    }({
                        driver: z({
                            dbName: "WALLET_CONNECT_V2_INDEXED_DB",
                            storeName: "keyvaluestorage"
                        })
                    })
                }
                async getKeys() {
                    return this.indexedDb.getKeys()
                }
                async getEntries() {
                    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map(r => [r.key, r.value])
                }
                async getItem(r) {
                    let l = await this.indexedDb.getItem(r);
                    if (null !== l) return l
                }
                async setItem(r, l) {
                    await this.indexedDb.setItem(r, (0, tW.u)(l))
                }
                async removeItem(r) {
                    await this.indexedDb.removeItem(r)
                }
            };
            var tV = "u" > typeof globalThis ? globalThis : "u" > typeof window ? window : "u" > typeof C.g ? C.g : "u" > typeof self ? self : {},
                tK = {
                    exports: {}
                };

            function k(r) {
                var l;
                return [r[0], (0, tW.D)(null != (l = r[1]) ? l : "")]
            }! function() {
                function t() {}
                t.prototype.getItem = function(r) {
                    return this.hasOwnProperty(r) ? String(this[r]) : null
                }, t.prototype.setItem = function(r, l) {
                    this[r] = String(l)
                }, t.prototype.removeItem = function(r) {
                    delete this[r]
                }, t.prototype.clear = function() {
                    let r = this;
                    Object.keys(r).forEach(function(l) {
                        r[l] = void 0, delete r[l]
                    })
                }, t.prototype.key = function(r) {
                    return r = r || 0, Object.keys(this)[r]
                }, t.prototype.__defineGetter__("length", function() {
                    return Object.keys(this).length
                }), "u" > typeof tV && tV.localStorage ? tK.exports = tV.localStorage : "u" > typeof window && window.localStorage ? tK.exports = window.localStorage : tK.exports = new t
            }();
            let K = class K {
                constructor() {
                    this.localStorage = tK.exports
                }
                async getKeys() {
                    return Object.keys(this.localStorage)
                }
                async getEntries() {
                    return Object.entries(this.localStorage).map(k)
                }
                async getItem(r) {
                    let l = this.localStorage.getItem(r);
                    if (null !== l) return (0, tW.D)(l)
                }
                async setItem(r, l) {
                    this.localStorage.setItem(r, (0, tW.u)(l))
                }
                async removeItem(r) {
                    this.localStorage.removeItem(r)
                }
            };
            let O = async (r, l, C) => {
                    let U = "wc_storage_version",
                        et = await l.getItem(U);
                    if (et && et >= 1) {
                        C(l);
                        return
                    }
                    let eo = await r.getKeys();
                    if (!eo.length) {
                        C(l);
                        return
                    }
                    let es = [];
                    for (; eo.length;) {
                        let C = eo.shift();
                        if (!C) continue;
                        let U = C.toLowerCase();
                        if (U.includes("wc@") || U.includes("walletconnect") || U.includes("wc_") || U.includes("wallet_connect")) {
                            let U = await r.getItem(C);
                            await l.setItem(C, U), es.push(C)
                        }
                    }
                    await l.setItem(U, 1), C(l), j(r, es)
                },
                j = async (r, l) => {
                    l.length && l.forEach(async l => {
                        await r.removeItem(l)
                    })
                };
            let h = class h {
                constructor() {
                    this.initialized = !1, this.setInitialized = r => {
                        this.storage = r, this.initialized = !0
                    };
                    let r = new K;
                    this.storage = r;
                    try {
                        let l = new _;
                        O(r, l, this.setInitialized)
                    } catch {
                        this.initialized = !0
                    }
                }
                async getKeys() {
                    return await this.initialize(), this.storage.getKeys()
                }
                async getEntries() {
                    return await this.initialize(), this.storage.getEntries()
                }
                async getItem(r) {
                    return await this.initialize(), this.storage.getItem(r)
                }
                async setItem(r, l) {
                    return await this.initialize(), this.storage.setItem(r, l)
                }
                async removeItem(r) {
                    return await this.initialize(), this.storage.removeItem(r)
                }
                async initialize() {
                    this.initialized || await new Promise(r => {
                        let l = setInterval(() => {
                            this.initialized && (clearInterval(l), r())
                        }, 20)
                    })
                }
            };
            var tG = C(96527),
                tJ = C(17731),
                tY = C(88124);
            let n = class n extends tY.q {
                constructor(r) {
                    super(), this.opts = r, this.protocol = "wc", this.version = 2
                }
            };
            let index_es_h = class index_es_h extends tY.q {
                constructor(r, l) {
                    super(), this.core = r, this.logger = l, this.records = new Map
                }
            };
            let a = class a {
                constructor(r, l) {
                    this.logger = r, this.core = l
                }
            };
            let u = class u extends tY.q {
                constructor(r, l) {
                    super(), this.relayer = r, this.logger = l
                }
            };
            let g = class g extends tY.q {
                constructor(r) {
                    super()
                }
            };
            let p = class p {
                constructor(r, l, C, U) {
                    this.core = r, this.logger = l, this.name = C
                }
            };
            let d = class d extends tY.q {
                constructor(r, l) {
                    super(), this.relayer = r, this.logger = l
                }
            };
            let index_es_E = class index_es_E extends tY.q {
                constructor(r, l) {
                    super(), this.core = r, this.logger = l
                }
            };
            let index_es_y = class index_es_y {
                constructor(r, l) {
                    this.projectId = r, this.logger = l
                }
            };
            let b = class b {
                constructor(r) {
                    this.opts = r, this.protocol = "wc", this.version = 2
                }
            };
            let S = class S {
                constructor(r) {
                    this.client = r
                }
            };
            var tZ = C(51133),
                tX = C(42532),
                tQ = C(23672);
            let t0 = "base64url",
                t1 = "base58btc";

            function as_uint8array_asUint8Array(r) {
                return null != globalThis.Buffer ? new Uint8Array(r.buffer, r.byteOffset, r.byteLength) : r
            }

            function allocUnsafe(r = 0) {
                return null != globalThis.Buffer && null != globalThis.Buffer.allocUnsafe ? as_uint8array_asUint8Array(globalThis.Buffer.allocUnsafe(r)) : new Uint8Array(r)
            }

            function concat(r, l) {
                l || (l = r.reduce((r, l) => r + l.length, 0));
                let C = allocUnsafe(l),
                    U = 0;
                for (let l of r) C.set(l, U), U += l.length;
                return as_uint8array_asUint8Array(C)
            }
            var base_x = function(r, l) {
                if (r.length >= 255) throw TypeError("Alphabet too long");
                for (var C = new Uint8Array(256), U = 0; U < C.length; U++) C[U] = 255;
                for (var et = 0; et < r.length; et++) {
                    var eo = r.charAt(et),
                        es = eo.charCodeAt(0);
                    if (255 !== C[es]) throw TypeError(eo + " is ambiguous");
                    C[es] = et
                }
                var el = r.length,
                    ec = r.charAt(0),
                    ed = Math.log(el) / Math.log(256),
                    eh = Math.log(256) / Math.log(el);

                function decodeUnsafe(r) {
                    if ("string" != typeof r) throw TypeError("Expected String");
                    if (0 === r.length) return new Uint8Array;
                    var l = 0;
                    if (" " !== r[0]) {
                        for (var U = 0, et = 0; r[l] === ec;) U++, l++;
                        for (var eo = (r.length - l) * ed + 1 >>> 0, es = new Uint8Array(eo); r[l];) {
                            var eh = C[r.charCodeAt(l)];
                            if (255 === eh) return;
                            for (var ef = 0, ep = eo - 1;
                                (0 !== eh || ef < et) && -1 !== ep; ep--, ef++) eh += el * es[ep] >>> 0, es[ep] = eh % 256 >>> 0, eh = eh / 256 >>> 0;
                            if (0 !== eh) throw Error("Non-zero carry");
                            et = ef, l++
                        }
                        if (" " !== r[l]) {
                            for (var eg = eo - et; eg !== eo && 0 === es[eg];) eg++;
                            for (var ey = new Uint8Array(U + (eo - eg)), em = U; eg !== eo;) ey[em++] = es[eg++];
                            return ey
                        }
                    }
                }
                return {
                    encode: function(l) {
                        if (l instanceof Uint8Array || (ArrayBuffer.isView(l) ? l = new Uint8Array(l.buffer, l.byteOffset, l.byteLength) : Array.isArray(l) && (l = Uint8Array.from(l))), !(l instanceof Uint8Array)) throw TypeError("Expected Uint8Array");
                        if (0 === l.length) return "";
                        for (var C = 0, U = 0, et = 0, eo = l.length; et !== eo && 0 === l[et];) et++, C++;
                        for (var es = (eo - et) * eh + 1 >>> 0, ed = new Uint8Array(es); et !== eo;) {
                            for (var ef = l[et], ep = 0, eg = es - 1;
                                (0 !== ef || ep < U) && -1 !== eg; eg--, ep++) ef += 256 * ed[eg] >>> 0, ed[eg] = ef % el >>> 0, ef = ef / el >>> 0;
                            if (0 !== ef) throw Error("Non-zero carry");
                            U = ep, et++
                        }
                        for (var ey = es - U; ey !== es && 0 === ed[ey];) ey++;
                        for (var em = ec.repeat(C); ey < es; ++ey) em += r.charAt(ed[ey]);
                        return em
                    },
                    decodeUnsafe: decodeUnsafe,
                    decode: function(r) {
                        var C = decodeUnsafe(r);
                        if (C) return C;
                        throw Error(`Non-${l} character`)
                    }
                }
            };
            new Uint8Array(0);
            let equals = (r, l) => {
                    if (r === l) return !0;
                    if (r.byteLength !== l.byteLength) return !1;
                    for (let C = 0; C < r.byteLength; C++)
                        if (r[C] !== l[C]) return !1;
                    return !0
                },
                coerce = r => {
                    if (r instanceof Uint8Array && "Uint8Array" === r.constructor.name) return r;
                    if (r instanceof ArrayBuffer) return new Uint8Array(r);
                    if (ArrayBuffer.isView(r)) return new Uint8Array(r.buffer, r.byteOffset, r.byteLength);
                    throw Error("Unknown type, must be binary type")
                },
                bytes_fromString = r => new TextEncoder().encode(r),
                bytes_toString = r => new TextDecoder().decode(r);
            let Encoder = class Encoder {
                constructor(r, l, C) {
                    this.name = r, this.prefix = l, this.baseEncode = C
                }
                encode(r) {
                    if (r instanceof Uint8Array) return `${this.prefix}${this.baseEncode(r)}`;
                    throw Error("Unknown type, must be binary type")
                }
            };
            let Decoder = class Decoder {
                constructor(r, l, C) {
                    if (this.name = r, this.prefix = l, void 0 === l.codePointAt(0)) throw Error("Invalid prefix character");
                    this.prefixCodePoint = l.codePointAt(0), this.baseDecode = C
                }
                decode(r) {
                    if ("string" == typeof r) {
                        if (r.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(r)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
                        return this.baseDecode(r.slice(this.prefix.length))
                    }
                    throw Error("Can only multibase decode strings")
                }
                or(r) {
                    return or(this, r)
                }
            };
            let ComposedDecoder = class ComposedDecoder {
                constructor(r) {
                    this.decoders = r
                }
                or(r) {
                    return or(this, r)
                }
                decode(r) {
                    let l = r[0],
                        C = this.decoders[l];
                    if (C) return C.decode(r);
                    throw RangeError(`Unable to decode multibase string ${JSON.stringify(r)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)
                }
            };
            let or = (r, l) => new ComposedDecoder({ ...r.decoders || {
                    [r.prefix]: r
                },
                ...l.decoders || {
                    [l.prefix]: l
                }
            });
            let Codec = class Codec {
                constructor(r, l, C, U) {
                    this.name = r, this.prefix = l, this.baseEncode = C, this.baseDecode = U, this.encoder = new Encoder(r, l, C), this.decoder = new Decoder(r, l, U)
                }
                encode(r) {
                    return this.encoder.encode(r)
                }
                decode(r) {
                    return this.decoder.decode(r)
                }
            };
            let from = ({
                    name: r,
                    prefix: l,
                    encode: C,
                    decode: U
                }) => new Codec(r, l, C, U),
                baseX = ({
                    prefix: r,
                    name: l,
                    alphabet: C
                }) => {
                    let {
                        encode: U,
                        decode: et
                    } = base_x(C, l);
                    return from({
                        prefix: r,
                        name: l,
                        encode: U,
                        decode: r => coerce(et(r))
                    })
                },
                decode = (r, l, C, U) => {
                    let et = {};
                    for (let r = 0; r < l.length; ++r) et[l[r]] = r;
                    let eo = r.length;
                    for (;
                        "=" === r[eo - 1];) --eo;
                    let es = new Uint8Array(eo * C / 8 | 0),
                        el = 0,
                        ec = 0,
                        ed = 0;
                    for (let l = 0; l < eo; ++l) {
                        let eo = et[r[l]];
                        if (void 0 === eo) throw SyntaxError(`Non-${U} character`);
                        ec = ec << C | eo, (el += C) >= 8 && (el -= 8, es[ed++] = 255 & ec >> el)
                    }
                    if (el >= C || 255 & ec << 8 - el) throw SyntaxError("Unexpected end of data");
                    return es
                },
                encode = (r, l, C) => {
                    let U = "=" === l[l.length - 1],
                        et = (1 << C) - 1,
                        eo = "",
                        es = 0,
                        el = 0;
                    for (let U = 0; U < r.length; ++U)
                        for (el = el << 8 | r[U], es += 8; es > C;) es -= C, eo += l[et & el >> es];
                    if (es && (eo += l[et & el << C - es]), U)
                        for (; eo.length * C & 7;) eo += "=";
                    return eo
                },
                rfc4648 = ({
                    name: r,
                    prefix: l,
                    bitsPerChar: C,
                    alphabet: U
                }) => from({
                    prefix: l,
                    name: r,
                    encode: r => encode(r, U, C),
                    decode: l => decode(l, U, C, r)
                }),
                t2 = from({
                    prefix: "\x00",
                    name: "identity",
                    encode: r => bytes_toString(r),
                    decode: r => bytes_fromString(r)
                }),
                t3 = rfc4648({
                    prefix: "0",
                    name: "base2",
                    alphabet: "01",
                    bitsPerChar: 1
                }),
                t5 = rfc4648({
                    prefix: "7",
                    name: "base8",
                    alphabet: "01234567",
                    bitsPerChar: 3
                }),
                t6 = baseX({
                    prefix: "9",
                    name: "base10",
                    alphabet: "0123456789"
                }),
                t8 = rfc4648({
                    prefix: "f",
                    name: "base16",
                    alphabet: "0123456789abcdef",
                    bitsPerChar: 4
                }),
                t4 = rfc4648({
                    prefix: "F",
                    name: "base16upper",
                    alphabet: "0123456789ABCDEF",
                    bitsPerChar: 4
                }),
                t9 = rfc4648({
                    prefix: "b",
                    name: "base32",
                    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
                    bitsPerChar: 5
                }),
                t7 = rfc4648({
                    prefix: "B",
                    name: "base32upper",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
                    bitsPerChar: 5
                }),
                ro = rfc4648({
                    prefix: "c",
                    name: "base32pad",
                    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
                    bitsPerChar: 5
                }),
                rs = rfc4648({
                    prefix: "C",
                    name: "base32padupper",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
                    bitsPerChar: 5
                }),
                ra = rfc4648({
                    prefix: "v",
                    name: "base32hex",
                    alphabet: "0123456789abcdefghijklmnopqrstuv",
                    bitsPerChar: 5
                }),
                rl = rfc4648({
                    prefix: "V",
                    name: "base32hexupper",
                    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
                    bitsPerChar: 5
                }),
                rc = rfc4648({
                    prefix: "t",
                    name: "base32hexpad",
                    alphabet: "0123456789abcdefghijklmnopqrstuv=",
                    bitsPerChar: 5
                }),
                rd = rfc4648({
                    prefix: "T",
                    name: "base32hexpadupper",
                    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
                    bitsPerChar: 5
                }),
                rh = rfc4648({
                    prefix: "h",
                    name: "base32z",
                    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
                    bitsPerChar: 5
                }),
                rp = baseX({
                    prefix: "k",
                    name: "base36",
                    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
                }),
                rg = baseX({
                    prefix: "K",
                    name: "base36upper",
                    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                }),
                ry = baseX({
                    name: "base58btc",
                    prefix: "z",
                    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
                }),
                rm = baseX({
                    name: "base58flickr",
                    prefix: "Z",
                    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
                }),
                r_ = rfc4648({
                    prefix: "m",
                    name: "base64",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
                    bitsPerChar: 6
                }),
                rb = rfc4648({
                    prefix: "M",
                    name: "base64pad",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                    bitsPerChar: 6
                }),
                rw = rfc4648({
                    prefix: "u",
                    name: "base64url",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
                    bitsPerChar: 6
                }),
                rE = rfc4648({
                    prefix: "U",
                    name: "base64urlpad",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
                    bitsPerChar: 6
                }),
                rI = Array.from("\uD83D\uDE80\uD83E\uDE90\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B\uD83E\uDD19\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81\uD83C\uDF1E\uD83C\uDF88\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74\uD83D\uDC8E\uD83D\uDCB8\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42"),
                rS = rI.reduce((r, l, C) => (r[C] = l, r), []),
                rx = rI.reduce((r, l, C) => (r[l.codePointAt(0)] = C, r), []),
                rA = from({
                    prefix: "\uD83D\uDE80",
                    name: "base256emoji",
                    encode: function(r) {
                        return r.reduce((r, l) => r += rS[l], "")
                    },
                    decode: function(r) {
                        let l = [];
                        for (let C of r) {
                            let r = rx[C.codePointAt(0)];
                            if (void 0 === r) throw Error(`Non-base256emoji character: ${C}`);
                            l.push(r)
                        }
                        return new Uint8Array(l)
                    }
                });

            function varint_encode(r, l, C) {
                l = l || [];
                for (var U = C = C || 0; r >= 2147483648;) l[C++] = 255 & r | 128, r /= 128;
                for (; - 128 & r;) l[C++] = 255 & r | 128, r >>>= 7;
                return l[C] = 0 | r, varint_encode.bytes = C - U + 1, l
            }

            function read(r, l) {
                var C, U = 0,
                    l = l || 0,
                    et = 0,
                    eo = l,
                    es = r.length;
                do {
                    if (eo >= es) throw read.bytes = 0, RangeError("Could not decode varint");
                    C = r[eo++], U += et < 28 ? (127 & C) << et : (127 & C) * Math.pow(2, et), et += 7
                } while (C >= 128);
                return read.bytes = eo - l, U
            }
            var rP = {
                encode: varint_encode,
                decode: read,
                encodingLength: function(r) {
                    return r < 128 ? 1 : r < 16384 ? 2 : r < 2097152 ? 3 : r < 268435456 ? 4 : r < 34359738368 ? 5 : r < 4398046511104 ? 6 : r < 562949953421312 ? 7 : r < 72057594037927940 ? 8 : r < 0x7fffffffffffffff ? 9 : 10
                }
            };
            let src_varint_decode = (r, l = 0) => {
                    let C = rP.decode(r, l);
                    return [C, rP.decode.bytes]
                },
                encodeTo = (r, l, C = 0) => (rP.encode(r, l, C), l),
                encodingLength = r => rP.encodingLength(r),
                digest_create = (r, l) => {
                    let C = l.byteLength,
                        U = encodingLength(r),
                        et = U + encodingLength(C),
                        eo = new Uint8Array(et + C);
                    return encodeTo(r, eo, 0), encodeTo(C, eo, U), eo.set(l, et), new Digest(r, C, l, eo)
                },
                digest_decode = r => {
                    let l = coerce(r),
                        [C, U] = src_varint_decode(l),
                        [et, eo] = src_varint_decode(l.subarray(U)),
                        es = l.subarray(U + eo);
                    if (es.byteLength !== et) throw Error("Incorrect length");
                    return new Digest(C, et, es, l)
                },
                digest_equals = (r, l) => r === l || r.code === l.code && r.size === l.size && equals(r.bytes, l.bytes);
            let Digest = class Digest {
                constructor(r, l, C, U) {
                    this.code = r, this.size = l, this.digest = C, this.bytes = U
                }
            };
            let hasher_from = ({
                name: r,
                code: l,
                encode: C
            }) => new Hasher(r, l, C);
            let Hasher = class Hasher {
                constructor(r, l, C) {
                    this.name = r, this.code = l, this.encode = C
                }
                digest(r) {
                    if (r instanceof Uint8Array) {
                        let l = this.encode(r);
                        return l instanceof Uint8Array ? digest_create(this.code, l) : l.then(r => digest_create(this.code, r))
                    }
                    throw Error("Unknown type, must be binary type")
                }
            };
            let sha = r => async l => new Uint8Array(await crypto.subtle.digest(r, l)),
                rC = hasher_from({
                    name: "sha2-256",
                    code: 18,
                    encode: sha("SHA-256")
                }),
                rk = hasher_from({
                    name: "sha2-512",
                    code: 19,
                    encode: sha("SHA-512")
                }),
                rN = {
                    code: 0,
                    name: "identity",
                    encode: coerce,
                    digest: r => digest_create(0, coerce(r))
                },
                rO = "raw",
                rT = 85,
                raw_encode = r => coerce(r),
                raw_decode = r => coerce(r),
                rR = new TextEncoder,
                rD = new TextDecoder,
                rB = "json",
                rU = 512,
                json_encode = r => rR.encode(JSON.stringify(r)),
                json_decode = r => JSON.parse(rD.decode(r));
            let CID = class CID {
                constructor(r, l, C, U) {
                    this.code = l, this.version = r, this.multihash = C, this.bytes = U, this.byteOffset = U.byteOffset, this.byteLength = U.byteLength, this.asCID = this, this._baseCache = new Map, Object.defineProperties(this, {
                        byteOffset: r$,
                        byteLength: r$,
                        code: rq,
                        version: rq,
                        multihash: rq,
                        bytes: rq,
                        _baseCache: r$,
                        asCID: r$
                    })
                }
                toV0() {
                    if (0 === this.version) return this; {
                        let {
                            code: r,
                            multihash: l
                        } = this;
                        if (r !== rL) throw Error("Cannot convert a non dag-pb CID to CIDv0");
                        if (l.code !== rM) throw Error("Cannot convert non sha2-256 multihash CID to CIDv0");
                        return CID.createV0(l)
                    }
                }
                toV1() {
                    switch (this.version) {
                        case 0:
                            {
                                let {
                                    code: r,
                                    digest: l
                                } = this.multihash,
                                C = digest_create(r, l);
                                return CID.createV1(this.code, C)
                            }
                        case 1:
                            return this;
                        default:
                            throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)
                    }
                }
                equals(r) {
                    return r && this.code === r.code && this.version === r.version && digest_equals(this.multihash, r.multihash)
                }
                toString(r) {
                    let {
                        bytes: l,
                        version: C,
                        _baseCache: U
                    } = this;
                    return 0 === C ? toStringV0(l, U, r || ry.encoder) : toStringV1(l, U, r || t9.encoder)
                }
                toJSON() {
                    return {
                        code: this.code,
                        version: this.version,
                        hash: this.multihash.bytes
                    }
                }
                get[Symbol.toStringTag]() {
                    return "CID"
                }[Symbol.for("nodejs.util.inspect.custom")]() {
                    return "CID(" + this.toString() + ")"
                }
                static isCID(r) {
                    return deprecate(/^0\.0/, rz), !!(r && (r[rj] || r.asCID === r))
                }
                get toBaseEncodedString() {
                    throw Error("Deprecated, use .toString()")
                }
                get codec() {
                    throw Error('"codec" property is deprecated, use integer "code" property instead')
                }
                get buffer() {
                    throw Error("Deprecated .buffer property, use .bytes to get Uint8Array instead")
                }
                get multibaseName() {
                    throw Error('"multibaseName" property is deprecated')
                }
                get prefix() {
                    throw Error('"prefix" property is deprecated')
                }
                static asCID(r) {
                    if (r instanceof CID) return r;
                    if (null != r && r.asCID === r) {
                        let {
                            version: l,
                            code: C,
                            multihash: U,
                            bytes: et
                        } = r;
                        return new CID(l, C, U, et || encodeCID(l, C, U.bytes))
                    }
                    if (null == r || !0 !== r[rj]) return null; {
                        let {
                            version: l,
                            multihash: C,
                            code: U
                        } = r, et = digest_decode(C);
                        return CID.create(l, U, et)
                    }
                }
                static create(r, l, C) {
                    if ("number" != typeof l) throw Error("String codecs are no longer supported");
                    switch (r) {
                        case 0:
                            if (l === rL) return new CID(r, l, C, C.bytes);
                            throw Error(`Version 0 CID must use dag-pb (code: ${rL}) block encoding`);
                        case 1:
                            {
                                let U = encodeCID(r, l, C.bytes);
                                return new CID(r, l, C, U)
                            }
                        default:
                            throw Error("Invalid version")
                    }
                }
                static createV0(r) {
                    return CID.create(0, rL, r)
                }
                static createV1(r, l) {
                    return CID.create(1, r, l)
                }
                static decode(r) {
                    let [l, C] = CID.decodeFirst(r);
                    if (C.length) throw Error("Incorrect length");
                    return l
                }
                static decodeFirst(r) {
                    let l = CID.inspectBytes(r),
                        C = l.size - l.multihashSize,
                        U = coerce(r.subarray(C, C + l.multihashSize));
                    if (U.byteLength !== l.multihashSize) throw Error("Incorrect length");
                    let et = U.subarray(l.multihashSize - l.digestSize),
                        eo = new Digest(l.multihashCode, l.digestSize, et, U),
                        es = 0 === l.version ? CID.createV0(eo) : CID.createV1(l.codec, eo);
                    return [es, r.subarray(l.size)]
                }
                static inspectBytes(r) {
                    let l = 0,
                        next = () => {
                            let [C, U] = src_varint_decode(r.subarray(l));
                            return l += U, C
                        },
                        C = next(),
                        U = rL;
                    if (18 === C ? (C = 0, l = 0) : 1 === C && (U = next()), 0 !== C && 1 !== C) throw RangeError(`Invalid CID version ${C}`);
                    let et = l,
                        eo = next(),
                        es = next(),
                        el = l + es;
                    return {
                        version: C,
                        codec: U,
                        multihashCode: eo,
                        digestSize: es,
                        multihashSize: el - et,
                        size: el
                    }
                }
                static parse(r, l) {
                    let [C, U] = parseCIDtoBytes(r, l), et = CID.decode(U);
                    return et._baseCache.set(C, r), et
                }
            };
            let parseCIDtoBytes = (r, l) => {
                    switch (r[0]) {
                        case "Q":
                            return [ry.prefix, (l || ry).decode(`${ry.prefix}${r}`)];
                        case ry.prefix:
                            return [ry.prefix, (l || ry).decode(r)];
                        case t9.prefix:
                            return [t9.prefix, (l || t9).decode(r)];
                        default:
                            if (null == l) throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
                            return [r[0], l.decode(r)]
                    }
                },
                toStringV0 = (r, l, C) => {
                    let {
                        prefix: U
                    } = C;
                    if (U !== ry.prefix) throw Error(`Cannot string encode V0 in ${C.name} encoding`);
                    let et = l.get(U);
                    if (null != et) return et; {
                        let et = C.encode(r).slice(1);
                        return l.set(U, et), et
                    }
                },
                toStringV1 = (r, l, C) => {
                    let {
                        prefix: U
                    } = C, et = l.get(U);
                    if (null != et) return et; {
                        let et = C.encode(r);
                        return l.set(U, et), et
                    }
                },
                rL = 112,
                rM = 18,
                encodeCID = (r, l, C) => {
                    let U = encodingLength(r),
                        et = U + encodingLength(l),
                        eo = new Uint8Array(et + C.byteLength);
                    return encodeTo(r, eo, 0), encodeTo(l, eo, U), eo.set(C, et), eo
                },
                rj = Symbol.for("@ipld/js-cid/CID"),
                rq = {
                    writable: !1,
                    configurable: !1,
                    enumerable: !0
                },
                r$ = {
                    writable: !1,
                    enumerable: !1,
                    configurable: !1
                },
                deprecate = (r, l) => {
                    if (r.test("0.0.0-dev")) console.warn(l);
                    else throw Error(l)
                },
                rz = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`,
                rH = { ...ec,
                    ...ed,
                    ...eh,
                    ...ef,
                    ...ep,
                    ...eg,
                    ...ey,
                    ...em,
                    ...e_,
                    ...eb
                };

            function createCodec(r, l, C, U) {
                return {
                    name: r,
                    prefix: l,
                    encoder: {
                        name: r,
                        prefix: l,
                        encode: C
                    },
                    decoder: {
                        decode: U
                    }
                }
            }({ ...ew,
                ...eE
            });
            let rF = createCodec("utf8", "u", r => {
                    let l = new TextDecoder("utf8");
                    return "u" + l.decode(r)
                }, r => {
                    let l = new TextEncoder;
                    return l.encode(r.substring(1))
                }),
                rW = createCodec("ascii", "a", r => {
                    let l = "a";
                    for (let C = 0; C < r.length; C++) l += String.fromCharCode(r[C]);
                    return l
                }, r => {
                    r = r.substring(1);
                    let l = allocUnsafe(r.length);
                    for (let C = 0; C < r.length; C++) l[C] = r.charCodeAt(C);
                    return l
                }),
                rV = {
                    utf8: rF,
                    "utf-8": rF,
                    hex: rH.base16,
                    latin1: rW,
                    ascii: rW,
                    binary: rW,
                    ...rH
                };

            function to_string_toString(r, l = "utf8") {
                let C = rV[l];
                if (!C) throw Error(`Unsupported encoding "${l}"`);
                return ("utf8" === l || "utf-8" === l) && null != globalThis.Buffer && null != globalThis.Buffer.from ? globalThis.Buffer.from(r.buffer, r.byteOffset, r.byteLength).toString("utf8") : C.encoder.encode(r).substring(1)
            }

            function from_string_fromString(r, l = "utf8") {
                let C = rV[l];
                if (!C) throw Error(`Unsupported encoding "${l}"`);
                return ("utf8" === l || "utf-8" === l) && null != globalThis.Buffer && null != globalThis.Buffer.from ? as_uint8array_asUint8Array(globalThis.Buffer.from(r, "utf-8")) : C.decoder.decode(`${C.prefix}${r}`)
            }

            function encodeJSON(r) {
                return to_string_toString(from_string_fromString((0, tW.u)(r), "utf8"), t0)
            }

            function encodeIss(r) {
                let l = from_string_fromString("K36", t1),
                    C = "z" + to_string_toString(concat([l, r]), t1);
                return ["did", "key", C].join(":")
            }

            function generateKeyPair(r = (0, tX.randomBytes)(32)) {
                return tZ._w(r)
            }
            async function signJWT(r, l, C, U, et = (0, tQ.fromMiliseconds)(Date.now())) {
                var eo, es;
                let el = {
                        alg: "EdDSA",
                        typ: "JWT"
                    },
                    ec = encodeIss(U.publicKey),
                    ed = {
                        iss: ec,
                        sub: r,
                        aud: l,
                        iat: et,
                        exp: et + C
                    },
                    eh = from_string_fromString([encodeJSON((eo = {
                        header: el,
                        payload: ed
                    }).header), encodeJSON(eo.payload)].join("."), "utf8"),
                    ef = tZ.Xx(U.secretKey, eh);
                return [encodeJSON((es = {
                    header: el,
                    payload: ed,
                    signature: ef
                }).header), encodeJSON(es.payload), to_string_toString(es.signature, t0)].join(".")
            }
            C(71782);
            var rK = C(58564),
                rG = C(13028),
                rJ = C(15086),
                rY = C(66436),
                rZ = C(9389),
                __spreadArray = function(r, l, C) {
                    if (C || 2 == arguments.length)
                        for (var U, et = 0, eo = l.length; et < eo; et++) !U && et in l || (U || (U = Array.prototype.slice.call(l, 0, et)), U[et] = l[et]);
                    return r.concat(U || Array.prototype.slice.call(l))
                },
                BrowserInfo = function(r, l, C) {
                    this.name = r, this.version = l, this.os = C, this.type = "browser"
                },
                NodeInfo = function(r) {
                    this.version = r, this.type = "node", this.name = "node", this.os = rZ.platform
                },
                SearchBotDeviceInfo = function(r, l, C, U) {
                    this.name = r, this.version = l, this.os = C, this.bot = U, this.type = "bot-device"
                },
                BotInfo = function() {
                    this.type = "bot", this.bot = !0, this.name = "bot", this.version = null, this.os = null
                },
                ReactNativeInfo = function() {
                    this.type = "react-native", this.name = "react-native", this.version = null, this.os = null
                },
                rX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/,
                rQ = [
                    ["aol", /AOLShield\/([0-9\._]+)/],
                    ["edge", /Edge\/([0-9\._]+)/],
                    ["edge-ios", /EdgiOS\/([0-9\._]+)/],
                    ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
                    ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
                    ["samsung", /SamsungBrowser\/([0-9\.]+)/],
                    ["silk", /\bSilk\/([0-9._-]+)\b/],
                    ["miui", /MiuiBrowser\/([0-9\.]+)$/],
                    ["beaker", /BeakerBrowser\/([0-9\.]+)/],
                    ["edge-chromium", /EdgA?\/([0-9\.]+)/],
                    ["chromium-webview", /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
                    ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
                    ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
                    ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
                    ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
                    ["fxios", /FxiOS\/([0-9\.]+)/],
                    ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
                    ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
                    ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
                    ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
                    ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
                    ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
                    ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
                    ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
                    ["ie", /MSIE\s(7\.0)/],
                    ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
                    ["android", /Android\s([0-9\.]+)/],
                    ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
                    ["safari", /Version\/([0-9\._]+).*Safari/],
                    ["facebook", /FB[AS]V\/([0-9\.]+)/],
                    ["instagram", /Instagram\s([0-9\.]+)/],
                    ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
                    ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
                    ["curl", /^curl\/([0-9\.]+)$/],
                    ["searchbot", /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/]
                ],
                r0 = [
                    ["iOS", /iP(hone|od|ad)/],
                    ["Android OS", /Android/],
                    ["BlackBerry OS", /BlackBerry|BB10/],
                    ["Windows Mobile", /IEMobile/],
                    ["Amazon OS", /Kindle/],
                    ["Windows 3.11", /Win16/],
                    ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
                    ["Windows 98", /(Windows 98)|(Win98)/],
                    ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
                    ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
                    ["Windows Server 2003", /(Windows NT 5.2)/],
                    ["Windows Vista", /(Windows NT 6.0)/],
                    ["Windows 7", /(Windows NT 6.1)/],
                    ["Windows 8", /(Windows NT 6.2)/],
                    ["Windows 8.1", /(Windows NT 6.3)/],
                    ["Windows 10", /(Windows NT 10.0)/],
                    ["Windows ME", /Windows ME/],
                    ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
                    ["Open BSD", /OpenBSD/],
                    ["Sun OS", /SunOS/],
                    ["Chrome OS", /CrOS/],
                    ["Linux", /(Linux)|(X11)/],
                    ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
                    ["QNX", /QNX/],
                    ["BeOS", /BeOS/],
                    ["OS/2", /OS\/2/]
                ];

            function parseUserAgent(r) {
                var l = "" !== r && rQ.reduce(function(l, C) {
                    var U = C[0],
                        et = C[1];
                    if (l) return l;
                    var eo = et.exec(r);
                    return !!eo && [U, eo]
                }, !1);
                if (!l) return null;
                var C = l[0],
                    U = l[1];
                if ("searchbot" === C) return new BotInfo;
                var et = U[1] && U[1].split(".").join("_").split("_").slice(0, 3);
                et ? et.length < 3 && (et = __spreadArray(__spreadArray([], et, !0), function(r) {
                    for (var l = [], C = 0; C < r; C++) l.push("0");
                    return l
                }(3 - et.length), !0)) : et = [];
                var eo = et.join("."),
                    es = function(r) {
                        for (var l = 0, C = r0.length; l < C; l++) {
                            var U = r0[l],
                                et = U[0];
                            if (U[1].exec(r)) return et
                        }
                        return null
                    }(r),
                    el = rX.exec(r);
                return el && el[1] ? new SearchBotDeviceInfo(C, eo, es, el[1]) : new BrowserInfo(C, eo, es)
            }
            var r1 = C(27324),
                r2 = C(69818),
                r3 = C(30240);
            C(66206);
            let r5 = {
                waku: {
                    publish: "waku_publish",
                    batchPublish: "waku_batchPublish",
                    subscribe: "waku_subscribe",
                    batchSubscribe: "waku_batchSubscribe",
                    subscription: "waku_subscription",
                    unsubscribe: "waku_unsubscribe",
                    batchUnsubscribe: "waku_batchUnsubscribe"
                },
                irn: {
                    publish: "irn_publish",
                    batchPublish: "irn_batchPublish",
                    subscribe: "irn_subscribe",
                    batchSubscribe: "irn_batchSubscribe",
                    subscription: "irn_subscription",
                    unsubscribe: "irn_unsubscribe",
                    batchUnsubscribe: "irn_batchUnsubscribe"
                },
                iridium: {
                    publish: "iridium_publish",
                    batchPublish: "iridium_batchPublish",
                    subscribe: "iridium_subscribe",
                    batchSubscribe: "iridium_batchSubscribe",
                    subscription: "iridium_subscription",
                    unsubscribe: "iridium_unsubscribe",
                    batchUnsubscribe: "iridium_batchUnsubscribe"
                }
            };
            var r6 = C(9389);

            function L(r, l) {
                return r.includes(":") ? [r] : l.chains || []
            }
            let r8 = "base10",
                r4 = "base16",
                r9 = "base64pad",
                r7 = "utf8";

            function Vn() {
                let r = (0, tX.randomBytes)(32);
                return to_string_toString(r, r4)
            }

            function Ln(r) {
                let l = (0, rJ.vp)(from_string_fromString(r, r7));
                return to_string_toString(l, r4)
            }

            function $(r) {
                return Number(to_string_toString(r, r8))
            }

            function ee(r) {
                let l = from_string_fromString(r, r9),
                    C = l.slice(0, 1);
                if (1 === $(C)) {
                    let r = l.slice(1, 33),
                        U = l.slice(33, 45),
                        et = l.slice(45);
                    return {
                        type: C,
                        sealed: et,
                        iv: U,
                        senderPublicKey: r
                    }
                }
                let U = l.slice(1, 13),
                    et = l.slice(13);
                return {
                    type: C,
                    sealed: et,
                    iv: U
                }
            }

            function Te(r) {
                let l = r ? .type || 0;
                if (1 === l) {
                    if (typeof r ? .senderPublicKey > "u") throw Error("missing sender public key");
                    if (typeof r ? .receiverPublicKey > "u") throw Error("missing receiver public key")
                }
                return {
                    type: l,
                    senderPublicKey: r ? .senderPublicKey,
                    receiverPublicKey: r ? .receiverPublicKey
                }
            }

            function qn(r) {
                return 1 === r.type && "string" == typeof r.senderPublicKey && "string" == typeof r.receiverPublicKey
            }
            var nn = Object.defineProperty,
                no = Object.getOwnPropertySymbols,
                ns = Object.prototype.hasOwnProperty,
                nl = Object.prototype.propertyIsEnumerable,
                Ue = (r, l, C) => l in r ? nn(r, l, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: C
                }) : r[l] = C,
                _e = (r, l) => {
                    for (var C in l || (l = {})) ns.call(l, C) && Ue(r, C, l[C]);
                    if (no)
                        for (var C of no(l)) nl.call(l, C) && Ue(r, C, l[C]);
                    return r
                };
            let nc = {
                reactNative: "react-native",
                node: "node",
                browser: "browser",
                unknown: "unknown"
            };

            function te() {
                return "u" > typeof r6 && "u" > typeof r6.versions && "u" > typeof r6.versions.node
            }

            function dist_index_es_C() {
                return !(0, r1.getDocument)() && !!(0, r1.getNavigator)() && "ReactNative" === navigator.product
            }

            function index_es_D() {
                return !te() && !!(0, r1.getNavigator)()
            }

            function T() {
                return dist_index_es_C() ? nc.reactNative : te() ? nc.node : index_es_D() ? nc.browser : nc.unknown
            }

            function index_es_O(r, l) {
                return r.filter(r => l.includes(r)).length === r.length
            }

            function rt(r) {
                return Object.fromEntries(r.entries())
            }

            function ot(r) {
                return new Map(Object.entries(r))
            }

            function at(r = tQ.FIVE_MINUTES, l) {
                let C, U, et;
                let eo = (0, tQ.toMiliseconds)(r || tQ.FIVE_MINUTES);
                return {
                    resolve: r => {
                        et && C && (clearTimeout(et), C(r))
                    },
                    reject: r => {
                        et && U && (clearTimeout(et), U(r))
                    },
                    done: () => new Promise((r, es) => {
                        et = setTimeout(() => {
                            es(Error(l))
                        }, eo), C = r, U = es
                    })
                }
            }

            function ut(r, l, C) {
                return new Promise(async (U, et) => {
                    let eo = setTimeout(() => et(Error(C)), l);
                    try {
                        let l = await r;
                        U(l)
                    } catch (r) {
                        et(r)
                    }
                    clearTimeout(eo)
                })
            }

            function re(r, l) {
                if ("string" == typeof l && l.startsWith(`${r}:`)) return l;
                if ("topic" === r.toLowerCase()) {
                    if ("string" != typeof l) throw Error('Value must be "string" for expirer target type: topic');
                    return `topic:${l}`
                }
                if ("id" === r.toLowerCase()) {
                    if ("number" != typeof l) throw Error('Value must be "number" for expirer target type: id');
                    return `id:${l}`
                }
                throw Error(`Unknown expirer target type: ${r}`)
            }

            function ft(r) {
                let [l, C] = r.split(":"), U = {
                    id: void 0,
                    topic: void 0
                };
                if ("topic" === l && "string" == typeof C) U.topic = C;
                else if ("id" === l && Number.isInteger(Number(C))) U.id = Number(C);
                else throw Error(`Invalid target, expected id:number or topic:string, got ${l}:${C}`);
                return U
            }

            function pt(r, l) {
                return (0, tQ.fromMiliseconds)((l || Date.now()) + (0, tQ.toMiliseconds)(r))
            }

            function mt(r) {
                return Date.now() >= (0, tQ.toMiliseconds)(r)
            }

            function yt(r, l) {
                return `${r}${l?`:${l}`:""}`
            }

            function index_es_S(r = [], l = []) {
                return [...new Set([...r, ...l])]
            }
            async function ht({
                id: r,
                topic: l,
                wcDeepLink: U
            }) {
                try {
                    if (!U) return;
                    let et = "string" == typeof U ? JSON.parse(U) : U,
                        eo = et ? .href;
                    if ("string" != typeof eo) return;
                    eo.endsWith("/") && (eo = eo.slice(0, -1));
                    let es = `${eo}/wc?requestId=${r}&sessionTopic=${l}`,
                        el = T();
                    el === nc.browser ? es.startsWith("https://") ? window.open(es, "_blank", "noreferrer noopener") : window.open(es, "_self", "noreferrer noopener") : el === nc.reactNative && "u" > typeof(null == C.g ? void 0 : C.g.Linking) && await C.g.Linking.openURL(es)
                } catch (r) {
                    console.error(r)
                }
            }
            async function gt(r, l) {
                try {
                    return await r.getItem(l) || (index_es_D() ? localStorage.getItem(l) : void 0)
                } catch (r) {
                    console.error(r)
                }
            }

            function vt(r) {
                return r ? .relay || {
                    protocol: "irn"
                }
            }

            function Et(r) {
                let l = r5[r];
                if (typeof l > "u") throw Error(`Relay Protocol not supported: ${r}`);
                return l
            }
            var nd = Object.defineProperty,
                nh = Object.getOwnPropertySymbols,
                nf = Object.prototype.hasOwnProperty,
                np = Object.prototype.propertyIsEnumerable,
                qe = (r, l, C) => l in r ? nd(r, l, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: C
                }) : r[l] = C,
                St = (r, l) => {
                    for (var C in l || (l = {})) nf.call(l, C) && qe(r, C, l[C]);
                    if (nh)
                        for (var C of nh(l)) np.call(l, C) && qe(r, C, l[C]);
                    return r
                };

            function wt(r) {
                var l;
                r = (r = r.includes("wc://") ? r.replace("wc://", "") : r).includes("wc:") ? r.replace("wc:", "") : r;
                let C = r.indexOf(":"),
                    U = -1 !== r.indexOf("?") ? r.indexOf("?") : void 0,
                    et = r.substring(0, C),
                    eo = r.substring(C + 1, U).split("@"),
                    es = "u" > typeof U ? r.substring(U) : "",
                    el = r3.parse(es);
                return {
                    protocol: et,
                    topic: (l = eo[0]).startsWith("//") ? l.substring(2) : l,
                    version: parseInt(eo[1], 10),
                    symKey: el.symKey,
                    relay: function(r, l = "-") {
                        let C = {},
                            U = "relay" + l;
                        return Object.keys(r).forEach(l => {
                            if (l.startsWith(U)) {
                                let et = l.replace(U, ""),
                                    eo = r[l];
                                C[et] = eo
                            }
                        }), C
                    }(el)
                }
            }

            function A(r) {
                let l = [];
                return r.forEach(r => {
                    let [C, U] = r.split(":");
                    l.push(`${C}:${U}`)
                }), l
            }

            function oe(r) {
                return r.includes(":")
            }

            function Xe(r) {
                return oe(r) ? r.split(":")[0] : r
            }
            Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable;
            let ng = {
                    INVALID_METHOD: {
                        message: "Invalid method.",
                        code: 1001
                    },
                    INVALID_EVENT: {
                        message: "Invalid event.",
                        code: 1002
                    },
                    INVALID_UPDATE_REQUEST: {
                        message: "Invalid update request.",
                        code: 1003
                    },
                    INVALID_EXTEND_REQUEST: {
                        message: "Invalid extend request.",
                        code: 1004
                    },
                    INVALID_SESSION_SETTLE_REQUEST: {
                        message: "Invalid session settle request.",
                        code: 1005
                    },
                    UNAUTHORIZED_METHOD: {
                        message: "Unauthorized method.",
                        code: 3001
                    },
                    UNAUTHORIZED_EVENT: {
                        message: "Unauthorized event.",
                        code: 3002
                    },
                    UNAUTHORIZED_UPDATE_REQUEST: {
                        message: "Unauthorized update request.",
                        code: 3003
                    },
                    UNAUTHORIZED_EXTEND_REQUEST: {
                        message: "Unauthorized extend request.",
                        code: 3004
                    },
                    USER_REJECTED: {
                        message: "User rejected.",
                        code: 5e3
                    },
                    USER_REJECTED_CHAINS: {
                        message: "User rejected chains.",
                        code: 5001
                    },
                    USER_REJECTED_METHODS: {
                        message: "User rejected methods.",
                        code: 5002
                    },
                    USER_REJECTED_EVENTS: {
                        message: "User rejected events.",
                        code: 5003
                    },
                    UNSUPPORTED_CHAINS: {
                        message: "Unsupported chains.",
                        code: 5100
                    },
                    UNSUPPORTED_METHODS: {
                        message: "Unsupported methods.",
                        code: 5101
                    },
                    UNSUPPORTED_EVENTS: {
                        message: "Unsupported events.",
                        code: 5102
                    },
                    UNSUPPORTED_ACCOUNTS: {
                        message: "Unsupported accounts.",
                        code: 5103
                    },
                    UNSUPPORTED_NAMESPACE_KEY: {
                        message: "Unsupported namespace key.",
                        code: 5104
                    },
                    USER_DISCONNECTED: {
                        message: "User disconnected.",
                        code: 6e3
                    },
                    SESSION_SETTLEMENT_FAILED: {
                        message: "Session settlement failed.",
                        code: 7e3
                    },
                    WC_METHOD_UNSUPPORTED: {
                        message: "Unsupported wc_ method.",
                        code: 10001
                    }
                },
                ny = {
                    NOT_INITIALIZED: {
                        message: "Not initialized.",
                        code: 1
                    },
                    NO_MATCHING_KEY: {
                        message: "No matching key.",
                        code: 2
                    },
                    RESTORE_WILL_OVERRIDE: {
                        message: "Restore will override.",
                        code: 3
                    },
                    RESUBSCRIBED: {
                        message: "Resubscribed.",
                        code: 4
                    },
                    MISSING_OR_INVALID: {
                        message: "Missing or invalid.",
                        code: 5
                    },
                    EXPIRED: {
                        message: "Expired.",
                        code: 6
                    },
                    UNKNOWN_TYPE: {
                        message: "Unknown type.",
                        code: 7
                    },
                    MISMATCHED_TOPIC: {
                        message: "Mismatched topic.",
                        code: 8
                    },
                    NON_CONFORMING_NAMESPACES: {
                        message: "Non conforming namespaces.",
                        code: 9
                    }
                };

            function index_es_N(r, l) {
                let {
                    message: C,
                    code: U
                } = ny[r];
                return {
                    message: l ? `${C} ${l}` : C,
                    code: U
                }
            }

            function index_es_U(r, l) {
                let {
                    message: C,
                    code: U
                } = ng[r];
                return {
                    message: l ? `${C} ${l}` : C,
                    code: U
                }
            }

            function index_es_k(r, l) {
                return !!Array.isArray(r) && (!("u" > typeof l) || !r.length || r.every(l))
            }

            function B(r) {
                return Object.getPrototypeOf(r) === Object.prototype && Object.keys(r).length
            }

            function w(r) {
                return typeof r > "u"
            }

            function dist_index_es_h(r, l) {
                return !!(l && w(r)) || "string" == typeof r && !!r.trim().length
            }

            function G(r, l) {
                return !!(l && w(r)) || "number" == typeof r && !isNaN(r)
            }

            function V(r) {
                return !!(dist_index_es_h(r, !1) && r.includes(":")) && 2 === r.split(":").length
            }

            function ie(r) {
                let l = !0;
                return index_es_k(r) ? r.length && (l = r.every(r => dist_index_es_h(r, !1))) : l = !1, l
            }

            function ce(r, l) {
                let C = null;
                return Object.values(r).forEach(r => {
                    var U;
                    let et;
                    if (C) return;
                    let eo = (U = `${l}, namespace`, et = null, ie(r ? .methods) ? ie(r ? .events) || (et = index_es_U("UNSUPPORTED_EVENTS", `${U}, events should be an array of strings or empty array for no events`)) : et = index_es_U("UNSUPPORTED_METHODS", `${U}, methods should be an array of strings or empty array for no methods`), et);
                    eo && (C = eo)
                }), C
            }

            function un(r, l) {
                let C = null;
                if (r && B(r)) {
                    let U;
                    let et = ce(r, l);
                    et && (C = et);
                    let eo = (U = null, Object.values(r).forEach(r => {
                        var C, et;
                        let eo;
                        if (U) return;
                        let es = (C = r ? .accounts, et = `${l} namespace`, eo = null, index_es_k(C) ? C.forEach(r => {
                            eo || function(r) {
                                if (dist_index_es_h(r, !1) && r.includes(":")) {
                                    let l = r.split(":");
                                    if (3 === l.length) {
                                        let r = l[0] + ":" + l[1];
                                        return !!l[2] && V(r)
                                    }
                                }
                                return !1
                            }(r) || (eo = index_es_U("UNSUPPORTED_ACCOUNTS", `${et}, account ${r} should be a string and conform to "namespace:chainId:address" format`))
                        }) : eo = index_es_U("UNSUPPORTED_ACCOUNTS", `${et}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), eo);
                        es && (U = es)
                    }), U);
                    eo && (C = eo)
                } else C = index_es_N("MISSING_OR_INVALID", `${l}, namespaces should be an object with data`);
                return C
            }

            function ln(r) {
                return dist_index_es_h(r.protocol, !0)
            }

            function Ht(r) {
                return "u" > typeof r
            }

            function zt(r, l) {
                return !(!V(l) || !(function(r) {
                    let l = [];
                    return Object.values(r).forEach(r => {
                        l.push(...A(r.accounts))
                    }), l
                })(r).includes(l))
            }

            function dn(r, l, C) {
                let U = null,
                    et = function(r) {
                        let l = {};
                        return Object.keys(r).forEach(C => {
                            var U;
                            C.includes(":") ? l[C] = r[C] : null == (U = r[C].chains) || U.forEach(U => {
                                l[U] = {
                                    methods: r[C].methods,
                                    events: r[C].events
                                }
                            })
                        }), l
                    }(r),
                    eo = function(r) {
                        let l = {};
                        return Object.keys(r).forEach(C => {
                            if (C.includes(":")) l[C] = r[C];
                            else {
                                let U = A(r[C].accounts);
                                U ? .forEach(U => {
                                    l[U] = {
                                        accounts: r[C].accounts.filter(r => r.includes(`${U}:`)),
                                        methods: r[C].methods,
                                        events: r[C].events
                                    }
                                })
                            }
                        }), l
                    }(l),
                    es = Object.keys(et),
                    el = Object.keys(eo),
                    ec = fn(Object.keys(r)),
                    ed = fn(Object.keys(l)),
                    eh = ec.filter(r => !ed.includes(r));
                return eh.length && (U = index_es_N("NON_CONFORMING_NAMESPACES", `${C} namespaces keys don't satisfy requiredNamespaces.
      Required: ${eh.toString()}
      Received: ${Object.keys(l).toString()}`)), index_es_O(es, el) || (U = index_es_N("NON_CONFORMING_NAMESPACES", `${C} namespaces chains don't satisfy required namespaces.
      Required: ${es.toString()}
      Approved: ${el.toString()}`)), Object.keys(l).forEach(r => {
                    if (!r.includes(":") || U) return;
                    let et = A(l[r].accounts);
                    et.includes(r) || (U = index_es_N("NON_CONFORMING_NAMESPACES", `${C} namespaces accounts don't satisfy namespace accounts for ${r}
        Required: ${r}
        Approved: ${et.toString()}`))
                }), es.forEach(r => {
                    U || (index_es_O(et[r].methods, eo[r].methods) ? index_es_O(et[r].events, eo[r].events) || (U = index_es_N("NON_CONFORMING_NAMESPACES", `${C} namespaces events don't satisfy namespace events for ${r}`)) : U = index_es_N("NON_CONFORMING_NAMESPACES", `${C} namespaces methods don't satisfy namespace methods for ${r}`))
                }), U
            }

            function fn(r) {
                return [...new Set(r.map(r => r.includes(":") ? r.split(":")[0] : r))]
            }

            function er() {
                let r = T();
                return new Promise(l => {
                    switch (r) {
                        case nc.browser:
                            l(index_es_D() && navigator ? .onLine);
                            break;
                        case nc.reactNative:
                            l(mn());
                            break;
                        case nc.node:
                        default:
                            l(!0)
                    }
                })
            }
            async function mn() {
                if (dist_index_es_C() && "u" > typeof C.g && null != C.g && C.g.NetInfo) {
                    let r = await (null == C.g ? void 0 : C.g.NetInfo.fetch());
                    return r ? .isConnected
                }
                return !0
            }
            let nm = {};
            let tr = class tr {
                static get(r) {
                    return nm[r]
                }
                static set(r, l) {
                    nm[r] = l
                }
                static delete(r) {
                    delete nm[r]
                }
            };
            var n_ = C(22458),
                nb = C(58256);
            let index_es_b = () => "u" > typeof WebSocket || "u" > typeof C.g && "u" > typeof C.g.WebSocket || "u" > typeof window && "u" > typeof window.WebSocket || "u" > typeof self && "u" > typeof self.WebSocket,
                index_es_a = r => r.split("?")[0],
                nw = "u" > typeof WebSocket ? WebSocket : "u" > typeof C.g && "u" > typeof C.g.WebSocket ? C.g.WebSocket : "u" > typeof window && "u" > typeof window.WebSocket ? window.WebSocket : "u" > typeof self && "u" > typeof self.WebSocket ? self.WebSocket : C(85217);
            let f = class f {
                constructor(r) {
                    if (this.url = r, this.events = new tM.EventEmitter, this.registering = !1, !(0, nb.isWsUrl)(r)) throw Error(`Provided URL is not compatible with WebSocket connection: ${r}`);
                    this.url = r
                }
                get connected() {
                    return "u" > typeof this.socket
                }
                get connecting() {
                    return this.registering
                }
                on(r, l) {
                    this.events.on(r, l)
                }
                once(r, l) {
                    this.events.once(r, l)
                }
                off(r, l) {
                    this.events.off(r, l)
                }
                removeListener(r, l) {
                    this.events.removeListener(r, l)
                }
                async open(r = this.url) {
                    await this.register(r)
                }
                async close() {
                    return new Promise((r, l) => {
                        if (typeof this.socket > "u") {
                            l(Error("Connection already closed"));
                            return
                        }
                        this.socket.onclose = l => {
                            this.onClose(l), r()
                        }, this.socket.close()
                    })
                }
                async send(r) {
                    typeof this.socket > "u" && (this.socket = await this.register());
                    try {
                        this.socket.send((0, tW.u)(r))
                    } catch (l) {
                        this.onError(r.id, l)
                    }
                }
                register(r = this.url) {
                    if (!(0, nb.isWsUrl)(r)) throw Error(`Provided URL is not compatible with WebSocket connection: ${r}`);
                    if (this.registering) {
                        let r = this.events.getMaxListeners();
                        return (this.events.listenerCount("register_error") >= r || this.events.listenerCount("open") >= r) && this.events.setMaxListeners(r + 1), new Promise((r, l) => {
                            this.events.once("register_error", r => {
                                this.resetMaxListeners(), l(r)
                            }), this.events.once("open", () => {
                                if (this.resetMaxListeners(), typeof this.socket > "u") return l(Error("WebSocket connection is missing or invalid"));
                                r(this.socket)
                            })
                        })
                    }
                    return this.url = r, this.registering = !0, new Promise((l, C) => {
                        let U = new URLSearchParams(r).get("origin"),
                            et = (0, nb.isReactNative)() ? {
                                headers: {
                                    origin: U
                                }
                            } : {
                                rejectUnauthorized: !(0, nb.isLocalhostUrl)(r)
                            },
                            eo = new nw(r, [], et);
                        index_es_b() ? eo.onerror = r => {
                            C(this.emitError(r.error))
                        } : eo.on("error", r => {
                            C(this.emitError(r))
                        }), eo.onopen = () => {
                            this.onOpen(eo), l(eo)
                        }
                    })
                }
                onOpen(r) {
                    r.onmessage = r => this.onPayload(r), r.onclose = r => this.onClose(r), this.socket = r, this.registering = !1, this.events.emit("open")
                }
                onClose(r) {
                    this.socket = void 0, this.registering = !1, this.events.emit("close", r)
                }
                onPayload(r) {
                    if (typeof r.data > "u") return;
                    let l = "string" == typeof r.data ? (0, tW.D)(r.data) : r.data;
                    this.events.emit("payload", l)
                }
                onError(r, l) {
                    let C = this.parseError(l),
                        U = C.message || C.toString(),
                        et = (0, nb.formatJsonRpcError)(r, U);
                    this.events.emit("payload", et)
                }
                parseError(r, l = this.url) {
                    return (0, nb.parseConnectionError)(r, index_es_a(l), "WS")
                }
                resetMaxListeners() {
                    this.events.getMaxListeners() > 10 && this.events.setMaxListeners(10)
                }
                emitError(r) {
                    let l = this.parseError(Error(r ? .message || `WebSocket connection failed for host: ${index_es_a(this.url)}`));
                    return this.events.emit("register_error", l), l
                }
            };
            var nE = C(9414),
                nI = C.n(nE),
                nS = C(9389),
                ji = function(r, l) {
                    if (r.length >= 255) throw TypeError("Alphabet too long");
                    for (var C = new Uint8Array(256), U = 0; U < C.length; U++) C[U] = 255;
                    for (var et = 0; et < r.length; et++) {
                        var eo = r.charAt(et),
                            es = eo.charCodeAt(0);
                        if (255 !== C[es]) throw TypeError(eo + " is ambiguous");
                        C[es] = et
                    }
                    var el = r.length,
                        ec = r.charAt(0),
                        ed = Math.log(el) / Math.log(256),
                        eh = Math.log(256) / Math.log(el);

                    function y(r) {
                        if ("string" != typeof r) throw TypeError("Expected String");
                        if (0 === r.length) return new Uint8Array;
                        var l = 0;
                        if (" " !== r[0]) {
                            for (var U = 0, et = 0; r[l] === ec;) U++, l++;
                            for (var eo = (r.length - l) * ed + 1 >>> 0, es = new Uint8Array(eo); r[l];) {
                                var eh = C[r.charCodeAt(l)];
                                if (255 === eh) return;
                                for (var ef = 0, ep = eo - 1;
                                    (0 !== eh || ef < et) && -1 !== ep; ep--, ef++) eh += el * es[ep] >>> 0, es[ep] = eh % 256 >>> 0, eh = eh / 256 >>> 0;
                                if (0 !== eh) throw Error("Non-zero carry");
                                et = ef, l++
                            }
                            if (" " !== r[l]) {
                                for (var eg = eo - et; eg !== eo && 0 === es[eg];) eg++;
                                for (var ey = new Uint8Array(U + (eo - eg)), em = U; eg !== eo;) ey[em++] = es[eg++];
                                return ey
                            }
                        }
                    }
                    return {
                        encode: function(l) {
                            if (l instanceof Uint8Array || (ArrayBuffer.isView(l) ? l = new Uint8Array(l.buffer, l.byteOffset, l.byteLength) : Array.isArray(l) && (l = Uint8Array.from(l))), !(l instanceof Uint8Array)) throw TypeError("Expected Uint8Array");
                            if (0 === l.length) return "";
                            for (var C = 0, U = 0, et = 0, eo = l.length; et !== eo && 0 === l[et];) et++, C++;
                            for (var es = (eo - et) * eh + 1 >>> 0, ed = new Uint8Array(es); et !== eo;) {
                                for (var ef = l[et], ep = 0, eg = es - 1;
                                    (0 !== ef || ep < U) && -1 !== eg; eg--, ep++) ef += 256 * ed[eg] >>> 0, ed[eg] = ef % el >>> 0, ef = ef / el >>> 0;
                                if (0 !== ef) throw Error("Non-zero carry");
                                U = ep, et++
                            }
                            for (var ey = es - U; ey !== es && 0 === ed[ey];) ey++;
                            for (var em = ec.repeat(C); ey < es; ++ey) em += r.charAt(ed[ey]);
                            return em
                        },
                        decodeUnsafe: y,
                        decode: function(r) {
                            var C = y(r);
                            if (C) return C;
                            throw Error(`Non-${l} character`)
                        }
                    }
                };
            let index_es_Ne = r => {
                    if (r instanceof Uint8Array && "Uint8Array" === r.constructor.name) return r;
                    if (r instanceof ArrayBuffer) return new Uint8Array(r);
                    if (ArrayBuffer.isView(r)) return new Uint8Array(r.buffer, r.byteOffset, r.byteLength);
                    throw Error("Unknown type, must be binary type")
                },
                Gi = r => new TextEncoder().encode(r),
                Yi = r => new TextDecoder().decode(r);
            let Hi = class Hi {
                constructor(r, l, C) {
                    this.name = r, this.prefix = l, this.baseEncode = C
                }
                encode(r) {
                    if (r instanceof Uint8Array) return `${this.prefix}${this.baseEncode(r)}`;
                    throw Error("Unknown type, must be binary type")
                }
            };
            let Ji = class Ji {
                constructor(r, l, C) {
                    if (this.name = r, this.prefix = l, void 0 === l.codePointAt(0)) throw Error("Invalid prefix character");
                    this.prefixCodePoint = l.codePointAt(0), this.baseDecode = C
                }
                decode(r) {
                    if ("string" == typeof r) {
                        if (r.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(r)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
                        return this.baseDecode(r.slice(this.prefix.length))
                    }
                    throw Error("Can only multibase decode strings")
                }
                or(r) {
                    return index_es_Ue(this, r)
                }
            };
            let Wi = class Wi {
                constructor(r) {
                    this.decoders = r
                }
                or(r) {
                    return index_es_Ue(this, r)
                }
                decode(r) {
                    let l = r[0],
                        C = this.decoders[l];
                    if (C) return C.decode(r);
                    throw RangeError(`Unable to decode multibase string ${JSON.stringify(r)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)
                }
            };
            let index_es_Ue = (r, l) => new Wi({ ...r.decoders || {
                    [r.prefix]: r
                },
                ...l.decoders || {
                    [l.prefix]: l
                }
            });
            let Xi = class Xi {
                constructor(r, l, C, U) {
                    this.name = r, this.prefix = l, this.baseEncode = C, this.baseDecode = U, this.encoder = new Hi(r, l, C), this.decoder = new Ji(r, l, U)
                }
                encode(r) {
                    return this.encoder.encode(r)
                }
                decode(r) {
                    return this.decoder.decode(r)
                }
            };
            let index_es_X = ({
                    name: r,
                    prefix: l,
                    encode: C,
                    decode: U
                }) => new Xi(r, l, C, U),
                index_es_B = ({
                    prefix: r,
                    name: l,
                    alphabet: C
                }) => {
                    let {
                        encode: U,
                        decode: et
                    } = ji(C, l);
                    return index_es_X({
                        prefix: r,
                        name: l,
                        encode: U,
                        decode: r => index_es_Ne(et(r))
                    })
                },
                Qi = (r, l, C, U) => {
                    let et = {};
                    for (let r = 0; r < l.length; ++r) et[l[r]] = r;
                    let eo = r.length;
                    for (;
                        "=" === r[eo - 1];) --eo;
                    let es = new Uint8Array(eo * C / 8 | 0),
                        el = 0,
                        ec = 0,
                        ed = 0;
                    for (let l = 0; l < eo; ++l) {
                        let eo = et[r[l]];
                        if (void 0 === eo) throw SyntaxError(`Non-${U} character`);
                        ec = ec << C | eo, (el += C) >= 8 && (el -= 8, es[ed++] = 255 & ec >> el)
                    }
                    if (el >= C || 255 & ec << 8 - el) throw SyntaxError("Unexpected end of data");
                    return es
                },
                Zi = (r, l, C) => {
                    let U = "=" === l[l.length - 1],
                        et = (1 << C) - 1,
                        eo = "",
                        es = 0,
                        el = 0;
                    for (let U = 0; U < r.length; ++U)
                        for (el = el << 8 | r[U], es += 8; es > C;) es -= C, eo += l[et & el >> es];
                    if (es && (eo += l[et & el << C - es]), U)
                        for (; eo.length * C & 7;) eo += "=";
                    return eo
                },
                index_es_g = ({
                    name: r,
                    prefix: l,
                    bitsPerChar: C,
                    alphabet: U
                }) => index_es_X({
                    prefix: l,
                    name: r,
                    encode: r => Zi(r, U, C),
                    decode: l => Qi(l, U, C, r)
                }),
                nx = index_es_X({
                    prefix: "\x00",
                    name: "identity",
                    encode: r => Yi(r),
                    decode: r => Gi(r)
                });
            var nA = Object.freeze({
                __proto__: null,
                identity: nx
            });
            let nP = index_es_g({
                prefix: "0",
                name: "base2",
                alphabet: "01",
                bitsPerChar: 1
            });
            var nC = Object.freeze({
                __proto__: null,
                base2: nP
            });
            let nk = index_es_g({
                prefix: "7",
                name: "base8",
                alphabet: "01234567",
                bitsPerChar: 3
            });
            var nN = Object.freeze({
                __proto__: null,
                base8: nk
            });
            let nO = index_es_B({
                prefix: "9",
                name: "base10",
                alphabet: "0123456789"
            });
            var nT = Object.freeze({
                __proto__: null,
                base10: nO
            });
            let nR = index_es_g({
                    prefix: "f",
                    name: "base16",
                    alphabet: "0123456789abcdef",
                    bitsPerChar: 4
                }),
                nD = index_es_g({
                    prefix: "F",
                    name: "base16upper",
                    alphabet: "0123456789ABCDEF",
                    bitsPerChar: 4
                });
            var nB = Object.freeze({
                __proto__: null,
                base16: nR,
                base16upper: nD
            });
            let nU = index_es_g({
                    prefix: "b",
                    name: "base32",
                    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
                    bitsPerChar: 5
                }),
                nL = index_es_g({
                    prefix: "B",
                    name: "base32upper",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
                    bitsPerChar: 5
                }),
                nM = index_es_g({
                    prefix: "c",
                    name: "base32pad",
                    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
                    bitsPerChar: 5
                }),
                nj = index_es_g({
                    prefix: "C",
                    name: "base32padupper",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
                    bitsPerChar: 5
                }),
                nq = index_es_g({
                    prefix: "v",
                    name: "base32hex",
                    alphabet: "0123456789abcdefghijklmnopqrstuv",
                    bitsPerChar: 5
                }),
                n$ = index_es_g({
                    prefix: "V",
                    name: "base32hexupper",
                    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
                    bitsPerChar: 5
                }),
                nz = index_es_g({
                    prefix: "t",
                    name: "base32hexpad",
                    alphabet: "0123456789abcdefghijklmnopqrstuv=",
                    bitsPerChar: 5
                }),
                nH = index_es_g({
                    prefix: "T",
                    name: "base32hexpadupper",
                    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
                    bitsPerChar: 5
                }),
                nF = index_es_g({
                    prefix: "h",
                    name: "base32z",
                    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
                    bitsPerChar: 5
                });
            var nW = Object.freeze({
                __proto__: null,
                base32: nU,
                base32upper: nL,
                base32pad: nM,
                base32padupper: nj,
                base32hex: nq,
                base32hexupper: n$,
                base32hexpad: nz,
                base32hexpadupper: nH,
                base32z: nF
            });
            let nV = index_es_B({
                    prefix: "k",
                    name: "base36",
                    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
                }),
                nK = index_es_B({
                    prefix: "K",
                    name: "base36upper",
                    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                });
            var nG = Object.freeze({
                __proto__: null,
                base36: nV,
                base36upper: nK
            });
            let nJ = index_es_B({
                    name: "base58btc",
                    prefix: "z",
                    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
                }),
                nY = index_es_B({
                    name: "base58flickr",
                    prefix: "Z",
                    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
                });
            var nZ = Object.freeze({
                __proto__: null,
                base58btc: nJ,
                base58flickr: nY
            });
            let nX = index_es_g({
                    prefix: "m",
                    name: "base64",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
                    bitsPerChar: 6
                }),
                nQ = index_es_g({
                    prefix: "M",
                    name: "base64pad",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                    bitsPerChar: 6
                }),
                n0 = index_es_g({
                    prefix: "u",
                    name: "base64url",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
                    bitsPerChar: 6
                }),
                n1 = index_es_g({
                    prefix: "U",
                    name: "base64urlpad",
                    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
                    bitsPerChar: 6
                });
            var n2 = Object.freeze({
                __proto__: null,
                base64: nX,
                base64pad: nQ,
                base64url: n0,
                base64urlpad: n1
            });
            let n3 = Array.from("\uD83D\uDE80\uD83E\uDE90\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B\uD83E\uDD19\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81\uD83C\uDF1E\uD83C\uDF88\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74\uD83D\uDC8E\uD83D\uDCB8\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42"),
                n5 = n3.reduce((r, l, C) => (r[C] = l, r), []),
                n6 = n3.reduce((r, l, C) => (r[l.codePointAt(0)] = C, r), []),
                n8 = index_es_X({
                    prefix: "\uD83D\uDE80",
                    name: "base256emoji",
                    encode: function(r) {
                        return r.reduce((r, l) => r += n5[l], "")
                    },
                    decode: function(r) {
                        let l = [];
                        for (let C of r) {
                            let r = n6[C.codePointAt(0)];
                            if (void 0 === r) throw Error(`Non-base256emoji character: ${C}`);
                            l.push(r)
                        }
                        return new Uint8Array(l)
                    }
                });
            var n4 = Object.freeze({
                __proto__: null,
                base256emoji: n8
            });

            function index_es_$e(r, l, C) {
                l = l || [], C = C || 0;
                for (var U = C; r >= 2147483648;) l[C++] = 255 & r | 128, r /= 128;
                for (; - 128 & r;) l[C++] = 255 & r | 128, r >>>= 7;
                return l[C] = 0 | r, index_es_$e.bytes = C - U + 1, l
            }

            function index_es_he(r, l) {
                var C, U = 0,
                    l = l || 0,
                    et = 0,
                    eo = l,
                    es = r.length;
                do {
                    if (eo >= es) throw index_es_he.bytes = 0, RangeError("Could not decode varint");
                    C = r[eo++], U += et < 28 ? (127 & C) << et : (127 & C) * Math.pow(2, et), et += 7
                } while (C >= 128);
                return index_es_he.bytes = eo - l, U
            }
            var n9 = {
                encode: index_es_$e,
                decode: index_es_he,
                encodingLength: function(r) {
                    return r < 128 ? 1 : r < 16384 ? 2 : r < 2097152 ? 3 : r < 268435456 ? 4 : r < 34359738368 ? 5 : r < 4398046511104 ? 6 : r < 562949953421312 ? 7 : r < 72057594037927940 ? 8 : r < 0x7fffffffffffffff ? 9 : 10
                }
            };
            let index_es_Ke = (r, l, C = 0) => (n9.encode(r, l, C), l),
                index_es_Be = r => n9.encodingLength(r),
                index_es_ce = (r, l) => {
                    let C = l.byteLength,
                        U = index_es_Be(r),
                        et = U + index_es_Be(C),
                        eo = new Uint8Array(et + C);
                    return index_es_Ke(r, eo, 0), index_es_Ke(C, eo, U), eo.set(l, et), new index_es_tr(r, C, l, eo)
                };
            let index_es_tr = class index_es_tr {
                constructor(r, l, C, U) {
                    this.code = r, this.size = l, this.digest = C, this.bytes = U
                }
            };
            let index_es_Ve = ({
                name: r,
                code: l,
                encode: C
            }) => new ir(r, l, C);
            let ir = class ir {
                constructor(r, l, C) {
                    this.name = r, this.code = l, this.encode = C
                }
                digest(r) {
                    if (r instanceof Uint8Array) {
                        let l = this.encode(r);
                        return l instanceof Uint8Array ? index_es_ce(this.code, l) : l.then(r => index_es_ce(this.code, r))
                    }
                    throw Error("Unknown type, must be binary type")
                }
            };
            let index_es_qe = r => async l => new Uint8Array(await crypto.subtle.digest(r, l)),
                n7 = index_es_Ve({
                    name: "sha2-256",
                    code: 18,
                    encode: index_es_qe("SHA-256")
                }),
                io = index_es_Ve({
                    name: "sha2-512",
                    code: 19,
                    encode: index_es_qe("SHA-512")
                });
            var iu = Object.freeze({
                    __proto__: null,
                    sha256: n7,
                    sha512: io
                }),
                il = Object.freeze({
                    __proto__: null,
                    identity: {
                        code: 0,
                        name: "identity",
                        encode: index_es_Ne,
                        digest: r => index_es_ce(0, index_es_Ne(r))
                    }
                });
            new TextEncoder, new TextDecoder;
            let ic = { ...nA,
                ...nC,
                ...nN,
                ...nT,
                ...nB,
                ...nW,
                ...nG,
                ...nZ,
                ...n2,
                ...n4
            };

            function index_es_He(r) {
                return null != globalThis.Buffer ? new Uint8Array(r.buffer, r.byteOffset, r.byteLength) : r
            }

            function dist_index_es_Je(r, l, C, U) {
                return {
                    name: r,
                    prefix: l,
                    encoder: {
                        name: r,
                        prefix: l,
                        encode: C
                    },
                    decoder: {
                        decode: U
                    }
                }
            }({ ...iu,
                ...il
            });
            let id = dist_index_es_Je("utf8", "u", r => "u" + new TextDecoder("utf8").decode(r), r => new TextEncoder().encode(r.substring(1))),
                ih = dist_index_es_Je("ascii", "a", r => {
                    let l = "a";
                    for (let C = 0; C < r.length; C++) l += String.fromCharCode(r[C]);
                    return l
                }, r => {
                    r = r.substring(1);
                    let l = function(r = 0) {
                        return null != globalThis.Buffer && null != globalThis.Buffer.allocUnsafe ? index_es_He(globalThis.Buffer.allocUnsafe(r)) : new Uint8Array(r)
                    }(r.length);
                    for (let C = 0; C < r.length; C++) l[C] = r.charCodeAt(C);
                    return l
                }),
                ip = {
                    utf8: id,
                    "utf-8": id,
                    hex: ic.base16,
                    latin1: ih,
                    ascii: ih,
                    binary: ih,
                    ...ic
                },
                ig = "core",
                iy = `wc@2:${ig}:`,
                im = {
                    logger: "error"
                },
                i_ = {
                    database: ":memory:"
                },
                ib = "client_ed25519_seed",
                iw = tQ.ONE_DAY,
                iE = tQ.SIX_HOURS,
                iI = "wss://relay.walletconnect.com",
                iS = "wss://relay.walletconnect.org",
                ix = {
                    message: "relayer_message",
                    message_ack: "relayer_message_ack",
                    connect: "relayer_connect",
                    disconnect: "relayer_disconnect",
                    error: "relayer_error",
                    connection_stalled: "relayer_connection_stalled",
                    publish: "relayer_publish"
                },
                iA = {
                    payload: "payload",
                    connect: "connect",
                    disconnect: "disconnect",
                    error: "error"
                },
                iP = tQ.ONE_SECOND,
                iC = {
                    created: "subscription_created",
                    deleted: "subscription_deleted",
                    sync: "subscription_sync",
                    resubscribed: "subscription_resubscribed"
                },
                ik = 1e3 * tQ.FIVE_SECONDS,
                iN = {
                    wc_pairingDelete: {
                        req: {
                            ttl: tQ.ONE_DAY,
                            prompt: !1,
                            tag: 1e3
                        },
                        res: {
                            ttl: tQ.ONE_DAY,
                            prompt: !1,
                            tag: 1001
                        }
                    },
                    wc_pairingPing: {
                        req: {
                            ttl: tQ.THIRTY_SECONDS,
                            prompt: !1,
                            tag: 1002
                        },
                        res: {
                            ttl: tQ.THIRTY_SECONDS,
                            prompt: !1,
                            tag: 1003
                        }
                    },
                    unregistered_method: {
                        req: {
                            ttl: tQ.ONE_DAY,
                            prompt: !1,
                            tag: 0
                        },
                        res: {
                            ttl: tQ.ONE_DAY,
                            prompt: !1,
                            tag: 0
                        }
                    }
                },
                iO = {
                    create: "pairing_create",
                    expire: "pairing_expire",
                    delete: "pairing_delete",
                    ping: "pairing_ping"
                },
                iT = {
                    created: "history_created",
                    updated: "history_updated",
                    deleted: "history_deleted",
                    sync: "history_sync"
                },
                iR = {
                    created: "expirer_created",
                    deleted: "expirer_deleted",
                    expired: "expirer_expired",
                    sync: "expirer_sync"
                },
                iD = "verify-api",
                iB = "https://verify.walletconnect.com",
                iU = "https://verify.walletconnect.org",
                iL = [iB, iU];
            let index_es_St = class index_es_St {
                constructor(r, l) {
                    this.core = r, this.logger = l, this.keychain = new Map, this.name = "keychain", this.version = "0.3", this.initialized = !1, this.storagePrefix = iy, this.init = async () => {
                        if (!this.initialized) {
                            let r = await this.getKeyChain();
                            "u" > typeof r && (this.keychain = r), this.initialized = !0
                        }
                    }, this.has = r => (this.isInitialized(), this.keychain.has(r)), this.set = async (r, l) => {
                        this.isInitialized(), this.keychain.set(r, l), await this.persist()
                    }, this.get = r => {
                        this.isInitialized();
                        let l = this.keychain.get(r);
                        if (typeof l > "u") {
                            let {
                                message: l
                            } = index_es_N("NO_MATCHING_KEY", `${this.name}: ${r}`);
                            throw Error(l)
                        }
                        return l
                    }, this.del = async r => {
                        this.isInitialized(), this.keychain.delete(r), await this.persist()
                    }, this.core = r, this.logger = (0, tJ.generateChildLogger)(l, this.name)
                }
                get context() {
                    return (0, tJ.getLoggerContext)(this.logger)
                }
                get storageKey() {
                    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
                }
                async setKeyChain(r) {
                    await this.core.storage.setItem(this.storageKey, rt(r))
                }
                async getKeyChain() {
                    let r = await this.core.storage.getItem(this.storageKey);
                    return "u" > typeof r ? ot(r) : void 0
                }
                async persist() {
                    await this.setKeyChain(this.keychain)
                }
                isInitialized() {
                    if (!this.initialized) {
                        let {
                            message: r
                        } = index_es_N("NOT_INITIALIZED", this.name);
                        throw Error(r)
                    }
                }
            };
            let index_es_Tt = class index_es_Tt {
                constructor(r, l, C) {
                    this.core = r, this.logger = l, this.name = "crypto", this.initialized = !1, this.init = async () => {
                        this.initialized || (await this.keychain.init(), this.initialized = !0)
                    }, this.hasKeys = r => (this.isInitialized(), this.keychain.has(r)), this.getClientId = async () => {
                        this.isInitialized();
                        let r = await this.getClientSeed(),
                            l = generateKeyPair(r);
                        return encodeIss(l.publicKey)
                    }, this.generateKeyPair = () => {
                        this.isInitialized();
                        let r = function() {
                            let r = rY.Au();
                            return {
                                privateKey: to_string_toString(r.secretKey, r4),
                                publicKey: to_string_toString(r.publicKey, r4)
                            }
                        }();
                        return this.setPrivateKey(r.publicKey, r.privateKey)
                    }, this.signJWT = async r => {
                        this.isInitialized();
                        let l = await this.getClientSeed(),
                            C = generateKeyPair(l),
                            U = Vn();
                        return await signJWT(U, r, iw, C)
                    }, this.generateSharedKey = (r, l, C) => {
                        this.isInitialized();
                        let U = this.getPrivateKey(r),
                            et = function(r, l) {
                                let C = rY.gi(from_string_fromString(r, r4), from_string_fromString(l, r4), !0),
                                    U = new rG.t(rJ.mE, C).expand(32);
                                return to_string_toString(U, r4)
                            }(U, l);
                        return this.setSymKey(et, C)
                    }, this.setSymKey = async (r, l) => {
                        this.isInitialized();
                        let C = l || function(r) {
                            let l = (0, rJ.vp)(from_string_fromString(r, r4));
                            return to_string_toString(l, r4)
                        }(r);
                        return await this.keychain.set(C, r), C
                    }, this.deleteKeyPair = async r => {
                        this.isInitialized(), await this.keychain.del(r)
                    }, this.deleteSymKey = async r => {
                        this.isInitialized(), await this.keychain.del(r)
                    }, this.encode = async (r, l, C) => {
                        this.isInitialized();
                        let U = Te(C),
                            et = (0, tW.u)(l);
                        if (qn(U)) {
                            let l = U.senderPublicKey,
                                C = U.receiverPublicKey;
                            r = await this.generateSharedKey(l, C)
                        }
                        let eo = this.getSymKey(r),
                            {
                                type: es,
                                senderPublicKey: el
                            } = U;
                        return function(r) {
                            var l;
                            let C = (l = "u" > typeof r.type ? r.type : 0, from_string_fromString(`${l}`, r8));
                            if (1 === $(C) && typeof r.senderPublicKey > "u") throw Error("Missing sender public key for type 1 envelope");
                            let U = "u" > typeof r.senderPublicKey ? from_string_fromString(r.senderPublicKey, r4) : void 0,
                                et = "u" > typeof r.iv ? from_string_fromString(r.iv, r4) : (0, tX.randomBytes)(12),
                                eo = new rK.OK(from_string_fromString(r.symKey, r4)).seal(et, from_string_fromString(r.message, r7));
                            return function(r) {
                                if (1 === $(r.type)) {
                                    if (typeof r.senderPublicKey > "u") throw Error("Missing sender public key for type 1 envelope");
                                    return to_string_toString(concat([r.type, r.senderPublicKey, r.iv, r.sealed]), r9)
                                }
                                return to_string_toString(concat([r.type, r.iv, r.sealed]), r9)
                            }({
                                type: C,
                                sealed: eo,
                                iv: et,
                                senderPublicKey: U
                            })
                        }({
                            type: es,
                            symKey: eo,
                            message: et,
                            senderPublicKey: el
                        })
                    }, this.decode = async (r, l, C) => {
                        this.isInitialized();
                        let U = function(r, l) {
                            let C = ee(r);
                            return Te({
                                type: $(C.type),
                                senderPublicKey: "u" > typeof C.senderPublicKey ? to_string_toString(C.senderPublicKey, r4) : void 0,
                                receiverPublicKey: l ? .receiverPublicKey
                            })
                        }(l, C);
                        if (qn(U)) {
                            let l = U.receiverPublicKey,
                                C = U.senderPublicKey;
                            r = await this.generateSharedKey(l, C)
                        }
                        try {
                            let C = this.getSymKey(r),
                                U = function(r) {
                                    let l = new rK.OK(from_string_fromString(r.symKey, r4)),
                                        {
                                            sealed: C,
                                            iv: U
                                        } = ee(r.encoded),
                                        et = l.open(U, C);
                                    if (null === et) throw Error("Failed to decrypt");
                                    return to_string_toString(et, r7)
                                }({
                                    symKey: C,
                                    encoded: l
                                });
                            return (0, tW.D)(U)
                        } catch (l) {
                            this.logger.error(`Failed to decode message from topic: '${r}', clientId: '${await this.getClientId()}'`), this.logger.error(l)
                        }
                    }, this.getPayloadType = r => {
                        let l = ee(r);
                        return $(l.type)
                    }, this.getPayloadSenderPublicKey = r => {
                        let l = ee(r);
                        return l.senderPublicKey ? to_string_toString(l.senderPublicKey, r4) : void 0
                    }, this.core = r, this.logger = (0, tJ.generateChildLogger)(l, this.name), this.keychain = C || new index_es_St(this.core, this.logger)
                }
                get context() {
                    return (0, tJ.getLoggerContext)(this.logger)
                }
                async setPrivateKey(r, l) {
                    return await this.keychain.set(r, l), r
                }
                getPrivateKey(r) {
                    return this.keychain.get(r)
                }
                async getClientSeed() {
                    let r = "";
                    try {
                        r = this.keychain.get(ib)
                    } catch {
                        r = Vn(), await this.keychain.set(ib, r)
                    }
                    return function(r, l = "utf8") {
                        let C = ip[l];
                        if (!C) throw Error(`Unsupported encoding "${l}"`);
                        return ("utf8" === l || "utf-8" === l) && null != globalThis.Buffer && null != globalThis.Buffer.from ? index_es_He(globalThis.Buffer.from(r, "utf-8")) : C.decoder.decode(`${C.prefix}${r}`)
                    }(r, "base16")
                }
                getSymKey(r) {
                    return this.keychain.get(r)
                }
                isInitialized() {
                    if (!this.initialized) {
                        let {
                            message: r
                        } = index_es_N("NOT_INITIALIZED", this.name);
                        throw Error(r)
                    }
                }
            };
            let index_es_Pt = class index_es_Pt extends a {
                constructor(r, l) {
                    super(r, l), this.logger = r, this.core = l, this.messages = new Map, this.name = "messages", this.version = "0.3", this.initialized = !1, this.storagePrefix = iy, this.init = async () => {
                        if (!this.initialized) {
                            this.logger.trace("Initialized");
                            try {
                                let r = await this.getRelayerMessages();
                                "u" > typeof r && (this.messages = r), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({
                                    type: "method",
                                    method: "restore",
                                    size: this.messages.size
                                })
                            } catch (r) {
                                this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(r)
                            } finally {
                                this.initialized = !0
                            }
                        }
                    }, this.set = async (r, l) => {
                        this.isInitialized();
                        let C = Ln(l),
                            U = this.messages.get(r);
                        return typeof U > "u" && (U = {}), "u" > typeof U[C] || (U[C] = l, this.messages.set(r, U), await this.persist()), C
                    }, this.get = r => {
                        this.isInitialized();
                        let l = this.messages.get(r);
                        return typeof l > "u" && (l = {}), l
                    }, this.has = (r, l) => {
                        this.isInitialized();
                        let C = this.get(r),
                            U = Ln(l);
                        return "u" > typeof C[U]
                    }, this.del = async r => {
                        this.isInitialized(), this.messages.delete(r), await this.persist()
                    }, this.logger = (0, tJ.generateChildLogger)(r, this.name), this.core = l
                }
                get context() {
                    return (0, tJ.getLoggerContext)(this.logger)
                }
                get storageKey() {
                    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
                }
                async setRelayerMessages(r) {
                    await this.core.storage.setItem(this.storageKey, rt(r))
                }
                async getRelayerMessages() {
                    let r = await this.core.storage.getItem(this.storageKey);
                    return "u" > typeof r ? ot(r) : void 0
                }
                async persist() {
                    await this.setRelayerMessages(this.messages)
                }
                isInitialized() {
                    if (!this.initialized) {
                        let {
                            message: r
                        } = index_es_N("NOT_INITIALIZED", this.name);
                        throw Error(r)
                    }
                }
            };
            let mr = class mr extends u {
                constructor(r, l) {
                    super(r, l), this.relayer = r, this.logger = l, this.events = new tM.EventEmitter, this.name = "publisher", this.queue = new Map, this.publishTimeout = (0, tQ.toMiliseconds)(tQ.TEN_SECONDS), this.needsTransportRestart = !1, this.publish = async (r, l, C) => {
                        var U;
                        this.logger.debug("Publishing Payload"), this.logger.trace({
                            type: "method",
                            method: "publish",
                            params: {
                                topic: r,
                                message: l,
                                opts: C
                            }
                        });
                        try {
                            let et = C ? .ttl || iE,
                                eo = vt(C),
                                es = C ? .prompt || !1,
                                el = C ? .tag || 0,
                                ec = C ? .id || (0, nb.getBigIntRpcId)().toString(),
                                ed = {
                                    topic: r,
                                    message: l,
                                    opts: {
                                        ttl: et,
                                        relay: eo,
                                        prompt: es,
                                        tag: el,
                                        id: ec
                                    }
                                },
                                eh = setTimeout(() => this.queue.set(ec, ed), this.publishTimeout);
                            try {
                                await await ut(this.rpcPublish(r, l, et, eo, es, el, ec), this.publishTimeout, "Failed to publish payload, please try again."), this.removeRequestFromQueue(ec), this.relayer.events.emit(ix.publish, ed)
                            } catch (r) {
                                if (this.logger.debug("Publishing Payload stalled"), this.needsTransportRestart = !0, null != (U = C ? .internal) && U.throwOnFailedPublish) throw this.removeRequestFromQueue(ec), r;
                                return
                            } finally {
                                clearTimeout(eh)
                            }
                            this.logger.debug("Successfully Published Payload"), this.logger.trace({
                                type: "method",
                                method: "publish",
                                params: {
                                    topic: r,
                                    message: l,
                                    opts: C
                                }
                            })
                        } catch (r) {
                            throw this.logger.debug("Failed to Publish Payload"), this.logger.error(r), r
                        }
                    }, this.on = (r, l) => {
                        this.events.on(r, l)
                    }, this.once = (r, l) => {
                        this.events.once(r, l)
                    }, this.off = (r, l) => {
                        this.events.off(r, l)
                    }, this.removeListener = (r, l) => {
                        this.events.removeListener(r, l)
                    }, this.relayer = r, this.logger = (0, tJ.generateChildLogger)(l, this.name), this.registerEventListeners()
                }
                get context() {
                    return (0, tJ.getLoggerContext)(this.logger)
                }
                rpcPublish(r, l, C, U, et, eo, es) {
                    var el, ec, ed, eh;
                    let ef = {
                        method: Et(U.protocol).publish,
                        params: {
                            topic: r,
                            message: l,
                            ttl: C,
                            prompt: et,
                            tag: eo
                        },
                        id: es
                    };
                    return w(null == (el = ef.params) ? void 0 : el.prompt) && (null == (ec = ef.params) || delete ec.prompt), w(null == (ed = ef.params) ? void 0 : ed.tag) && (null == (eh = ef.params) || delete eh.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
                        type: "message",
                        direction: "outgoing",
                        request: ef
                    }), this.relayer.request(ef)
                }
                removeRequestFromQueue(r) {
                    this.queue.delete(r)
                }
                checkQueue() {
                    this.queue.forEach(async r => {
                        let {
                            topic: l,
                            message: C,
                            opts: U
                        } = r;
                        await this.publish(l, C, U)
                    })
                }
                registerEventListeners() {
                    this.relayer.core.heartbeat.on(tG.HEARTBEAT_EVENTS.pulse, () => {
                        if (this.needsTransportRestart) {
                            this.needsTransportRestart = !1, this.relayer.events.emit(ix.connection_stalled);
                            return
                        }
                        this.checkQueue()
                    }), this.relayer.on(ix.message_ack, r => {
                        this.removeRequestFromQueue(r.id.toString())
                    })
                }
            };
            let br = class br {
                constructor() {
                    this.map = new Map, this.set = (r, l) => {
                        let C = this.get(r);
                        this.exists(r, l) || this.map.set(r, [...C, l])
                    }, this.get = r => this.map.get(r) || [], this.exists = (r, l) => this.get(r).includes(l), this.delete = (r, l) => {
                        if (typeof l > "u") {
                            this.map.delete(r);
                            return
                        }
                        if (!this.map.has(r)) return;
                        let C = this.get(r);
                        if (!this.exists(r, l)) return;
                        let U = C.filter(r => r !== l);
                        if (!U.length) {
                            this.map.delete(r);
                            return
                        }
                        this.map.set(r, U)
                    }, this.clear = () => {
                        this.map.clear()
                    }
                }
                get topics() {
                    return Array.from(this.map.keys())
                }
            };
            var iM = Object.defineProperty,
                ij = Object.defineProperties,
                iq = Object.getOwnPropertyDescriptors,
                i$ = Object.getOwnPropertySymbols,
                iz = Object.prototype.hasOwnProperty,
                iH = Object.prototype.propertyIsEnumerable,
                index_es_Ot = (r, l, C) => l in r ? iM(r, l, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: C
                }) : r[l] = C,
                index_es_q = (r, l) => {
                    for (var C in l || (l = {})) iz.call(l, C) && index_es_Ot(r, C, l[C]);
                    if (i$)
                        for (var C of i$(l)) iH.call(l, C) && index_es_Ot(r, C, l[C]);
                    return r
                },
                index_es_De = (r, l) => ij(r, iq(l));
            let index_es_At = class index_es_At extends d {
                constructor(r, l) {
                    super(r, l), this.relayer = r, this.logger = l, this.subscriptions = new Map, this.topicMap = new br, this.events = new tM.EventEmitter, this.name = "subscription", this.version = "0.3", this.pending = new Map, this.cached = [], this.initialized = !1, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = iy, this.subscribeTimeout = 1e4, this.restartInProgress = !1, this.batchSubscribeTopicsLimit = 500, this.init = async () => {
                        this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId())
                    }, this.subscribe = async (r, l) => {
                        await this.restartToComplete(), this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({
                            type: "method",
                            method: "subscribe",
                            params: {
                                topic: r,
                                opts: l
                            }
                        });
                        try {
                            let C = vt(l),
                                U = {
                                    topic: r,
                                    relay: C
                                };
                            this.pending.set(r, U);
                            let et = await this.rpcSubscribe(r, C);
                            return this.onSubscribe(et, U), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({
                                type: "method",
                                method: "subscribe",
                                params: {
                                    topic: r,
                                    opts: l
                                }
                            }), et
                        } catch (r) {
                            throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(r), r
                        }
                    }, this.unsubscribe = async (r, l) => {
                        await this.restartToComplete(), this.isInitialized(), "u" > typeof l ? .id ? await this.unsubscribeById(r, l.id, l) : await this.unsubscribeByTopic(r, l)
                    }, this.isSubscribed = async r => !!this.topics.includes(r) || await new Promise((l, C) => {
                        let U = new tQ.Watch;
                        U.start(this.pendingSubscriptionWatchLabel);
                        let et = setInterval(() => {
                            !this.pending.has(r) && this.topics.includes(r) && (clearInterval(et), U.stop(this.pendingSubscriptionWatchLabel), l(!0)), U.elapsed(this.pendingSubscriptionWatchLabel) >= ik && (clearInterval(et), U.stop(this.pendingSubscriptionWatchLabel), C(Error("Subscription resolution timeout")))
                        }, this.pollingInterval)
                    }).catch(() => !1), this.on = (r, l) => {
                        this.events.on(r, l)
                    }, this.once = (r, l) => {
                        this.events.once(r, l)
                    }, this.off = (r, l) => {
                        this.events.off(r, l)
                    }, this.removeListener = (r, l) => {
                        this.events.removeListener(r, l)
                    }, this.restart = async () => {
                        this.restartInProgress = !0, await this.restore(), await this.reset(), this.restartInProgress = !1
                    }, this.relayer = r, this.logger = (0, tJ.generateChildLogger)(l, this.name), this.clientId = ""
                }
                get context() {
                    return (0, tJ.getLoggerContext)(this.logger)
                }
                get storageKey() {
                    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name
                }
                get length() {
                    return this.subscriptions.size
                }
                get ids() {
                    return Array.from(this.subscriptions.keys())
                }
                get values() {
                    return Array.from(this.subscriptions.values())
                }
                get topics() {
                    return this.topicMap.topics
                }
                hasSubscription(r, l) {
                    let C = !1;
                    try {
                        C = this.getSubscription(r).topic === l
                    } catch {}
                    return C
                }
                onEnable() {
                    this.cached = [], this.initialized = !0
                }
                onDisable() {
                    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear()
                }
                async unsubscribeByTopic(r, l) {
                    let C = this.topicMap.get(r);
                    await Promise.all(C.map(async C => await this.unsubscribeById(r, C, l)))
                }
                async unsubscribeById(r, l, C) {
                    this.logger.debug("Unsubscribing Topic"), this.logger.trace({
                        type: "method",
                        method: "unsubscribe",
                        params: {
                            topic: r,
                            id: l,
                            opts: C
                        }
                    });
                    try {
                        let U = vt(C);
                        await this.rpcUnsubscribe(r, l, U);
                        let et = index_es_U("USER_DISCONNECTED", `${this.name}, ${r}`);
                        await this.onUnsubscribe(r, l, et), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({
                            type: "method",
                            method: "unsubscribe",
                            params: {
                                topic: r,
                                id: l,
                                opts: C
                            }
                        })
                    } catch (r) {
                        throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(r), r
                    }
                }
                async rpcSubscribe(r, l) {
                    let C = {
                        method: Et(l.protocol).subscribe,
                        params: {
                            topic: r
                        }
                    };
                    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
                        type: "payload",
                        direction: "outgoing",
                        request: C
                    });
                    try {
                        await await ut(this.relayer.request(C), this.subscribeTimeout)
                    } catch {
                        this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(ix.connection_stalled)
                    }
                    return Ln(r + this.clientId)
                }
                async rpcBatchSubscribe(r) {
                    if (!r.length) return;
                    let l = r[0].relay,
                        C = {
                            method: Et(l.protocol).batchSubscribe,
                            params: {
                                topics: r.map(r => r.topic)
                            }
                        };
                    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
                        type: "payload",
                        direction: "outgoing",
                        request: C
                    });
                    try {
                        return await await ut(this.relayer.request(C), this.subscribeTimeout)
                    } catch {
                        this.logger.debug("Outgoing Relay Payload stalled"), this.relayer.events.emit(ix.connection_stalled)
                    }
                }
                rpcUnsubscribe(r, l, C) {
                    let U = {
                        method: Et(C.protocol).unsubscribe,
                        params: {
                            topic: r,
                            id: l
                        }
                    };
                    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
                        type: "payload",
                        direction: "outgoing",
                        request: U
                    }), this.relayer.request(U)
                }
                onSubscribe(r, l) {
                    this.setSubscription(r, index_es_De(index_es_q({}, l), {
                        id: r
                    })), this.pending.delete(l.topic)
                }
                onBatchSubscribe(r) {
                    r.length && r.forEach(r => {
                        this.setSubscription(r.id, index_es_q({}, r)), this.pending.delete(r.topic)
                    })
                }
                async onUnsubscribe(r, l, C) {
                    this.events.removeAllListeners(l), this.hasSubscription(l, r) && this.deleteSubscription(l, C), await this.relayer.messages.del(r)
                }
                async setRelayerSubscriptions(r) {
                    await this.relayer.core.storage.setItem(this.storageKey, r)
                }
                async getRelayerSubscriptions() {
                    return await this.relayer.core.storage.getItem(this.storageKey)
                }
                setSubscription(r, l) {
                    this.subscriptions.has(r) || (this.logger.debug("Setting subscription"), this.logger.trace({
                        type: "method",
                        method: "setSubscription",
                        id: r,
                        subscription: l
                    }), this.addSubscription(r, l))
                }
                addSubscription(r, l) {
                    this.subscriptions.set(r, index_es_q({}, l)), this.topicMap.set(l.topic, r), this.events.emit(iC.created, l)
                }
                getSubscription(r) {
                    this.logger.debug("Getting subscription"), this.logger.trace({
                        type: "method",
                        method: "getSubscription",
                        id: r
                    });
                    let l = this.subscriptions.get(r);
                    if (!l) {
                        let {
                            message: l
                        } = index_es_N("NO_MATCHING_KEY", `${this.name}: ${r}`);
                        throw Error(l)
                    }
                    return l
                }
                deleteSubscription(r, l) {
                    this.logger.debug("Deleting subscription"), this.logger.trace({
                        type: "method",
                        method: "deleteSubscription",
                        id: r,
                        reason: l
                    });
                    let C = this.getSubscription(r);
                    this.subscriptions.delete(r), this.topicMap.delete(C.topic, r), this.events.emit(iC.deleted, index_es_De(index_es_q({}, C), {
                        reason: l
                    }))
                }
                async persist() {
                    await this.setRelayerSubscriptions(this.values), this.events.emit(iC.sync)
                }
                async reset() {
                    if (this.cached.length) {
                        let r = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
                        for (let l = 0; l < r; l++) {
                            let r = this.cached.splice(0, this.batchSubscribeTopicsLimit);
                            await this.batchSubscribe(r)
                        }
                    }
                    this.events.emit(iC.resubscribed)
                }
                async restore() {
                    try {
                        let r = await this.getRelayerSubscriptions();
                        if (typeof r > "u" || !r.length) return;
                        if (this.subscriptions.size) {
                            let {
                                message: r
                            } = index_es_N("RESTORE_WILL_OVERRIDE", this.name);
                            throw this.logger.error(r), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), Error(r)
                        }
                        this.cached = r, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({
                            type: "method",
                            method: "restore",
                            subscriptions: this.values
                        })
                    } catch (r) {
                        this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(r)
                    }
                }
                async batchSubscribe(r) {
                    if (!r.length) return;
                    let l = await this.rpcBatchSubscribe(r);
                    index_es_k(l) && this.onBatchSubscribe(l.map((l, C) => index_es_De(index_es_q({}, r[C]), {
                        id: l
                    })))
                }
                async onConnect() {
                    this.restartInProgress || (await this.restart(), this.onEnable())
                }
                onDisconnect() {
                    this.onDisable()
                }
                async checkPending() {
                    if (!this.initialized || this.relayer.transportExplicitlyClosed) return;
                    let r = [];
                    this.pending.forEach(l => {
                        r.push(l)
                    }), await this.batchSubscribe(r)
                }
                registerEventListeners() {
                    this.relayer.core.heartbeat.on(tG.HEARTBEAT_EVENTS.pulse, async () => {
                        await this.checkPending()
                    }), this.relayer.on(ix.connect, async () => {
                        await this.onConnect()
                    }), this.relayer.on(ix.disconnect, () => {
                        this.onDisconnect()
                    }), this.events.on(iC.created, async r => {
                        let l = iC.created;
                        this.logger.info(`Emitting ${l}`), this.logger.debug({
                            type: "event",
                            event: l,
                            data: r
                        }), await this.persist()
                    }), this.events.on(iC.deleted, async r => {
                        let l = iC.deleted;
                        this.logger.info(`Emitting ${l}`), this.logger.debug({
                            type: "event",
                            event: l,
                            data: r
                        }), await this.persist()
                    })
                }
                isInitialized() {
                    if (!this.initialized) {
                        let {
                            message: r
                        } = index_es_N("NOT_INITIALIZED", this.name);
                        throw Error(r)
                    }
                }
                async restartToComplete() {
                    this.restartInProgress && await new Promise(r => {
                        let l = setInterval(() => {
                            this.restartInProgress || (clearInterval(l), r())
                        }, this.pollingInterval)
                    })
                }
            };
            var iF = Object.defineProperty,
                iW = Object.getOwnPropertySymbols,
                iV = Object.prototype.hasOwnProperty,
                iK = Object.prototype.propertyIsEnumerable,
                index_es_Nt = (r, l, C) => l in r ? iF(r, l, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: C
                }) : r[l] = C,
                Sr = (r, l) => {
                    for (var C in l || (l = {})) iV.call(l, C) && index_es_Nt(r, C, l[C]);
                    if (iW)
                        for (var C of iW(l)) iK.call(l, C) && index_es_Nt(r, C, l[C]);
                    return r
                };
            let index_es_Ut = class index_es_Ut extends g {
                constructor(r) {
                    super(r), this.protocol = "wc", this.version = 2, this.events = new tM.EventEmitter, this.name = "relayer", this.transportExplicitlyClosed = !1, this.initialized = !1, this.connectionAttemptInProgress = !1, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "socket stalled"], this.hasExperiencedNetworkDisruption = !1, this.request = async r => {
                        this.logger.debug("Publishing Request Payload");
                        try {
                            return await this.toEstablishConnection(), await this.provider.request(r)
                        } catch (r) {
                            throw this.logger.debug("Failed to Publish Request"), this.logger.error(r), r
                        }
                    }, this.onPayloadHandler = r => {
                        this.onProviderPayload(r)
                    }, this.onConnectHandler = () => {
                        this.events.emit(ix.connect)
                    }, this.onDisconnectHandler = () => {
                        this.onProviderDisconnect()
                    }, this.onProviderErrorHandler = r => {
                        this.logger.error(r), this.events.emit(ix.error, r), this.logger.info("Fatal socket error received, closing transport"), this.transportClose()
                    }, this.registerProviderListeners = () => {
                        this.provider.on(iA.payload, this.onPayloadHandler), this.provider.on(iA.connect, this.onConnectHandler), this.provider.on(iA.disconnect, this.onDisconnectHandler), this.provider.on(iA.error, this.onProviderErrorHandler)
                    }, this.core = r.core, this.logger = "u" > typeof r.logger && "string" != typeof r.logger ? (0, tJ.generateChildLogger)(r.logger, this.name) : (0, tJ.pino)((0, tJ.getDefaultLoggerOptions)({
                        level: r.logger || "error"
                    })), this.messages = new index_es_Pt(this.logger, r.core), this.subscriber = new index_es_At(this, this.logger), this.publisher = new mr(this, this.logger), this.relayUrl = r ? .relayUrl || iI, this.projectId = r.projectId, this.bundleId = function() {
                        var r;
                        try {
                            return dist_index_es_C() && "u" > typeof C.g && "u" > typeof(null == C.g ? void 0 : C.g.Application) ? null == (r = C.g.Application) ? void 0 : r.applicationId : void 0
                        } catch {
                            return
                        }
                    }(), this.provider = {}
                }
                async init() {
                    this.logger.trace("Initialized"), this.registerEventListeners(), await this.createProvider(), await Promise.all([this.messages.init(), this.subscriber.init()]);
                    try {
                        await this.transportOpen()
                    } catch {
                        this.logger.warn(`Connection via ${this.relayUrl} failed, attempting to connect via failover domain ${iS}...`), await this.restartTransport(iS)
                    }
                    this.initialized = !0, setTimeout(async () => {
                        0 === this.subscriber.topics.length && (this.logger.info("No topics subscribed to after init, closing transport"), await this.transportClose(), this.transportExplicitlyClosed = !1)
                    }, 1e4)
                }
                get context() {
                    return (0, tJ.getLoggerContext)(this.logger)
                }
                get connected() {
                    return this.provider.connection.connected
                }
                get connecting() {
                    return this.provider.connection.connecting
                }
                async publish(r, l, C) {
                    this.isInitialized(), await this.publisher.publish(r, l, C), await this.recordMessageEvent({
                        topic: r,
                        message: l,
                        publishedAt: Date.now()
                    })
                }
                async subscribe(r, l) {
                    var C;
                    let U;
                    this.isInitialized();
                    let et = (null == (C = this.subscriber.topicMap.get(r)) ? void 0 : C[0]) || "";
                    if (et) return et;
                    let o = l => {
                        l.topic === r && (this.subscriber.off(iC.created, o), U())
                    };
                    return await Promise.all([new Promise(r => {
                        U = r, this.subscriber.on(iC.created, o)
                    }), new Promise(async C => {
                        et = await this.subscriber.subscribe(r, l), C()
                    })]), et
                }
                async unsubscribe(r, l) {
                    this.isInitialized(), await this.subscriber.unsubscribe(r, l)
                }
                on(r, l) {
                    this.events.on(r, l)
                }
                once(r, l) {
                    this.events.once(r, l)
                }
                off(r, l) {
                    this.events.off(r, l)
                }
                removeListener(r, l) {
                    this.events.removeListener(r, l)
                }
                async transportClose() {
                    this.transportExplicitlyClosed = !0, this.hasExperiencedNetworkDisruption && this.connected ? await ut(this.provider.disconnect(), 1e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.connected && await this.provider.disconnect()
                }
                async transportOpen(r) {
                    if (this.transportExplicitlyClosed = !1, await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress) {
                        r && r !== this.relayUrl && (this.relayUrl = r, await this.transportClose(), await this.createProvider()), this.connectionAttemptInProgress = !0;
                        try {
                            await Promise.all([new Promise(r => {
                                if (!this.initialized) return r();
                                this.subscriber.once(iC.resubscribed, () => {
                                    r()
                                })
                            }), new Promise(async (r, l) => {
                                try {
                                    await ut(this.provider.connect(), 1e4, `Socket stalled when trying to connect to ${this.relayUrl}`)
                                } catch (r) {
                                    l(r);
                                    return
                                }
                                r()
                            })])
                        } catch (r) {
                            if (this.logger.error(r), !this.isConnectionStalled(r.message)) throw r;
                            this.provider.events.emit(iA.disconnect)
                        } finally {
                            this.connectionAttemptInProgress = !1, this.hasExperiencedNetworkDisruption = !1
                        }
                    }
                }
                async restartTransport(r) {
                    await this.confirmOnlineStateOrThrow(), this.connectionAttemptInProgress || (this.relayUrl = r || this.relayUrl, await this.transportClose(), await this.createProvider(), await this.transportOpen())
                }
                async confirmOnlineStateOrThrow() {
                    if (!await er()) throw Error("No internet connection detected. Please restart your network and try again.")
                }
                isConnectionStalled(r) {
                    return this.staleConnectionErrors.some(l => r.includes(l))
                }
                async createProvider() {
                    this.provider.connection && this.unregisterProviderListeners();
                    let r = await this.core.crypto.signJWT(this.relayUrl);
                    this.provider = new n_.r(new f(function({
                        protocol: r,
                        version: l,
                        relayUrl: U,
                        sdkVersion: et,
                        auth: eo,
                        projectId: es,
                        useOnCloseEvent: el,
                        bundleId: ec
                    }) {
                        var ed;
                        let eh;
                        let ef = U.split("?"),
                            ep = function(r, l, U) {
                                let et = function() {
                                        var r;
                                        if (T() === nc.reactNative && "u" > typeof C.g && "u" > typeof(null == C.g ? void 0 : C.g.Platform)) {
                                            let {
                                                OS: r,
                                                Version: l
                                            } = C.g.Platform;
                                            return [r, l].join("-")
                                        }
                                        let l = r ? parseUserAgent(r) : "undefined" == typeof document && "undefined" != typeof navigator && "ReactNative" === navigator.product ? new ReactNativeInfo : "undefined" != typeof navigator ? parseUserAgent(navigator.userAgent) : void 0 !== rZ && rZ.version ? new NodeInfo(rZ.version.slice(1)) : null;
                                        if (null === l) return "unknown";
                                        let U = l.os ? l.os.replace(" ", "").toLowerCase() : "unknown";
                                        return "browser" === l.type ? [U, l.name, l.version].join("-") : [U, l.version].join("-")
                                    }(),
                                    eo = function() {
                                        var r;
                                        let l = T();
                                        return l === nc.browser ? [l, (null == (r = (0, r1.getLocation)()) ? void 0 : r.host) || "unknown"].join(":") : l
                                    }();
                                return [
                                    [r, l].join("-"), ["js", U].join("-"), et, eo
                                ].join("/")
                            }(r, l, et),
                            eg = (ed = ef[1] || "", eh = _e(_e({}, eh = r3.parse(ed)), {
                                auth: eo,
                                ua: ep,
                                projectId: es,
                                useOnCloseEvent: el || void 0,
                                origin: ec || void 0
                            }), ed = r3.stringify(eh));
                        return ef[0] + "?" + eg
                    }({
                        sdkVersion: "2.10.6",
                        protocol: this.protocol,
                        version: this.version,
                        relayUrl: this.relayUrl,
                        projectId: this.projectId,
                        auth: r,
                        useOnCloseEvent: !0,
                        bundleId: this.bundleId
                    }))), this.registerProviderListeners()
                }
                async recordMessageEvent(r) {
                    let {
                        topic: l,
                        message: C
                    } = r;
                    await this.messages.set(l, C)
                }
                async shouldIgnoreMessageEvent(r) {
                    let {
                        topic: l,
                        message: C
                    } = r;
                    if (!C || 0 === C.length) return this.logger.debug(`Ignoring invalid/empty message: ${C}`), !0;
                    if (!await this.subscriber.isSubscribed(l)) return this.logger.debug(`Ignoring message for non-subscribed topic ${l}`), !0;
                    let U = this.messages.has(l, C);
                    return U && this.logger.debug(`Ignoring duplicate message: ${C}`), U
                }
                async onProviderPayload(r) {
                    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({
                            type: "payload",
                            direction: "incoming",
                            payload: r
                        }), (0, nb.isJsonRpcRequest)(r)) {
                        if (!r.method.endsWith("_subscription")) return;
                        let l = r.params,
                            {
                                topic: C,
                                message: U,
                                publishedAt: et
                            } = l.data,
                            eo = {
                                topic: C,
                                message: U,
                                publishedAt: et
                            };
                        this.logger.debug("Emitting Relayer Payload"), this.logger.trace(Sr({
                            type: "event",
                            event: l.id
                        }, eo)), this.events.emit(l.id, eo), await this.acknowledgePayload(r), await this.onMessageEvent(eo)
                    } else(0, nb.isJsonRpcResponse)(r) && this.events.emit(ix.message_ack, r)
                }
                async onMessageEvent(r) {
                    await this.shouldIgnoreMessageEvent(r) || (this.events.emit(ix.message, r), await this.recordMessageEvent(r))
                }
                async acknowledgePayload(r) {
                    let l = (0, nb.formatJsonRpcResult)(r.id, !0);
                    await this.provider.connection.send(l)
                }
                unregisterProviderListeners() {
                    this.provider.off(iA.payload, this.onPayloadHandler), this.provider.off(iA.connect, this.onConnectHandler), this.provider.off(iA.disconnect, this.onDisconnectHandler), this.provider.off(iA.error, this.onProviderErrorHandler)
                }
                async registerEventListeners() {
                    this.events.on(ix.connection_stalled, () => {
                        this.restartTransport().catch(r => this.logger.error(r))
                    });
                    let r = await er();
                    ! function(r) {
                        switch (T()) {
                            case nc.browser:
                                !dist_index_es_C() && index_es_D() && (window.addEventListener("online", () => r(!0)), window.addEventListener("offline", () => r(!1)));
                                break;
                            case nc.reactNative:
                                dist_index_es_C() && "u" > typeof C.g && null != C.g && C.g.NetInfo && C.g ? .NetInfo.addEventListener(l => r(l ? .isConnected));
                            case nc.node:
                        }
                    }(async l => {
                        this.initialized && r !== l && (r = l, l ? await this.restartTransport().catch(r => this.logger.error(r)) : (this.hasExperiencedNetworkDisruption = !0, await this.transportClose().catch(r => this.logger.error(r))))
                    })
                }
                onProviderDisconnect() {
                    this.events.emit(ix.disconnect), this.attemptToReconnect()
                }
                attemptToReconnect() {
                    this.transportExplicitlyClosed || (this.logger.info("attemptToReconnect called. Connecting..."), setTimeout(async () => {
                        await this.restartTransport().catch(r => this.logger.error(r))
                    }, (0, tQ.toMiliseconds)(iP)))
                }
                isInitialized() {
                    if (!this.initialized) {
                        let {
                            message: r
                        } = index_es_N("NOT_INITIALIZED", this.name);
                        throw Error(r)
                    }
                }
                async toEstablishConnection() {
                    if (await this.confirmOnlineStateOrThrow(), !this.connected) {
                        if (this.connectionAttemptInProgress) return await new Promise(r => {
                            let l = setInterval(() => {
                                this.connected && (clearInterval(l), r())
                            }, this.connectionStatusPollingInterval)
                        });
                        await this.restartTransport()
                    }
                }
            };
            var iG = Object.defineProperty,
                iJ = Object.getOwnPropertySymbols,
                iY = Object.prototype.hasOwnProperty,
                iZ = Object.prototype.propertyIsEnumerable,
                index_es_Ft = (r, l, C) => l in r ? iG(r, l, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: C
                }) : r[l] = C,
                index_es_$t = (r, l) => {
                    for (var C in l || (l = {})) iY.call(l, C) && index_es_Ft(r, C, l[C]);
                    if (iJ)
                        for (var C of iJ(l)) iZ.call(l, C) && index_es_Ft(r, C, l[C]);
                    return r
                };
            let Mt = class Mt extends p {
                constructor(r, l, C, U = iy, et) {
                    super(r, l, C, U), this.core = r, this.logger = l, this.name = C, this.map = new Map, this.version = "0.3", this.cached = [], this.initialized = !1, this.storagePrefix = iy, this.init = async () => {
                        this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach(r => {
                            var l;
                            this.getKey && null !== r && !w(r) ? this.map.set(this.getKey(r), r) : (null == (l = r ? .proposer) ? void 0 : l.publicKey) ? this.map.set(r.id, r) : r ? .topic && this.map.set(r.topic, r)
                        }), this.cached = [], this.initialized = !0)
                    }, this.set = async (r, l) => {
                        this.isInitialized(), this.map.has(r) ? await this.update(r, l) : (this.logger.debug("Setting value"), this.logger.trace({
                            type: "method",
                            method: "set",
                            key: r,
                            value: l
                        }), this.map.set(r, l), await this.persist())
                    }, this.get = r => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({
                        type: "method",
                        method: "get",
                        key: r
                    }), this.getData(r)), this.getAll = r => (this.isInitialized(), r ? this.values.filter(l => Object.keys(r).every(C => nI()(l[C], r[C]))) : this.values), this.update = async (r, l) => {
                        this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({
                            type: "method",
                            method: "update",
                            key: r,
                            update: l
                        });
                        let C = index_es_$t(index_es_$t({}, this.getData(r)), l);
                        this.map.set(r, C), await this.persist()
                    }, this.delete = async (r, l) => {
                        this.isInitialized(), this.map.has(r) && (this.logger.debug("Deleting value"), this.logger.trace({
                            type: "method",
                            method: "delete",
                            key: r,
                            reason: l
                        }), this.map.delete(r), await this.persist())
                    }, this.logger = (0, tJ.generateChildLogger)(l, this.name), this.storagePrefix = U, this.getKey = et
                }
                get context() {
                    return (0, tJ.getLoggerContext)(this.logger)
                }
                get storageKey() {
                    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
                }
                get length() {
                    return this.map.size
                }
                get keys() {
                    return Array.from(this.map.keys())
                }
                get values() {
                    return Array.from(this.map.values())
                }
                async setDataStore(r) {
                    await this.core.storage.setItem(this.storageKey, r)
                }
                async getDataStore() {
                    return await this.core.storage.getItem(this.storageKey)
                }
                getData(r) {
                    let l = this.map.get(r);
                    if (!l) {
                        let {
                            message: l
                        } = index_es_N("NO_MATCHING_KEY", `${this.name}: ${r}`);
                        throw this.logger.error(l), Error(l)
                    }
                    return l
                }
                async persist() {
                    await this.setDataStore(this.values)
                }
                async restore() {
                    try {
                        let r = await this.getDataStore();
                        if (typeof r > "u" || !r.length) return;
                        if (this.map.size) {
                            let {
                                message: r
                            } = index_es_N("RESTORE_WILL_OVERRIDE", this.name);
                            throw this.logger.error(r), Error(r)
                        }
                        this.cached = r, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({
                            type: "method",
                            method: "restore",
                            value: this.values
                        })
                    } catch (r) {
                        this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(r)
                    }
                }
                isInitialized() {
                    if (!this.initialized) {
                        let {
                            message: r
                        } = index_es_N("NOT_INITIALIZED", this.name);
                        throw Error(r)
                    }
                }
            };
            let kt = class kt {
                constructor(r, l) {
                    this.core = r, this.logger = l, this.name = "pairing", this.version = "0.3", this.events = new(tj()), this.initialized = !1, this.storagePrefix = iy, this.ignoredPayloadTypes = [1], this.registeredMethods = [], this.init = async () => {
                        this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = !0, this.logger.trace("Initialized"))
                    }, this.register = ({
                        methods: r
                    }) => {
                        this.isInitialized(), this.registeredMethods = [...new Set([...this.registeredMethods, ...r])]
                    }, this.create = async () => {
                        var r;
                        this.isInitialized();
                        let l = Vn(),
                            C = await this.core.crypto.setSymKey(l),
                            U = pt(tQ.FIVE_MINUTES),
                            et = {
                                protocol: "irn"
                            },
                            eo = (r = {
                                protocol: this.core.protocol,
                                version: this.core.version,
                                topic: C,
                                symKey: l,
                                relay: et
                            }, `${r.protocol}:${r.topic}@${r.version}?` + r3.stringify(St({
                                symKey: r.symKey
                            }, function(r, l = "-") {
                                let C = {};
                                return Object.keys(r).forEach(U => {
                                    r[U] && (C["relay" + l + U] = r[U])
                                }), C
                            }(r.relay))));
                        return await this.pairings.set(C, {
                            topic: C,
                            expiry: U,
                            relay: et,
                            active: !1
                        }), await this.core.relayer.subscribe(C), this.core.expirer.set(C, U), {
                            topic: C,
                            uri: eo
                        }
                    }, this.pair = async r => {
                        this.isInitialized(), this.isValidPair(r);
                        let {
                            topic: l,
                            symKey: C,
                            relay: U
                        } = wt(r.uri);
                        if (this.pairings.keys.includes(l) && this.pairings.get(l).active) throw Error(`Pairing already exists: ${l}. Please try again with a new connection URI.`);
                        let et = pt(tQ.FIVE_MINUTES),
                            eo = {
                                topic: l,
                                relay: U,
                                expiry: et,
                                active: !1
                            };
                        return await this.pairings.set(l, eo), this.core.expirer.set(l, et), r.activatePairing && await this.activate({
                            topic: l
                        }), this.events.emit(iO.create, eo), this.core.crypto.keychain.has(l) || (await this.core.crypto.setSymKey(C, l), await this.core.relayer.subscribe(l, {
                            relay: U
                        })), eo
                    }, this.activate = async ({
                        topic: r
                    }) => {
                        this.isInitialized();
                        let l = pt(tQ.THIRTY_DAYS);
                        await this.pairings.update(r, {
                            active: !0,
                            expiry: l
                        }), this.core.expirer.set(r, l)
                    }, this.ping = async r => {
                        this.isInitialized(), await this.isValidPing(r);
                        let {
                            topic: l
                        } = r;
                        if (this.pairings.keys.includes(l)) {
                            let r = await this.sendRequest(l, "wc_pairingPing", {}),
                                {
                                    done: C,
                                    resolve: U,
                                    reject: et
                                } = at();
                            this.events.once(yt("pairing_ping", r), ({
                                error: r
                            }) => {
                                r ? et(r) : U()
                            }), await C()
                        }
                    }, this.updateExpiry = async ({
                        topic: r,
                        expiry: l
                    }) => {
                        this.isInitialized(), await this.pairings.update(r, {
                            expiry: l
                        })
                    }, this.updateMetadata = async ({
                        topic: r,
                        metadata: l
                    }) => {
                        this.isInitialized(), await this.pairings.update(r, {
                            peerMetadata: l
                        })
                    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async r => {
                        this.isInitialized(), await this.isValidDisconnect(r);
                        let {
                            topic: l
                        } = r;
                        this.pairings.keys.includes(l) && (await this.sendRequest(l, "wc_pairingDelete", index_es_U("USER_DISCONNECTED")), await this.deletePairing(l))
                    }, this.sendRequest = async (r, l, C) => {
                        let U = (0, nb.formatJsonRpcRequest)(l, C),
                            et = await this.core.crypto.encode(r, U),
                            eo = iN[l].req;
                        return this.core.history.set(r, U), this.core.relayer.publish(r, et, eo), U.id
                    }, this.sendResult = async (r, l, C) => {
                        let U = (0, nb.formatJsonRpcResult)(r, C),
                            et = await this.core.crypto.encode(l, U),
                            eo = await this.core.history.get(l, r),
                            es = iN[eo.request.method].res;
                        await this.core.relayer.publish(l, et, es), await this.core.history.resolve(U)
                    }, this.sendError = async (r, l, C) => {
                        let U = (0, nb.formatJsonRpcError)(r, C),
                            et = await this.core.crypto.encode(l, U),
                            eo = await this.core.history.get(l, r),
                            es = iN[eo.request.method] ? iN[eo.request.method].res : iN.unregistered_method.res;
                        await this.core.relayer.publish(l, et, es), await this.core.history.resolve(U)
                    }, this.deletePairing = async (r, l) => {
                        await this.core.relayer.unsubscribe(r), await Promise.all([this.pairings.delete(r, index_es_U("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(r), l ? Promise.resolve() : this.core.expirer.del(r)])
                    }, this.cleanup = async () => {
                        let r = this.pairings.getAll().filter(r => mt(r.expiry));
                        await Promise.all(r.map(r => this.deletePairing(r.topic)))
                    }, this.onRelayEventRequest = r => {
                        let {
                            topic: l,
                            payload: C
                        } = r;
                        switch (C.method) {
                            case "wc_pairingPing":
                                return this.onPairingPingRequest(l, C);
                            case "wc_pairingDelete":
                                return this.onPairingDeleteRequest(l, C);
                            default:
                                return this.onUnknownRpcMethodRequest(l, C)
                        }
                    }, this.onRelayEventResponse = async r => {
                        let {
                            topic: l,
                            payload: C
                        } = r, U = (await this.core.history.get(l, C.id)).request.method;
                        return "wc_pairingPing" === U ? this.onPairingPingResponse(l, C) : this.onUnknownRpcMethodResponse(U)
                    }, this.onPairingPingRequest = async (r, l) => {
                        let {
                            id: C
                        } = l;
                        try {
                            this.isValidPing({
                                topic: r
                            }), await this.sendResult(C, r, !0), this.events.emit(iO.ping, {
                                id: C,
                                topic: r
                            })
                        } catch (l) {
                            await this.sendError(C, r, l), this.logger.error(l)
                        }
                    }, this.onPairingPingResponse = (r, l) => {
                        let {
                            id: C
                        } = l;
                        setTimeout(() => {
                            (0, nb.isJsonRpcResult)(l) ? this.events.emit(yt("pairing_ping", C), {}): (0, nb.isJsonRpcError)(l) && this.events.emit(yt("pairing_ping", C), {
                                error: l.error
                            })
                        }, 500)
                    }, this.onPairingDeleteRequest = async (r, l) => {
                        let {
                            id: C
                        } = l;
                        try {
                            this.isValidDisconnect({
                                topic: r
                            }), await this.deletePairing(r), this.events.emit(iO.delete, {
                                id: C,
                                topic: r
                            })
                        } catch (l) {
                            await this.sendError(C, r, l), this.logger.error(l)
                        }
                    }, this.onUnknownRpcMethodRequest = async (r, l) => {
                        let {
                            id: C,
                            method: U
                        } = l;
                        try {
                            if (this.registeredMethods.includes(U)) return;
                            let l = index_es_U("WC_METHOD_UNSUPPORTED", U);
                            await this.sendError(C, r, l), this.logger.error(l)
                        } catch (l) {
                            await this.sendError(C, r, l), this.logger.error(l)
                        }
                    }, this.onUnknownRpcMethodResponse = r => {
                        this.registeredMethods.includes(r) || this.logger.error(index_es_U("WC_METHOD_UNSUPPORTED", r))
                    }, this.isValidPair = r => {
                        var l;
                        if (!Ht(r)) {
                            let {
                                message: l
                            } = index_es_N("MISSING_OR_INVALID", `pair() params: ${r}`);
                            throw Error(l)
                        }
                        if (! function(r) {
                                if (dist_index_es_h(r, !1)) try {
                                    return "u" > typeof new URL(r)
                                } catch {}
                                return !1
                            }(r.uri)) {
                            let {
                                message: l
                            } = index_es_N("MISSING_OR_INVALID", `pair() uri: ${r.uri}`);
                            throw Error(l)
                        }
                        let C = wt(r.uri);
                        if (!(null != (l = C ? .relay) && l.protocol)) {
                            let {
                                message: r
                            } = index_es_N("MISSING_OR_INVALID", "pair() uri#relay-protocol");
                            throw Error(r)
                        }
                        if (!(null != C && C.symKey)) {
                            let {
                                message: r
                            } = index_es_N("MISSING_OR_INVALID", "pair() uri#symKey");
                            throw Error(r)
                        }
                    }, this.isValidPing = async r => {
                        if (!Ht(r)) {
                            let {
                                message: l
                            } = index_es_N("MISSING_OR_INVALID", `ping() params: ${r}`);
                            throw Error(l)
                        }
                        let {
                            topic: l
                        } = r;
                        await this.isValidPairingTopic(l)
                    }, this.isValidDisconnect = async r => {
                        if (!Ht(r)) {
                            let {
                                message: l
                            } = index_es_N("MISSING_OR_INVALID", `disconnect() params: ${r}`);
                            throw Error(l)
                        }
                        let {
                            topic: l
                        } = r;
                        await this.isValidPairingTopic(l)
                    }, this.isValidPairingTopic = async r => {
                        if (!dist_index_es_h(r, !1)) {
                            let {
                                message: l
                            } = index_es_N("MISSING_OR_INVALID", `pairing topic should be a string: ${r}`);
                            throw Error(l)
                        }
                        if (!this.pairings.keys.includes(r)) {
                            let {
                                message: l
                            } = index_es_N("NO_MATCHING_KEY", `pairing topic doesn't exist: ${r}`);
                            throw Error(l)
                        }
                        if (mt(this.pairings.get(r).expiry)) {
                            await this.deletePairing(r);
                            let {
                                message: l
                            } = index_es_N("EXPIRED", `pairing topic: ${r}`);
                            throw Error(l)
                        }
                    }, this.core = r, this.logger = (0, tJ.generateChildLogger)(l, this.name), this.pairings = new Mt(this.core, this.logger, this.name, this.storagePrefix)
                }
                get context() {
                    return (0, tJ.getLoggerContext)(this.logger)
                }
                isInitialized() {
                    if (!this.initialized) {
                        let {
                            message: r
                        } = index_es_N("NOT_INITIALIZED", this.name);
                        throw Error(r)
                    }
                }
                registerRelayerEvents() {
                    this.core.relayer.on(ix.message, async r => {
                        let {
                            topic: l,
                            message: C
                        } = r;
                        if (!this.pairings.keys.includes(l) || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(C))) return;
                        let U = await this.core.crypto.decode(l, C);
                        try {
                            (0, nb.isJsonRpcRequest)(U) ? (this.core.history.set(l, U), this.onRelayEventRequest({
                                topic: l,
                                payload: U
                            })) : (0, nb.isJsonRpcResponse)(U) && (await this.core.history.resolve(U), await this.onRelayEventResponse({
                                topic: l,
                                payload: U
                            }), this.core.history.delete(l, U.id))
                        } catch (r) {
                            this.logger.error(r)
                        }
                    })
                }
                registerExpirerEvents() {
                    this.core.expirer.on(iR.expired, async r => {
                        let {
                            topic: l
                        } = ft(r.target);
                        l && this.pairings.keys.includes(l) && (await this.deletePairing(l, !0), this.events.emit(iO.expire, {
                            topic: l
                        }))
                    })
                }
            };
            let index_es_Kt = class index_es_Kt extends index_es_h {
                constructor(r, l) {
                    super(r, l), this.core = r, this.logger = l, this.records = new Map, this.events = new tM.EventEmitter, this.name = "history", this.version = "0.3", this.cached = [], this.initialized = !1, this.storagePrefix = iy, this.init = async () => {
                        this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach(r => this.records.set(r.id, r)), this.cached = [], this.registerEventListeners(), this.initialized = !0)
                    }, this.set = (r, l, C) => {
                        if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({
                                type: "method",
                                method: "set",
                                topic: r,
                                request: l,
                                chainId: C
                            }), this.records.has(l.id)) return;
                        let U = {
                            id: l.id,
                            topic: r,
                            request: {
                                method: l.method,
                                params: l.params || null
                            },
                            chainId: C,
                            expiry: pt(tQ.THIRTY_DAYS)
                        };
                        this.records.set(U.id, U), this.events.emit(iT.created, U)
                    }, this.resolve = async r => {
                        if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({
                                type: "method",
                                method: "update",
                                response: r
                            }), !this.records.has(r.id)) return;
                        let l = await this.getRecord(r.id);
                        typeof l.response > "u" && (l.response = (0, nb.isJsonRpcError)(r) ? {
                            error: r.error
                        } : {
                            result: r.result
                        }, this.records.set(l.id, l), this.events.emit(iT.updated, l))
                    }, this.get = async (r, l) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({
                        type: "method",
                        method: "get",
                        topic: r,
                        id: l
                    }), await this.getRecord(l)), this.delete = (r, l) => {
                        this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({
                            type: "method",
                            method: "delete",
                            id: l
                        }), this.values.forEach(C => {
                            C.topic !== r || "u" > typeof l && C.id !== l || (this.records.delete(C.id), this.events.emit(iT.deleted, C))
                        })
                    }, this.exists = async (r, l) => (this.isInitialized(), !!this.records.has(l) && (await this.getRecord(l)).topic === r), this.on = (r, l) => {
                        this.events.on(r, l)
                    }, this.once = (r, l) => {
                        this.events.once(r, l)
                    }, this.off = (r, l) => {
                        this.events.off(r, l)
                    }, this.removeListener = (r, l) => {
                        this.events.removeListener(r, l)
                    }, this.logger = (0, tJ.generateChildLogger)(l, this.name)
                }
                get context() {
                    return (0, tJ.getLoggerContext)(this.logger)
                }
                get storageKey() {
                    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
                }
                get size() {
                    return this.records.size
                }
                get keys() {
                    return Array.from(this.records.keys())
                }
                get values() {
                    return Array.from(this.records.values())
                }
                get pending() {
                    let r = [];
                    return this.values.forEach(l => {
                        if ("u" > typeof l.response) return;
                        let C = {
                            topic: l.topic,
                            request: (0, nb.formatJsonRpcRequest)(l.request.method, l.request.params, l.id),
                            chainId: l.chainId
                        };
                        return r.push(C)
                    }), r
                }
                async setJsonRpcRecords(r) {
                    await this.core.storage.setItem(this.storageKey, r)
                }
                async getJsonRpcRecords() {
                    return await this.core.storage.getItem(this.storageKey)
                }
                getRecord(r) {
                    this.isInitialized();
                    let l = this.records.get(r);
                    if (!l) {
                        let {
                            message: l
                        } = index_es_N("NO_MATCHING_KEY", `${this.name}: ${r}`);
                        throw Error(l)
                    }
                    return l
                }
                async persist() {
                    await this.setJsonRpcRecords(this.values), this.events.emit(iT.sync)
                }
                async restore() {
                    try {
                        let r = await this.getJsonRpcRecords();
                        if (typeof r > "u" || !r.length) return;
                        if (this.records.size) {
                            let {
                                message: r
                            } = index_es_N("RESTORE_WILL_OVERRIDE", this.name);
                            throw this.logger.error(r), Error(r)
                        }
                        this.cached = r, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({
                            type: "method",
                            method: "restore",
                            records: this.values
                        })
                    } catch (r) {
                        this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(r)
                    }
                }
                registerEventListeners() {
                    this.events.on(iT.created, r => {
                        let l = iT.created;
                        this.logger.info(`Emitting ${l}`), this.logger.debug({
                            type: "event",
                            event: l,
                            record: r
                        }), this.persist()
                    }), this.events.on(iT.updated, r => {
                        let l = iT.updated;
                        this.logger.info(`Emitting ${l}`), this.logger.debug({
                            type: "event",
                            event: l,
                            record: r
                        }), this.persist()
                    }), this.events.on(iT.deleted, r => {
                        let l = iT.deleted;
                        this.logger.info(`Emitting ${l}`), this.logger.debug({
                            type: "event",
                            event: l,
                            record: r
                        }), this.persist()
                    }), this.core.heartbeat.on(tG.HEARTBEAT_EVENTS.pulse, () => {
                        this.cleanup()
                    })
                }
                cleanup() {
                    try {
                        this.records.forEach(r => {
                            (0, tQ.toMiliseconds)(r.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${r.id}`), this.delete(r.topic, r.id))
                        })
                    } catch (r) {
                        this.logger.warn(r)
                    }
                }
                isInitialized() {
                    if (!this.initialized) {
                        let {
                            message: r
                        } = index_es_N("NOT_INITIALIZED", this.name);
                        throw Error(r)
                    }
                }
            };
            let index_es_Bt = class index_es_Bt extends index_es_E {
                constructor(r, l) {
                    super(r, l), this.core = r, this.logger = l, this.expirations = new Map, this.events = new tM.EventEmitter, this.name = "expirer", this.version = "0.3", this.cached = [], this.initialized = !1, this.storagePrefix = iy, this.init = async () => {
                        this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach(r => this.expirations.set(r.target, r)), this.cached = [], this.registerEventListeners(), this.initialized = !0)
                    }, this.has = r => {
                        try {
                            let l = this.formatTarget(r);
                            return "u" > typeof this.getExpiration(l)
                        } catch {
                            return !1
                        }
                    }, this.set = (r, l) => {
                        this.isInitialized();
                        let C = this.formatTarget(r),
                            U = {
                                target: C,
                                expiry: l
                            };
                        this.expirations.set(C, U), this.checkExpiry(C, U), this.events.emit(iR.created, {
                            target: C,
                            expiration: U
                        })
                    }, this.get = r => {
                        this.isInitialized();
                        let l = this.formatTarget(r);
                        return this.getExpiration(l)
                    }, this.del = r => {
                        if (this.isInitialized(), this.has(r)) {
                            let l = this.formatTarget(r),
                                C = this.getExpiration(l);
                            this.expirations.delete(l), this.events.emit(iR.deleted, {
                                target: l,
                                expiration: C
                            })
                        }
                    }, this.on = (r, l) => {
                        this.events.on(r, l)
                    }, this.once = (r, l) => {
                        this.events.once(r, l)
                    }, this.off = (r, l) => {
                        this.events.off(r, l)
                    }, this.removeListener = (r, l) => {
                        this.events.removeListener(r, l)
                    }, this.logger = (0, tJ.generateChildLogger)(l, this.name)
                }
                get context() {
                    return (0, tJ.getLoggerContext)(this.logger)
                }
                get storageKey() {
                    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name
                }
                get length() {
                    return this.expirations.size
                }
                get keys() {
                    return Array.from(this.expirations.keys())
                }
                get values() {
                    return Array.from(this.expirations.values())
                }
                formatTarget(r) {
                    if ("string" == typeof r) return re("topic", r);
                    if ("number" == typeof r) return re("id", r);
                    let {
                        message: l
                    } = index_es_N("UNKNOWN_TYPE", `Target type: ${typeof r}`);
                    throw Error(l)
                }
                async setExpirations(r) {
                    await this.core.storage.setItem(this.storageKey, r)
                }
                async getExpirations() {
                    return await this.core.storage.getItem(this.storageKey)
                }
                async persist() {
                    await this.setExpirations(this.values), this.events.emit(iR.sync)
                }
                async restore() {
                    try {
                        let r = await this.getExpirations();
                        if (typeof r > "u" || !r.length) return;
                        if (this.expirations.size) {
                            let {
                                message: r
                            } = index_es_N("RESTORE_WILL_OVERRIDE", this.name);
                            throw this.logger.error(r), Error(r)
                        }
                        this.cached = r, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({
                            type: "method",
                            method: "restore",
                            expirations: this.values
                        })
                    } catch (r) {
                        this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(r)
                    }
                }
                getExpiration(r) {
                    let l = this.expirations.get(r);
                    if (!l) {
                        let {
                            message: l
                        } = index_es_N("NO_MATCHING_KEY", `${this.name}: ${r}`);
                        throw this.logger.error(l), Error(l)
                    }
                    return l
                }
                checkExpiry(r, l) {
                    let {
                        expiry: C
                    } = l;
                    (0, tQ.toMiliseconds)(C) - Date.now() <= 0 && this.expire(r, l)
                }
                expire(r, l) {
                    this.expirations.delete(r), this.events.emit(iR.expired, {
                        target: r,
                        expiration: l
                    })
                }
                checkExpirations() {
                    this.core.relayer.connected && this.expirations.forEach((r, l) => this.checkExpiry(l, r))
                }
                registerEventListeners() {
                    this.core.heartbeat.on(tG.HEARTBEAT_EVENTS.pulse, () => this.checkExpirations()), this.events.on(iR.created, r => {
                        let l = iR.created;
                        this.logger.info(`Emitting ${l}`), this.logger.debug({
                            type: "event",
                            event: l,
                            data: r
                        }), this.persist()
                    }), this.events.on(iR.expired, r => {
                        let l = iR.expired;
                        this.logger.info(`Emitting ${l}`), this.logger.debug({
                            type: "event",
                            event: l,
                            data: r
                        }), this.persist()
                    }), this.events.on(iR.deleted, r => {
                        let l = iR.deleted;
                        this.logger.info(`Emitting ${l}`), this.logger.debug({
                            type: "event",
                            event: l,
                            data: r
                        }), this.persist()
                    })
                }
                isInitialized() {
                    if (!this.initialized) {
                        let {
                            message: r
                        } = index_es_N("NOT_INITIALIZED", this.name);
                        throw Error(r)
                    }
                }
            };
            let index_es_Vt = class index_es_Vt extends index_es_y {
                constructor(r, l) {
                    super(r, l), this.projectId = r, this.logger = l, this.name = iD, this.initialized = !1, this.queue = [], this.verifyDisabled = !1, this.init = async r => {
                        if (this.verifyDisabled || dist_index_es_C() || !index_es_D()) return;
                        let l = this.getVerifyUrl(r ? .verifyUrl);
                        this.verifyUrl !== l && this.removeIframe(), this.verifyUrl = l;
                        try {
                            await this.createIframe()
                        } catch (r) {
                            this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(r)
                        }
                        if (!this.initialized) {
                            this.removeIframe(), this.verifyUrl = iU;
                            try {
                                await this.createIframe()
                            } catch (r) {
                                this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(r), this.verifyDisabled = !0
                            }
                        }
                    }, this.register = async r => {
                        this.initialized ? this.sendPost(r.attestationId) : (this.addToQueue(r.attestationId), await this.init())
                    }, this.resolve = async r => {
                        let l;
                        if (this.isDevEnv) return "";
                        let C = this.getVerifyUrl(r ? .verifyUrl);
                        try {
                            l = await this.fetchAttestation(r.attestationId, C)
                        } catch (U) {
                            this.logger.info(`failed to resolve attestation: ${r.attestationId} from url: ${C}`), this.logger.info(U), l = await this.fetchAttestation(r.attestationId, iU)
                        }
                        return l
                    }, this.fetchAttestation = async (r, l) => {
                        this.logger.info(`resolving attestation: ${r} from url: ${l}`);
                        let C = this.startAbortTimer(2 * tQ.ONE_SECOND),
                            U = await fetch(`${l}/attestation/${r}`, {
                                signal: this.abortController.signal
                            });
                        return clearTimeout(C), 200 === U.status ? await U.json() : void 0
                    }, this.addToQueue = r => {
                        this.queue.push(r)
                    }, this.processQueue = () => {
                        0 !== this.queue.length && (this.queue.forEach(r => this.sendPost(r)), this.queue = [])
                    }, this.sendPost = r => {
                        var l;
                        try {
                            if (!this.iframe) return;
                            null == (l = this.iframe.contentWindow) || l.postMessage(r, "*"), this.logger.info(`postMessage sent: ${r} ${this.verifyUrl}`)
                        } catch {}
                    }, this.createIframe = async () => {
                        let r;
                        let s = l => {
                            "verify_ready" === l.data && (this.initialized = !0, this.processQueue(), window.removeEventListener("message", s), r())
                        };
                        await Promise.race([new Promise(l => {
                            if (document.getElementById(iD)) return l();
                            window.addEventListener("message", s);
                            let C = document.createElement("iframe");
                            C.id = iD, C.src = `${this.verifyUrl}/${this.projectId}`, C.style.display = "none", document.body.append(C), this.iframe = C, r = l
                        }), new Promise((r, l) => setTimeout(() => {
                            window.removeEventListener("message", s), l("verify iframe load timeout")
                        }, (0, tQ.toMiliseconds)(tQ.FIVE_SECONDS)))])
                    }, this.removeIframe = () => {
                        this.iframe && (this.iframe.remove(), this.iframe = void 0, this.initialized = !1)
                    }, this.getVerifyUrl = r => {
                        let l = r || iB;
                        return iL.includes(l) || (this.logger.info(`verify url: ${l}, not included in trusted list, assigning default: ${iB}`), l = iB), l
                    }, this.logger = (0, tJ.generateChildLogger)(l, this.name), this.verifyUrl = iB, this.abortController = new AbortController, this.isDevEnv = te() && nS.env.IS_VITEST
                }
                get context() {
                    return (0, tJ.getLoggerContext)(this.logger)
                }
                startAbortTimer(r) {
                    return this.abortController = new AbortController, setTimeout(() => this.abortController.abort(), (0, tQ.toMiliseconds)(r))
                }
            };
            var iX = Object.defineProperty,
                iQ = Object.getOwnPropertySymbols,
                i0 = Object.prototype.hasOwnProperty,
                i1 = Object.prototype.propertyIsEnumerable,
                index_es_jt = (r, l, C) => l in r ? iX(r, l, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: C
                }) : r[l] = C,
                index_es_Gt = (r, l) => {
                    for (var C in l || (l = {})) i0.call(l, C) && index_es_jt(r, C, l[C]);
                    if (iQ)
                        for (var C of iQ(l)) i1.call(l, C) && index_es_jt(r, C, l[C]);
                    return r
                };
            let index_es_te = class index_es_te extends n {
                constructor(r) {
                    super(r), this.protocol = "wc", this.version = 2, this.name = ig, this.events = new tM.EventEmitter, this.initialized = !1, this.on = (r, l) => this.events.on(r, l), this.once = (r, l) => this.events.once(r, l), this.off = (r, l) => this.events.off(r, l), this.removeListener = (r, l) => this.events.removeListener(r, l), this.projectId = r ? .projectId, this.relayUrl = r ? .relayUrl || iI, this.customStoragePrefix = null != r && r.customStoragePrefix ? `:${r.customStoragePrefix}` : "";
                    let l = "u" > typeof r ? .logger && "string" != typeof r ? .logger ? r.logger : (0, tJ.pino)((0, tJ.getDefaultLoggerOptions)({
                        level: r ? .logger || im.logger
                    }));
                    this.logger = (0, tJ.generateChildLogger)(l, this.name), this.heartbeat = new tG.HeartBeat, this.crypto = new index_es_Tt(this, this.logger, r ? .keychain), this.history = new index_es_Kt(this, this.logger), this.expirer = new index_es_Bt(this, this.logger), this.storage = null != r && r.storage ? r.storage : new h(index_es_Gt(index_es_Gt({}, i_), r ? .storageOptions)), this.relayer = new index_es_Ut({
                        core: this,
                        logger: this.logger,
                        relayUrl: this.relayUrl,
                        projectId: this.projectId
                    }), this.pairing = new kt(this, this.logger), this.verify = new index_es_Vt(this.projectId || "", this.logger)
                }
                static async init(r) {
                    let l = new index_es_te(r);
                    await l.initialize();
                    let C = await l.crypto.getClientId();
                    return await l.storage.setItem("WALLETCONNECT_CLIENT_ID", C), l
                }
                get context() {
                    return (0, tJ.getLoggerContext)(this.logger)
                }
                async start() {
                    this.initialized || await this.initialize()
                }
                async initialize() {
                    this.logger.trace("Initialized");
                    try {
                        await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.initialized = !0, this.logger.info("Core Initialization Success")
                    } catch (r) {
                        throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, r), this.logger.error(r.message), r
                    }
                }
            };
            let i2 = "client",
                i3 = `wc@2:${i2}:`,
                i5 = {
                    name: i2,
                    logger: "error"
                },
                i6 = "WALLETCONNECT_DEEPLINK_CHOICE",
                i8 = "Proposal expired",
                i4 = tQ.SEVEN_DAYS,
                i9 = {
                    wc_sessionPropose: {
                        req: {
                            ttl: tQ.FIVE_MINUTES,
                            prompt: !0,
                            tag: 1100
                        },
                        res: {
                            ttl: tQ.FIVE_MINUTES,
                            prompt: !1,
                            tag: 1101
                        }
                    },
                    wc_sessionSettle: {
                        req: {
                            ttl: tQ.FIVE_MINUTES,
                            prompt: !1,
                            tag: 1102
                        },
                        res: {
                            ttl: tQ.FIVE_MINUTES,
                            prompt: !1,
                            tag: 1103
                        }
                    },
                    wc_sessionUpdate: {
                        req: {
                            ttl: tQ.ONE_DAY,
                            prompt: !1,
                            tag: 1104
                        },
                        res: {
                            ttl: tQ.ONE_DAY,
                            prompt: !1,
                            tag: 1105
                        }
                    },
                    wc_sessionExtend: {
                        req: {
                            ttl: tQ.ONE_DAY,
                            prompt: !1,
                            tag: 1106
                        },
                        res: {
                            ttl: tQ.ONE_DAY,
                            prompt: !1,
                            tag: 1107
                        }
                    },
                    wc_sessionRequest: {
                        req: {
                            ttl: tQ.FIVE_MINUTES,
                            prompt: !0,
                            tag: 1108
                        },
                        res: {
                            ttl: tQ.FIVE_MINUTES,
                            prompt: !1,
                            tag: 1109
                        }
                    },
                    wc_sessionEvent: {
                        req: {
                            ttl: tQ.FIVE_MINUTES,
                            prompt: !0,
                            tag: 1110
                        },
                        res: {
                            ttl: tQ.FIVE_MINUTES,
                            prompt: !1,
                            tag: 1111
                        }
                    },
                    wc_sessionDelete: {
                        req: {
                            ttl: tQ.ONE_DAY,
                            prompt: !1,
                            tag: 1112
                        },
                        res: {
                            ttl: tQ.ONE_DAY,
                            prompt: !1,
                            tag: 1113
                        }
                    },
                    wc_sessionPing: {
                        req: {
                            ttl: tQ.THIRTY_SECONDS,
                            prompt: !1,
                            tag: 1114
                        },
                        res: {
                            ttl: tQ.THIRTY_SECONDS,
                            prompt: !1,
                            tag: 1115
                        }
                    }
                },
                i7 = {
                    min: tQ.FIVE_MINUTES,
                    max: tQ.SEVEN_DAYS
                },
                oo = {
                    idle: "IDLE",
                    active: "ACTIVE"
                },
                os = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest"];
            var ol = Object.defineProperty,
                oc = Object.defineProperties,
                od = Object.getOwnPropertyDescriptors,
                oh = Object.getOwnPropertySymbols,
                of = Object.prototype.hasOwnProperty,
                op = Object.prototype.propertyIsEnumerable,
                index_es_de = (r, l, C) => l in r ? ol(r, l, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: C
                }) : r[l] = C,
                dist_index_es_g = (r, l) => {
                    for (var C in l || (l = {})) of .call(l, C) && index_es_de(r, C, l[C]);
                    if (oh)
                        for (var C of oh(l)) op.call(l, C) && index_es_de(r, C, l[C]);
                    return r
                },
                dist_index_es_b = (r, l) => oc(r, od(l));
            let index_es_hs = class index_es_hs extends S {
                constructor(r) {
                    super(r), this.name = "engine", this.events = new(tj()), this.initialized = !1, this.ignoredPayloadTypes = [1], this.requestQueue = {
                        state: oo.idle,
                        queue: []
                    }, this.sessionRequestQueue = {
                        state: oo.idle,
                        queue: []
                    }, this.requestQueueDelay = tQ.ONE_SECOND, this.init = async () => {
                        this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), this.client.core.pairing.register({
                            methods: Object.keys(i9)
                        }), this.initialized = !0, setTimeout(() => {
                            this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue()
                        }, (0, tQ.toMiliseconds)(this.requestQueueDelay)))
                    }, this.connect = async r => {
                        await this.isInitialized();
                        let l = dist_index_es_b(dist_index_es_g({}, r), {
                            requiredNamespaces: r.requiredNamespaces || {},
                            optionalNamespaces: r.optionalNamespaces || {}
                        });
                        await this.isValidConnect(l);
                        let {
                            pairingTopic: C,
                            requiredNamespaces: U,
                            optionalNamespaces: et,
                            sessionProperties: eo,
                            relays: es
                        } = l, el = C, ec, ed = !1;
                        if (el && (ed = this.client.core.pairing.pairings.get(el).active), !el || !ed) {
                            let {
                                topic: r,
                                uri: l
                            } = await this.client.core.pairing.create();
                            el = r, ec = l
                        }
                        let eh = await this.client.core.crypto.generateKeyPair(),
                            ef = dist_index_es_g({
                                requiredNamespaces: U,
                                optionalNamespaces: et,
                                relays: es ? ? [{
                                    protocol: "irn"
                                }],
                                proposer: {
                                    publicKey: eh,
                                    metadata: this.client.metadata
                                }
                            }, eo && {
                                sessionProperties: eo
                            }),
                            {
                                reject: ep,
                                resolve: eg,
                                done: ey
                            } = at(tQ.FIVE_MINUTES, i8);
                        if (this.events.once(yt("session_connect"), async ({
                                error: r,
                                session: l
                            }) => {
                                if (r) ep(r);
                                else if (l) {
                                    l.self.publicKey = eh;
                                    let r = dist_index_es_b(dist_index_es_g({}, l), {
                                        requiredNamespaces: l.requiredNamespaces,
                                        optionalNamespaces: l.optionalNamespaces
                                    });
                                    await this.client.session.set(l.topic, r), await this.setExpiry(l.topic, l.expiry), el && await this.client.core.pairing.updateMetadata({
                                        topic: el,
                                        metadata: l.peer.metadata
                                    }), eg(r)
                                }
                            }), !el) {
                            let {
                                message: r
                            } = index_es_N("NO_MATCHING_KEY", `connect() pairing topic: ${el}`);
                            throw Error(r)
                        }
                        let em = await this.sendRequest({
                                topic: el,
                                method: "wc_sessionPropose",
                                params: ef
                            }),
                            e_ = pt(tQ.FIVE_MINUTES);
                        return await this.setProposal(em, dist_index_es_g({
                            id: em,
                            expiry: e_
                        }, ef)), {
                            uri: ec,
                            approval: ey
                        }
                    }, this.pair = async r => (await this.isInitialized(), await this.client.core.pairing.pair(r)), this.approve = async r => {
                        await this.isInitialized(), await this.isValidApprove(r);
                        let {
                            id: l,
                            relayProtocol: C,
                            namespaces: U,
                            sessionProperties: et
                        } = r, eo = this.client.proposal.get(l), {
                            pairingTopic: es,
                            proposer: el,
                            requiredNamespaces: ec,
                            optionalNamespaces: ed
                        } = eo;
                        es = es || "", B(ec) || (ec = function(r, l) {
                            let C = un(r, l);
                            if (C) throw Error(C.message);
                            let U = {};
                            for (let [l, C] of Object.entries(r)) U[l] = {
                                methods: C.methods,
                                events: C.events,
                                chains: C.accounts.map(r => `${r.split(":")[0]}:${r.split(":")[1]}`)
                            };
                            return U
                        }(U, "approve()"));
                        let eh = await this.client.core.crypto.generateKeyPair(),
                            ef = el.publicKey,
                            ep = await this.client.core.crypto.generateSharedKey(eh, ef);
                        es && l && (await this.client.core.pairing.updateMetadata({
                            topic: es,
                            metadata: el.metadata
                        }), await this.sendResult({
                            id: l,
                            topic: es,
                            result: {
                                relay: {
                                    protocol: C ? ? "irn"
                                },
                                responderPublicKey: eh
                            }
                        }), await this.client.proposal.delete(l, index_es_U("USER_DISCONNECTED")), await this.client.core.pairing.activate({
                            topic: es
                        }));
                        let eg = dist_index_es_g({
                            relay: {
                                protocol: C ? ? "irn"
                            },
                            namespaces: U,
                            requiredNamespaces: ec,
                            optionalNamespaces: ed,
                            pairingTopic: es,
                            controller: {
                                publicKey: eh,
                                metadata: this.client.metadata
                            },
                            expiry: pt(i4)
                        }, et && {
                            sessionProperties: et
                        });
                        await this.client.core.relayer.subscribe(ep), await this.sendRequest({
                            topic: ep,
                            method: "wc_sessionSettle",
                            params: eg,
                            throwOnFailedPublish: !0
                        });
                        let ey = dist_index_es_b(dist_index_es_g({}, eg), {
                            topic: ep,
                            pairingTopic: es,
                            acknowledged: !1,
                            self: eg.controller,
                            peer: {
                                publicKey: el.publicKey,
                                metadata: el.metadata
                            },
                            controller: eh
                        });
                        return await this.client.session.set(ep, ey), await this.setExpiry(ep, pt(i4)), {
                            topic: ep,
                            acknowledged: () => new Promise(r => setTimeout(() => r(this.client.session.get(ep)), 500))
                        }
                    }, this.reject = async r => {
                        await this.isInitialized(), await this.isValidReject(r);
                        let {
                            id: l,
                            reason: C
                        } = r, {
                            pairingTopic: U
                        } = this.client.proposal.get(l);
                        U && (await this.sendError(l, U, C), await this.client.proposal.delete(l, index_es_U("USER_DISCONNECTED")))
                    }, this.update = async r => {
                        await this.isInitialized(), await this.isValidUpdate(r);
                        let {
                            topic: l,
                            namespaces: C
                        } = r, U = await this.sendRequest({
                            topic: l,
                            method: "wc_sessionUpdate",
                            params: {
                                namespaces: C
                            }
                        }), {
                            done: et,
                            resolve: eo,
                            reject: es
                        } = at();
                        return this.events.once(yt("session_update", U), ({
                            error: r
                        }) => {
                            r ? es(r) : eo()
                        }), await this.client.session.update(l, {
                            namespaces: C
                        }), {
                            acknowledged: et
                        }
                    }, this.extend = async r => {
                        await this.isInitialized(), await this.isValidExtend(r);
                        let {
                            topic: l
                        } = r, C = await this.sendRequest({
                            topic: l,
                            method: "wc_sessionExtend",
                            params: {}
                        }), {
                            done: U,
                            resolve: et,
                            reject: eo
                        } = at();
                        return this.events.once(yt("session_extend", C), ({
                            error: r
                        }) => {
                            r ? eo(r) : et()
                        }), await this.setExpiry(l, pt(i4)), {
                            acknowledged: U
                        }
                    }, this.request = async r => {
                        await this.isInitialized(), await this.isValidRequest(r);
                        let {
                            chainId: l,
                            request: C,
                            topic: U,
                            expiry: et
                        } = r, eo = (0, nb.payloadId)(), {
                            done: es,
                            resolve: el,
                            reject: ec
                        } = at(et, "Request expired. Please try again.");
                        return this.events.once(yt("session_request", eo), ({
                            error: r,
                            result: l
                        }) => {
                            r ? ec(r) : el(l)
                        }), await Promise.all([new Promise(async r => {
                            await this.sendRequest({
                                clientRpcId: eo,
                                topic: U,
                                method: "wc_sessionRequest",
                                params: {
                                    request: C,
                                    chainId: l
                                },
                                expiry: et,
                                throwOnFailedPublish: !0
                            }).catch(r => ec(r)), this.client.events.emit("session_request_sent", {
                                topic: U,
                                request: C,
                                chainId: l,
                                id: eo
                            }), r()
                        }), new Promise(async r => {
                            let l = await gt(this.client.core.storage, i6);
                            ht({
                                id: eo,
                                topic: U,
                                wcDeepLink: l
                            }), r()
                        }), es()]).then(r => r[2])
                    }, this.respond = async r => {
                        await this.isInitialized(), await this.isValidRespond(r);
                        let {
                            topic: l,
                            response: C
                        } = r, {
                            id: U
                        } = C;
                        (0, nb.isJsonRpcResult)(C) ? await this.sendResult({
                            id: U,
                            topic: l,
                            result: C.result,
                            throwOnFailedPublish: !0
                        }): (0, nb.isJsonRpcError)(C) && await this.sendError(U, l, C.error), this.cleanupAfterResponse(r)
                    }, this.ping = async r => {
                        await this.isInitialized(), await this.isValidPing(r);
                        let {
                            topic: l
                        } = r;
                        if (this.client.session.keys.includes(l)) {
                            let r = await this.sendRequest({
                                    topic: l,
                                    method: "wc_sessionPing",
                                    params: {}
                                }),
                                {
                                    done: C,
                                    resolve: U,
                                    reject: et
                                } = at();
                            this.events.once(yt("session_ping", r), ({
                                error: r
                            }) => {
                                r ? et(r) : U()
                            }), await C()
                        } else this.client.core.pairing.pairings.keys.includes(l) && await this.client.core.pairing.ping({
                            topic: l
                        })
                    }, this.emit = async r => {
                        await this.isInitialized(), await this.isValidEmit(r);
                        let {
                            topic: l,
                            event: C,
                            chainId: U
                        } = r;
                        await this.sendRequest({
                            topic: l,
                            method: "wc_sessionEvent",
                            params: {
                                event: C,
                                chainId: U
                            }
                        })
                    }, this.disconnect = async r => {
                        await this.isInitialized(), await this.isValidDisconnect(r);
                        let {
                            topic: l
                        } = r;
                        this.client.session.keys.includes(l) ? (await this.sendRequest({
                            topic: l,
                            method: "wc_sessionDelete",
                            params: index_es_U("USER_DISCONNECTED"),
                            throwOnFailedPublish: !0
                        }), await this.deleteSession(l)) : await this.client.core.pairing.disconnect({
                            topic: l
                        })
                    }, this.find = r => (this.isInitialized(), this.client.session.getAll().filter(l => (function(r, l) {
                        let {
                            requiredNamespaces: C
                        } = l, U = Object.keys(r.namespaces), et = Object.keys(C), eo = !0;
                        return !!index_es_O(et, U) && (U.forEach(l => {
                            let {
                                accounts: U,
                                methods: et,
                                events: es
                            } = r.namespaces[l], el = A(U), ec = C[l];
                            index_es_O(L(l, ec), el) && index_es_O(ec.methods, et) && index_es_O(ec.events, es) || (eo = !1)
                        }), eo)
                    })(l, r))), this.getPendingSessionRequests = () => (this.isInitialized(), this.client.pendingRequest.getAll()), this.cleanupDuplicatePairings = async r => {
                        if (r.pairingTopic) try {
                            let l = this.client.core.pairing.pairings.get(r.pairingTopic),
                                C = this.client.core.pairing.pairings.getAll().filter(C => {
                                    var U, et;
                                    return (null == (U = C.peerMetadata) ? void 0 : U.url) && (null == (et = C.peerMetadata) ? void 0 : et.url) === r.peer.metadata.url && C.topic && C.topic !== l.topic
                                });
                            if (0 === C.length) return;
                            this.client.logger.info(`Cleaning up ${C.length} duplicate pairing(s)`), await Promise.all(C.map(r => this.client.core.pairing.disconnect({
                                topic: r.topic
                            }))), this.client.logger.info("Duplicate pairings clean up finished")
                        } catch (r) {
                            this.client.logger.error(r)
                        }
                    }, this.deleteSession = async (r, l) => {
                        let {
                            self: C
                        } = this.client.session.get(r);
                        await this.client.core.relayer.unsubscribe(r), this.client.session.delete(r, index_es_U("USER_DISCONNECTED")), this.client.core.crypto.keychain.has(C.publicKey) && await this.client.core.crypto.deleteKeyPair(C.publicKey), this.client.core.crypto.keychain.has(r) && await this.client.core.crypto.deleteSymKey(r), l || this.client.core.expirer.del(r), this.client.core.storage.removeItem(i6).catch(r => this.client.logger.warn(r))
                    }, this.deleteProposal = async (r, l) => {
                        await Promise.all([this.client.proposal.delete(r, index_es_U("USER_DISCONNECTED")), l ? Promise.resolve() : this.client.core.expirer.del(r)])
                    }, this.deletePendingSessionRequest = async (r, l, C = !1) => {
                        await Promise.all([this.client.pendingRequest.delete(r, l), C ? Promise.resolve() : this.client.core.expirer.del(r)]), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter(l => l.id !== r), C && (this.sessionRequestQueue.state = oo.idle)
                    }, this.setExpiry = async (r, l) => {
                        this.client.session.keys.includes(r) && await this.client.session.update(r, {
                            expiry: l
                        }), this.client.core.expirer.set(r, l)
                    }, this.setProposal = async (r, l) => {
                        await this.client.proposal.set(r, l), this.client.core.expirer.set(r, l.expiry)
                    }, this.setPendingSessionRequest = async r => {
                        let l = i9.wc_sessionRequest.req.ttl,
                            {
                                id: C,
                                topic: U,
                                params: et,
                                verifyContext: eo
                            } = r;
                        await this.client.pendingRequest.set(C, {
                            id: C,
                            topic: U,
                            params: et,
                            verifyContext: eo
                        }), l && this.client.core.expirer.set(C, pt(l))
                    }, this.sendRequest = async r => {
                        let {
                            topic: l,
                            method: C,
                            params: U,
                            expiry: et,
                            relayRpcId: eo,
                            clientRpcId: es,
                            throwOnFailedPublish: el
                        } = r, ec = (0, nb.formatJsonRpcRequest)(C, U, es);
                        if (index_es_D() && os.includes(C)) {
                            let r = Ln(JSON.stringify(ec));
                            this.client.core.verify.register({
                                attestationId: r
                            })
                        }
                        let ed = await this.client.core.crypto.encode(l, ec),
                            eh = i9[C].req;
                        return et && (eh.ttl = et), eo && (eh.id = eo), this.client.core.history.set(l, ec), el ? (eh.internal = dist_index_es_b(dist_index_es_g({}, eh.internal), {
                            throwOnFailedPublish: !0
                        }), await this.client.core.relayer.publish(l, ed, eh)) : this.client.core.relayer.publish(l, ed, eh).catch(r => this.client.logger.error(r)), ec.id
                    }, this.sendResult = async r => {
                        let {
                            id: l,
                            topic: C,
                            result: U,
                            throwOnFailedPublish: et
                        } = r, eo = (0, nb.formatJsonRpcResult)(l, U), es = await this.client.core.crypto.encode(C, eo), el = await this.client.core.history.get(C, l), ec = i9[el.request.method].res;
                        et ? (ec.internal = dist_index_es_b(dist_index_es_g({}, ec.internal), {
                            throwOnFailedPublish: !0
                        }), await this.client.core.relayer.publish(C, es, ec)) : this.client.core.relayer.publish(C, es, ec).catch(r => this.client.logger.error(r)), await this.client.core.history.resolve(eo)
                    }, this.sendError = async (r, l, C) => {
                        let U = (0, nb.formatJsonRpcError)(r, C),
                            et = await this.client.core.crypto.encode(l, U),
                            eo = await this.client.core.history.get(l, r),
                            es = i9[eo.request.method].res;
                        this.client.core.relayer.publish(l, et, es), await this.client.core.history.resolve(U)
                    }, this.cleanup = async () => {
                        let r = [],
                            l = [];
                        this.client.session.getAll().forEach(l => {
                            mt(l.expiry) && r.push(l.topic)
                        }), this.client.proposal.getAll().forEach(r => {
                            mt(r.expiry) && l.push(r.id)
                        }), await Promise.all([...r.map(r => this.deleteSession(r)), ...l.map(r => this.deleteProposal(r))])
                    }, this.onRelayEventRequest = async r => {
                        this.requestQueue.queue.push(r), await this.processRequestsQueue()
                    }, this.processRequestsQueue = async () => {
                        if (this.requestQueue.state === oo.active) {
                            this.client.logger.info("Request queue already active, skipping...");
                            return
                        }
                        for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0;) {
                            this.requestQueue.state = oo.active;
                            let r = this.requestQueue.queue.shift();
                            if (r) try {
                                this.processRequest(r), await new Promise(r => setTimeout(r, 300))
                            } catch (r) {
                                this.client.logger.warn(r)
                            }
                        }
                        this.requestQueue.state = oo.idle
                    }, this.processRequest = r => {
                        let {
                            topic: l,
                            payload: C
                        } = r, U = C.method;
                        switch (U) {
                            case "wc_sessionPropose":
                                return this.onSessionProposeRequest(l, C);
                            case "wc_sessionSettle":
                                return this.onSessionSettleRequest(l, C);
                            case "wc_sessionUpdate":
                                return this.onSessionUpdateRequest(l, C);
                            case "wc_sessionExtend":
                                return this.onSessionExtendRequest(l, C);
                            case "wc_sessionPing":
                                return this.onSessionPingRequest(l, C);
                            case "wc_sessionDelete":
                                return this.onSessionDeleteRequest(l, C);
                            case "wc_sessionRequest":
                                return this.onSessionRequest(l, C);
                            case "wc_sessionEvent":
                                return this.onSessionEventRequest(l, C);
                            default:
                                return this.client.logger.info(`Unsupported request method ${U}`)
                        }
                    }, this.onRelayEventResponse = async r => {
                        let {
                            topic: l,
                            payload: C
                        } = r, U = (await this.client.core.history.get(l, C.id)).request.method;
                        switch (U) {
                            case "wc_sessionPropose":
                                return this.onSessionProposeResponse(l, C);
                            case "wc_sessionSettle":
                                return this.onSessionSettleResponse(l, C);
                            case "wc_sessionUpdate":
                                return this.onSessionUpdateResponse(l, C);
                            case "wc_sessionExtend":
                                return this.onSessionExtendResponse(l, C);
                            case "wc_sessionPing":
                                return this.onSessionPingResponse(l, C);
                            case "wc_sessionRequest":
                                return this.onSessionRequestResponse(l, C);
                            default:
                                return this.client.logger.info(`Unsupported response method ${U}`)
                        }
                    }, this.onRelayEventUnknownPayload = r => {
                        let {
                            topic: l
                        } = r, {
                            message: C
                        } = index_es_N("MISSING_OR_INVALID", `Decoded payload on topic ${l} is not identifiable as a JSON-RPC request or a response.`);
                        throw Error(C)
                    }, this.onSessionProposeRequest = async (r, l) => {
                        let {
                            params: C,
                            id: U
                        } = l;
                        try {
                            this.isValidConnect(dist_index_es_g({}, l.params));
                            let et = pt(tQ.FIVE_MINUTES),
                                eo = dist_index_es_g({
                                    id: U,
                                    pairingTopic: r,
                                    expiry: et
                                }, C);
                            await this.setProposal(U, eo);
                            let es = Ln(JSON.stringify(l)),
                                el = await this.getVerifyContext(es, eo.proposer.metadata);
                            this.client.events.emit("session_proposal", {
                                id: U,
                                params: eo,
                                verifyContext: el
                            })
                        } catch (l) {
                            await this.sendError(U, r, l), this.client.logger.error(l)
                        }
                    }, this.onSessionProposeResponse = async (r, l) => {
                        let {
                            id: C
                        } = l;
                        if ((0, nb.isJsonRpcResult)(l)) {
                            let {
                                result: U
                            } = l;
                            this.client.logger.trace({
                                type: "method",
                                method: "onSessionProposeResponse",
                                result: U
                            });
                            let et = this.client.proposal.get(C);
                            this.client.logger.trace({
                                type: "method",
                                method: "onSessionProposeResponse",
                                proposal: et
                            });
                            let eo = et.proposer.publicKey;
                            this.client.logger.trace({
                                type: "method",
                                method: "onSessionProposeResponse",
                                selfPublicKey: eo
                            });
                            let es = U.responderPublicKey;
                            this.client.logger.trace({
                                type: "method",
                                method: "onSessionProposeResponse",
                                peerPublicKey: es
                            });
                            let el = await this.client.core.crypto.generateSharedKey(eo, es);
                            this.client.logger.trace({
                                type: "method",
                                method: "onSessionProposeResponse",
                                sessionTopic: el
                            });
                            let ec = await this.client.core.relayer.subscribe(el);
                            this.client.logger.trace({
                                type: "method",
                                method: "onSessionProposeResponse",
                                subscriptionId: ec
                            }), await this.client.core.pairing.activate({
                                topic: r
                            })
                        } else(0, nb.isJsonRpcError)(l) && (await this.client.proposal.delete(C, index_es_U("USER_DISCONNECTED")), this.events.emit(yt("session_connect"), {
                            error: l.error
                        }))
                    }, this.onSessionSettleRequest = async (r, l) => {
                        let {
                            id: C,
                            params: U
                        } = l;
                        try {
                            this.isValidSessionSettleRequest(U);
                            let {
                                relay: C,
                                controller: et,
                                expiry: eo,
                                namespaces: es,
                                requiredNamespaces: el,
                                optionalNamespaces: ec,
                                sessionProperties: ed,
                                pairingTopic: eh
                            } = l.params, ef = dist_index_es_g({
                                topic: r,
                                relay: C,
                                expiry: eo,
                                namespaces: es,
                                acknowledged: !0,
                                pairingTopic: eh,
                                requiredNamespaces: el,
                                optionalNamespaces: ec,
                                controller: et.publicKey,
                                self: {
                                    publicKey: "",
                                    metadata: this.client.metadata
                                },
                                peer: {
                                    publicKey: et.publicKey,
                                    metadata: et.metadata
                                }
                            }, ed && {
                                sessionProperties: ed
                            });
                            await this.sendResult({
                                id: l.id,
                                topic: r,
                                result: !0
                            }), this.events.emit(yt("session_connect"), {
                                session: ef
                            }), this.cleanupDuplicatePairings(ef)
                        } catch (l) {
                            await this.sendError(C, r, l), this.client.logger.error(l)
                        }
                    }, this.onSessionSettleResponse = async (r, l) => {
                        let {
                            id: C
                        } = l;
                        (0, nb.isJsonRpcResult)(l) ? (await this.client.session.update(r, {
                            acknowledged: !0
                        }), this.events.emit(yt("session_approve", C), {})) : (0, nb.isJsonRpcError)(l) && (await this.client.session.delete(r, index_es_U("USER_DISCONNECTED")), this.events.emit(yt("session_approve", C), {
                            error: l.error
                        }))
                    }, this.onSessionUpdateRequest = async (r, l) => {
                        let {
                            params: C,
                            id: U
                        } = l;
                        try {
                            let l = `${r}_session_update`,
                                et = tr.get(l);
                            if (et && this.isRequestOutOfSync(et, U)) {
                                this.client.logger.info(`Discarding out of sync request - ${U}`);
                                return
                            }
                            this.isValidUpdate(dist_index_es_g({
                                topic: r
                            }, C)), await this.client.session.update(r, {
                                namespaces: C.namespaces
                            }), await this.sendResult({
                                id: U,
                                topic: r,
                                result: !0
                            }), this.client.events.emit("session_update", {
                                id: U,
                                topic: r,
                                params: C
                            }), tr.set(l, U)
                        } catch (l) {
                            await this.sendError(U, r, l), this.client.logger.error(l)
                        }
                    }, this.isRequestOutOfSync = (r, l) => parseInt(l.toString().slice(0, -3)) <= parseInt(r.toString().slice(0, -3)), this.onSessionUpdateResponse = (r, l) => {
                        let {
                            id: C
                        } = l;
                        (0, nb.isJsonRpcResult)(l) ? this.events.emit(yt("session_update", C), {}): (0, nb.isJsonRpcError)(l) && this.events.emit(yt("session_update", C), {
                            error: l.error
                        })
                    }, this.onSessionExtendRequest = async (r, l) => {
                        let {
                            id: C
                        } = l;
                        try {
                            this.isValidExtend({
                                topic: r
                            }), await this.setExpiry(r, pt(i4)), await this.sendResult({
                                id: C,
                                topic: r,
                                result: !0
                            }), this.client.events.emit("session_extend", {
                                id: C,
                                topic: r
                            })
                        } catch (l) {
                            await this.sendError(C, r, l), this.client.logger.error(l)
                        }
                    }, this.onSessionExtendResponse = (r, l) => {
                        let {
                            id: C
                        } = l;
                        (0, nb.isJsonRpcResult)(l) ? this.events.emit(yt("session_extend", C), {}): (0, nb.isJsonRpcError)(l) && this.events.emit(yt("session_extend", C), {
                            error: l.error
                        })
                    }, this.onSessionPingRequest = async (r, l) => {
                        let {
                            id: C
                        } = l;
                        try {
                            this.isValidPing({
                                topic: r
                            }), await this.sendResult({
                                id: C,
                                topic: r,
                                result: !0
                            }), this.client.events.emit("session_ping", {
                                id: C,
                                topic: r
                            })
                        } catch (l) {
                            await this.sendError(C, r, l), this.client.logger.error(l)
                        }
                    }, this.onSessionPingResponse = (r, l) => {
                        let {
                            id: C
                        } = l;
                        setTimeout(() => {
                            (0, nb.isJsonRpcResult)(l) ? this.events.emit(yt("session_ping", C), {}): (0, nb.isJsonRpcError)(l) && this.events.emit(yt("session_ping", C), {
                                error: l.error
                            })
                        }, 500)
                    }, this.onSessionDeleteRequest = async (r, l) => {
                        let {
                            id: C
                        } = l;
                        try {
                            this.isValidDisconnect({
                                topic: r,
                                reason: l.params
                            }), await Promise.all([new Promise(l => {
                                this.client.core.relayer.once(ix.publish, async () => {
                                    l(await this.deleteSession(r))
                                })
                            }), this.sendResult({
                                id: C,
                                topic: r,
                                result: !0
                            })]), this.client.events.emit("session_delete", {
                                id: C,
                                topic: r
                            })
                        } catch (r) {
                            this.client.logger.error(r)
                        }
                    }, this.onSessionRequest = async (r, l) => {
                        let {
                            id: C,
                            params: U
                        } = l;
                        try {
                            this.isValidRequest(dist_index_es_g({
                                topic: r
                            }, U));
                            let l = Ln(JSON.stringify((0, nb.formatJsonRpcRequest)("wc_sessionRequest", U, C))),
                                et = this.client.session.get(r),
                                eo = await this.getVerifyContext(l, et.peer.metadata),
                                es = {
                                    id: C,
                                    topic: r,
                                    params: U,
                                    verifyContext: eo
                                };
                            await this.setPendingSessionRequest(es), this.addSessionRequestToSessionRequestQueue(es), this.processSessionRequestQueue()
                        } catch (l) {
                            await this.sendError(C, r, l), this.client.logger.error(l)
                        }
                    }, this.onSessionRequestResponse = (r, l) => {
                        let {
                            id: C
                        } = l;
                        (0, nb.isJsonRpcResult)(l) ? this.events.emit(yt("session_request", C), {
                            result: l.result
                        }): (0, nb.isJsonRpcError)(l) && this.events.emit(yt("session_request", C), {
                            error: l.error
                        })
                    }, this.onSessionEventRequest = async (r, l) => {
                        let {
                            id: C,
                            params: U
                        } = l;
                        try {
                            let l = `${r}_session_event_${U.event.name}`,
                                et = tr.get(l);
                            if (et && this.isRequestOutOfSync(et, C)) {
                                this.client.logger.info(`Discarding out of sync request - ${C}`);
                                return
                            }
                            this.isValidEmit(dist_index_es_g({
                                topic: r
                            }, U)), this.client.events.emit("session_event", {
                                id: C,
                                topic: r,
                                params: U
                            }), tr.set(l, C)
                        } catch (l) {
                            await this.sendError(C, r, l), this.client.logger.error(l)
                        }
                    }, this.addSessionRequestToSessionRequestQueue = r => {
                        this.sessionRequestQueue.queue.push(r)
                    }, this.cleanupAfterResponse = r => {
                        this.deletePendingSessionRequest(r.response.id, {
                            message: "fulfilled",
                            code: 0
                        }), setTimeout(() => {
                            this.sessionRequestQueue.state = oo.idle, this.processSessionRequestQueue()
                        }, (0, tQ.toMiliseconds)(this.requestQueueDelay))
                    }, this.processSessionRequestQueue = () => {
                        if (this.sessionRequestQueue.state === oo.active) {
                            this.client.logger.info("session request queue is already active.");
                            return
                        }
                        let r = this.sessionRequestQueue.queue[0];
                        if (!r) {
                            this.client.logger.info("session request queue is empty.");
                            return
                        }
                        try {
                            this.sessionRequestQueue.state = oo.active, this.client.events.emit("session_request", r)
                        } catch (r) {
                            this.client.logger.error(r)
                        }
                    }, this.onPairingCreated = r => {
                        if (r.active) return;
                        let l = this.client.proposal.getAll().find(l => l.pairingTopic === r.topic);
                        l && this.onSessionProposeRequest(r.topic, (0, nb.formatJsonRpcRequest)("wc_sessionPropose", {
                            requiredNamespaces: l.requiredNamespaces,
                            optionalNamespaces: l.optionalNamespaces,
                            relays: l.relays,
                            proposer: l.proposer,
                            sessionProperties: l.sessionProperties
                        }, l.id))
                    }, this.isValidConnect = async r => {
                        let l;
                        if (!Ht(r)) {
                            let {
                                message: l
                            } = index_es_N("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(r)}`);
                            throw Error(l)
                        }
                        let {
                            pairingTopic: C,
                            requiredNamespaces: U,
                            optionalNamespaces: et,
                            sessionProperties: eo,
                            relays: es
                        } = r;
                        if (w(C) || await this.isValidPairingTopic(C), l = !1, es ? es && index_es_k(es) && es.length && es.forEach(r => {
                                l = ln(r)
                            }) : l = !0, !l) {
                            let {
                                message: r
                            } = index_es_N("MISSING_OR_INVALID", `connect() relays: ${es}`);
                            throw Error(r)
                        }
                        w(U) || 0 === B(U) || this.validateNamespaces(U, "requiredNamespaces"), w(et) || 0 === B(et) || this.validateNamespaces(et, "optionalNamespaces"), w(eo) || this.validateSessionProps(eo, "sessionProperties")
                    }, this.validateNamespaces = (r, l) => {
                        let C = function(r, l, C) {
                            let U = null;
                            if (r && B(r)) {
                                let et;
                                let eo = ce(r, l);
                                eo && (U = eo);
                                let es = (et = null, Object.entries(r).forEach(([r, U]) => {
                                    var eo, es;
                                    let el;
                                    if (et) return;
                                    let ec = (eo = L(r, U), es = `${l} ${C}`, el = null, index_es_k(eo) && eo.length ? eo.forEach(r => {
                                        el || V(r) || (el = index_es_U("UNSUPPORTED_CHAINS", `${es}, chain ${r} should be a string and conform to "namespace:chainId" format`))
                                    }) : V(r) || (el = index_es_U("UNSUPPORTED_CHAINS", `${es}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), el);
                                    ec && (et = ec)
                                }), et);
                                es && (U = es)
                            } else U = index_es_N("MISSING_OR_INVALID", `${l}, ${C} should be an object with data`);
                            return U
                        }(r, "connect()", l);
                        if (C) throw Error(C.message)
                    }, this.isValidApprove = async r => {
                        if (!Ht(r)) throw Error(index_es_N("MISSING_OR_INVALID", `approve() params: ${r}`).message);
                        let {
                            id: l,
                            namespaces: C,
                            relayProtocol: U,
                            sessionProperties: et
                        } = r;
                        await this.isValidProposalId(l);
                        let eo = this.client.proposal.get(l),
                            es = un(C, "approve()");
                        if (es) throw Error(es.message);
                        let el = dn(eo.requiredNamespaces, C, "approve()");
                        if (el) throw Error(el.message);
                        if (!dist_index_es_h(U, !0)) {
                            let {
                                message: r
                            } = index_es_N("MISSING_OR_INVALID", `approve() relayProtocol: ${U}`);
                            throw Error(r)
                        }
                        w(et) || this.validateSessionProps(et, "sessionProperties")
                    }, this.isValidReject = async r => {
                        if (!Ht(r)) {
                            let {
                                message: l
                            } = index_es_N("MISSING_OR_INVALID", `reject() params: ${r}`);
                            throw Error(l)
                        }
                        let {
                            id: l,
                            reason: C
                        } = r;
                        if (await this.isValidProposalId(l), !C || "object" != typeof C || !C.code || !G(C.code, !1) || !C.message || !dist_index_es_h(C.message, !1)) {
                            let {
                                message: r
                            } = index_es_N("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(C)}`);
                            throw Error(r)
                        }
                    }, this.isValidSessionSettleRequest = r => {
                        let l;
                        if (!Ht(r)) {
                            let {
                                message: l
                            } = index_es_N("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${r}`);
                            throw Error(l)
                        }
                        let {
                            relay: C,
                            controller: U,
                            namespaces: et,
                            expiry: eo
                        } = r;
                        if (!ln(C)) {
                            let {
                                message: r
                            } = index_es_N("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
                            throw Error(r)
                        }
                        let es = (l = null, dist_index_es_h(U ? .publicKey, !1) || (l = index_es_N("MISSING_OR_INVALID", "onSessionSettleRequest() controller public key should be a string")), l);
                        if (es) throw Error(es.message);
                        let el = un(et, "onSessionSettleRequest()");
                        if (el) throw Error(el.message);
                        if (mt(eo)) {
                            let {
                                message: r
                            } = index_es_N("EXPIRED", "onSessionSettleRequest()");
                            throw Error(r)
                        }
                    }, this.isValidUpdate = async r => {
                        if (!Ht(r)) {
                            let {
                                message: l
                            } = index_es_N("MISSING_OR_INVALID", `update() params: ${r}`);
                            throw Error(l)
                        }
                        let {
                            topic: l,
                            namespaces: C
                        } = r;
                        await this.isValidSessionTopic(l);
                        let U = this.client.session.get(l),
                            et = un(C, "update()");
                        if (et) throw Error(et.message);
                        let eo = dn(U.requiredNamespaces, C, "update()");
                        if (eo) throw Error(eo.message)
                    }, this.isValidExtend = async r => {
                        if (!Ht(r)) {
                            let {
                                message: l
                            } = index_es_N("MISSING_OR_INVALID", `extend() params: ${r}`);
                            throw Error(l)
                        }
                        let {
                            topic: l
                        } = r;
                        await this.isValidSessionTopic(l)
                    }, this.isValidRequest = async r => {
                        var l;
                        if (!Ht(r)) {
                            let {
                                message: l
                            } = index_es_N("MISSING_OR_INVALID", `request() params: ${r}`);
                            throw Error(l)
                        }
                        let {
                            topic: C,
                            request: U,
                            chainId: et,
                            expiry: eo
                        } = r;
                        await this.isValidSessionTopic(C);
                        let {
                            namespaces: es
                        } = this.client.session.get(C);
                        if (!zt(es, et)) {
                            let {
                                message: r
                            } = index_es_N("MISSING_OR_INVALID", `request() chainId: ${et}`);
                            throw Error(r)
                        }
                        if (w(U) || !dist_index_es_h(U.method, !1)) {
                            let {
                                message: r
                            } = index_es_N("MISSING_OR_INVALID", `request() ${JSON.stringify(U)}`);
                            throw Error(r)
                        }
                        if (!(dist_index_es_h(l = U.method, !1) && (function(r, l) {
                                let C = [];
                                return Object.values(r).forEach(r => {
                                    A(r.accounts).includes(l) && C.push(...r.methods)
                                }), C
                            })(es, et).includes(l))) {
                            let {
                                message: r
                            } = index_es_N("MISSING_OR_INVALID", `request() method: ${U.method}`);
                            throw Error(r)
                        }
                        if (eo && (!G(eo, !1) || !(eo <= i7.max) || !(eo >= i7.min))) {
                            let {
                                message: r
                            } = index_es_N("MISSING_OR_INVALID", `request() expiry: ${eo}. Expiry must be a number (in seconds) between ${i7.min} and ${i7.max}`);
                            throw Error(r)
                        }
                    }, this.isValidRespond = async r => {
                        if (!Ht(r)) {
                            let {
                                message: l
                            } = index_es_N("MISSING_OR_INVALID", `respond() params: ${r}`);
                            throw Error(l)
                        }
                        let {
                            topic: l,
                            response: C
                        } = r;
                        if (await this.isValidSessionTopic(l), w(C) || w(C.result) && w(C.error) || !G(C.id, !1) || !dist_index_es_h(C.jsonrpc, !1)) {
                            let {
                                message: r
                            } = index_es_N("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(C)}`);
                            throw Error(r)
                        }
                    }, this.isValidPing = async r => {
                        if (!Ht(r)) {
                            let {
                                message: l
                            } = index_es_N("MISSING_OR_INVALID", `ping() params: ${r}`);
                            throw Error(l)
                        }
                        let {
                            topic: l
                        } = r;
                        await this.isValidSessionOrPairingTopic(l)
                    }, this.isValidEmit = async r => {
                        var l;
                        if (!Ht(r)) {
                            let {
                                message: l
                            } = index_es_N("MISSING_OR_INVALID", `emit() params: ${r}`);
                            throw Error(l)
                        }
                        let {
                            topic: C,
                            event: U,
                            chainId: et
                        } = r;
                        await this.isValidSessionTopic(C);
                        let {
                            namespaces: eo
                        } = this.client.session.get(C);
                        if (!zt(eo, et)) {
                            let {
                                message: r
                            } = index_es_N("MISSING_OR_INVALID", `emit() chainId: ${et}`);
                            throw Error(r)
                        }
                        if (w(U) || !dist_index_es_h(U.name, !1)) {
                            let {
                                message: r
                            } = index_es_N("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(U)}`);
                            throw Error(r)
                        }
                        if (!(dist_index_es_h(l = U.name, !1) && (function(r, l) {
                                let C = [];
                                return Object.values(r).forEach(r => {
                                    A(r.accounts).includes(l) && C.push(...r.events)
                                }), C
                            })(eo, et).includes(l))) {
                            let {
                                message: r
                            } = index_es_N("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(U)}`);
                            throw Error(r)
                        }
                    }, this.isValidDisconnect = async r => {
                        if (!Ht(r)) {
                            let {
                                message: l
                            } = index_es_N("MISSING_OR_INVALID", `disconnect() params: ${r}`);
                            throw Error(l)
                        }
                        let {
                            topic: l
                        } = r;
                        await this.isValidSessionOrPairingTopic(l)
                    }, this.getVerifyContext = async (r, l) => {
                        let C = {
                            verified: {
                                verifyUrl: l.verifyUrl || iB,
                                validation: "UNKNOWN",
                                origin: l.url || ""
                            }
                        };
                        try {
                            let U = await this.client.core.verify.resolve({
                                attestationId: r,
                                verifyUrl: l.verifyUrl
                            });
                            U && (C.verified.origin = U.origin, C.verified.isScam = U.isScam, C.verified.validation = U.origin === new URL(l.url).origin ? "VALID" : "INVALID")
                        } catch (r) {
                            this.client.logger.info(r)
                        }
                        return this.client.logger.info(`Verify context: ${JSON.stringify(C)}`), C
                    }, this.validateSessionProps = (r, l) => {
                        Object.values(r).forEach(r => {
                            if (!dist_index_es_h(r, !1)) {
                                let {
                                    message: C
                                } = index_es_N("MISSING_OR_INVALID", `${l} must be in Record<string, string> format. Received: ${JSON.stringify(r)}`);
                                throw Error(C)
                            }
                        })
                    }
                }
                async isInitialized() {
                    if (!this.initialized) {
                        let {
                            message: r
                        } = index_es_N("NOT_INITIALIZED", this.name);
                        throw Error(r)
                    }
                    await this.client.core.relayer.confirmOnlineStateOrThrow()
                }
                registerRelayerEvents() {
                    this.client.core.relayer.on(ix.message, async r => {
                        let {
                            topic: l,
                            message: C
                        } = r;
                        if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(C))) return;
                        let U = await this.client.core.crypto.decode(l, C);
                        try {
                            (0, nb.isJsonRpcRequest)(U) ? (this.client.core.history.set(l, U), this.onRelayEventRequest({
                                topic: l,
                                payload: U
                            })) : (0, nb.isJsonRpcResponse)(U) ? (await this.client.core.history.resolve(U), await this.onRelayEventResponse({
                                topic: l,
                                payload: U
                            }), this.client.core.history.delete(l, U.id)) : this.onRelayEventUnknownPayload({
                                topic: l,
                                payload: U
                            })
                        } catch (r) {
                            this.client.logger.error(r)
                        }
                    })
                }
                registerExpirerEvents() {
                    this.client.core.expirer.on(iR.expired, async r => {
                        let {
                            topic: l,
                            id: C
                        } = ft(r.target);
                        if (C && this.client.pendingRequest.keys.includes(C)) return await this.deletePendingSessionRequest(C, index_es_N("EXPIRED"), !0);
                        l ? this.client.session.keys.includes(l) && (await this.deleteSession(l, !0), this.client.events.emit("session_expire", {
                            topic: l
                        })) : C && (await this.deleteProposal(C, !0), this.client.events.emit("proposal_expire", {
                            id: C
                        }))
                    })
                }
                registerPairingEvents() {
                    this.client.core.pairing.events.on(iO.create, r => this.onPairingCreated(r))
                }
                isValidPairingTopic(r) {
                    if (!dist_index_es_h(r, !1)) {
                        let {
                            message: l
                        } = index_es_N("MISSING_OR_INVALID", `pairing topic should be a string: ${r}`);
                        throw Error(l)
                    }
                    if (!this.client.core.pairing.pairings.keys.includes(r)) {
                        let {
                            message: l
                        } = index_es_N("NO_MATCHING_KEY", `pairing topic doesn't exist: ${r}`);
                        throw Error(l)
                    }
                    if (mt(this.client.core.pairing.pairings.get(r).expiry)) {
                        let {
                            message: l
                        } = index_es_N("EXPIRED", `pairing topic: ${r}`);
                        throw Error(l)
                    }
                }
                async isValidSessionTopic(r) {
                    if (!dist_index_es_h(r, !1)) {
                        let {
                            message: l
                        } = index_es_N("MISSING_OR_INVALID", `session topic should be a string: ${r}`);
                        throw Error(l)
                    }
                    if (!this.client.session.keys.includes(r)) {
                        let {
                            message: l
                        } = index_es_N("NO_MATCHING_KEY", `session topic doesn't exist: ${r}`);
                        throw Error(l)
                    }
                    if (mt(this.client.session.get(r).expiry)) {
                        await this.deleteSession(r);
                        let {
                            message: l
                        } = index_es_N("EXPIRED", `session topic: ${r}`);
                        throw Error(l)
                    }
                }
                async isValidSessionOrPairingTopic(r) {
                    if (this.client.session.keys.includes(r)) await this.isValidSessionTopic(r);
                    else if (this.client.core.pairing.pairings.keys.includes(r)) this.isValidPairingTopic(r);
                    else if (dist_index_es_h(r, !1)) {
                        let {
                            message: l
                        } = index_es_N("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${r}`);
                        throw Error(l)
                    } else {
                        let {
                            message: l
                        } = index_es_N("MISSING_OR_INVALID", `session or pairing topic should be a string: ${r}`);
                        throw Error(l)
                    }
                }
                async isValidProposalId(r) {
                    if ("number" != typeof r) {
                        let {
                            message: l
                        } = index_es_N("MISSING_OR_INVALID", `proposal id should be a number: ${r}`);
                        throw Error(l)
                    }
                    if (!this.client.proposal.keys.includes(r)) {
                        let {
                            message: l
                        } = index_es_N("NO_MATCHING_KEY", `proposal id doesn't exist: ${r}`);
                        throw Error(l)
                    }
                    if (mt(this.client.proposal.get(r).expiry)) {
                        await this.deleteProposal(r);
                        let {
                            message: l
                        } = index_es_N("EXPIRED", `proposal id: ${r}`);
                        throw Error(l)
                    }
                }
            };
            let index_es_ds = class index_es_ds extends Mt {
                constructor(r, l) {
                    super(r, l, "proposal", i3), this.core = r, this.logger = l
                }
            };
            let index_es_us = class index_es_us extends Mt {
                constructor(r, l) {
                    super(r, l, "session", i3), this.core = r, this.logger = l
                }
            };
            let index_es_gs = class index_es_gs extends Mt {
                constructor(r, l) {
                    super(r, l, "request", i3, r => r.id), this.core = r, this.logger = l
                }
            };
            let dist_index_es_Q = class dist_index_es_Q extends b {
                constructor(r) {
                    super(r), this.protocol = "wc", this.version = 2, this.name = i5.name, this.events = new tM.EventEmitter, this.on = (r, l) => this.events.on(r, l), this.once = (r, l) => this.events.once(r, l), this.off = (r, l) => this.events.off(r, l), this.removeListener = (r, l) => this.events.removeListener(r, l), this.removeAllListeners = r => this.events.removeAllListeners(r), this.connect = async r => {
                        try {
                            return await this.engine.connect(r)
                        } catch (r) {
                            throw this.logger.error(r.message), r
                        }
                    }, this.pair = async r => {
                        try {
                            return await this.engine.pair(r)
                        } catch (r) {
                            throw this.logger.error(r.message), r
                        }
                    }, this.approve = async r => {
                        try {
                            return await this.engine.approve(r)
                        } catch (r) {
                            throw this.logger.error(r.message), r
                        }
                    }, this.reject = async r => {
                        try {
                            return await this.engine.reject(r)
                        } catch (r) {
                            throw this.logger.error(r.message), r
                        }
                    }, this.update = async r => {
                        try {
                            return await this.engine.update(r)
                        } catch (r) {
                            throw this.logger.error(r.message), r
                        }
                    }, this.extend = async r => {
                        try {
                            return await this.engine.extend(r)
                        } catch (r) {
                            throw this.logger.error(r.message), r
                        }
                    }, this.request = async r => {
                        try {
                            return await this.engine.request(r)
                        } catch (r) {
                            throw this.logger.error(r.message), r
                        }
                    }, this.respond = async r => {
                        try {
                            return await this.engine.respond(r)
                        } catch (r) {
                            throw this.logger.error(r.message), r
                        }
                    }, this.ping = async r => {
                        try {
                            return await this.engine.ping(r)
                        } catch (r) {
                            throw this.logger.error(r.message), r
                        }
                    }, this.emit = async r => {
                        try {
                            return await this.engine.emit(r)
                        } catch (r) {
                            throw this.logger.error(r.message), r
                        }
                    }, this.disconnect = async r => {
                        try {
                            return await this.engine.disconnect(r)
                        } catch (r) {
                            throw this.logger.error(r.message), r
                        }
                    }, this.find = r => {
                        try {
                            return this.engine.find(r)
                        } catch (r) {
                            throw this.logger.error(r.message), r
                        }
                    }, this.getPendingSessionRequests = () => {
                        try {
                            return this.engine.getPendingSessionRequests()
                        } catch (r) {
                            throw this.logger.error(r.message), r
                        }
                    }, this.name = r ? .name || i5.name, this.metadata = r ? .metadata || (0, r2.D)() || {
                        name: "",
                        description: "",
                        url: "",
                        icons: [""]
                    };
                    let l = "u" > typeof r ? .logger && "string" != typeof r ? .logger ? r.logger : (0, tJ.pino)((0, tJ.getDefaultLoggerOptions)({
                        level: r ? .logger || i5.logger
                    }));
                    this.core = r ? .core || new index_es_te(r), this.logger = (0, tJ.generateChildLogger)(l, this.name), this.session = new index_es_us(this.core, this.logger), this.proposal = new index_es_ds(this.core, this.logger), this.pendingRequest = new index_es_gs(this.core, this.logger), this.engine = new index_es_hs(this)
                }
                static async init(r) {
                    let l = new dist_index_es_Q(r);
                    return await l.initialize(), l
                }
                get context() {
                    return (0, tJ.getLoggerContext)(this.logger)
                }
                get pairing() {
                    return this.core.pairing.pairings
                }
                async initialize() {
                    this.logger.trace("Initialized");
                    try {
                        await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.engine.init(), this.core.verify.init({
                            verifyUrl: this.metadata.verifyUrl
                        }), this.logger.info("SignClient Initialization Success")
                    } catch (r) {
                        throw this.logger.info("SignClient Initialization Failure"), this.logger.error(r.message), r
                    }
                }
            };
            var og = C(49961);
            let oy = "error",
                om = "wc@2:universal_provider:",
                ov = {
                    DEFAULT_CHAIN_CHANGED: "default_chain_changed"
                };
            var o_ = "u" > typeof globalThis ? globalThis : "u" > typeof window ? window : "u" > typeof C.g ? C.g : "u" > typeof self ? self : {},
                ob = {
                    exports: {}
                };
            /**
             * @license
             * Lodash <https://lodash.com/>
             * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
             * Released under MIT license <https://lodash.com/license>
             * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
             * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
             */
            ! function(r, l) {
                (function() {
                    var C, U = "Expected a function",
                        et = "__lodash_hash_undefined__",
                        eo = "__lodash_placeholder__",
                        es = 1 / 0,
                        el = 0 / 0,
                        ec = [
                            ["ary", 128],
                            ["bind", 1],
                            ["bindKey", 2],
                            ["curry", 8],
                            ["curryRight", 16],
                            ["flip", 512],
                            ["partial", 32],
                            ["partialRight", 64],
                            ["rearg", 256]
                        ],
                        ed = "[object Arguments]",
                        eh = "[object Array]",
                        ef = "[object Boolean]",
                        ep = "[object Date]",
                        eg = "[object Error]",
                        ey = "[object Function]",
                        em = "[object GeneratorFunction]",
                        e_ = "[object Map]",
                        eb = "[object Number]",
                        ew = "[object Object]",
                        eE = "[object Promise]",
                        eI = "[object RegExp]",
                        eS = "[object Set]",
                        ex = "[object String]",
                        eA = "[object Symbol]",
                        eP = "[object WeakMap]",
                        eC = "[object ArrayBuffer]",
                        ek = "[object DataView]",
                        eN = "[object Float32Array]",
                        eO = "[object Float64Array]",
                        eT = "[object Int8Array]",
                        eR = "[object Int16Array]",
                        eD = "[object Int32Array]",
                        eB = "[object Uint8Array]",
                        eU = "[object Uint8ClampedArray]",
                        eL = "[object Uint16Array]",
                        eM = "[object Uint32Array]",
                        ej = /\b__p \+= '';/g,
                        e$ = /\b(__p \+=) '' \+/g,
                        ez = /(__e\(.*?\)|\b__t\)) \+\n'';/g,
                        eH = /&(?:amp|lt|gt|quot|#39);/g,
                        eF = /[&<>"']/g,
                        eW = RegExp(eH.source),
                        eV = RegExp(eF.source),
                        eK = /<%-([\s\S]+?)%>/g,
                        eG = /<%([\s\S]+?)%>/g,
                        eJ = /<%=([\s\S]+?)%>/g,
                        eY = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
                        eZ = /^\w*$/,
                        eX = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
                        eQ = /[\\^$.*+?()[\]{}|]/g,
                        e0 = RegExp(eQ.source),
                        e1 = /^\s+/,
                        e2 = /\s/,
                        e3 = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
                        e5 = /\{\n\/\* \[wrapped with (.+)\] \*/,
                        e6 = /,? & /,
                        e8 = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,
                        e4 = /[()=,{}\[\]\/\s]/,
                        e9 = /\\(\\)?/g,
                        e7 = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,
                        tn = /\w*$/,
                        to = /^[-+]0x[0-9a-f]+$/i,
                        ts = /^0b[01]+$/i,
                        ta = /^\[object .+?Constructor\]$/,
                        tl = /^0o[0-7]+$/i,
                        tc = /^(?:0|[1-9]\d*)$/,
                        td = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,
                        th = /($^)/,
                        tf = /['\n\r\u2028\u2029\\]/g,
                        tp = "\ud800-\udfff",
                        tg = "\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff",
                        ty = "\\u2700-\\u27bf",
                        tm = "a-z\\xdf-\\xf6\\xf8-\\xff",
                        t_ = "A-Z\\xc0-\\xd6\\xd8-\\xde",
                        tb = "\\ufe0e\\ufe0f",
                        tw = "\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
                        tE = "[']",
                        tI = "[" + tw + "]",
                        tS = "[" + tg + "]",
                        tx = "[" + tm + "]",
                        tA = "[^" + tp + tw + "\\d+" + ty + tm + t_ + "]",
                        tP = "\ud83c[\udffb-\udfff]",
                        tC = "[^" + tp + "]",
                        tk = "(?:\ud83c[\udde6-\uddff]){2}",
                        tN = "[\ud800-\udbff][\udc00-\udfff]",
                        tO = "[" + t_ + "]",
                        tT = "\\u200d",
                        tR = "(?:" + tx + "|" + tA + ")",
                        tD = "(?:" + tE + "(?:d|ll|m|re|s|t|ve))?",
                        tB = "(?:" + tE + "(?:D|LL|M|RE|S|T|VE))?",
                        tU = "(?:" + tS + "|" + tP + ")?",
                        tL = "[" + tb + "]?",
                        tM = "(?:" + tT + "(?:" + [tC, tk, tN].join("|") + ")" + tL + tU + ")*",
                        tj = tL + tU + tM,
                        tq = "(?:" + ["[" + ty + "]", tk, tN].join("|") + ")" + tj,
                        t$ = "(?:" + [tC + tS + "?", tS, tk, tN, "[" + tp + "]"].join("|") + ")",
                        tz = RegExp(tE, "g"),
                        tH = RegExp(tS, "g"),
                        tF = RegExp(tP + "(?=" + tP + ")|" + t$ + tj, "g"),
                        tW = RegExp([tO + "?" + tx + "+" + tD + "(?=" + [tI, tO, "$"].join("|") + ")", "(?:" + tO + "|" + tA + ")+" + tB + "(?=" + [tI, tO + tR, "$"].join("|") + ")", tO + "?" + tR + "+" + tD, tO + "+" + tB, "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", "\\d+", tq].join("|"), "g"),
                        tV = RegExp("[" + tT + tp + tg + tb + "]"),
                        tK = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,
                        tG = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"],
                        tJ = -1,
                        tY = {};
                    tY[eN] = tY[eO] = tY[eT] = tY[eR] = tY[eD] = tY[eB] = tY[eU] = tY[eL] = tY[eM] = !0, tY[ed] = tY[eh] = tY[eC] = tY[ef] = tY[ek] = tY[ep] = tY[eg] = tY[ey] = tY[e_] = tY[eb] = tY[ew] = tY[eI] = tY[eS] = tY[ex] = tY[eP] = !1;
                    var tZ = {};
                    tZ[ed] = tZ[eh] = tZ[eC] = tZ[ek] = tZ[ef] = tZ[ep] = tZ[eN] = tZ[eO] = tZ[eT] = tZ[eR] = tZ[eD] = tZ[e_] = tZ[eb] = tZ[ew] = tZ[eI] = tZ[eS] = tZ[ex] = tZ[eA] = tZ[eB] = tZ[eU] = tZ[eL] = tZ[eM] = !0, tZ[eg] = tZ[ey] = tZ[eP] = !1;
                    var tX = {
                            "\\": "\\",
                            "'": "'",
                            "\n": "n",
                            "\r": "r",
                            "\u2028": "u2028",
                            "\u2029": "u2029"
                        },
                        tQ = parseFloat,
                        t0 = parseInt,
                        t1 = "object" == typeof o_ && o_ && o_.Object === Object && o_,
                        t2 = "object" == typeof self && self && self.Object === Object && self,
                        t3 = t1 || t2 || Function("return this")(),
                        t5 = l && !l.nodeType && l,
                        t6 = t5 && r && !r.nodeType && r,
                        t8 = t6 && t6.exports === t5,
                        t4 = t8 && t1.process,
                        t9 = function() {
                            try {
                                return t6 && t6.require && t6.require("util").types || t4 && t4.binding && t4.binding("util")
                            } catch {}
                        }(),
                        t7 = t9 && t9.isArrayBuffer,
                        ro = t9 && t9.isDate,
                        rs = t9 && t9.isMap,
                        ra = t9 && t9.isRegExp,
                        rl = t9 && t9.isSet,
                        rc = t9 && t9.isTypedArray;

                    function cn(r, l, C) {
                        switch (C.length) {
                            case 0:
                                return r.call(l);
                            case 1:
                                return r.call(l, C[0]);
                            case 2:
                                return r.call(l, C[0], C[1]);
                            case 3:
                                return r.call(l, C[0], C[1], C[2])
                        }
                        return r.apply(l, C)
                    }

                    function Vo(r, l, C, U) {
                        for (var et = -1, eo = null == r ? 0 : r.length; ++et < eo;) {
                            var es = r[et];
                            l(U, es, C(es), r)
                        }
                        return U
                    }

                    function mn(r, l) {
                        for (var C = -1, U = null == r ? 0 : r.length; ++C < U && !1 !== l(r[C], C, r););
                        return r
                    }

                    function As(r, l) {
                        for (var C = -1, U = null == r ? 0 : r.length; ++C < U;)
                            if (!l(r[C], C, r)) return !1;
                        return !0
                    }

                    function jn(r, l) {
                        for (var C = -1, U = null == r ? 0 : r.length, et = 0, eo = []; ++C < U;) {
                            var es = r[C];
                            l(es, C, r) && (eo[et++] = es)
                        }
                        return eo
                    }

                    function Ee(r, l) {
                        return !!(null == r ? 0 : r.length) && Tt(r, l, 0) > -1
                    }

                    function Dr(r, l, C) {
                        for (var U = -1, et = null == r ? 0 : r.length; ++U < et;)
                            if (C(l, r[U])) return !0;
                        return !1
                    }

                    function G(r, l) {
                        for (var C = -1, U = null == r ? 0 : r.length, et = Array(U); ++C < U;) et[C] = l(r[C], C, r);
                        return et
                    }

                    function nt(r, l) {
                        for (var C = -1, U = l.length, et = r.length; ++C < U;) r[et + C] = l[C];
                        return r
                    }

                    function Hr(r, l, C, U) {
                        var et = -1,
                            eo = null == r ? 0 : r.length;
                        for (U && eo && (C = r[++et]); ++et < eo;) C = l(C, r[et], et, r);
                        return C
                    }

                    function jo(r, l, C, U) {
                        var et = null == r ? 0 : r.length;
                        for (U && et && (C = r[--et]); et--;) C = l(C, r[et], et, r);
                        return C
                    }

                    function Nr(r, l) {
                        for (var C = -1, U = null == r ? 0 : r.length; ++C < U;)
                            if (l(r[C], C, r)) return !0;
                        return !1
                    }
                    var rd = $r("length");

                    function Cs(r, l, C) {
                        var U;
                        return C(r, function(r, C, et) {
                            if (l(r, C, et)) return U = C, !1
                        }), U
                    }

                    function ye(r, l, C, U) {
                        for (var et = r.length, eo = C + (U ? 1 : -1); U ? eo-- : ++eo < et;)
                            if (l(r[eo], eo, r)) return eo;
                        return -1
                    }

                    function Tt(r, l, C) {
                        return l == l ? function(r, l, C) {
                            for (var U = C - 1, et = r.length; ++U < et;)
                                if (r[U] === l) return U;
                            return -1
                        }(r, l, C) : ye(r, Is, C)
                    }

                    function rf(r, l, C, U) {
                        for (var et = C - 1, eo = r.length; ++et < eo;)
                            if (U(r[et], l)) return et;
                        return -1
                    }

                    function Is(r) {
                        return r != r
                    }

                    function xs(r, l) {
                        var C = null == r ? 0 : r.length;
                        return C ? Wr(r, l) / C : el
                    }

                    function $r(r) {
                        return function(l) {
                            return null == l ? C : l[r]
                        }
                    }

                    function Ur(r) {
                        return function(l) {
                            return null == r ? C : r[l]
                        }
                    }

                    function Es(r, l, C, U, et) {
                        return et(r, function(r, et, eo) {
                            C = U ? (U = !1, r) : l(C, r, et, eo)
                        }), C
                    }

                    function Wr(r, l) {
                        for (var U, et = -1, eo = r.length; ++et < eo;) {
                            var es = l(r[et]);
                            es !== C && (U = U === C ? es : U + es)
                        }
                        return U
                    }

                    function Fr(r, l) {
                        for (var C = -1, U = Array(r); ++C < r;) U[C] = l(C);
                        return U
                    }

                    function ys(r) {
                        return r && r.slice(0, bs(r) + 1).replace(e1, "")
                    }

                    function hn(r) {
                        return function(l) {
                            return r(l)
                        }
                    }

                    function Mr(r, l) {
                        return G(l, function(l) {
                            return r[l]
                        })
                    }

                    function jt(r, l) {
                        return r.has(l)
                    }

                    function Ss(r, l) {
                        for (var C = -1, U = r.length; ++C < U && Tt(l, r[C], 0) > -1;);
                        return C
                    }

                    function Os(r, l) {
                        for (var C = r.length; C-- && Tt(l, r[C], 0) > -1;);
                        return C
                    }
                    var rh = Ur({
                            : "A",
                            : "A",
                            : "A",
                            : "A",
                            : "A",
                            : "A",
                            : "a",
                            : "a",
                            : "a",
                            : "a",
                            : "a",
                            : "a",
                            : "C",
                            : "c",
                            : "D",
                            : "d",
                            : "E",
                            : "E",
                            : "E",
                            : "E",
                            : "e",
                            : "e",
                            : "e",
                            : "e",
                            : "I",
                            : "I",
                            : "I",
                            : "I",
                            : "i",
                            : "i",
                            : "i",
                            : "i",
                            : "N",
                            : "n",
                            : "O",
                            : "O",
                            : "O",
                            : "O",
                            : "O",
                            : "O",
                            : "o",
                            : "o",
                            : "o",
                            : "o",
                            : "o",
                            : "o",
                            : "U",
                            : "U",
                            : "U",
                            : "U",
                            : "u",
                            : "u",
                            : "u",
                            : "u",
                            : "Y",
                            : "y",
                            : "y",
                            : "Ae",
                            : "ae",
                            : "Th",
                            : "th",
                            : "ss",
                            : "A",
                            : "A",
                            : "A",
                            : "a",
                            : "a",
                            : "a",
                            : "C",
                            : "C",
                            : "C",
                            : "C",
                            : "c",
                            : "c",
                            : "c",
                            : "c",
                            : "D",
                            : "D",
                            : "d",
                            : "d",
                            : "E",
                            : "E",
                            : "E",
                            : "E",
                            : "E",
                            : "e",
                            : "e",
                            : "e",
                            : "e",
                            : "e",
                            : "G",
                            : "G",
                            : "G",
                            : "G",
                            : "g",
                            : "g",
                            : "g",
                            : "g",
                            : "H",
                            : "H",
                            : "h",
                            : "h",
                            : "I",
                            : "I",
                            : "I",
                            : "I",
                            : "I",
                            : "i",
                            : "i",
                            : "i",
                            : "i",
                            : "i",
                            : "J",
                            : "j",
                            : "K",
                            : "k",
                            : "k",
                            : "L",
                            : "L",
                            : "L",
                            : "L",
                            : "L",
                            : "l",
                            : "l",
                            : "l",
                            : "l",
                            : "l",
                            : "N",
                            : "N",
                            : "N",
                            : "N",
                            : "n",
                            : "n",
                            : "n",
                            : "n",
                            : "O",
                            : "O",
                            : "O",
                            : "o",
                            : "o",
                            : "o",
                            : "R",
                            : "R",
                            : "R",
                            : "r",
                            : "r",
                            : "r",
                            : "S",
                            : "S",
                            : "S",
                            : "S",
                            : "s",
                            : "s",
                            : "s",
                            : "s",
                            : "T",
                            : "T",
                            : "T",
                            : "t",
                            : "t",
                            : "t",
                            : "U",
                            : "U",
                            : "U",
                            : "U",
                            : "U",
                            : "U",
                            : "u",
                            : "u",
                            : "u",
                            : "u",
                            : "u",
                            : "u",
                            : "W",
                            : "w",
                            : "Y",
                            : "y",
                            : "Y",
                            : "Z",
                            : "Z",
                            : "Z",
                            : "z",
                            : "z",
                            : "z",
                            : "IJ",
                            : "ij",
                            : "Oe",
                            : "oe",
                            : "'n",
                            : "s"
                        }),
                        rp = Ur({
                            "&": "&amp;",
                            "<": "&lt;",
                            ">": "&gt;",
                            '"': "&quot;",
                            "'": "&#39;"
                        });

                    function cf(r) {
                        return "\\" + tX[r]
                    }

                    function Lt(r) {
                        return tV.test(r)
                    }

                    function qr(r) {
                        var l = -1,
                            C = Array(r.size);
                        return r.forEach(function(r, U) {
                            C[++l] = [U, r]
                        }), C
                    }

                    function Rs(r, l) {
                        return function(C) {
                            return r(l(C))
                        }
                    }

                    function tt(r, l) {
                        for (var C = -1, U = r.length, et = 0, es = []; ++C < U;) {
                            var el = r[C];
                            (el === l || el === eo) && (r[C] = eo, es[et++] = C)
                        }
                        return es
                    }

                    function Se(r) {
                        var l = -1,
                            C = Array(r.size);
                        return r.forEach(function(r) {
                            C[++l] = r
                        }), C
                    }

                    function Dt(r) {
                        return Lt(r) ? function(r) {
                            for (var l = tF.lastIndex = 0; tF.test(r);) ++l;
                            return l
                        }(r) : rd(r)
                    }

                    function On(r) {
                        return Lt(r) ? r.match(tF) || [] : r.split("")
                    }

                    function bs(r) {
                        for (var l = r.length; l-- && e2.test(r.charAt(l)););
                        return l
                    }
                    var rg = Ur({
                            "&amp;": "&",
                            "&lt;": "<",
                            "&gt;": ">",
                            "&quot;": '"',
                            "&#39;": "'"
                        }),
                        ry = function h(r) {
                            var l, e2, tp, tg, ty = (r = null == r ? t3 : ry.defaults(t3.Object(), r, ry.pick(t3, tG))).Array,
                                tm = r.Date,
                                t_ = r.Error,
                                tb = r.Function,
                                tw = r.Math,
                                tE = r.Object,
                                tI = r.RegExp,
                                tS = r.String,
                                tx = r.TypeError,
                                tA = ty.prototype,
                                tP = tb.prototype,
                                tC = tE.prototype,
                                tk = r["__core-js_shared__"],
                                tN = tP.toString,
                                tO = tC.hasOwnProperty,
                                tT = 0,
                                tR = (l = /[^.]+$/.exec(tk && tk.keys && tk.keys.IE_PROTO || "")) ? "Symbol(src)_1." + l : "",
                                tD = tC.toString,
                                tB = tN.call(tE),
                                tU = t3._,
                                tL = tI("^" + tN.call(tO).replace(eQ, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
                                tM = t8 ? r.Buffer : C,
                                tj = r.Symbol,
                                tq = r.Uint8Array,
                                t$ = tM ? tM.allocUnsafe : C,
                                tF = Rs(tE.getPrototypeOf, tE),
                                tV = tE.create,
                                tX = tC.propertyIsEnumerable,
                                t1 = tA.splice,
                                t2 = tj ? tj.isConcatSpreadable : C,
                                t5 = tj ? tj.iterator : C,
                                t6 = tj ? tj.toStringTag : C,
                                t4 = function() {
                                    try {
                                        var r = mt(tE, "defineProperty");
                                        return r({}, "", {}), r
                                    } catch {}
                                }(),
                                t9 = r.clearTimeout !== t3.clearTimeout && r.clearTimeout,
                                rd = tm && tm.now !== t3.Date.now && tm.now,
                                rm = r.setTimeout !== t3.setTimeout && r.setTimeout,
                                r_ = tw.ceil,
                                rb = tw.floor,
                                rw = tE.getOwnPropertySymbols,
                                rE = tM ? tM.isBuffer : C,
                                rI = r.isFinite,
                                rS = tA.join,
                                rx = Rs(tE.keys, tE),
                                rA = tw.max,
                                rP = tw.min,
                                rC = tm.now,
                                rk = r.parseInt,
                                rN = tw.random,
                                rO = tA.reverse,
                                rT = mt(r, "DataView"),
                                rR = mt(r, "Map"),
                                rD = mt(r, "Promise"),
                                rB = mt(r, "Set"),
                                rU = mt(r, "WeakMap"),
                                rL = mt(tE, "create"),
                                rM = rU && new rU,
                                rj = {},
                                rq = wt(rT),
                                r$ = wt(rR),
                                rz = wt(rD),
                                rH = wt(rB),
                                rF = wt(rU),
                                rW = tj ? tj.prototype : C,
                                rV = rW ? rW.valueOf : C,
                                rK = rW ? rW.toString : C;

                            function a(r) {
                                if (Y(r) && !nK(r) && !(r instanceof H)) {
                                    if (r instanceof Pn) return r;
                                    if (tO.call(r, "__wrapped__")) return Fu(r)
                                }
                                return new Pn(r)
                            }
                            var rG = function() {
                                function n() {}
                                return function(r) {
                                    if (!K(r)) return {};
                                    if (tV) return tV(r);
                                    n.prototype = r;
                                    var l = new n;
                                    return n.prototype = C, l
                                }
                            }();

                            function qe() {}

                            function Pn(r, l) {
                                this.__wrapped__ = r, this.__actions__ = [], this.__chain__ = !!l, this.__index__ = 0, this.__values__ = C
                            }

                            function H(r) {
                                this.__wrapped__ = r, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = 4294967295, this.__views__ = []
                            }

                            function dt(r) {
                                var l = -1,
                                    C = null == r ? 0 : r.length;
                                for (this.clear(); ++l < C;) {
                                    var U = r[l];
                                    this.set(U[0], U[1])
                                }
                            }

                            function Bn(r) {
                                var l = -1,
                                    C = null == r ? 0 : r.length;
                                for (this.clear(); ++l < C;) {
                                    var U = r[l];
                                    this.set(U[0], U[1])
                                }
                            }

                            function Gn(r) {
                                var l = -1,
                                    C = null == r ? 0 : r.length;
                                for (this.clear(); ++l < C;) {
                                    var U = r[l];
                                    this.set(U[0], U[1])
                                }
                            }

                            function gt(r) {
                                var l = -1,
                                    C = null == r ? 0 : r.length;
                                for (this.__data__ = new Gn; ++l < C;) this.add(r[l])
                            }

                            function Rn(r) {
                                var l = this.__data__ = new Bn(r);
                                this.size = l.size
                            }

                            function Fs(r, l) {
                                var C = nK(r),
                                    U = !C && nV(r),
                                    et = !C && !U && nJ(r),
                                    eo = !C && !U && !et && n0(r),
                                    es = C || U || et || eo,
                                    el = es ? Fr(r.length, tS) : [],
                                    ec = el.length;
                                for (var ed in r)(l || tO.call(r, ed)) && !(es && ("length" == ed || et && ("offset" == ed || "parent" == ed) || eo && ("buffer" == ed || "byteLength" == ed || "byteOffset" == ed) || Zn(ed, ec))) && el.push(ed);
                                return el
                            }

                            function Ms(r) {
                                var l = r.length;
                                return l ? r[ei(0, l - 1)] : C
                            }

                            function Yr(r, l, U) {
                                (U === C || bn(r[l], U)) && (U !== C || l in r) || zn(r, l, U)
                            }

                            function se(r, l, U) {
                                var et = r[l];
                                tO.call(r, l) && bn(et, U) && (U !== C || l in r) || zn(r, l, U)
                            }

                            function Be(r, l) {
                                for (var C = r.length; C--;)
                                    if (bn(r[C][0], l)) return C;
                                return -1
                            }

                            function gc(r, l, C, U) {
                                return rJ(r, function(r, et, eo) {
                                    l(U, r, C(r), eo)
                                }), U
                            }

                            function qs(r, l) {
                                return r && Un(l, V(l), r)
                            }

                            function zn(r, l, C) {
                                "__proto__" == l && t4 ? t4(r, l, {
                                    configurable: !0,
                                    enumerable: !0,
                                    value: C,
                                    writable: !0
                                }) : r[l] = C
                            }

                            function Zr(r, l) {
                                for (var U = -1, et = l.length, eo = ty(et), es = null == r; ++U < et;) eo[U] = es ? C : Si(r, l[U]);
                                return eo
                            }

                            function vt(r, l, U) {
                                return r == r && (U !== C && (r = r <= U ? r : U), l !== C && (r = r >= l ? r : l)), r
                            }

                            function An(r, l, U, et, eo, es) {
                                var el, ec = 1 & l,
                                    eh = 2 & l,
                                    eg = 4 & l;
                                if (U && (el = eo ? U(r, et, eo, es) : U(r)), el !== C) return el;
                                if (!K(r)) return r;
                                var eE = nK(r);
                                if (eE) {
                                    if (eP = r.length, ej = new r.constructor(eP), eP && "string" == typeof r[0] && tO.call(r, "index") && (ej.index = r.index, ej.input = r.input), el = ej, !ec) return un(r, el)
                                } else {
                                    var eP, ej, e$, ez, eH, eF = r8(r),
                                        eW = eF == ey || eF == em;
                                    if (nJ(r)) return hu(r, ec);
                                    if (eF == ew || eF == ed || eW && !eo) {
                                        if (el = eh || eW ? {} : bu(r), !ec) return eh ? (e$ = (eH = el) && Un(r, on(r), eH), Un(r, r6(r), e$)) : (ez = qs(el, r), Un(r, r5(r), ez))
                                    } else {
                                        if (!tZ[eF]) return eo ? r : {};
                                        el = function(r, l, C) {
                                            var U, et, eo = r.constructor;
                                            switch (l) {
                                                case eC:
                                                    return fi(r);
                                                case ef:
                                                case ep:
                                                    return new eo(+r);
                                                case ek:
                                                    return U = C ? fi(r.buffer) : r.buffer, new r.constructor(U, r.byteOffset, r.byteLength);
                                                case eN:
                                                case eO:
                                                case eT:
                                                case eR:
                                                case eD:
                                                case eB:
                                                case eU:
                                                case eL:
                                                case eM:
                                                    return lu(r, C);
                                                case e_:
                                                    return new eo;
                                                case eb:
                                                case ex:
                                                    return new eo(r);
                                                case eI:
                                                    return (et = new r.constructor(r.source, tn.exec(r))).lastIndex = r.lastIndex, et;
                                                case eS:
                                                    return new eo;
                                                case eA:
                                                    return rV ? tE(rV.call(r)) : {}
                                            }
                                        }(r, eF, ec)
                                    }
                                }
                                es || (es = new Rn);
                                var eV = es.get(r);
                                if (eV) return eV;
                                es.set(r, el), nQ(r) ? r.forEach(function(C) {
                                    el.add(An(C, l, U, C, r, es))
                                }) : nZ(r) && r.forEach(function(C, et) {
                                    el.set(et, An(C, l, U, et, r, es))
                                });
                                var eK = eg ? eh ? pi : li : eh ? on : V,
                                    eG = eE ? C : eK(r);
                                return mn(eG || r, function(C, et) {
                                    eG && (C = r[et = C]), se(el, et, An(C, l, U, et, r, es))
                                }), el
                            }

                            function Bs(r, l, U) {
                                var et = U.length;
                                if (null == r) return !et;
                                for (r = tE(r); et--;) {
                                    var eo = U[et],
                                        es = l[eo],
                                        el = r[eo];
                                    if (el === C && !(eo in r) || !es(el)) return !1
                                }
                                return !0
                            }

                            function Gs(r, l, et) {
                                if ("function" != typeof r) throw new tx(U);
                                return r7(function() {
                                    r.apply(C, et)
                                }, l)
                            }

                            function ue(r, l, C, U) {
                                var et = -1,
                                    eo = Ee,
                                    es = !0,
                                    el = r.length,
                                    ec = [],
                                    ed = l.length;
                                if (!el) return ec;
                                C && (l = G(l, hn(C))), U ? (eo = Dr, es = !1) : l.length >= 200 && (eo = jt, es = !1, l = new gt(l));
                                e: for (; ++et < el;) {
                                    var eh = r[et],
                                        ef = null == C ? eh : C(eh);
                                    if (eh = U || 0 !== eh ? eh : 0, es && ef == ef) {
                                        for (var ep = ed; ep--;)
                                            if (l[ep] === ef) continue e;
                                        ec.push(eh)
                                    } else eo(l, ef, U) || ec.push(eh)
                                }
                                return ec
                            }
                            a.templateSettings = {
                                escape: eK,
                                evaluate: eG,
                                interpolate: eJ,
                                variable: "",
                                imports: {
                                    _: a
                                }
                            }, a.prototype = qe.prototype, a.prototype.constructor = a, Pn.prototype = rG(qe.prototype), Pn.prototype.constructor = Pn, H.prototype = rG(qe.prototype), H.prototype.constructor = H, dt.prototype.clear = function() {
                                this.__data__ = rL ? rL(null) : {}, this.size = 0
                            }, dt.prototype.delete = function(r) {
                                var l = this.has(r) && delete this.__data__[r];
                                return this.size -= l ? 1 : 0, l
                            }, dt.prototype.get = function(r) {
                                var l = this.__data__;
                                if (rL) {
                                    var U = l[r];
                                    return U === et ? C : U
                                }
                                return tO.call(l, r) ? l[r] : C
                            }, dt.prototype.has = function(r) {
                                var l = this.__data__;
                                return rL ? l[r] !== C : tO.call(l, r)
                            }, dt.prototype.set = function(r, l) {
                                var U = this.__data__;
                                return this.size += this.has(r) ? 0 : 1, U[r] = rL && l === C ? et : l, this
                            }, Bn.prototype.clear = function() {
                                this.__data__ = [], this.size = 0
                            }, Bn.prototype.delete = function(r) {
                                var l = this.__data__,
                                    C = Be(l, r);
                                return !(C < 0) && (C == l.length - 1 ? l.pop() : t1.call(l, C, 1), --this.size, !0)
                            }, Bn.prototype.get = function(r) {
                                var l = this.__data__,
                                    U = Be(l, r);
                                return U < 0 ? C : l[U][1]
                            }, Bn.prototype.has = function(r) {
                                return Be(this.__data__, r) > -1
                            }, Bn.prototype.set = function(r, l) {
                                var C = this.__data__,
                                    U = Be(C, r);
                                return U < 0 ? (++this.size, C.push([r, l])) : C[U][1] = l, this
                            }, Gn.prototype.clear = function() {
                                this.size = 0, this.__data__ = {
                                    hash: new dt,
                                    map: new(rR || Bn),
                                    string: new dt
                                }
                            }, Gn.prototype.delete = function(r) {
                                var l = nr(this, r).delete(r);
                                return this.size -= l ? 1 : 0, l
                            }, Gn.prototype.get = function(r) {
                                return nr(this, r).get(r)
                            }, Gn.prototype.has = function(r) {
                                return nr(this, r).has(r)
                            }, Gn.prototype.set = function(r, l) {
                                var C = nr(this, r),
                                    U = C.size;
                                return C.set(r, l), this.size += C.size == U ? 0 : 1, this
                            }, gt.prototype.add = gt.prototype.push = function(r) {
                                return this.__data__.set(r, et), this
                            }, gt.prototype.has = function(r) {
                                return this.__data__.has(r)
                            }, Rn.prototype.clear = function() {
                                this.__data__ = new Bn, this.size = 0
                            }, Rn.prototype.delete = function(r) {
                                var l = this.__data__,
                                    C = l.delete(r);
                                return this.size = l.size, C
                            }, Rn.prototype.get = function(r) {
                                return this.__data__.get(r)
                            }, Rn.prototype.has = function(r) {
                                return this.__data__.has(r)
                            }, Rn.prototype.set = function(r, l) {
                                var C = this.__data__;
                                if (C instanceof Bn) {
                                    var U = C.__data__;
                                    if (!rR || U.length < 199) return U.push([r, l]), this.size = ++C.size, this;
                                    C = this.__data__ = new Gn(U)
                                }
                                return C.set(r, l), this.size = C.size, this
                            };
                            var rJ = vu($n),
                                rY = vu(Xr, !0);

                            function mc(r, l) {
                                var C = !0;
                                return rJ(r, function(r, U, et) {
                                    return C = !!l(r, U, et)
                                }), C
                            }

                            function Ge(r, l, U) {
                                for (var et = -1, eo = r.length; ++et < eo;) {
                                    var es = r[et],
                                        el = l(es);
                                    if (null != el && (ec === C ? el == el && !pn(el) : U(el, ec))) var ec = el,
                                        ed = es
                                }
                                return ed
                            }

                            function Ks(r, l) {
                                var C = [];
                                return rJ(r, function(r, U, et) {
                                    l(r, U, et) && C.push(r)
                                }), C
                            }

                            function j(r, l, C, U, et) {
                                var eo = -1,
                                    es = r.length;
                                for (C || (C = ah), et || (et = []); ++eo < es;) {
                                    var el = r[eo];
                                    l > 0 && C(el) ? l > 1 ? j(el, l - 1, C, U, et) : nt(et, el) : U || (et[et.length] = el)
                                }
                                return et
                            }
                            var rZ = _u(),
                                rX = _u(!0);

                            function $n(r, l) {
                                return r && rZ(r, l, V)
                            }

                            function Xr(r, l) {
                                return r && rX(r, l, V)
                            }

                            function ze(r, l) {
                                return jn(l, function(l) {
                                    return Jn(r[l])
                                })
                            }

                            function _t(r, l) {
                                l = st(l, r);
                                for (var U = 0, et = l.length; null != r && U < et;) r = r[Wn(l[U++])];
                                return U && U == et ? r : C
                            }

                            function Zs(r, l, C) {
                                var U = l(r);
                                return nK(r) ? U : nt(U, C(r))
                            }

                            function en(r) {
                                return null == r ? r === C ? "[object Undefined]" : "[object Null]" : t6 && t6 in tE(r) ? function(r) {
                                    var l = tO.call(r, t6),
                                        U = r[t6];
                                    try {
                                        r[t6] = C;
                                        var et = !0
                                    } catch {}
                                    var eo = tD.call(r);
                                    return et && (l ? r[t6] = U : delete r[t6]), eo
                                }(r) : tD.call(r)
                            }

                            function Qr(r, l) {
                                return r > l
                            }

                            function Pc(r, l) {
                                return null != r && tO.call(r, l)
                            }

                            function Ac(r, l) {
                                return null != r && l in tE(r)
                            }

                            function Vr(r, l, U) {
                                for (var et = U ? Dr : Ee, eo = r[0].length, es = r.length, el = es, ec = ty(es), ed = 1 / 0, eh = []; el--;) {
                                    var ef = r[el];
                                    el && l && (ef = G(ef, hn(l))), ed = rP(ef.length, ed), ec[el] = !U && (l || eo >= 120 && ef.length >= 120) ? new gt(el && ef) : C
                                }
                                ef = r[0];
                                var ep = -1,
                                    eg = ec[0];
                                e: for (; ++ep < eo && eh.length < ed;) {
                                    var ey = ef[ep],
                                        em = l ? l(ey) : ey;
                                    if (ey = U || 0 !== ey ? ey : 0, !(eg ? jt(eg, em) : et(eh, em, U))) {
                                        for (el = es; --el;) {
                                            var e_ = ec[el];
                                            if (!(e_ ? jt(e_, em) : et(r[el], em, U))) continue e
                                        }
                                        eg && eg.push(em), eh.push(ey)
                                    }
                                }
                                return eh
                            }

                            function ae(r, l, U) {
                                l = st(l, r);
                                var et = null == (r = Hu(r, l)) ? r : r[Wn(In(l))];
                                return null == et ? C : cn(et, r, U)
                            }

                            function Js(r) {
                                return Y(r) && en(r) == ed
                            }

                            function oe(r, l, U, et, eo) {
                                return r === l || (null != r && null != l && (Y(r) || Y(l)) ? function(r, l, U, et, eo, es) {
                                    var el = nK(r),
                                        ec = nK(l),
                                        ey = el ? eh : r8(r),
                                        em = ec ? eh : r8(l);
                                    ey = ey == ed ? ew : ey, em = em == ed ? ew : em;
                                    var eE = ey == ew,
                                        eP = em == ew,
                                        eN = ey == em;
                                    if (eN && nJ(r)) {
                                        if (!nJ(l)) return !1;
                                        el = !0, eE = !1
                                    }
                                    if (eN && !eE) return es || (es = new Rn), el || n0(r) ? Su(r, l, U, et, eo, es) : function(r, l, C, U, et, eo, es) {
                                        switch (C) {
                                            case ek:
                                                if (r.byteLength != l.byteLength || r.byteOffset != l.byteOffset) break;
                                                r = r.buffer, l = l.buffer;
                                            case eC:
                                                return !(r.byteLength != l.byteLength || !eo(new tq(r), new tq(l)));
                                            case ef:
                                            case ep:
                                            case eb:
                                                return bn(+r, +l);
                                            case eg:
                                                return r.name == l.name && r.message == l.message;
                                            case eI:
                                            case ex:
                                                return r == l + "";
                                            case e_:
                                                var el = qr;
                                            case eS:
                                                var ec = 1 & U;
                                                if (el || (el = Se), r.size != l.size && !ec) break;
                                                var ed = es.get(r);
                                                if (ed) return ed == l;
                                                U |= 2, es.set(r, l);
                                                var eh = Su(el(r), el(l), U, et, eo, es);
                                                return es.delete(r), eh;
                                            case eA:
                                                if (rV) return rV.call(r) == rV.call(l)
                                        }
                                        return !1
                                    }(r, l, ey, U, et, eo, es);
                                    if (!(1 & U)) {
                                        var eO = eE && tO.call(r, "__wrapped__"),
                                            eT = eP && tO.call(l, "__wrapped__");
                                        if (eO || eT) {
                                            var eR = eO ? r.value() : r,
                                                eD = eT ? l.value() : l;
                                            return es || (es = new Rn), eo(eR, eD, U, et, es)
                                        }
                                    }
                                    return !!eN && (es || (es = new Rn), function(r, l, U, et, eo, es) {
                                        var el = 1 & U,
                                            ec = li(r),
                                            ed = ec.length;
                                        if (ed != li(l).length && !el) return !1;
                                        for (var eh = ed; eh--;) {
                                            var ef = ec[eh];
                                            if (!(el ? ef in l : tO.call(l, ef))) return !1
                                        }
                                        var ep = es.get(r),
                                            eg = es.get(l);
                                        if (ep && eg) return ep == l && eg == r;
                                        var ey = !0;
                                        es.set(r, l), es.set(l, r);
                                        for (var em = el; ++eh < ed;) {
                                            var e_ = r[ef = ec[eh]],
                                                eb = l[ef];
                                            if (et) var ew = el ? et(eb, e_, ef, l, r, es) : et(e_, eb, ef, r, l, es);
                                            if (!(ew === C ? e_ === eb || eo(e_, eb, U, et, es) : ew)) {
                                                ey = !1;
                                                break
                                            }
                                            em || (em = "constructor" == ef)
                                        }
                                        if (ey && !em) {
                                            var eE = r.constructor,
                                                eI = l.constructor;
                                            eE != eI && "constructor" in r && "constructor" in l && !("function" == typeof eE && eE instanceof eE && "function" == typeof eI && eI instanceof eI) && (ey = !1)
                                        }
                                        return es.delete(r), es.delete(l), ey
                                    }(r, l, U, et, eo, es))
                                }(r, l, U, et, oe, eo) : r != r && l != l)
                            }

                            function kr(r, l, U, et) {
                                var eo = U.length,
                                    es = eo,
                                    el = !et;
                                if (null == r) return !es;
                                for (r = tE(r); eo--;) {
                                    var ec = U[eo];
                                    if (el && ec[2] ? ec[1] !== r[ec[0]] : !(ec[0] in r)) return !1
                                }
                                for (; ++eo < es;) {
                                    var ed = (ec = U[eo])[0],
                                        eh = r[ed],
                                        ef = ec[1];
                                    if (el && ec[2]) {
                                        if (eh === C && !(ed in r)) return !1
                                    } else {
                                        var ep = new Rn;
                                        if (et) var eg = et(eh, ef, ed, r, l, ep);
                                        if (!(eg === C ? oe(ef, eh, 3, et, ep) : eg)) return !1
                                    }
                                }
                                return !0
                            }

                            function Xs(r) {
                                return !(!K(r) || tR && tR in r) && (Jn(r) ? tL : ta).test(wt(r))
                            }

                            function Qs(r) {
                                return "function" == typeof r ? r : null == r ? fn : "object" == typeof r ? nK(r) ? js(r[0], r[1]) : ks(r) : ma(r)
                            }

                            function jr(r) {
                                if (!he(r)) return rx(r);
                                var l = [];
                                for (var C in tE(r)) tO.call(r, C) && "constructor" != C && l.push(C);
                                return l
                            }

                            function ni(r, l) {
                                return r < l
                            }

                            function Vs(r, l) {
                                var C = -1,
                                    U = an(r) ? ty(r.length) : [];
                                return rJ(r, function(r, et, eo) {
                                    U[++C] = l(r, et, eo)
                                }), U
                            }

                            function ks(r) {
                                var l = gi(r);
                                return 1 == l.length && l[0][2] ? Lu(l[0][0], l[0][1]) : function(C) {
                                    return C === r || kr(C, r, l)
                                }
                            }

                            function js(r, l) {
                                var U;
                                return _i(r) && (U = l) == U && !K(U) ? Lu(Wn(r), l) : function(U) {
                                    var et = Si(U, r);
                                    return et === C && et === l ? Oi(U, r) : oe(l, et, 3)
                                }
                            }

                            function Ke(r, l, U, et, eo) {
                                r !== l && rZ(l, function(es, el) {
                                    if (eo || (eo = new Rn), K(es)) ! function(r, l, U, et, eo, es, el) {
                                        var ec = wi(r, U),
                                            ed = wi(l, U),
                                            eh = el.get(ed);
                                        if (eh) {
                                            Yr(r, U, eh);
                                            return
                                        }
                                        var ef = es ? es(ec, ed, U + "", r, l, el) : C,
                                            ep = ef === C;
                                        if (ep) {
                                            var eg = nK(ed),
                                                ey = !eg && nJ(ed),
                                                em = !eg && !ey && n0(ed);
                                            ef = ed, eg || ey || em ? nK(ec) ? ef = ec : Z(ec) ? ef = un(ec) : ey ? (ep = !1, ef = hu(ed, !0)) : em ? (ep = !1, ef = lu(ed, !0)) : ef = [] : pe(ed) || nV(ed) ? (ef = ec, nV(ec) ? ef = oa(ec) : (!K(ec) || Jn(ec)) && (ef = bu(ed))) : ep = !1
                                        }
                                        ep && (el.set(ed, ef), eo(ef, ed, et, es, el), el.delete(ed)), Yr(r, U, ef)
                                    }(r, l, el, U, Ke, et, eo);
                                    else {
                                        var ec = et ? et(wi(r, el), es, el + "", r, l, eo) : C;
                                        ec === C && (ec = es), Yr(r, el, ec)
                                    }
                                }, on)
                            }

                            function nu(r, l) {
                                var U = r.length;
                                if (U) return Zn(l += l < 0 ? U : 0, U) ? r[l] : C
                            }

                            function tu(r, l, C) {
                                l = l.length ? G(l, function(r) {
                                    return nK(r) ? function(l) {
                                        return _t(l, 1 === r.length ? r[0] : r)
                                    } : r
                                }) : [fn];
                                var U = -1;
                                return l = G(l, hn(x())),
                                    function(r, l) {
                                        var C = r.length;
                                        for (r.sort(l); C--;) r[C] = r[C].value;
                                        return r
                                    }(Vs(r, function(r, C, et) {
                                        return {
                                            criteria: G(l, function(l) {
                                                return l(r)
                                            }),
                                            index: ++U,
                                            value: r
                                        }
                                    }), function(r, l) {
                                        return function(r, l, C) {
                                            for (var U = -1, et = r.criteria, eo = l.criteria, es = et.length, el = C.length; ++U < es;) {
                                                var ec = pu(et[U], eo[U]);
                                                if (ec) {
                                                    if (U >= el) return ec;
                                                    return ec * ("desc" == C[U] ? -1 : 1)
                                                }
                                            }
                                            return r.index - l.index
                                        }(r, l, C)
                                    })
                            }

                            function eu(r, l, C) {
                                for (var U = -1, et = l.length, eo = {}; ++U < et;) {
                                    var es = l[U],
                                        el = _t(r, es);
                                    C(el, es) && fe(eo, st(es, r), el)
                                }
                                return eo
                            }

                            function ti(r, l, C, U) {
                                var et = U ? rf : Tt,
                                    eo = -1,
                                    es = l.length,
                                    el = r;
                                for (r === l && (l = un(l)), C && (el = G(r, hn(C))); ++eo < es;)
                                    for (var ec = 0, ed = l[eo], eh = C ? C(ed) : ed;
                                        (ec = et(el, eh, ec, U)) > -1;) el !== r && t1.call(el, ec, 1), t1.call(r, ec, 1);
                                return r
                            }

                            function ru(r, l) {
                                for (var C = r ? l.length : 0, U = C - 1; C--;) {
                                    var et = l[C];
                                    if (C == U || et !== eo) {
                                        var eo = et;
                                        Zn(et) ? t1.call(r, et, 1) : si(r, et)
                                    }
                                }
                                return r
                            }

                            function ei(r, l) {
                                return r + rb(rN() * (l - r + 1))
                            }

                            function ri(r, l) {
                                var C = "";
                                if (!r || l < 1 || l > 9007199254740991) return C;
                                do l % 2 && (C += r), (l = rb(l / 2)) && (r += r); while (l);
                                return C
                            }

                            function L(r, l) {
                                return nn(Du(r, l, fn), r + "")
                            }

                            function fe(r, l, U, et) {
                                if (!K(r)) return r;
                                l = st(l, r);
                                for (var eo = -1, es = l.length, el = es - 1, ec = r; null != ec && ++eo < es;) {
                                    var ed = Wn(l[eo]),
                                        eh = U;
                                    if ("__proto__" === ed || "constructor" === ed || "prototype" === ed) break;
                                    if (eo != el) {
                                        var ef = ec[ed];
                                        (eh = et ? et(ef, ed, ec) : C) === C && (eh = K(ef) ? ef : Zn(l[eo + 1]) ? [] : {})
                                    }
                                    se(ec, ed, eh), ec = ec[ed]
                                }
                                return r
                            }
                            var rQ = rM ? function(r, l) {
                                    return rM.set(r, l), r
                                } : fn,
                                r0 = t4 ? function(r, l) {
                                    return t4(r, "toString", {
                                        configurable: !0,
                                        enumerable: !1,
                                        value: bi(l),
                                        writable: !0
                                    })
                                } : fn;

                            function Cn(r, l, C) {
                                var U = -1,
                                    et = r.length;
                                l < 0 && (l = -l > et ? 0 : et + l), (C = C > et ? et : C) < 0 && (C += et), et = l > C ? 0 : C - l >>> 0, l >>>= 0;
                                for (var eo = ty(et); ++U < et;) eo[U] = r[U + l];
                                return eo
                            }

                            function Mc(r, l) {
                                var C;
                                return rJ(r, function(r, U, et) {
                                    return !(C = l(r, U, et))
                                }), !!C
                            }

                            function Ye(r, l, C) {
                                var U = 0,
                                    et = null == r ? U : r.length;
                                if ("number" == typeof l && l == l && et <= 2147483647) {
                                    for (; U < et;) {
                                        var eo = U + et >>> 1,
                                            es = r[eo];
                                        null !== es && !pn(es) && (C ? es <= l : es < l) ? U = eo + 1 : et = eo
                                    }
                                    return et
                                }
                                return ii(r, l, fn, C)
                            }

                            function ii(r, l, U, et) {
                                var eo = 0,
                                    es = null == r ? 0 : r.length;
                                if (0 === es) return 0;
                                l = U(l);
                                for (var el = l != l, ec = null === l, ed = pn(l), eh = l === C; eo < es;) {
                                    var ef = rb((eo + es) / 2),
                                        ep = U(r[ef]),
                                        eg = ep !== C,
                                        ey = null === ep,
                                        em = ep == ep,
                                        e_ = pn(ep);
                                    if (el) var eb = et || em;
                                    else eb = eh ? em && (et || eg) : ec ? em && eg && (et || !ey) : ed ? em && eg && !ey && (et || !e_) : !ey && !e_ && (et ? ep <= l : ep < l);
                                    eb ? eo = ef + 1 : es = ef
                                }
                                return rP(es, 4294967294)
                            }

                            function su(r, l) {
                                for (var C = -1, U = r.length, et = 0, eo = []; ++C < U;) {
                                    var es = r[C],
                                        el = l ? l(es) : es;
                                    if (!C || !bn(el, ec)) {
                                        var ec = el;
                                        eo[et++] = 0 === es ? 0 : es
                                    }
                                }
                                return eo
                            }

                            function uu(r) {
                                return "number" == typeof r ? r : pn(r) ? el : +r
                            }

                            function ln(r) {
                                if ("string" == typeof r) return r;
                                if (nK(r)) return G(r, ln) + "";
                                if (pn(r)) return rK ? rK.call(r) : "";
                                var l = r + "";
                                return "0" == l && 1 / r == -es ? "-0" : l
                            }

                            function it(r, l, C) {
                                var U = -1,
                                    et = Ee,
                                    eo = r.length,
                                    es = !0,
                                    el = [],
                                    ec = el;
                                if (C) es = !1, et = Dr;
                                else if (eo >= 200) {
                                    var ed = l ? null : r2(r);
                                    if (ed) return Se(ed);
                                    es = !1, et = jt, ec = new gt
                                } else ec = l ? [] : el;
                                e: for (; ++U < eo;) {
                                    var eh = r[U],
                                        ef = l ? l(eh) : eh;
                                    if (eh = C || 0 !== eh ? eh : 0, es && ef == ef) {
                                        for (var ep = ec.length; ep--;)
                                            if (ec[ep] === ef) continue e;
                                        l && ec.push(ef), el.push(eh)
                                    } else et(ec, ef, C) || (ec !== el && ec.push(ef), el.push(eh))
                                }
                                return el
                            }

                            function si(r, l) {
                                return l = st(l, r), null == (r = Hu(r, l)) || delete r[Wn(In(l))]
                            }

                            function au(r, l, C, U) {
                                return fe(r, l, C(_t(r, l)), U)
                            }

                            function Ze(r, l, C, U) {
                                for (var et = r.length, eo = U ? et : -1;
                                    (U ? eo-- : ++eo < et) && l(r[eo], eo, r););
                                return C ? Cn(r, U ? 0 : eo, U ? eo + 1 : et) : Cn(r, U ? eo + 1 : 0, U ? et : eo)
                            }

                            function ou(r, l) {
                                var C = r;
                                return C instanceof H && (C = C.value()), Hr(l, function(r, l) {
                                    return l.func.apply(l.thisArg, nt([r], l.args))
                                }, C)
                            }

                            function ui(r, l, C) {
                                var U = r.length;
                                if (U < 2) return U ? it(r[0]) : [];
                                for (var et = -1, eo = ty(U); ++et < U;)
                                    for (var es = r[et], el = -1; ++el < U;) el != et && (eo[et] = ue(eo[et] || es, r[el], l, C));
                                return it(j(eo, 1), l, C)
                            }

                            function fu(r, l, U) {
                                for (var et = -1, eo = r.length, es = l.length, el = {}; ++et < eo;) {
                                    var ec = et < es ? l[et] : C;
                                    U(el, r[et], ec)
                                }
                                return el
                            }

                            function ai(r) {
                                return Z(r) ? r : []
                            }

                            function oi(r) {
                                return "function" == typeof r ? r : fn
                            }

                            function st(r, l) {
                                return nK(r) ? r : _i(r, l) ? [r] : no(W(r))
                            }

                            function ut(r, l, U) {
                                var et = r.length;
                                return U = U === C ? et : U, !l && U >= et ? r : Cn(r, l, U)
                            }
                            var r1 = t9 || function(r) {
                                return t3.clearTimeout(r)
                            };

                            function hu(r, l) {
                                if (l) return r.slice();
                                var C = r.length,
                                    U = t$ ? t$(C) : new r.constructor(C);
                                return r.copy(U), U
                            }

                            function fi(r) {
                                var l = new r.constructor(r.byteLength);
                                return new tq(l).set(new tq(r)), l
                            }

                            function lu(r, l) {
                                var C = l ? fi(r.buffer) : r.buffer;
                                return new r.constructor(C, r.byteOffset, r.length)
                            }

                            function pu(r, l) {
                                if (r !== l) {
                                    var U = r !== C,
                                        et = null === r,
                                        eo = r == r,
                                        es = pn(r),
                                        el = l !== C,
                                        ec = null === l,
                                        ed = l == l,
                                        eh = pn(l);
                                    if (!ec && !eh && !es && r > l || es && el && ed && !ec && !eh || et && el && ed || !U && ed || !eo) return 1;
                                    if (!et && !es && !eh && r < l || eh && U && eo && !et && !es || ec && U && eo || !el && eo || !ed) return -1
                                }
                                return 0
                            }

                            function du(r, l, C, U) {
                                for (var et = -1, eo = r.length, es = C.length, el = -1, ec = l.length, ed = rA(eo - es, 0), eh = ty(ec + ed), ef = !U; ++el < ec;) eh[el] = l[el];
                                for (; ++et < es;)(ef || et < eo) && (eh[C[et]] = r[et]);
                                for (; ed--;) eh[el++] = r[et++];
                                return eh
                            }

                            function gu(r, l, C, U) {
                                for (var et = -1, eo = r.length, es = -1, el = C.length, ec = -1, ed = l.length, eh = rA(eo - el, 0), ef = ty(eh + ed), ep = !U; ++et < eh;) ef[et] = r[et];
                                for (var eg = et; ++ec < ed;) ef[eg + ec] = l[ec];
                                for (; ++es < el;)(ep || et < eo) && (ef[eg + C[es]] = r[et++]);
                                return ef
                            }

                            function un(r, l) {
                                var C = -1,
                                    U = r.length;
                                for (l || (l = ty(U)); ++C < U;) l[C] = r[C];
                                return l
                            }

                            function Un(r, l, U, et) {
                                var eo = !U;
                                U || (U = {});
                                for (var es = -1, el = l.length; ++es < el;) {
                                    var ec = l[es],
                                        ed = et ? et(U[ec], r[ec], ec, U, r) : C;
                                    ed === C && (ed = r[ec]), eo ? zn(U, ec, ed) : se(U, ec, ed)
                                }
                                return U
                            }

                            function Je(r, l) {
                                return function(C, U) {
                                    var et = nK(C) ? Vo : gc,
                                        eo = l ? l() : {};
                                    return et(C, r, x(U, 2), eo)
                                }
                            }

                            function Ft(r) {
                                return L(function(l, U) {
                                    var et = -1,
                                        eo = U.length,
                                        es = eo > 1 ? U[eo - 1] : C,
                                        el = eo > 2 ? U[2] : C;
                                    for (es = r.length > 3 && "function" == typeof es ? (eo--, es) : C, el && rn(U[0], U[1], el) && (es = eo < 3 ? C : es, eo = 1), l = tE(l); ++et < eo;) {
                                        var ec = U[et];
                                        ec && r(l, ec, et, es)
                                    }
                                    return l
                                })
                            }

                            function vu(r, l) {
                                return function(C, U) {
                                    if (null == C) return C;
                                    if (!an(C)) return r(C, U);
                                    for (var et = C.length, eo = l ? et : -1, es = tE(C);
                                        (l ? eo-- : ++eo < et) && !1 !== U(es[eo], eo, es););
                                    return C
                                }
                            }

                            function _u(r) {
                                return function(l, C, U) {
                                    for (var et = -1, eo = tE(l), es = U(l), el = es.length; el--;) {
                                        var ec = es[r ? el : ++et];
                                        if (!1 === C(eo[ec], ec, eo)) break
                                    }
                                    return l
                                }
                            }

                            function mu(r) {
                                return function(l) {
                                    var U = Lt(l = W(l)) ? On(l) : C,
                                        et = U ? U[0] : l.charAt(0),
                                        eo = U ? ut(U, 1).join("") : l.slice(1);
                                    return et[r]() + eo
                                }
                            }

                            function Mt(r) {
                                return function(l) {
                                    return Hr(va(ga(l).replace(tz, "")), r, "")
                                }
                            }

                            function ce(r) {
                                return function() {
                                    var l = arguments;
                                    switch (l.length) {
                                        case 0:
                                            return new r;
                                        case 1:
                                            return new r(l[0]);
                                        case 2:
                                            return new r(l[0], l[1]);
                                        case 3:
                                            return new r(l[0], l[1], l[2]);
                                        case 4:
                                            return new r(l[0], l[1], l[2], l[3]);
                                        case 5:
                                            return new r(l[0], l[1], l[2], l[3], l[4]);
                                        case 6:
                                            return new r(l[0], l[1], l[2], l[3], l[4], l[5]);
                                        case 7:
                                            return new r(l[0], l[1], l[2], l[3], l[4], l[5], l[6])
                                    }
                                    var C = rG(r.prototype),
                                        U = r.apply(C, l);
                                    return K(U) ? U : C
                                }
                            }

                            function wu(r) {
                                return function(l, U, et) {
                                    var eo = tE(l);
                                    if (!an(l)) {
                                        var es = x(U, 3);
                                        l = V(l), U = function(r) {
                                            return es(eo[r], r, eo)
                                        }
                                    }
                                    var el = r(l, U, et);
                                    return el > -1 ? eo[es ? l[el] : el] : C
                                }
                            }

                            function Pu(r) {
                                return Yn(function(l) {
                                    var et = l.length,
                                        eo = et,
                                        es = Pn.prototype.thru;
                                    for (r && l.reverse(); eo--;) {
                                        var el = l[eo];
                                        if ("function" != typeof el) throw new tx(U);
                                        if (es && !ec && "wrapper" == je(el)) var ec = new Pn([], !0)
                                    }
                                    for (eo = ec ? eo : et; ++eo < et;) {
                                        var ed = je(el = l[eo]),
                                            eh = "wrapper" == ed ? r3(el) : C;
                                        ec = eh && mi(eh[0]) && 424 == eh[1] && !eh[4].length && 1 == eh[9] ? ec[je(eh[0])].apply(ec, eh[3]) : 1 == el.length && mi(el) ? ec[ed]() : ec.thru(el)
                                    }
                                    return function() {
                                        var r = arguments,
                                            C = r[0];
                                        if (ec && 1 == r.length && nK(C)) return ec.plant(C).value();
                                        for (var U = 0, eo = et ? l[U].apply(this, r) : C; ++U < et;) eo = l[U].call(this, eo);
                                        return eo
                                    }
                                })
                            }

                            function Xe(r, l, U, et, eo, es, el, ec, ed, eh) {
                                var ef = 128 & l,
                                    ep = 1 & l,
                                    eg = 2 & l,
                                    ey = 24 & l,
                                    em = 512 & l,
                                    e_ = eg ? C : ce(r);
                                return function y() {
                                    for (var eb = arguments.length, ew = ty(eb), eE = eb; eE--;) ew[eE] = arguments[eE];
                                    if (ey) var eI = qt(y),
                                        eS = function(r, l) {
                                            for (var C = r.length, U = 0; C--;) r[C] === l && ++U;
                                            return U
                                        }(ew, eI);
                                    if (et && (ew = du(ew, et, eo, ey)), es && (ew = gu(ew, es, el, ey)), eb -= eS, ey && eb < eh) {
                                        var ex = tt(ew, eI);
                                        return Iu(r, l, Xe, y.placeholder, U, ew, ex, ec, ed, eh - eb)
                                    }
                                    var eA = ep ? U : this,
                                        eP = eg ? eA[r] : r;
                                    return eb = ew.length, ec ? ew = function(r, l) {
                                        for (var U = r.length, et = rP(l.length, U), eo = un(r); et--;) {
                                            var es = l[et];
                                            r[et] = Zn(es, U) ? eo[es] : C
                                        }
                                        return r
                                    }(ew, ec) : em && eb > 1 && ew.reverse(), ef && ed < eb && (ew.length = ed), this && this !== t3 && this instanceof y && (eP = e_ || ce(eP)), eP.apply(eA, ew)
                                }
                            }

                            function Au(r, l) {
                                return function(C, U) {
                                    var et, eo;
                                    return et = l(U), eo = {}, $n(C, function(l, C, U) {
                                        r(eo, et(l), C, U)
                                    }), eo
                                }
                            }

                            function Qe(r, l) {
                                return function(U, et) {
                                    var eo;
                                    if (U === C && et === C) return l;
                                    if (U !== C && (eo = U), et !== C) {
                                        if (eo === C) return et;
                                        "string" == typeof U || "string" == typeof et ? (U = ln(U), et = ln(et)) : (U = uu(U), et = uu(et)), eo = r(U, et)
                                    }
                                    return eo
                                }
                            }

                            function ci(r) {
                                return Yn(function(l) {
                                    return l = G(l, hn(x())), L(function(C) {
                                        var U = this;
                                        return r(l, function(r) {
                                            return cn(r, U, C)
                                        })
                                    })
                                })
                            }

                            function Ve(r, l) {
                                var U = (l = l === C ? " " : ln(l)).length;
                                if (U < 2) return U ? ri(l, r) : l;
                                var et = ri(l, r_(r / Dt(l)));
                                return Lt(l) ? ut(On(et), 0, r).join("") : et.slice(0, r)
                            }

                            function Cu(r) {
                                return function(l, U, et) {
                                    return et && "number" != typeof et && rn(l, U, et) && (U = et = C), l = Xn(l), U === C ? (U = l, l = 0) : U = Xn(U), et = et === C ? l < U ? 1 : -1 : Xn(et),
                                        function(r, l, C, U) {
                                            for (var et = -1, eo = rA(r_((l - r) / (C || 1)), 0), es = ty(eo); eo--;) es[U ? eo : ++et] = r, r += C;
                                            return es
                                        }(l, U, et, r)
                                }
                            }

                            function ke(r) {
                                return function(l, C) {
                                    return "string" == typeof l && "string" == typeof C || (l = xn(l), C = xn(C)), r(l, C)
                                }
                            }

                            function Iu(r, l, U, et, eo, es, el, ec, ed, eh) {
                                var ef = 8 & l,
                                    ep = ef ? el : C,
                                    eg = ef ? C : el,
                                    ey = ef ? es : C,
                                    em = ef ? C : es;
                                l |= ef ? 32 : 64, 4 & (l &= ~(ef ? 64 : 32)) || (l &= -4);
                                var e_ = [r, l, eo, ey, ep, em, eg, ec, ed, eh],
                                    eb = U.apply(C, e_);
                                return mi(r) && r9(eb, e_), eb.placeholder = et, $u(eb, r, l)
                            }

                            function hi(r) {
                                var l = tw[r];
                                return function(r, C) {
                                    if (r = xn(r), (C = null == C ? 0 : rP(R(C), 292)) && rI(r)) {
                                        var U = (W(r) + "e").split("e");
                                        return +((U = (W(l(U[0] + "e" + (+U[1] + C))) + "e").split("e"))[0] + "e" + (+U[1] - C))
                                    }
                                    return l(r)
                                }
                            }
                            var r2 = rB && 1 / Se(new rB([, -0]))[1] == es ? function(r) {
                                return new rB(r)
                            } : Di;

                            function xu(r) {
                                return function(l) {
                                    var C, U, et = r8(l);
                                    return et == e_ ? qr(l) : et == eS ? (C = -1, U = Array(l.size), l.forEach(function(r) {
                                        U[++C] = [r, r]
                                    }), U) : G(r(l), function(r) {
                                        return [r, l[r]]
                                    })
                                }
                            }

                            function Kn(r, l, et, es, el, ec, ed, eh) {
                                var ef = 2 & l;
                                if (!ef && "function" != typeof r) throw new tx(U);
                                var ep = es ? es.length : 0;
                                if (ep || (l &= -97, es = el = C), ed = ed === C ? ed : rA(R(ed), 0), eh = eh === C ? eh : R(eh), ep -= el ? el.length : 0, 64 & l) {
                                    var eg = es,
                                        ey = el;
                                    es = el = C
                                }
                                var em = ef ? C : r3(r),
                                    e_ = [r, l, et, es, el, eg, ey, ec, ed, eh];
                                if (em && function(r, l) {
                                        var C = r[1],
                                            U = l[1],
                                            et = C | U,
                                            es = et < 131,
                                            el = 128 == U && 8 == C || 128 == U && 256 == C && r[7].length <= l[8] || 384 == U && l[7].length <= l[8] && 8 == C;
                                        if (es || el) {
                                            1 & U && (r[2] = l[2], et |= 1 & C ? 0 : 4);
                                            var ec = l[3];
                                            if (ec) {
                                                var ed = r[3];
                                                r[3] = ed ? du(ed, ec, l[4]) : ec, r[4] = ed ? tt(r[3], eo) : l[4]
                                            }(ec = l[5]) && (ed = r[5], r[5] = ed ? gu(ed, ec, l[6]) : ec, r[6] = ed ? tt(r[5], eo) : l[6]), (ec = l[7]) && (r[7] = ec), 128 & U && (r[8] = null == r[8] ? l[8] : rP(r[8], l[8])), null == r[9] && (r[9] = l[9]), r[0] = l[0], r[1] = et
                                        }
                                    }(e_, em), r = e_[0], l = e_[1], et = e_[2], es = e_[3], el = e_[4], (eh = e_[9] = e_[9] === C ? ef ? 0 : r.length : rA(e_[9] - ep, 0)) || !(24 & l) || (l &= -25), l && 1 != l) 8 == l || 16 == l ? (eb = r, ew = l, eE = eh, eI = ce(eb), eB = function s() {
                                    for (var r = arguments.length, l = ty(r), U = r, et = qt(s); U--;) l[U] = arguments[U];
                                    var eo = r < 3 && l[0] !== et && l[r - 1] !== et ? [] : tt(l, et);
                                    return (r -= eo.length) < eE ? Iu(eb, ew, Xe, s.placeholder, C, l, eo, C, C, eE - r) : cn(this && this !== t3 && this instanceof s ? eI : eb, this, l)
                                }) : 32 != l && 33 != l || el.length ? eB = Xe.apply(C, e_) : (eS = r, ex = l, eA = et, eP = es, eC = 1 & ex, ek = ce(eS), eB = function f() {
                                    for (var r = -1, l = arguments.length, C = -1, U = eP.length, et = ty(U + l), eo = this && this !== t3 && this instanceof f ? ek : eS; ++C < U;) et[C] = eP[C];
                                    for (; l--;) et[C++] = arguments[++r];
                                    return cn(eo, eC ? eA : this, et)
                                });
                                else var eb, ew, eE, eI, eS, ex, eA, eP, eC, ek, eN, eO, eT, eR, eD, eB = (eN = r, eO = l, eT = et, eR = 1 & eO, eD = ce(eN), function o() {
                                    return (this && this !== t3 && this instanceof o ? eD : eN).apply(eR ? eT : this, arguments)
                                });
                                return $u((em ? rQ : r9)(eB, e_), r, l)
                            }

                            function Eu(r, l, U, et) {
                                return r === C || bn(r, tC[U]) && !tO.call(et, U) ? l : r
                            }

                            function yu(r, l, U, et, eo, es) {
                                return K(r) && K(l) && (es.set(l, r), Ke(r, l, C, yu, es), es.delete(l)), r
                            }

                            function kc(r) {
                                return pe(r) ? C : r
                            }

                            function Su(r, l, U, et, eo, es) {
                                var el = 1 & U,
                                    ec = r.length,
                                    ed = l.length;
                                if (ec != ed && !(el && ed > ec)) return !1;
                                var eh = es.get(r),
                                    ef = es.get(l);
                                if (eh && ef) return eh == l && ef == r;
                                var ep = -1,
                                    eg = !0,
                                    ey = 2 & U ? new gt : C;
                                for (es.set(r, l), es.set(l, r); ++ep < ec;) {
                                    var em = r[ep],
                                        e_ = l[ep];
                                    if (et) var eb = el ? et(e_, em, ep, l, r, es) : et(em, e_, ep, r, l, es);
                                    if (eb !== C) {
                                        if (eb) continue;
                                        eg = !1;
                                        break
                                    }
                                    if (ey) {
                                        if (!Nr(l, function(r, l) {
                                                if (!jt(ey, l) && (em === r || eo(em, r, U, et, es))) return ey.push(l)
                                            })) {
                                            eg = !1;
                                            break
                                        }
                                    } else if (!(em === e_ || eo(em, e_, U, et, es))) {
                                        eg = !1;
                                        break
                                    }
                                }
                                return es.delete(r), es.delete(l), eg
                            }

                            function Yn(r) {
                                return nn(Du(r, C, Bu), r + "")
                            }

                            function li(r) {
                                return Zs(r, V, r5)
                            }

                            function pi(r) {
                                return Zs(r, on, r6)
                            }
                            var r3 = rM ? function(r) {
                                return rM.get(r)
                            } : Di;

                            function je(r) {
                                for (var l = r.name + "", C = rj[l], U = tO.call(rj, l) ? C.length : 0; U--;) {
                                    var et = C[U],
                                        eo = et.func;
                                    if (null == eo || eo == r) return et.name
                                }
                                return l
                            }

                            function qt(r) {
                                return (tO.call(a, "placeholder") ? a : r).placeholder
                            }

                            function x() {
                                var r = a.iteratee || Ti;
                                return r = r === Ti ? Qs : r, arguments.length ? r(arguments[0], arguments[1]) : r
                            }

                            function nr(r, l) {
                                var C, U = r.__data__;
                                return ("string" == (C = typeof l) || "number" == C || "symbol" == C || "boolean" == C ? "__proto__" !== l : null === l) ? U["string" == typeof l ? "string" : "hash"] : U.map
                            }

                            function gi(r) {
                                for (var l = V(r), C = l.length; C--;) {
                                    var U = l[C],
                                        et = r[U];
                                    l[C] = [U, et, et == et && !K(et)]
                                }
                                return l
                            }

                            function mt(r, l) {
                                var U = null == r ? C : r[l];
                                return Xs(U) ? U : C
                            }
                            var r5 = rw ? function(r) {
                                    return null == r ? [] : jn(rw(r = tE(r)), function(l) {
                                        return tX.call(r, l)
                                    })
                                } : Hi,
                                r6 = rw ? function(r) {
                                    for (var l = []; r;) nt(l, r5(r)), r = tF(r);
                                    return l
                                } : Hi,
                                r8 = en;

                            function Ru(r, l, C) {
                                l = st(l, r);
                                for (var U = -1, et = l.length, eo = !1; ++U < et;) {
                                    var es = Wn(l[U]);
                                    if (!(eo = null != r && C(r, es))) break;
                                    r = r[es]
                                }
                                return eo || ++U != et ? eo : !!(et = null == r ? 0 : r.length) && ar(et) && Zn(es, et) && (nK(r) || nV(r))
                            }

                            function bu(r) {
                                return "function" != typeof r.constructor || he(r) ? {} : rG(tF(r))
                            }

                            function ah(r) {
                                return nK(r) || nV(r) || !!(t2 && r && r[t2])
                            }

                            function Zn(r, l) {
                                var C = typeof r;
                                return !!(l = l ? ? 9007199254740991) && ("number" == C || "symbol" != C && tc.test(r)) && r > -1 && r % 1 == 0 && r < l
                            }

                            function rn(r, l, C) {
                                if (!K(C)) return !1;
                                var U = typeof l;
                                return ("number" == U ? !!(an(C) && Zn(l, C.length)) : "string" == U && l in C) && bn(C[l], r)
                            }

                            function _i(r, l) {
                                if (nK(r)) return !1;
                                var C = typeof r;
                                return !!("number" == C || "symbol" == C || "boolean" == C || null == r || pn(r)) || eZ.test(r) || !eY.test(r) || null != l && r in tE(l)
                            }

                            function mi(r) {
                                var l = je(r),
                                    C = a[l];
                                if ("function" != typeof C || !(l in H.prototype)) return !1;
                                if (r === C) return !0;
                                var U = r3(C);
                                return !!U && r === U[0]
                            }(rT && r8(new rT(new ArrayBuffer(1))) != ek || rR && r8(new rR) != e_ || rD && r8(rD.resolve()) != eE || rB && r8(new rB) != eS || rU && r8(new rU) != eP) && (r8 = function(r) {
                                var l = en(r),
                                    U = l == ew ? r.constructor : C,
                                    et = U ? wt(U) : "";
                                if (et) switch (et) {
                                    case rq:
                                        return ek;
                                    case r$:
                                        return e_;
                                    case rz:
                                        return eE;
                                    case rH:
                                        return eS;
                                    case rF:
                                        return eP
                                }
                                return l
                            });
                            var r4 = tk ? Jn : Ni;

                            function he(r) {
                                var l = r && r.constructor;
                                return r === ("function" == typeof l && l.prototype || tC)
                            }

                            function Lu(r, l) {
                                return function(U) {
                                    return null != U && U[r] === l && (l !== C || r in tE(U))
                                }
                            }

                            function Du(r, l, U) {
                                return l = rA(l === C ? r.length - 1 : l, 0),
                                    function() {
                                        for (var C = arguments, et = -1, eo = rA(C.length - l, 0), es = ty(eo); ++et < eo;) es[et] = C[l + et];
                                        et = -1;
                                        for (var el = ty(l + 1); ++et < l;) el[et] = C[et];
                                        return el[l] = U(es), cn(r, this, el)
                                    }
                            }

                            function Hu(r, l) {
                                return l.length < 2 ? r : _t(r, Cn(l, 0, -1))
                            }

                            function wi(r, l) {
                                if (!("constructor" === l && "function" == typeof r[l]) && "__proto__" != l) return r[l]
                            }
                            var r9 = Uu(rQ),
                                r7 = rm || function(r, l) {
                                    return t3.setTimeout(r, l)
                                },
                                nn = Uu(r0);

                            function $u(r, l, C) {
                                var U, et, eo = l + "";
                                return nn(r, function(r, l) {
                                    var C = l.length;
                                    if (!C) return r;
                                    var U = C - 1;
                                    return l[U] = (C > 1 ? "& " : "") + l[U], l = l.join(C > 2 ? ", " : " "), r.replace(e3, `{
/* [wrapped with ` + l + `] */
`)
                                }(eo, (U = (et = eo.match(e5)) ? et[1].split(e6) : [], mn(ec, function(r) {
                                    var l = "_." + r[0];
                                    C & r[1] && !Ee(U, l) && U.push(l)
                                }), U.sort())))
                            }

                            function Uu(r) {
                                var l = 0,
                                    U = 0;
                                return function() {
                                    var et = rC(),
                                        eo = 16 - (et - U);
                                    if (U = et, eo > 0) {
                                        if (++l >= 800) return arguments[0]
                                    } else l = 0;
                                    return r.apply(C, arguments)
                                }
                            }

                            function tr(r, l) {
                                var U = -1,
                                    et = r.length,
                                    eo = et - 1;
                                for (l = l === C ? et : l; ++U < l;) {
                                    var es = ei(U, eo),
                                        el = r[es];
                                    r[es] = r[U], r[U] = el
                                }
                                return r.length = l, r
                            }
                            var no = (tp = (e2 = sr(function(r) {
                                var l = [];
                                return 46 === r.charCodeAt(0) && l.push(""), r.replace(eX, function(r, C, U, et) {
                                    l.push(U ? et.replace(e9, "$1") : C || r)
                                }), l
                            }, function(r) {
                                return 500 === tp.size && tp.clear(), r
                            })).cache, e2);

                            function Wn(r) {
                                if ("string" == typeof r || pn(r)) return r;
                                var l = r + "";
                                return "0" == l && 1 / r == -es ? "-0" : l
                            }

                            function wt(r) {
                                if (null != r) {
                                    try {
                                        return tN.call(r)
                                    } catch {}
                                    try {
                                        return r + ""
                                    } catch {}
                                }
                                return ""
                            }

                            function Fu(r) {
                                if (r instanceof H) return r.clone();
                                var l = new Pn(r.__wrapped__, r.__chain__);
                                return l.__actions__ = un(r.__actions__), l.__index__ = r.__index__, l.__values__ = r.__values__, l
                            }
                            var ns = L(function(r, l) {
                                    return Z(r) ? ue(r, j(l, 1, Z, !0)) : []
                                }),
                                nl = L(function(r, l) {
                                    var U = In(l);
                                    return Z(U) && (U = C), Z(r) ? ue(r, j(l, 1, Z, !0), x(U, 2)) : []
                                }),
                                nc = L(function(r, l) {
                                    var U = In(l);
                                    return Z(U) && (U = C), Z(r) ? ue(r, j(l, 1, Z, !0), C, U) : []
                                });

                            function Mu(r, l, C) {
                                var U = null == r ? 0 : r.length;
                                if (!U) return -1;
                                var et = null == C ? 0 : R(C);
                                return et < 0 && (et = rA(U + et, 0)), ye(r, x(l, 3), et)
                            }

                            function qu(r, l, U) {
                                var et = null == r ? 0 : r.length;
                                if (!et) return -1;
                                var eo = et - 1;
                                return U !== C && (eo = R(U), eo = U < 0 ? rA(et + eo, 0) : rP(eo, et - 1)), ye(r, x(l, 3), eo, !0)
                            }

                            function Bu(r) {
                                return (null == r ? 0 : r.length) ? j(r, 1) : []
                            }

                            function Gu(r) {
                                return r && r.length ? r[0] : C
                            }
                            var nd = L(function(r) {
                                    var l = G(r, ai);
                                    return l.length && l[0] === r[0] ? Vr(l) : []
                                }),
                                nh = L(function(r) {
                                    var l = In(r),
                                        U = G(r, ai);
                                    return l === In(U) ? l = C : U.pop(), U.length && U[0] === r[0] ? Vr(U, x(l, 2)) : []
                                }),
                                nf = L(function(r) {
                                    var l = In(r),
                                        U = G(r, ai);
                                    return (l = "function" == typeof l ? l : C) && U.pop(), U.length && U[0] === r[0] ? Vr(U, C, l) : []
                                });

                            function In(r) {
                                var l = null == r ? 0 : r.length;
                                return l ? r[l - 1] : C
                            }
                            var np = L(zu);

                            function zu(r, l) {
                                return r && r.length && l && l.length ? ti(r, l) : r
                            }
                            var ng = Yn(function(r, l) {
                                var C = null == r ? 0 : r.length,
                                    U = Zr(r, l);
                                return ru(r, G(l, function(r) {
                                    return Zn(r, C) ? +r : r
                                }).sort(pu)), U
                            });

                            function Ai(r) {
                                return null == r ? r : rO.call(r)
                            }
                            var ny = L(function(r) {
                                    return it(j(r, 1, Z, !0))
                                }),
                                nm = L(function(r) {
                                    var l = In(r);
                                    return Z(l) && (l = C), it(j(r, 1, Z, !0), x(l, 2))
                                }),
                                n_ = L(function(r) {
                                    var l = In(r);
                                    return l = "function" == typeof l ? l : C, it(j(r, 1, Z, !0), C, l)
                                });

                            function Ci(r) {
                                if (!(r && r.length)) return [];
                                var l = 0;
                                return r = jn(r, function(r) {
                                    if (Z(r)) return l = rA(r.length, l), !0
                                }), Fr(l, function(l) {
                                    return G(r, $r(l))
                                })
                            }

                            function Ku(r, l) {
                                if (!(r && r.length)) return [];
                                var U = Ci(r);
                                return null == l ? U : G(U, function(r) {
                                    return cn(l, C, r)
                                })
                            }
                            var nb = L(function(r, l) {
                                    return Z(r) ? ue(r, l) : []
                                }),
                                nw = L(function(r) {
                                    return ui(jn(r, Z))
                                }),
                                nE = L(function(r) {
                                    var l = In(r);
                                    return Z(l) && (l = C), ui(jn(r, Z), x(l, 2))
                                }),
                                nI = L(function(r) {
                                    var l = In(r);
                                    return l = "function" == typeof l ? l : C, ui(jn(r, Z), C, l)
                                }),
                                nS = L(Ci),
                                nx = L(function(r) {
                                    var l = r.length,
                                        U = l > 1 ? r[l - 1] : C;
                                    return U = "function" == typeof U ? (r.pop(), U) : C, Ku(r, U)
                                });

                            function Yu(r) {
                                var l = a(r);
                                return l.__chain__ = !0, l
                            }

                            function er(r, l) {
                                return l(r)
                            }
                            var nA = Yn(function(r) {
                                    var l = r.length,
                                        U = l ? r[0] : 0,
                                        et = this.__wrapped__,
                                        s = function(l) {
                                            return Zr(l, r)
                                        };
                                    return !(l > 1) && !this.__actions__.length && et instanceof H && Zn(U) ? ((et = et.slice(U, +U + (l ? 1 : 0))).__actions__.push({
                                        func: er,
                                        args: [s],
                                        thisArg: C
                                    }), new Pn(et, this.__chain__).thru(function(r) {
                                        return l && !r.length && r.push(C), r
                                    })) : this.thru(s)
                                }),
                                nP = Je(function(r, l, C) {
                                    tO.call(r, C) ? ++r[C] : zn(r, C, 1)
                                }),
                                nC = wu(Mu),
                                nk = wu(qu);

                            function Zu(r, l) {
                                return (nK(r) ? mn : rJ)(r, x(l, 3))
                            }

                            function Ju(r, l) {
                                return (nK(r) ? function(r, l) {
                                    for (var C = null == r ? 0 : r.length; C-- && !1 !== l(r[C], C, r););
                                    return r
                                } : rY)(r, x(l, 3))
                            }
                            var nN = Je(function(r, l, C) {
                                    tO.call(r, C) ? r[C].push(l) : zn(r, C, [l])
                                }),
                                nO = L(function(r, l, C) {
                                    var U = -1,
                                        et = "function" == typeof l,
                                        eo = an(r) ? ty(r.length) : [];
                                    return rJ(r, function(r) {
                                        eo[++U] = et ? cn(l, r, C) : ae(r, l, C)
                                    }), eo
                                }),
                                nT = Je(function(r, l, C) {
                                    zn(r, C, l)
                                });

                            function rr(r, l) {
                                return (nK(r) ? G : Vs)(r, x(l, 3))
                            }
                            var nR = Je(function(r, l, C) {
                                    r[C ? 0 : 1].push(l)
                                }, function() {
                                    return [
                                        [],
                                        []
                                    ]
                                }),
                                nD = L(function(r, l) {
                                    if (null == r) return [];
                                    var C = l.length;
                                    return C > 1 && rn(r, l[0], l[1]) ? l = [] : C > 2 && rn(l[0], l[1], l[2]) && (l = [l[0]]), tu(r, j(l, 1), [])
                                }),
                                nB = rd || function() {
                                    return t3.Date.now()
                                };

                            function Xu(r, l, U) {
                                return l = U ? C : l, l = r && null == l ? r.length : l, Kn(r, 128, C, C, C, C, l)
                            }

                            function Qu(r, l) {
                                var et;
                                if ("function" != typeof l) throw new tx(U);
                                return r = R(r),
                                    function() {
                                        return --r > 0 && (et = l.apply(this, arguments)), r <= 1 && (l = C), et
                                    }
                            }
                            var nU = L(function(r, l, C) {
                                    var U = 1;
                                    if (C.length) {
                                        var et = tt(C, qt(nU));
                                        U |= 32
                                    }
                                    return Kn(r, U, l, C, et)
                                }),
                                nL = L(function(r, l, C) {
                                    var U = 3;
                                    if (C.length) {
                                        var et = tt(C, qt(nL));
                                        U |= 32
                                    }
                                    return Kn(l, U, r, C, et)
                                });

                            function na(r, l, et) {
                                var eo, es, el, ec, ed, eh, ef = 0,
                                    ep = !1,
                                    eg = !1,
                                    ey = !0;
                                if ("function" != typeof r) throw new tx(U);

                                function I(l) {
                                    var U = eo,
                                        et = es;
                                    return eo = es = C, ef = l, ec = r.apply(et, U)
                                }

                                function y(r) {
                                    var U = r - eh,
                                        et = r - ef;
                                    return eh === C || U >= l || U < 0 || eg && et >= el
                                }

                                function D() {
                                    var r, C, U, et = nB();
                                    if (y(et)) return N(et);
                                    ed = r7(D, (r = et - eh, C = et - ef, U = l - r, eg ? rP(U, el - C) : U))
                                }

                                function N(r) {
                                    return ed = C, ey && eo ? I(r) : (eo = es = C, ec)
                                }

                                function gn() {
                                    var r, U = nB(),
                                        et = y(U);
                                    if (eo = arguments, es = this, eh = U, et) {
                                        if (ed === C) return ef = r = eh, ed = r7(D, l), ep ? I(r) : ec;
                                        if (eg) return r1(ed), ed = r7(D, l), I(eh)
                                    }
                                    return ed === C && (ed = r7(D, l)), ec
                                }
                                return l = xn(l) || 0, K(et) && (ep = !!et.leading, el = (eg = "maxWait" in et) ? rA(xn(et.maxWait) || 0, l) : el, ey = "trailing" in et ? !!et.trailing : ey), gn.cancel = function() {
                                    ed !== C && r1(ed), ef = 0, eo = eh = es = ed = C
                                }, gn.flush = function() {
                                    return ed === C ? ec : N(nB())
                                }, gn
                            }
                            var nM = L(function(r, l) {
                                    return Gs(r, 1, l)
                                }),
                                nj = L(function(r, l, C) {
                                    return Gs(r, xn(l) || 0, C)
                                });

                            function sr(r, l) {
                                if ("function" != typeof r || null != l && "function" != typeof l) throw new tx(U);
                                var e = function() {
                                    var C = arguments,
                                        U = l ? l.apply(this, C) : C[0],
                                        et = e.cache;
                                    if (et.has(U)) return et.get(U);
                                    var eo = r.apply(this, C);
                                    return e.cache = et.set(U, eo) || et, eo
                                };
                                return e.cache = new(sr.Cache || Gn), e
                            }

                            function ur(r) {
                                if ("function" != typeof r) throw new tx(U);
                                return function() {
                                    var l = arguments;
                                    switch (l.length) {
                                        case 0:
                                            return !r.call(this);
                                        case 1:
                                            return !r.call(this, l[0]);
                                        case 2:
                                            return !r.call(this, l[0], l[1]);
                                        case 3:
                                            return !r.call(this, l[0], l[1], l[2])
                                    }
                                    return !r.apply(this, l)
                                }
                            }
                            sr.Cache = Gn;
                            var nq = L(function(r, l) {
                                    var C = (l = 1 == l.length && nK(l[0]) ? G(l[0], hn(x())) : G(j(l, 1), hn(x()))).length;
                                    return L(function(U) {
                                        for (var et = -1, eo = rP(U.length, C); ++et < eo;) U[et] = l[et].call(this, U[et]);
                                        return cn(r, this, U)
                                    })
                                }),
                                n$ = L(function(r, l) {
                                    var U = tt(l, qt(n$));
                                    return Kn(r, 32, C, l, U)
                                }),
                                nz = L(function(r, l) {
                                    var U = tt(l, qt(nz));
                                    return Kn(r, 64, C, l, U)
                                }),
                                nH = Yn(function(r, l) {
                                    return Kn(r, 256, C, C, C, l)
                                });

                            function bn(r, l) {
                                return r === l || r != r && l != l
                            }
                            var nF = ke(Qr),
                                nW = ke(function(r, l) {
                                    return r >= l
                                }),
                                nV = Js(function() {
                                    return arguments
                                }()) ? Js : function(r) {
                                    return Y(r) && tO.call(r, "callee") && !tX.call(r, "callee")
                                },
                                nK = ty.isArray,
                                nG = t7 ? hn(t7) : function(r) {
                                    return Y(r) && en(r) == eC
                                };

                            function an(r) {
                                return null != r && ar(r.length) && !Jn(r)
                            }

                            function Z(r) {
                                return Y(r) && an(r)
                            }
                            var nJ = rE || Ni,
                                nY = ro ? hn(ro) : function(r) {
                                    return Y(r) && en(r) == ep
                                };

                            function Ei(r) {
                                if (!Y(r)) return !1;
                                var l = en(r);
                                return l == eg || "[object DOMException]" == l || "string" == typeof r.message && "string" == typeof r.name && !pe(r)
                            }

                            function Jn(r) {
                                if (!K(r)) return !1;
                                var l = en(r);
                                return l == ey || l == em || "[object AsyncFunction]" == l || "[object Proxy]" == l
                            }

                            function ea(r) {
                                return "number" == typeof r && r == R(r)
                            }

                            function ar(r) {
                                return "number" == typeof r && r > -1 && r % 1 == 0 && r <= 9007199254740991
                            }

                            function K(r) {
                                var l = typeof r;
                                return null != r && ("object" == l || "function" == l)
                            }

                            function Y(r) {
                                return null != r && "object" == typeof r
                            }
                            var nZ = rs ? hn(rs) : function(r) {
                                return Y(r) && r8(r) == e_
                            };

                            function ia(r) {
                                return "number" == typeof r || Y(r) && en(r) == eb
                            }

                            function pe(r) {
                                if (!Y(r) || en(r) != ew) return !1;
                                var l = tF(r);
                                if (null === l) return !0;
                                var C = tO.call(l, "constructor") && l.constructor;
                                return "function" == typeof C && C instanceof C && tN.call(C) == tB
                            }
                            var nX = ra ? hn(ra) : function(r) {
                                    return Y(r) && en(r) == eI
                                },
                                nQ = rl ? hn(rl) : function(r) {
                                    return Y(r) && r8(r) == eS
                                };

                            function or(r) {
                                return "string" == typeof r || !nK(r) && Y(r) && en(r) == ex
                            }

                            function pn(r) {
                                return "symbol" == typeof r || Y(r) && en(r) == eA
                            }
                            var n0 = rc ? hn(rc) : function(r) {
                                    return Y(r) && ar(r.length) && !!tY[en(r)]
                                },
                                n1 = ke(ni),
                                n2 = ke(function(r, l) {
                                    return r <= l
                                });

                            function ua(r) {
                                if (!r) return [];
                                if (an(r)) return or(r) ? On(r) : un(r);
                                if (t5 && r[t5]) return function(r) {
                                    for (var l, C = []; !(l = r.next()).done;) C.push(l.value);
                                    return C
                                }(r[t5]());
                                var l = r8(r);
                                return (l == e_ ? qr : l == eS ? Se : Gt)(r)
                            }

                            function Xn(r) {
                                return r ? (r = xn(r)) === es || r === -es ? (r < 0 ? -1 : 1) * 17976931348623157e292 : r == r ? r : 0 : 0 === r ? r : 0
                            }

                            function R(r) {
                                var l = Xn(r),
                                    C = l % 1;
                                return l == l ? C ? l - C : l : 0
                            }

                            function aa(r) {
                                return r ? vt(R(r), 0, 4294967295) : 0
                            }

                            function xn(r) {
                                if ("number" == typeof r) return r;
                                if (pn(r)) return el;
                                if (K(r)) {
                                    var l = "function" == typeof r.valueOf ? r.valueOf() : r;
                                    r = K(l) ? l + "" : l
                                }
                                if ("string" != typeof r) return 0 === r ? r : +r;
                                r = ys(r);
                                var C = ts.test(r);
                                return C || tl.test(r) ? t0(r.slice(2), C ? 2 : 8) : to.test(r) ? el : +r
                            }

                            function oa(r) {
                                return Un(r, on(r))
                            }

                            function W(r) {
                                return null == r ? "" : ln(r)
                            }
                            var n3 = Ft(function(r, l) {
                                    if (he(l) || an(l)) {
                                        Un(l, V(l), r);
                                        return
                                    }
                                    for (var C in l) tO.call(l, C) && se(r, C, l[C])
                                }),
                                n5 = Ft(function(r, l) {
                                    Un(l, on(l), r)
                                }),
                                n6 = Ft(function(r, l, C, U) {
                                    Un(l, on(l), r, U)
                                }),
                                n8 = Ft(function(r, l, C, U) {
                                    Un(l, V(l), r, U)
                                }),
                                n4 = Yn(Zr),
                                n9 = L(function(r, l) {
                                    r = tE(r);
                                    var U = -1,
                                        et = l.length,
                                        eo = et > 2 ? l[2] : C;
                                    for (eo && rn(l[0], l[1], eo) && (et = 1); ++U < et;)
                                        for (var es = l[U], el = on(es), ec = -1, ed = el.length; ++ec < ed;) {
                                            var eh = el[ec],
                                                ef = r[eh];
                                            (ef === C || bn(ef, tC[eh]) && !tO.call(r, eh)) && (r[eh] = es[eh])
                                        }
                                    return r
                                }),
                                n7 = L(function(r) {
                                    return r.push(C, yu), cn(id, C, r)
                                });

                            function Si(r, l, U) {
                                var et = null == r ? C : _t(r, l);
                                return et === C ? U : et
                            }

                            function Oi(r, l) {
                                return null != r && Ru(r, l, Ac)
                            }
                            var io = Au(function(r, l, C) {
                                    null != l && "function" != typeof l.toString && (l = tD.call(l)), r[l] = C
                                }, bi(fn)),
                                iu = Au(function(r, l, C) {
                                    null != l && "function" != typeof l.toString && (l = tD.call(l)), tO.call(r, l) ? r[l].push(C) : r[l] = [C]
                                }, x),
                                il = L(ae);

                            function V(r) {
                                return an(r) ? Fs(r) : jr(r)
                            }

                            function on(r) {
                                return an(r) ? Fs(r, !0) : function(r) {
                                    if (!K(r)) return function(r) {
                                        var l = [];
                                        if (null != r)
                                            for (var C in tE(r)) l.push(C);
                                        return l
                                    }(r);
                                    var l = he(r),
                                        C = [];
                                    for (var U in r) "constructor" == U && (l || !tO.call(r, U)) || C.push(U);
                                    return C
                                }(r)
                            }
                            var ic = Ft(function(r, l, C) {
                                    Ke(r, l, C)
                                }),
                                id = Ft(function(r, l, C, U) {
                                    Ke(r, l, C, U)
                                }),
                                ih = Yn(function(r, l) {
                                    var C = {};
                                    if (null == r) return C;
                                    var U = !1;
                                    l = G(l, function(l) {
                                        return l = st(l, r), U || (U = l.length > 1), l
                                    }), Un(r, pi(r), C), U && (C = An(C, 7, kc));
                                    for (var et = l.length; et--;) si(C, l[et]);
                                    return C
                                }),
                                ip = Yn(function(r, l) {
                                    return null == r ? {} : eu(r, l, function(l, C) {
                                        return Oi(r, C)
                                    })
                                });

                            function ha(r, l) {
                                if (null == r) return {};
                                var C = G(pi(r), function(r) {
                                    return [r]
                                });
                                return l = x(l), eu(r, C, function(r, C) {
                                    return l(r, C[0])
                                })
                            }
                            var ig = xu(V),
                                iy = xu(on);

                            function Gt(r) {
                                return null == r ? [] : Mr(r, V(r))
                            }
                            var im = Mt(function(r, l, C) {
                                return l = l.toLowerCase(), r + (C ? da(l) : l)
                            });

                            function da(r) {
                                return ix(W(r).toLowerCase())
                            }

                            function ga(r) {
                                return (r = W(r)) && r.replace(td, rh).replace(tH, "")
                            }
                            var i_ = Mt(function(r, l, C) {
                                    return r + (C ? "-" : "") + l.toLowerCase()
                                }),
                                ib = Mt(function(r, l, C) {
                                    return r + (C ? " " : "") + l.toLowerCase()
                                }),
                                iw = mu("toLowerCase"),
                                iE = Mt(function(r, l, C) {
                                    return r + (C ? "_" : "") + l.toLowerCase()
                                }),
                                iI = Mt(function(r, l, C) {
                                    return r + (C ? " " : "") + ix(l)
                                }),
                                iS = Mt(function(r, l, C) {
                                    return r + (C ? " " : "") + l.toUpperCase()
                                }),
                                ix = mu("toUpperCase");

                            function va(r, l, U) {
                                var et;
                                return r = W(r), (l = U ? C : l) === C ? (et = r, tK.test(et)) ? r.match(tW) || [] : r.match(e8) || [] : r.match(l) || []
                            }
                            var iA = L(function(r, l) {
                                    try {
                                        return cn(r, C, l)
                                    } catch (r) {
                                        return Ei(r) ? r : new t_(r)
                                    }
                                }),
                                iP = Yn(function(r, l) {
                                    return mn(l, function(l) {
                                        zn(r, l = Wn(l), nU(r[l], r))
                                    }), r
                                });

                            function bi(r) {
                                return function() {
                                    return r
                                }
                            }
                            var iC = Pu(),
                                ik = Pu(!0);

                            function fn(r) {
                                return r
                            }

                            function Ti(r) {
                                return Qs("function" == typeof r ? r : An(r, 1))
                            }
                            var iN = L(function(r, l) {
                                    return function(C) {
                                        return ae(C, r, l)
                                    }
                                }),
                                iO = L(function(r, l) {
                                    return function(C) {
                                        return ae(r, C, l)
                                    }
                                });

                            function Li(r, l, C) {
                                var U = V(l),
                                    et = ze(l, U);
                                null != C || K(l) && (et.length || !U.length) || (C = l, l = r, r = this, et = ze(l, V(l)));
                                var eo = !(K(C) && "chain" in C) || !!C.chain,
                                    es = Jn(r);
                                return mn(et, function(C) {
                                    var U = l[C];
                                    r[C] = U, es && (r.prototype[C] = function() {
                                        var l = this.__chain__;
                                        if (eo || l) {
                                            var C = r(this.__wrapped__);
                                            return (C.__actions__ = un(this.__actions__)).push({
                                                func: U,
                                                args: arguments,
                                                thisArg: r
                                            }), C.__chain__ = l, C
                                        }
                                        return U.apply(r, nt([this.value()], arguments))
                                    })
                                }), r
                            }

                            function Di() {}
                            var iT = ci(G),
                                iR = ci(As),
                                iD = ci(Nr);

                            function ma(r) {
                                return _i(r) ? $r(Wn(r)) : function(l) {
                                    return _t(l, r)
                                }
                            }
                            var iB = Cu(),
                                iU = Cu(!0);

                            function Hi() {
                                return []
                            }

                            function Ni() {
                                return !1
                            }
                            var iL = Qe(function(r, l) {
                                    return r + l
                                }, 0),
                                iM = hi("ceil"),
                                ij = Qe(function(r, l) {
                                    return r / l
                                }, 1),
                                iq = hi("floor"),
                                i$ = Qe(function(r, l) {
                                    return r * l
                                }, 1),
                                iz = hi("round"),
                                iH = Qe(function(r, l) {
                                    return r - l
                                }, 0);
                            return a.after = function(r, l) {
                                if ("function" != typeof l) throw new tx(U);
                                return r = R(r),
                                    function() {
                                        if (--r < 1) return l.apply(this, arguments)
                                    }
                            }, a.ary = Xu, a.assign = n3, a.assignIn = n5, a.assignInWith = n6, a.assignWith = n8, a.at = n4, a.before = Qu, a.bind = nU, a.bindAll = iP, a.bindKey = nL, a.castArray = function() {
                                if (!arguments.length) return [];
                                var r = arguments[0];
                                return nK(r) ? r : [r]
                            }, a.chain = Yu, a.chunk = function(r, l, U) {
                                l = (U ? rn(r, l, U) : l === C) ? 1 : rA(R(l), 0);
                                var et = null == r ? 0 : r.length;
                                if (!et || l < 1) return [];
                                for (var eo = 0, es = 0, el = ty(r_(et / l)); eo < et;) el[es++] = Cn(r, eo, eo += l);
                                return el
                            }, a.compact = function(r) {
                                for (var l = -1, C = null == r ? 0 : r.length, U = 0, et = []; ++l < C;) {
                                    var eo = r[l];
                                    eo && (et[U++] = eo)
                                }
                                return et
                            }, a.concat = function() {
                                var r = arguments.length;
                                if (!r) return [];
                                for (var l = ty(r - 1), C = arguments[0], U = r; U--;) l[U - 1] = arguments[U];
                                return nt(nK(C) ? un(C) : [C], j(l, 1))
                            }, a.cond = function(r) {
                                var l = null == r ? 0 : r.length,
                                    C = x();
                                return r = l ? G(r, function(r) {
                                    if ("function" != typeof r[1]) throw new tx(U);
                                    return [C(r[0]), r[1]]
                                }) : [], L(function(C) {
                                    for (var U = -1; ++U < l;) {
                                        var et = r[U];
                                        if (cn(et[0], this, C)) return cn(et[1], this, C)
                                    }
                                })
                            }, a.conforms = function(r) {
                                var l, C;
                                return C = V(l = An(r, 1)),
                                    function(r) {
                                        return Bs(r, l, C)
                                    }
                            }, a.constant = bi, a.countBy = nP, a.create = function(r, l) {
                                var C = rG(r);
                                return null == l ? C : qs(C, l)
                            }, a.curry = function ku(r, l, U) {
                                l = U ? C : l;
                                var et = Kn(r, 8, C, C, C, C, C, l);
                                return et.placeholder = ku.placeholder, et
                            }, a.curryRight = function ju(r, l, U) {
                                l = U ? C : l;
                                var et = Kn(r, 16, C, C, C, C, C, l);
                                return et.placeholder = ju.placeholder, et
                            }, a.debounce = na, a.defaults = n9, a.defaultsDeep = n7, a.defer = nM, a.delay = nj, a.difference = ns, a.differenceBy = nl, a.differenceWith = nc, a.drop = function(r, l, U) {
                                var et = null == r ? 0 : r.length;
                                return et ? Cn(r, (l = U || l === C ? 1 : R(l)) < 0 ? 0 : l, et) : []
                            }, a.dropRight = function(r, l, U) {
                                var et = null == r ? 0 : r.length;
                                return et ? Cn(r, 0, (l = et - (l = U || l === C ? 1 : R(l))) < 0 ? 0 : l) : []
                            }, a.dropRightWhile = function(r, l) {
                                return r && r.length ? Ze(r, x(l, 3), !0, !0) : []
                            }, a.dropWhile = function(r, l) {
                                return r && r.length ? Ze(r, x(l, 3), !0) : []
                            }, a.fill = function(r, l, U, et) {
                                var eo = null == r ? 0 : r.length;
                                return eo ? (U && "number" != typeof U && rn(r, l, U) && (U = 0, et = eo), function(r, l, U, et) {
                                    var eo = r.length;
                                    for ((U = R(U)) < 0 && (U = -U > eo ? 0 : eo + U), (et = et === C || et > eo ? eo : R(et)) < 0 && (et += eo), et = U > et ? 0 : aa(et); U < et;) r[U++] = l;
                                    return r
                                }(r, l, U, et)) : []
                            }, a.filter = function(r, l) {
                                return (nK(r) ? jn : Ks)(r, x(l, 3))
                            }, a.flatMap = function(r, l) {
                                return j(rr(r, l), 1)
                            }, a.flatMapDeep = function(r, l) {
                                return j(rr(r, l), es)
                            }, a.flatMapDepth = function(r, l, U) {
                                return U = U === C ? 1 : R(U), j(rr(r, l), U)
                            }, a.flatten = Bu, a.flattenDeep = function(r) {
                                return (null == r ? 0 : r.length) ? j(r, es) : []
                            }, a.flattenDepth = function(r, l) {
                                return (null == r ? 0 : r.length) ? j(r, l = l === C ? 1 : R(l)) : []
                            }, a.flip = function(r) {
                                return Kn(r, 512)
                            }, a.flow = iC, a.flowRight = ik, a.fromPairs = function(r) {
                                for (var l = -1, C = null == r ? 0 : r.length, U = {}; ++l < C;) {
                                    var et = r[l];
                                    U[et[0]] = et[1]
                                }
                                return U
                            }, a.functions = function(r) {
                                return null == r ? [] : ze(r, V(r))
                            }, a.functionsIn = function(r) {
                                return null == r ? [] : ze(r, on(r))
                            }, a.groupBy = nN, a.initial = function(r) {
                                return (null == r ? 0 : r.length) ? Cn(r, 0, -1) : []
                            }, a.intersection = nd, a.intersectionBy = nh, a.intersectionWith = nf, a.invert = io, a.invertBy = iu, a.invokeMap = nO, a.iteratee = Ti, a.keyBy = nT, a.keys = V, a.keysIn = on, a.map = rr, a.mapKeys = function(r, l) {
                                var C = {};
                                return l = x(l, 3), $n(r, function(r, U, et) {
                                    zn(C, l(r, U, et), r)
                                }), C
                            }, a.mapValues = function(r, l) {
                                var C = {};
                                return l = x(l, 3), $n(r, function(r, U, et) {
                                    zn(C, U, l(r, U, et))
                                }), C
                            }, a.matches = function(r) {
                                return ks(An(r, 1))
                            }, a.matchesProperty = function(r, l) {
                                return js(r, An(l, 1))
                            }, a.memoize = sr, a.merge = ic, a.mergeWith = id, a.method = iN, a.methodOf = iO, a.mixin = Li, a.negate = ur, a.nthArg = function(r) {
                                return r = R(r), L(function(l) {
                                    return nu(l, r)
                                })
                            }, a.omit = ih, a.omitBy = function(r, l) {
                                return ha(r, ur(x(l)))
                            }, a.once = function(r) {
                                return Qu(2, r)
                            }, a.orderBy = function(r, l, U, et) {
                                return null == r ? [] : (nK(l) || (l = null == l ? [] : [l]), nK(U = et ? C : U) || (U = null == U ? [] : [U]), tu(r, l, U))
                            }, a.over = iT, a.overArgs = nq, a.overEvery = iR, a.overSome = iD, a.partial = n$, a.partialRight = nz, a.partition = nR, a.pick = ip, a.pickBy = ha, a.property = ma, a.propertyOf = function(r) {
                                return function(l) {
                                    return null == r ? C : _t(r, l)
                                }
                            }, a.pull = np, a.pullAll = zu, a.pullAllBy = function(r, l, C) {
                                return r && r.length && l && l.length ? ti(r, l, x(C, 2)) : r
                            }, a.pullAllWith = function(r, l, U) {
                                return r && r.length && l && l.length ? ti(r, l, C, U) : r
                            }, a.pullAt = ng, a.range = iB, a.rangeRight = iU, a.rearg = nH, a.reject = function(r, l) {
                                return (nK(r) ? jn : Ks)(r, ur(x(l, 3)))
                            }, a.remove = function(r, l) {
                                var C = [];
                                if (!(r && r.length)) return C;
                                var U = -1,
                                    et = [],
                                    eo = r.length;
                                for (l = x(l, 3); ++U < eo;) {
                                    var es = r[U];
                                    l(es, U, r) && (C.push(es), et.push(U))
                                }
                                return ru(r, et), C
                            }, a.rest = function(r, l) {
                                if ("function" != typeof r) throw new tx(U);
                                return L(r, l = l === C ? l : R(l))
                            }, a.reverse = Ai, a.sampleSize = function(r, l, U) {
                                return l = (U ? rn(r, l, U) : l === C) ? 1 : R(l), (nK(r) ? function(r, l) {
                                    return tr(un(r), vt(l, 0, r.length))
                                } : function(r, l) {
                                    var C = Gt(r);
                                    return tr(C, vt(l, 0, C.length))
                                })(r, l)
                            }, a.set = function(r, l, C) {
                                return null == r ? r : fe(r, l, C)
                            }, a.setWith = function(r, l, U, et) {
                                return et = "function" == typeof et ? et : C, null == r ? r : fe(r, l, U, et)
                            }, a.shuffle = function(r) {
                                return (nK(r) ? function(r) {
                                    return tr(un(r))
                                } : function(r) {
                                    return tr(Gt(r))
                                })(r)
                            }, a.slice = function(r, l, U) {
                                var et = null == r ? 0 : r.length;
                                return et ? (U && "number" != typeof U && rn(r, l, U) ? (l = 0, U = et) : (l = null == l ? 0 : R(l), U = U === C ? et : R(U)), Cn(r, l, U)) : []
                            }, a.sortBy = nD, a.sortedUniq = function(r) {
                                return r && r.length ? su(r) : []
                            }, a.sortedUniqBy = function(r, l) {
                                return r && r.length ? su(r, x(l, 2)) : []
                            }, a.split = function(r, l, U) {
                                return U && "number" != typeof U && rn(r, l, U) && (l = U = C), (U = U === C ? 4294967295 : U >>> 0) ? (r = W(r)) && ("string" == typeof l || null != l && !nX(l)) && !(l = ln(l)) && Lt(r) ? ut(On(r), 0, U) : r.split(l, U) : []
                            }, a.spread = function(r, l) {
                                if ("function" != typeof r) throw new tx(U);
                                return l = null == l ? 0 : rA(R(l), 0), L(function(C) {
                                    var U = C[l],
                                        et = ut(C, 0, l);
                                    return U && nt(et, U), cn(r, this, et)
                                })
                            }, a.tail = function(r) {
                                var l = null == r ? 0 : r.length;
                                return l ? Cn(r, 1, l) : []
                            }, a.take = function(r, l, U) {
                                return r && r.length ? Cn(r, 0, (l = U || l === C ? 1 : R(l)) < 0 ? 0 : l) : []
                            }, a.takeRight = function(r, l, U) {
                                var et = null == r ? 0 : r.length;
                                return et ? Cn(r, (l = et - (l = U || l === C ? 1 : R(l))) < 0 ? 0 : l, et) : []
                            }, a.takeRightWhile = function(r, l) {
                                return r && r.length ? Ze(r, x(l, 3), !1, !0) : []
                            }, a.takeWhile = function(r, l) {
                                return r && r.length ? Ze(r, x(l, 3)) : []
                            }, a.tap = function(r, l) {
                                return l(r), r
                            }, a.throttle = function(r, l, C) {
                                var et = !0,
                                    eo = !0;
                                if ("function" != typeof r) throw new tx(U);
                                return K(C) && (et = "leading" in C ? !!C.leading : et, eo = "trailing" in C ? !!C.trailing : eo), na(r, l, {
                                    leading: et,
                                    maxWait: l,
                                    trailing: eo
                                })
                            }, a.thru = er, a.toArray = ua, a.toPairs = ig, a.toPairsIn = iy, a.toPath = function(r) {
                                return nK(r) ? G(r, Wn) : pn(r) ? [r] : un(no(W(r)))
                            }, a.toPlainObject = oa, a.transform = function(r, l, C) {
                                var U = nK(r),
                                    et = U || nJ(r) || n0(r);
                                if (l = x(l, 4), null == C) {
                                    var eo = r && r.constructor;
                                    C = et ? U ? new eo : [] : K(r) && Jn(eo) ? rG(tF(r)) : {}
                                }
                                return (et ? mn : $n)(r, function(r, U, et) {
                                    return l(C, r, U, et)
                                }), C
                            }, a.unary = function(r) {
                                return Xu(r, 1)
                            }, a.union = ny, a.unionBy = nm, a.unionWith = n_, a.uniq = function(r) {
                                return r && r.length ? it(r) : []
                            }, a.uniqBy = function(r, l) {
                                return r && r.length ? it(r, x(l, 2)) : []
                            }, a.uniqWith = function(r, l) {
                                return l = "function" == typeof l ? l : C, r && r.length ? it(r, C, l) : []
                            }, a.unset = function(r, l) {
                                return null == r || si(r, l)
                            }, a.unzip = Ci, a.unzipWith = Ku, a.update = function(r, l, C) {
                                return null == r ? r : au(r, l, oi(C))
                            }, a.updateWith = function(r, l, U, et) {
                                return et = "function" == typeof et ? et : C, null == r ? r : au(r, l, oi(U), et)
                            }, a.values = Gt, a.valuesIn = function(r) {
                                return null == r ? [] : Mr(r, on(r))
                            }, a.without = nb, a.words = va, a.wrap = function(r, l) {
                                return n$(oi(l), r)
                            }, a.xor = nw, a.xorBy = nE, a.xorWith = nI, a.zip = nS, a.zipObject = function(r, l) {
                                return fu(r || [], l || [], se)
                            }, a.zipObjectDeep = function(r, l) {
                                return fu(r || [], l || [], fe)
                            }, a.zipWith = nx, a.entries = ig, a.entriesIn = iy, a.extend = n5, a.extendWith = n6, Li(a, a), a.add = iL, a.attempt = iA, a.camelCase = im, a.capitalize = da, a.ceil = iM, a.clamp = function(r, l, U) {
                                return U === C && (U = l, l = C), U !== C && (U = (U = xn(U)) == U ? U : 0), l !== C && (l = (l = xn(l)) == l ? l : 0), vt(xn(r), l, U)
                            }, a.clone = function(r) {
                                return An(r, 4)
                            }, a.cloneDeep = function(r) {
                                return An(r, 5)
                            }, a.cloneDeepWith = function(r, l) {
                                return An(r, 5, l = "function" == typeof l ? l : C)
                            }, a.cloneWith = function(r, l) {
                                return An(r, 4, l = "function" == typeof l ? l : C)
                            }, a.conformsTo = function(r, l) {
                                return null == l || Bs(r, l, V(l))
                            }, a.deburr = ga, a.defaultTo = function(r, l) {
                                return null == r || r != r ? l : r
                            }, a.divide = ij, a.endsWith = function(r, l, U) {
                                r = W(r), l = ln(l);
                                var et = r.length,
                                    eo = U = U === C ? et : vt(R(U), 0, et);
                                return (U -= l.length) >= 0 && r.slice(U, eo) == l
                            }, a.eq = bn, a.escape = function(r) {
                                return (r = W(r)) && eV.test(r) ? r.replace(eF, rp) : r
                            }, a.escapeRegExp = function(r) {
                                return (r = W(r)) && e0.test(r) ? r.replace(eQ, "\\$&") : r
                            }, a.every = function(r, l, U) {
                                var et = nK(r) ? As : mc;
                                return U && rn(r, l, U) && (l = C), et(r, x(l, 3))
                            }, a.find = nC, a.findIndex = Mu, a.findKey = function(r, l) {
                                return Cs(r, x(l, 3), $n)
                            }, a.findLast = nk, a.findLastIndex = qu, a.findLastKey = function(r, l) {
                                return Cs(r, x(l, 3), Xr)
                            }, a.floor = iq, a.forEach = Zu, a.forEachRight = Ju, a.forIn = function(r, l) {
                                return null == r ? r : rZ(r, x(l, 3), on)
                            }, a.forInRight = function(r, l) {
                                return null == r ? r : rX(r, x(l, 3), on)
                            }, a.forOwn = function(r, l) {
                                return r && $n(r, x(l, 3))
                            }, a.forOwnRight = function(r, l) {
                                return r && Xr(r, x(l, 3))
                            }, a.get = Si, a.gt = nF, a.gte = nW, a.has = function(r, l) {
                                return null != r && Ru(r, l, Pc)
                            }, a.hasIn = Oi, a.head = Gu, a.identity = fn, a.includes = function(r, l, C, U) {
                                r = an(r) ? r : Gt(r), C = C && !U ? R(C) : 0;
                                var et = r.length;
                                return C < 0 && (C = rA(et + C, 0)), or(r) ? C <= et && r.indexOf(l, C) > -1 : !!et && Tt(r, l, C) > -1
                            }, a.indexOf = function(r, l, C) {
                                var U = null == r ? 0 : r.length;
                                if (!U) return -1;
                                var et = null == C ? 0 : R(C);
                                return et < 0 && (et = rA(U + et, 0)), Tt(r, l, et)
                            }, a.inRange = function(r, l, U) {
                                var et, eo, es;
                                return l = Xn(l), U === C ? (U = l, l = 0) : U = Xn(U), (et = r = xn(r)) >= rP(eo = l, es = U) && et < rA(eo, es)
                            }, a.invoke = il, a.isArguments = nV, a.isArray = nK, a.isArrayBuffer = nG, a.isArrayLike = an, a.isArrayLikeObject = Z, a.isBoolean = function(r) {
                                return !0 === r || !1 === r || Y(r) && en(r) == ef
                            }, a.isBuffer = nJ, a.isDate = nY, a.isElement = function(r) {
                                return Y(r) && 1 === r.nodeType && !pe(r)
                            }, a.isEmpty = function(r) {
                                if (null == r) return !0;
                                if (an(r) && (nK(r) || "string" == typeof r || "function" == typeof r.splice || nJ(r) || n0(r) || nV(r))) return !r.length;
                                var l = r8(r);
                                if (l == e_ || l == eS) return !r.size;
                                if (he(r)) return !jr(r).length;
                                for (var C in r)
                                    if (tO.call(r, C)) return !1;
                                return !0
                            }, a.isEqual = function(r, l) {
                                return oe(r, l)
                            }, a.isEqualWith = function(r, l, U) {
                                var et = (U = "function" == typeof U ? U : C) ? U(r, l) : C;
                                return et === C ? oe(r, l, C, U) : !!et
                            }, a.isError = Ei, a.isFinite = function(r) {
                                return "number" == typeof r && rI(r)
                            }, a.isFunction = Jn, a.isInteger = ea, a.isLength = ar, a.isMap = nZ, a.isMatch = function(r, l) {
                                return r === l || kr(r, l, gi(l))
                            }, a.isMatchWith = function(r, l, U) {
                                return U = "function" == typeof U ? U : C, kr(r, l, gi(l), U)
                            }, a.isNaN = function(r) {
                                return ia(r) && r != +r
                            }, a.isNative = function(r) {
                                if (r4(r)) throw new t_("Unsupported core-js use. Try https://npms.io/search?q=ponyfill.");
                                return Xs(r)
                            }, a.isNil = function(r) {
                                return null == r
                            }, a.isNull = function(r) {
                                return null === r
                            }, a.isNumber = ia, a.isObject = K, a.isObjectLike = Y, a.isPlainObject = pe, a.isRegExp = nX, a.isSafeInteger = function(r) {
                                return ea(r) && r >= -9007199254740991 && r <= 9007199254740991
                            }, a.isSet = nQ, a.isString = or, a.isSymbol = pn, a.isTypedArray = n0, a.isUndefined = function(r) {
                                return r === C
                            }, a.isWeakMap = function(r) {
                                return Y(r) && r8(r) == eP
                            }, a.isWeakSet = function(r) {
                                return Y(r) && "[object WeakSet]" == en(r)
                            }, a.join = function(r, l) {
                                return null == r ? "" : rS.call(r, l)
                            }, a.kebabCase = i_, a.last = In, a.lastIndexOf = function(r, l, U) {
                                var et = null == r ? 0 : r.length;
                                if (!et) return -1;
                                var eo = et;
                                return U !== C && (eo = (eo = R(U)) < 0 ? rA(et + eo, 0) : rP(eo, et - 1)), l == l ? function(r, l, C) {
                                    for (var U = C + 1; U-- && r[U] !== l;);
                                    return U
                                }(r, l, eo) : ye(r, Is, eo, !0)
                            }, a.lowerCase = ib, a.lowerFirst = iw, a.lt = n1, a.lte = n2, a.max = function(r) {
                                return r && r.length ? Ge(r, fn, Qr) : C
                            }, a.maxBy = function(r, l) {
                                return r && r.length ? Ge(r, x(l, 2), Qr) : C
                            }, a.mean = function(r) {
                                return xs(r, fn)
                            }, a.meanBy = function(r, l) {
                                return xs(r, x(l, 2))
                            }, a.min = function(r) {
                                return r && r.length ? Ge(r, fn, ni) : C
                            }, a.minBy = function(r, l) {
                                return r && r.length ? Ge(r, x(l, 2), ni) : C
                            }, a.stubArray = Hi, a.stubFalse = Ni, a.stubObject = function() {
                                return {}
                            }, a.stubString = function() {
                                return ""
                            }, a.stubTrue = function() {
                                return !0
                            }, a.multiply = i$, a.nth = function(r, l) {
                                return r && r.length ? nu(r, R(l)) : C
                            }, a.noConflict = function() {
                                return t3._ === this && (t3._ = tU), this
                            }, a.noop = Di, a.now = nB, a.pad = function(r, l, C) {
                                r = W(r);
                                var U = (l = R(l)) ? Dt(r) : 0;
                                if (!l || U >= l) return r;
                                var et = (l - U) / 2;
                                return Ve(rb(et), C) + r + Ve(r_(et), C)
                            }, a.padEnd = function(r, l, C) {
                                r = W(r);
                                var U = (l = R(l)) ? Dt(r) : 0;
                                return l && U < l ? r + Ve(l - U, C) : r
                            }, a.padStart = function(r, l, C) {
                                r = W(r);
                                var U = (l = R(l)) ? Dt(r) : 0;
                                return l && U < l ? Ve(l - U, C) + r : r
                            }, a.parseInt = function(r, l, C) {
                                return C || null == l ? l = 0 : l && (l = +l), rk(W(r).replace(e1, ""), l || 0)
                            }, a.random = function(r, l, U) {
                                if (U && "boolean" != typeof U && rn(r, l, U) && (l = U = C), U === C && ("boolean" == typeof l ? (U = l, l = C) : "boolean" == typeof r && (U = r, r = C)), r === C && l === C ? (r = 0, l = 1) : (r = Xn(r), l === C ? (l = r, r = 0) : l = Xn(l)), r > l) {
                                    var et = r;
                                    r = l, l = et
                                }
                                if (U || r % 1 || l % 1) {
                                    var eo = rN();
                                    return rP(r + eo * (l - r + tQ("1e-" + ((eo + "").length - 1))), l)
                                }
                                return ei(r, l)
                            }, a.reduce = function(r, l, C) {
                                var U = nK(r) ? Hr : Es,
                                    et = arguments.length < 3;
                                return U(r, x(l, 4), C, et, rJ)
                            }, a.reduceRight = function(r, l, C) {
                                var U = nK(r) ? jo : Es,
                                    et = arguments.length < 3;
                                return U(r, x(l, 4), C, et, rY)
                            }, a.repeat = function(r, l, U) {
                                return l = (U ? rn(r, l, U) : l === C) ? 1 : R(l), ri(W(r), l)
                            }, a.replace = function() {
                                var r = arguments,
                                    l = W(r[0]);
                                return r.length < 3 ? l : l.replace(r[1], r[2])
                            }, a.result = function(r, l, U) {
                                l = st(l, r);
                                var et = -1,
                                    eo = l.length;
                                for (eo || (eo = 1, r = C); ++et < eo;) {
                                    var es = null == r ? C : r[Wn(l[et])];
                                    es === C && (et = eo, es = U), r = Jn(es) ? es.call(r) : es
                                }
                                return r
                            }, a.round = iz, a.runInContext = h, a.sample = function(r) {
                                return (nK(r) ? Ms : function(r) {
                                    return Ms(Gt(r))
                                })(r)
                            }, a.size = function(r) {
                                if (null == r) return 0;
                                if (an(r)) return or(r) ? Dt(r) : r.length;
                                var l = r8(r);
                                return l == e_ || l == eS ? r.size : jr(r).length
                            }, a.snakeCase = iE, a.some = function(r, l, U) {
                                var et = nK(r) ? Nr : Mc;
                                return U && rn(r, l, U) && (l = C), et(r, x(l, 3))
                            }, a.sortedIndex = function(r, l) {
                                return Ye(r, l)
                            }, a.sortedIndexBy = function(r, l, C) {
                                return ii(r, l, x(C, 2))
                            }, a.sortedIndexOf = function(r, l) {
                                var C = null == r ? 0 : r.length;
                                if (C) {
                                    var U = Ye(r, l);
                                    if (U < C && bn(r[U], l)) return U
                                }
                                return -1
                            }, a.sortedLastIndex = function(r, l) {
                                return Ye(r, l, !0)
                            }, a.sortedLastIndexBy = function(r, l, C) {
                                return ii(r, l, x(C, 2), !0)
                            }, a.sortedLastIndexOf = function(r, l) {
                                if (null == r ? 0 : r.length) {
                                    var C = Ye(r, l, !0) - 1;
                                    if (bn(r[C], l)) return C
                                }
                                return -1
                            }, a.startCase = iI, a.startsWith = function(r, l, C) {
                                return r = W(r), C = null == C ? 0 : vt(R(C), 0, r.length), l = ln(l), r.slice(C, C + l.length) == l
                            }, a.subtract = iH, a.sum = function(r) {
                                return r && r.length ? Wr(r, fn) : 0
                            }, a.sumBy = function(r, l) {
                                return r && r.length ? Wr(r, x(l, 2)) : 0
                            }, a.template = function(r, l, U) {
                                var et = a.templateSettings;
                                U && rn(r, l, U) && (l = C), r = W(r), l = n6({}, l, et, Eu);
                                var eo, es, el = n6({}, l.imports, et.imports, Eu),
                                    ec = V(el),
                                    ed = Mr(el, ec),
                                    eh = 0,
                                    ef = l.interpolate || th,
                                    ep = "__p += '",
                                    eg = tI((l.escape || th).source + "|" + ef.source + "|" + (ef === eJ ? e7 : th).source + "|" + (l.evaluate || th).source + "|$", "g"),
                                    ey = "//# sourceURL=" + (tO.call(l, "sourceURL") ? (l.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++tJ + "]") + `
`;
                                r.replace(eg, function(l, C, U, et, el, ec) {
                                    return U || (U = et), ep += r.slice(eh, ec).replace(tf, cf), C && (eo = !0, ep += `' +
__e(` + C + `) +
'`), el && (es = !0, ep += `';
` + el + `;
__p += '`), U && (ep += `' +
((__t = (` + U + `)) == null ? '' : __t) +
'`), eh = ec + l.length, l
                                }), ep += `';
`;
                                var em = tO.call(l, "variable") && l.variable;
                                if (em) {
                                    if (e4.test(em)) throw new t_("Invalid `variable` option passed into `_.template`")
                                } else ep = `with (obj) {
` + ep + `
}
`;
                                ep = (es ? ep.replace(ej, "") : ep).replace(e$, "$1").replace(ez, "$1;"), ep = "function(" + (em || "obj") + `) {
` + (em ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (eo ? ", __e = _.escape" : "") + (es ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + ep + `return __p
}`;
                                var e_ = iA(function() {
                                    return tb(ec, ey + "return " + ep).apply(C, ed)
                                });
                                if (e_.source = ep, Ei(e_)) throw e_;
                                return e_
                            }, a.times = function(r, l) {
                                if ((r = R(r)) < 1 || r > 9007199254740991) return [];
                                var C = 4294967295,
                                    U = rP(r, 4294967295);
                                l = x(l), r -= 4294967295;
                                for (var et = Fr(U, l); ++C < r;) l(C);
                                return et
                            }, a.toFinite = Xn, a.toInteger = R, a.toLength = aa, a.toLower = function(r) {
                                return W(r).toLowerCase()
                            }, a.toNumber = xn, a.toSafeInteger = function(r) {
                                return r ? vt(R(r), -9007199254740991, 9007199254740991) : 0 === r ? r : 0
                            }, a.toString = W, a.toUpper = function(r) {
                                return W(r).toUpperCase()
                            }, a.trim = function(r, l, U) {
                                if ((r = W(r)) && (U || l === C)) return ys(r);
                                if (!r || !(l = ln(l))) return r;
                                var et = On(r),
                                    eo = On(l),
                                    es = Ss(et, eo),
                                    el = Os(et, eo) + 1;
                                return ut(et, es, el).join("")
                            }, a.trimEnd = function(r, l, U) {
                                if ((r = W(r)) && (U || l === C)) return r.slice(0, bs(r) + 1);
                                if (!r || !(l = ln(l))) return r;
                                var et = On(r),
                                    eo = Os(et, On(l)) + 1;
                                return ut(et, 0, eo).join("")
                            }, a.trimStart = function(r, l, U) {
                                if ((r = W(r)) && (U || l === C)) return r.replace(e1, "");
                                if (!r || !(l = ln(l))) return r;
                                var et = On(r),
                                    eo = Ss(et, On(l));
                                return ut(et, eo).join("")
                            }, a.truncate = function(r, l) {
                                var U = 30,
                                    et = "...";
                                if (K(l)) {
                                    var eo = "separator" in l ? l.separator : eo;
                                    U = "length" in l ? R(l.length) : U, et = "omission" in l ? ln(l.omission) : et
                                }
                                var es = (r = W(r)).length;
                                if (Lt(r)) {
                                    var el = On(r);
                                    es = el.length
                                }
                                if (U >= es) return r;
                                var ec = U - Dt(et);
                                if (ec < 1) return et;
                                var ed = el ? ut(el, 0, ec).join("") : r.slice(0, ec);
                                if (eo === C) return ed + et;
                                if (el && (ec += ed.length - ec), nX(eo)) {
                                    if (r.slice(ec).search(eo)) {
                                        var eh, ef = ed;
                                        for (eo.global || (eo = tI(eo.source, W(tn.exec(eo)) + "g")), eo.lastIndex = 0; eh = eo.exec(ef);) var ep = eh.index;
                                        ed = ed.slice(0, ep === C ? ec : ep)
                                    }
                                } else if (r.indexOf(ln(eo), ec) != ec) {
                                    var eg = ed.lastIndexOf(eo);
                                    eg > -1 && (ed = ed.slice(0, eg))
                                }
                                return ed + et
                            }, a.unescape = function(r) {
                                return (r = W(r)) && eW.test(r) ? r.replace(eH, rg) : r
                            }, a.uniqueId = function(r) {
                                var l = ++tT;
                                return W(r) + l
                            }, a.upperCase = iS, a.upperFirst = ix, a.each = Zu, a.eachRight = Ju, a.first = Gu, Li(a, (tg = {}, $n(a, function(r, l) {
                                tO.call(a.prototype, l) || (tg[l] = r)
                            }), tg), {
                                chain: !1
                            }), a.VERSION = "4.17.21", mn(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(r) {
                                a[r].placeholder = a
                            }), mn(["drop", "take"], function(r, l) {
                                H.prototype[r] = function(U) {
                                    U = U === C ? 1 : rA(R(U), 0);
                                    var et = this.__filtered__ && !l ? new H(this) : this.clone();
                                    return et.__filtered__ ? et.__takeCount__ = rP(U, et.__takeCount__) : et.__views__.push({
                                        size: rP(U, 4294967295),
                                        type: r + (et.__dir__ < 0 ? "Right" : "")
                                    }), et
                                }, H.prototype[r + "Right"] = function(l) {
                                    return this.reverse()[r](l).reverse()
                                }
                            }), mn(["filter", "map", "takeWhile"], function(r, l) {
                                var C = l + 1,
                                    U = 1 == C || 3 == C;
                                H.prototype[r] = function(r) {
                                    var l = this.clone();
                                    return l.__iteratees__.push({
                                        iteratee: x(r, 3),
                                        type: C
                                    }), l.__filtered__ = l.__filtered__ || U, l
                                }
                            }), mn(["head", "last"], function(r, l) {
                                var C = "take" + (l ? "Right" : "");
                                H.prototype[r] = function() {
                                    return this[C](1).value()[0]
                                }
                            }), mn(["initial", "tail"], function(r, l) {
                                var C = "drop" + (l ? "" : "Right");
                                H.prototype[r] = function() {
                                    return this.__filtered__ ? new H(this) : this[C](1)
                                }
                            }), H.prototype.compact = function() {
                                return this.filter(fn)
                            }, H.prototype.find = function(r) {
                                return this.filter(r).head()
                            }, H.prototype.findLast = function(r) {
                                return this.reverse().find(r)
                            }, H.prototype.invokeMap = L(function(r, l) {
                                return "function" == typeof r ? new H(this) : this.map(function(C) {
                                    return ae(C, r, l)
                                })
                            }), H.prototype.reject = function(r) {
                                return this.filter(ur(x(r)))
                            }, H.prototype.slice = function(r, l) {
                                r = R(r);
                                var U = this;
                                return U.__filtered__ && (r > 0 || l < 0) ? new H(U) : (r < 0 ? U = U.takeRight(-r) : r && (U = U.drop(r)), l !== C && (U = (l = R(l)) < 0 ? U.dropRight(-l) : U.take(l - r)), U)
                            }, H.prototype.takeRightWhile = function(r) {
                                return this.reverse().takeWhile(r).reverse()
                            }, H.prototype.toArray = function() {
                                return this.take(4294967295)
                            }, $n(H.prototype, function(r, l) {
                                var U = /^(?:filter|find|map|reject)|While$/.test(l),
                                    et = /^(?:head|last)$/.test(l),
                                    eo = a[et ? "take" + ("last" == l ? "Right" : "") : l],
                                    es = et || /^find/.test(l);
                                eo && (a.prototype[l] = function() {
                                    var l = this.__wrapped__,
                                        el = et ? [1] : arguments,
                                        ec = l instanceof H,
                                        ed = el[0],
                                        eh = ec || nK(l),
                                        m = function(r) {
                                            var l = eo.apply(a, nt([r], el));
                                            return et && ef ? l[0] : l
                                        };
                                    eh && U && "function" == typeof ed && 1 != ed.length && (ec = eh = !1);
                                    var ef = this.__chain__,
                                        ep = !!this.__actions__.length,
                                        eg = es && !ef,
                                        ey = ec && !ep;
                                    if (!es && eh) {
                                        l = ey ? l : new H(this);
                                        var em = r.apply(l, el);
                                        return em.__actions__.push({
                                            func: er,
                                            args: [m],
                                            thisArg: C
                                        }), new Pn(em, ef)
                                    }
                                    return eg && ey ? r.apply(this, el) : (em = this.thru(m), eg ? et ? em.value()[0] : em.value() : em)
                                })
                            }), mn(["pop", "push", "shift", "sort", "splice", "unshift"], function(r) {
                                var l = tA[r],
                                    C = /^(?:push|sort|unshift)$/.test(r) ? "tap" : "thru",
                                    U = /^(?:pop|shift)$/.test(r);
                                a.prototype[r] = function() {
                                    var r = arguments;
                                    if (U && !this.__chain__) {
                                        var et = this.value();
                                        return l.apply(nK(et) ? et : [], r)
                                    }
                                    return this[C](function(C) {
                                        return l.apply(nK(C) ? C : [], r)
                                    })
                                }
                            }), $n(H.prototype, function(r, l) {
                                var C = a[l];
                                if (C) {
                                    var U = C.name + "";
                                    tO.call(rj, U) || (rj[U] = []), rj[U].push({
                                        name: l,
                                        func: C
                                    })
                                }
                            }), rj[Xe(C, 2).name] = [{
                                name: "wrapper",
                                func: C
                            }], H.prototype.clone = function() {
                                var r = new H(this.__wrapped__);
                                return r.__actions__ = un(this.__actions__), r.__dir__ = this.__dir__, r.__filtered__ = this.__filtered__, r.__iteratees__ = un(this.__iteratees__), r.__takeCount__ = this.__takeCount__, r.__views__ = un(this.__views__), r
                            }, H.prototype.reverse = function() {
                                if (this.__filtered__) {
                                    var r = new H(this);
                                    r.__dir__ = -1, r.__filtered__ = !0
                                } else r = this.clone(), r.__dir__ *= -1;
                                return r
                            }, H.prototype.value = function() {
                                var r = this.__wrapped__.value(),
                                    l = this.__dir__,
                                    C = nK(r),
                                    U = l < 0,
                                    et = C ? r.length : 0,
                                    eo = function(r, l, C) {
                                        for (var U = -1, et = C.length; ++U < et;) {
                                            var eo = C[U],
                                                es = eo.size;
                                            switch (eo.type) {
                                                case "drop":
                                                    r += es;
                                                    break;
                                                case "dropRight":
                                                    l -= es;
                                                    break;
                                                case "take":
                                                    l = rP(l, r + es);
                                                    break;
                                                case "takeRight":
                                                    r = rA(r, l - es)
                                            }
                                        }
                                        return {
                                            start: r,
                                            end: l
                                        }
                                    }(0, et, this.__views__),
                                    es = eo.start,
                                    el = eo.end,
                                    ec = el - es,
                                    ed = U ? el : es - 1,
                                    eh = this.__iteratees__,
                                    ef = eh.length,
                                    ep = 0,
                                    eg = rP(ec, this.__takeCount__);
                                if (!C || !U && et == ec && eg == ec) return ou(r, this.__actions__);
                                var ey = [];
                                e: for (; ec-- && ep < eg;) {
                                    ed += l;
                                    for (var em = -1, e_ = r[ed]; ++em < ef;) {
                                        var eb = eh[em],
                                            ew = eb.iteratee,
                                            eE = eb.type,
                                            eI = ew(e_);
                                        if (2 == eE) e_ = eI;
                                        else if (!eI) {
                                            if (1 == eE) continue e;
                                            break e
                                        }
                                    }
                                    ey[ep++] = e_
                                }
                                return ey
                            }, a.prototype.at = nA, a.prototype.chain = function() {
                                return Yu(this)
                            }, a.prototype.commit = function() {
                                return new Pn(this.value(), this.__chain__)
                            }, a.prototype.next = function() {
                                this.__values__ === C && (this.__values__ = ua(this.value()));
                                var r = this.__index__ >= this.__values__.length,
                                    l = r ? C : this.__values__[this.__index__++];
                                return {
                                    done: r,
                                    value: l
                                }
                            }, a.prototype.plant = function(r) {
                                for (var l, U = this; U instanceof qe;) {
                                    var et = Fu(U);
                                    et.__index__ = 0, et.__values__ = C, l ? eo.__wrapped__ = et : l = et;
                                    var eo = et;
                                    U = U.__wrapped__
                                }
                                return eo.__wrapped__ = r, l
                            }, a.prototype.reverse = function() {
                                var r = this.__wrapped__;
                                if (r instanceof H) {
                                    var l = r;
                                    return this.__actions__.length && (l = new H(this)), (l = l.reverse()).__actions__.push({
                                        func: er,
                                        args: [Ai],
                                        thisArg: C
                                    }), new Pn(l, this.__chain__)
                                }
                                return this.thru(Ai)
                            }, a.prototype.toJSON = a.prototype.valueOf = a.prototype.value = function() {
                                return ou(this.__wrapped__, this.__actions__)
                            }, a.prototype.first = a.prototype.head, t5 && (a.prototype[t5] = function() {
                                return this
                            }), a
                        }();
                    t6 ? ((t6.exports = ry)._ = ry, t5._ = ry) : t3._ = ry
                }).call(o_)
            }(ob, ob.exports);
            var ow = Object.defineProperty,
                oE = Object.defineProperties,
                oI = Object.getOwnPropertyDescriptors,
                oS = Object.getOwnPropertySymbols,
                ox = Object.prototype.hasOwnProperty,
                oA = Object.prototype.propertyIsEnumerable,
                ya = (r, l, C) => l in r ? ow(r, l, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: C
                }) : r[l] = C,
                index_es_cr = (r, l) => {
                    for (var C in l || (l = {})) ox.call(l, C) && ya(r, C, l[C]);
                    if (oS)
                        for (var C of oS(l)) oA.call(l, C) && ya(r, C, l[C]);
                    return r
                },
                Yg = (r, l) => oE(r, oI(l));

            function dist_index_es_ft(r, l, C) {
                var U;
                let et = function(r) {
                    let [l, C] = r.split(":");
                    return {
                        namespace: l,
                        reference: C
                    }
                }(r);
                return (null == (U = l.rpcMap) ? void 0 : U[et.reference]) || `https://rpc.walletconnect.com/v1/?chainId=${et.namespace}:${et.reference}&projectId=${C}`
            }

            function dist_index_es_Ct(r) {
                return r.includes(":") ? r.split(":")[1] : r
            }

            function Sa(r) {
                return r.map(r => `${r.split(":")[0]}:${r.split(":")[1]}`)
            }

            function Oa(r) {
                var l, C, U, et;
                let eo = {};
                if (!B(r)) return eo;
                for (let [es, el] of Object.entries(r)) {
                    let r = oe(es) ? [es] : el.chains,
                        ec = el.methods || [],
                        ed = el.events || [],
                        eh = el.rpcMap || {},
                        ef = Xe(es);
                    eo[ef] = Yg(index_es_cr(index_es_cr({}, eo[ef]), el), {
                        chains: index_es_S(r, null == (l = eo[ef]) ? void 0 : l.chains),
                        methods: index_es_S(ec, null == (C = eo[ef]) ? void 0 : C.methods),
                        events: index_es_S(ed, null == (U = eo[ef]) ? void 0 : U.events),
                        rpcMap: index_es_cr(index_es_cr({}, eh), null == (et = eo[ef]) ? void 0 : et.rpcMap)
                    })
                }
                return eo
            }

            function Xg(r) {
                return r.includes(":") ? r.split(":")[2] : r
            }

            function index_es_Wi(r) {
                return "number" == typeof r ? r : r.includes("0x") ? parseInt(r, 16) : r.includes(":") ? Number(r.split(":")[1]) : Number(r)
            }
            let oP = {},
                dist_index_es_z = r => oP[r],
                Fi = (r, l) => {
                    oP[r] = l
                };
            let Vg = class Vg {
                constructor(r) {
                    this.name = "polkadot", this.namespace = r.namespace, this.events = dist_index_es_z("events"), this.client = dist_index_es_z("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
                }
                updateNamespace(r) {
                    this.namespace = Object.assign(this.namespace, r)
                }
                requestAccounts() {
                    return this.getAccounts()
                }
                getDefaultChain() {
                    if (this.chainId) return this.chainId;
                    if (this.namespace.defaultChain) return this.namespace.defaultChain;
                    let r = this.namespace.chains[0];
                    if (!r) throw Error("ChainId not found");
                    return r.split(":")[1]
                }
                request(r) {
                    return this.namespace.methods.includes(r.request.method) ? this.client.request(r) : this.getHttpProvider().request(r.request)
                }
                setDefaultChain(r, l) {
                    this.httpProviders[r] || this.setHttpProvider(r, l), this.chainId = r, this.events.emit(ov.DEFAULT_CHAIN_CHANGED, `${this.name}:${r}`)
                }
                getAccounts() {
                    let r = this.namespace.accounts;
                    return r && r.filter(r => r.split(":")[1] === this.chainId.toString()).map(r => r.split(":")[2]) || []
                }
                createHttpProviders() {
                    let r = {};
                    return this.namespace.chains.forEach(l => {
                        var C;
                        let U = dist_index_es_Ct(l);
                        r[U] = this.createHttpProvider(U, null == (C = this.namespace.rpcMap) ? void 0 : C[l])
                    }), r
                }
                getHttpProvider() {
                    let r = `${this.name}:${this.chainId}`,
                        l = this.httpProviders[r];
                    if (typeof l > "u") throw Error(`JSON-RPC provider for ${r} not found`);
                    return l
                }
                setHttpProvider(r, l) {
                    let C = this.createHttpProvider(r, l);
                    C && (this.httpProviders[r] = C)
                }
                createHttpProvider(r, l) {
                    let C = l || dist_index_es_ft(r, this.namespace, this.client.core.projectId);
                    if (!C) throw Error(`No RPC url provided for chainId: ${r}`);
                    return new n_.r(new og.Z(C, dist_index_es_z("disableProviderPing")))
                }
            };
            let kg = class kg {
                constructor(r) {
                    this.name = "eip155", this.namespace = r.namespace, this.events = dist_index_es_z("events"), this.client = dist_index_es_z("client"), this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain())
                }
                async request(r) {
                    switch (r.request.method) {
                        case "eth_requestAccounts":
                        case "eth_accounts":
                            return this.getAccounts();
                        case "wallet_switchEthereumChain":
                            return await this.handleSwitchChain(r);
                        case "eth_chainId":
                            return parseInt(this.getDefaultChain())
                    }
                    return this.namespace.methods.includes(r.request.method) ? await this.client.request(r) : this.getHttpProvider().request(r.request)
                }
                updateNamespace(r) {
                    this.namespace = Object.assign(this.namespace, r)
                }
                setDefaultChain(r, l) {
                    this.httpProviders[r] || this.setHttpProvider(parseInt(r), l), this.chainId = parseInt(r), this.events.emit(ov.DEFAULT_CHAIN_CHANGED, `${this.name}:${r}`)
                }
                requestAccounts() {
                    return this.getAccounts()
                }
                getDefaultChain() {
                    if (this.chainId) return this.chainId.toString();
                    if (this.namespace.defaultChain) return this.namespace.defaultChain;
                    let r = this.namespace.chains[0];
                    if (!r) throw Error("ChainId not found");
                    return r.split(":")[1]
                }
                createHttpProvider(r, l) {
                    let C = l || dist_index_es_ft(`${this.name}:${r}`, this.namespace, this.client.core.projectId);
                    if (!C) throw Error(`No RPC url provided for chainId: ${r}`);
                    return new n_.r(new og.k(C, dist_index_es_z("disableProviderPing")))
                }
                setHttpProvider(r, l) {
                    let C = this.createHttpProvider(r, l);
                    C && (this.httpProviders[r] = C)
                }
                createHttpProviders() {
                    let r = {};
                    return this.namespace.chains.forEach(l => {
                        var C;
                        let U = parseInt(dist_index_es_Ct(l));
                        r[U] = this.createHttpProvider(U, null == (C = this.namespace.rpcMap) ? void 0 : C[l])
                    }), r
                }
                getAccounts() {
                    let r = this.namespace.accounts;
                    return r ? [...new Set(r.filter(r => r.split(":")[1] === this.chainId.toString()).map(r => r.split(":")[2]))] : []
                }
                getHttpProvider() {
                    let r = this.chainId,
                        l = this.httpProviders[r];
                    if (typeof l > "u") throw Error(`JSON-RPC provider for ${r} not found`);
                    return l
                }
                async handleSwitchChain(r) {
                    var l, C;
                    let U = r.request.params ? null == (l = r.request.params[0]) ? void 0 : l.chainId : "0x0";
                    U = U.startsWith("0x") ? U : `0x${U}`;
                    let et = parseInt(U, 16);
                    if (this.isChainApproved(et)) this.setDefaultChain(`${et}`);
                    else if (this.namespace.methods.includes("wallet_switchEthereumChain")) await this.client.request({
                        topic: r.topic,
                        request: {
                            method: r.request.method,
                            params: [{
                                chainId: U
                            }]
                        },
                        chainId: null == (C = this.namespace.chains) ? void 0 : C[0]
                    }), this.setDefaultChain(`${et}`);
                    else throw Error(`Failed to switch to chain 'eip155:${et}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);
                    return null
                }
                isChainApproved(r) {
                    return this.namespace.chains.includes(`${this.name}:${r}`)
                }
            };
            let jg = class jg {
                constructor(r) {
                    this.name = "solana", this.namespace = r.namespace, this.events = dist_index_es_z("events"), this.client = dist_index_es_z("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
                }
                updateNamespace(r) {
                    this.namespace = Object.assign(this.namespace, r)
                }
                requestAccounts() {
                    return this.getAccounts()
                }
                request(r) {
                    return this.namespace.methods.includes(r.request.method) ? this.client.request(r) : this.getHttpProvider().request(r.request)
                }
                setDefaultChain(r, l) {
                    this.httpProviders[r] || this.setHttpProvider(r, l), this.chainId = r, this.events.emit(ov.DEFAULT_CHAIN_CHANGED, `${this.name}:${r}`)
                }
                getDefaultChain() {
                    if (this.chainId) return this.chainId;
                    if (this.namespace.defaultChain) return this.namespace.defaultChain;
                    let r = this.namespace.chains[0];
                    if (!r) throw Error("ChainId not found");
                    return r.split(":")[1]
                }
                getAccounts() {
                    let r = this.namespace.accounts;
                    return r ? [...new Set(r.filter(r => r.split(":")[1] === this.chainId.toString()).map(r => r.split(":")[2]))] : []
                }
                createHttpProviders() {
                    let r = {};
                    return this.namespace.chains.forEach(l => {
                        var C;
                        let U = dist_index_es_Ct(l);
                        r[U] = this.createHttpProvider(U, null == (C = this.namespace.rpcMap) ? void 0 : C[l])
                    }), r
                }
                getHttpProvider() {
                    let r = `${this.name}:${this.chainId}`,
                        l = this.httpProviders[r];
                    if (typeof l > "u") throw Error(`JSON-RPC provider for ${r} not found`);
                    return l
                }
                setHttpProvider(r, l) {
                    let C = this.createHttpProvider(r, l);
                    C && (this.httpProviders[r] = C)
                }
                createHttpProvider(r, l) {
                    let C = l || dist_index_es_ft(r, this.namespace, this.client.core.projectId);
                    if (!C) throw Error(`No RPC url provided for chainId: ${r}`);
                    return new n_.r(new og.Z(C, dist_index_es_z("disableProviderPing")))
                }
            };
            let nv = class nv {
                constructor(r) {
                    this.name = "cosmos", this.namespace = r.namespace, this.events = dist_index_es_z("events"), this.client = dist_index_es_z("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
                }
                updateNamespace(r) {
                    this.namespace = Object.assign(this.namespace, r)
                }
                requestAccounts() {
                    return this.getAccounts()
                }
                getDefaultChain() {
                    if (this.chainId) return this.chainId;
                    if (this.namespace.defaultChain) return this.namespace.defaultChain;
                    let r = this.namespace.chains[0];
                    if (!r) throw Error("ChainId not found");
                    return r.split(":")[1]
                }
                request(r) {
                    return this.namespace.methods.includes(r.request.method) ? this.client.request(r) : this.getHttpProvider().request(r.request)
                }
                setDefaultChain(r, l) {
                    this.httpProviders[r] || this.setHttpProvider(r, l), this.chainId = r, this.events.emit(ov.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`)
                }
                getAccounts() {
                    let r = this.namespace.accounts;
                    return r ? [...new Set(r.filter(r => r.split(":")[1] === this.chainId.toString()).map(r => r.split(":")[2]))] : []
                }
                createHttpProviders() {
                    let r = {};
                    return this.namespace.chains.forEach(l => {
                        var C;
                        let U = dist_index_es_Ct(l);
                        r[U] = this.createHttpProvider(U, null == (C = this.namespace.rpcMap) ? void 0 : C[l])
                    }), r
                }
                getHttpProvider() {
                    let r = `${this.name}:${this.chainId}`,
                        l = this.httpProviders[r];
                    if (typeof l > "u") throw Error(`JSON-RPC provider for ${r} not found`);
                    return l
                }
                setHttpProvider(r, l) {
                    let C = this.createHttpProvider(r, l);
                    C && (this.httpProviders[r] = C)
                }
                createHttpProvider(r, l) {
                    let C = l || dist_index_es_ft(r, this.namespace, this.client.core.projectId);
                    if (!C) throw Error(`No RPC url provided for chainId: ${r}`);
                    return new n_.r(new og.Z(C, dist_index_es_z("disableProviderPing")))
                }
            };
            let tv = class tv {
                constructor(r) {
                    this.name = "cip34", this.namespace = r.namespace, this.events = dist_index_es_z("events"), this.client = dist_index_es_z("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
                }
                updateNamespace(r) {
                    this.namespace = Object.assign(this.namespace, r)
                }
                requestAccounts() {
                    return this.getAccounts()
                }
                getDefaultChain() {
                    if (this.chainId) return this.chainId;
                    if (this.namespace.defaultChain) return this.namespace.defaultChain;
                    let r = this.namespace.chains[0];
                    if (!r) throw Error("ChainId not found");
                    return r.split(":")[1]
                }
                request(r) {
                    return this.namespace.methods.includes(r.request.method) ? this.client.request(r) : this.getHttpProvider().request(r.request)
                }
                setDefaultChain(r, l) {
                    this.httpProviders[r] || this.setHttpProvider(r, l), this.chainId = r, this.events.emit(ov.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`)
                }
                getAccounts() {
                    let r = this.namespace.accounts;
                    return r ? [...new Set(r.filter(r => r.split(":")[1] === this.chainId.toString()).map(r => r.split(":")[2]))] : []
                }
                createHttpProviders() {
                    let r = {};
                    return this.namespace.chains.forEach(l => {
                        let C = this.getCardanoRPCUrl(l),
                            U = dist_index_es_Ct(l);
                        r[U] = this.createHttpProvider(U, C)
                    }), r
                }
                getHttpProvider() {
                    let r = `${this.name}:${this.chainId}`,
                        l = this.httpProviders[r];
                    if (typeof l > "u") throw Error(`JSON-RPC provider for ${r} not found`);
                    return l
                }
                getCardanoRPCUrl(r) {
                    let l = this.namespace.rpcMap;
                    if (l) return l[r]
                }
                setHttpProvider(r, l) {
                    let C = this.createHttpProvider(r, l);
                    C && (this.httpProviders[r] = C)
                }
                createHttpProvider(r, l) {
                    let C = l || this.getCardanoRPCUrl(r);
                    if (!C) throw Error(`No RPC url provided for chainId: ${r}`);
                    return new n_.r(new og.Z(C, dist_index_es_z("disableProviderPing")))
                }
            };
            let ev = class ev {
                constructor(r) {
                    this.name = "elrond", this.namespace = r.namespace, this.events = dist_index_es_z("events"), this.client = dist_index_es_z("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
                }
                updateNamespace(r) {
                    this.namespace = Object.assign(this.namespace, r)
                }
                requestAccounts() {
                    return this.getAccounts()
                }
                request(r) {
                    return this.namespace.methods.includes(r.request.method) ? this.client.request(r) : this.getHttpProvider().request(r.request)
                }
                setDefaultChain(r, l) {
                    this.httpProviders[r] || this.setHttpProvider(r, l), this.chainId = r, this.events.emit(ov.DEFAULT_CHAIN_CHANGED, `${this.name}:${r}`)
                }
                getDefaultChain() {
                    if (this.chainId) return this.chainId;
                    if (this.namespace.defaultChain) return this.namespace.defaultChain;
                    let r = this.namespace.chains[0];
                    if (!r) throw Error("ChainId not found");
                    return r.split(":")[1]
                }
                getAccounts() {
                    let r = this.namespace.accounts;
                    return r ? [...new Set(r.filter(r => r.split(":")[1] === this.chainId.toString()).map(r => r.split(":")[2]))] : []
                }
                createHttpProviders() {
                    let r = {};
                    return this.namespace.chains.forEach(l => {
                        var C;
                        let U = dist_index_es_Ct(l);
                        r[U] = this.createHttpProvider(U, null == (C = this.namespace.rpcMap) ? void 0 : C[l])
                    }), r
                }
                getHttpProvider() {
                    let r = `${this.name}:${this.chainId}`,
                        l = this.httpProviders[r];
                    if (typeof l > "u") throw Error(`JSON-RPC provider for ${r} not found`);
                    return l
                }
                setHttpProvider(r, l) {
                    let C = this.createHttpProvider(r, l);
                    C && (this.httpProviders[r] = C)
                }
                createHttpProvider(r, l) {
                    let C = l || dist_index_es_ft(r, this.namespace, this.client.core.projectId);
                    if (!C) throw Error(`No RPC url provided for chainId: ${r}`);
                    return new n_.r(new og.Z(C, dist_index_es_z("disableProviderPing")))
                }
            };
            let rv = class rv {
                constructor(r) {
                    this.name = "multiversx", this.namespace = r.namespace, this.events = dist_index_es_z("events"), this.client = dist_index_es_z("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
                }
                updateNamespace(r) {
                    this.namespace = Object.assign(this.namespace, r)
                }
                requestAccounts() {
                    return this.getAccounts()
                }
                request(r) {
                    return this.namespace.methods.includes(r.request.method) ? this.client.request(r) : this.getHttpProvider().request(r.request)
                }
                setDefaultChain(r, l) {
                    this.httpProviders[r] || this.setHttpProvider(r, l), this.chainId = r, this.events.emit(ov.DEFAULT_CHAIN_CHANGED, `${this.name}:${r}`)
                }
                getDefaultChain() {
                    if (this.chainId) return this.chainId;
                    if (this.namespace.defaultChain) return this.namespace.defaultChain;
                    let r = this.namespace.chains[0];
                    if (!r) throw Error("ChainId not found");
                    return r.split(":")[1]
                }
                getAccounts() {
                    let r = this.namespace.accounts;
                    return r ? [...new Set(r.filter(r => r.split(":")[1] === this.chainId.toString()).map(r => r.split(":")[2]))] : []
                }
                createHttpProviders() {
                    let r = {};
                    return this.namespace.chains.forEach(l => {
                        var C;
                        let U = dist_index_es_Ct(l);
                        r[U] = this.createHttpProvider(U, null == (C = this.namespace.rpcMap) ? void 0 : C[l])
                    }), r
                }
                getHttpProvider() {
                    let r = `${this.name}:${this.chainId}`,
                        l = this.httpProviders[r];
                    if (typeof l > "u") throw Error(`JSON-RPC provider for ${r} not found`);
                    return l
                }
                setHttpProvider(r, l) {
                    let C = this.createHttpProvider(r, l);
                    C && (this.httpProviders[r] = C)
                }
                createHttpProvider(r, l) {
                    let C = l || dist_index_es_ft(r, this.namespace, this.client.core.projectId);
                    if (!C) throw Error(`No RPC url provided for chainId: ${r}`);
                    return new n_.r(new og.Z(C, dist_index_es_z("disableProviderPing")))
                }
            };
            let iv = class iv {
                constructor(r) {
                    this.name = "near", this.namespace = r.namespace, this.events = dist_index_es_z("events"), this.client = dist_index_es_z("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders()
                }
                updateNamespace(r) {
                    this.namespace = Object.assign(this.namespace, r)
                }
                requestAccounts() {
                    return this.getAccounts()
                }
                getDefaultChain() {
                    if (this.chainId) return this.chainId;
                    if (this.namespace.defaultChain) return this.namespace.defaultChain;
                    let r = this.namespace.chains[0];
                    if (!r) throw Error("ChainId not found");
                    return r.split(":")[1]
                }
                request(r) {
                    return this.namespace.methods.includes(r.request.method) ? this.client.request(r) : this.getHttpProvider().request(r.request)
                }
                setDefaultChain(r, l) {
                    if (this.chainId = r, !this.httpProviders[r]) {
                        let C = l || dist_index_es_ft(`${this.name}:${r}`, this.namespace);
                        if (!C) throw Error(`No RPC url provided for chainId: ${r}`);
                        this.setHttpProvider(r, C)
                    }
                    this.events.emit(ov.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`)
                }
                getAccounts() {
                    let r = this.namespace.accounts;
                    return r && r.filter(r => r.split(":")[1] === this.chainId.toString()).map(r => r.split(":")[2]) || []
                }
                createHttpProviders() {
                    let r = {};
                    return this.namespace.chains.forEach(l => {
                        var C;
                        r[l] = this.createHttpProvider(l, null == (C = this.namespace.rpcMap) ? void 0 : C[l])
                    }), r
                }
                getHttpProvider() {
                    let r = `${this.name}:${this.chainId}`,
                        l = this.httpProviders[r];
                    if (typeof l > "u") throw Error(`JSON-RPC provider for ${r} not found`);
                    return l
                }
                setHttpProvider(r, l) {
                    let C = this.createHttpProvider(r, l);
                    C && (this.httpProviders[r] = C)
                }
                createHttpProvider(r, l) {
                    let C = l || dist_index_es_ft(r, this.namespace);
                    return typeof C > "u" ? void 0 : new n_.r(new og.Z(C, dist_index_es_z("disableProviderPing")))
                }
            };
            var oC = Object.defineProperty,
                ok = Object.defineProperties,
                oN = Object.getOwnPropertyDescriptors,
                oO = Object.getOwnPropertySymbols,
                oT = Object.prototype.hasOwnProperty,
                oR = Object.prototype.propertyIsEnumerable,
                Ta = (r, l, C) => l in r ? oC(r, l, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: C
                }) : r[l] = C,
                index_es_hr = (r, l) => {
                    for (var C in l || (l = {})) oT.call(l, C) && Ta(r, C, l[C]);
                    if (oO)
                        for (var C of oO(l)) oR.call(l, C) && Ta(r, C, l[C]);
                    return r
                },
                Mi = (r, l) => ok(r, oN(l));
            let index_es_lr = class index_es_lr {
                constructor(r) {
                    this.events = new(tj()), this.rpcProviders = {}, this.shouldAbortPairingAttempt = !1, this.maxPairingAttempts = 10, this.disableProviderPing = !1, this.providerOpts = r, this.logger = "u" > typeof r ? .logger && "string" != typeof r ? .logger ? r.logger : (0, tJ.pino)((0, tJ.getDefaultLoggerOptions)({
                        level: r ? .logger || oy
                    })), this.disableProviderPing = r ? .disableProviderPing || !1
                }
                static async init(r) {
                    let l = new index_es_lr(r);
                    return await l.initialize(), l
                }
                async request(r, l) {
                    let [C, U] = this.validateChain(l);
                    if (!this.session) throw Error("Please call connect() before request()");
                    return await this.getProvider(C).request({
                        request: index_es_hr({}, r),
                        chainId: `${C}:${U}`,
                        topic: this.session.topic
                    })
                }
                sendAsync(r, l, C) {
                    this.request(r, C).then(r => l(null, r)).catch(r => l(r, void 0))
                }
                async enable() {
                    if (!this.client) throw Error("Sign Client not initialized");
                    return this.session || await this.connect({
                        namespaces: this.namespaces,
                        optionalNamespaces: this.optionalNamespaces,
                        sessionProperties: this.sessionProperties
                    }), await this.requestAccounts()
                }
                async disconnect() {
                    var r;
                    if (!this.session) throw Error("Please call connect() before enable()");
                    await this.client.disconnect({
                        topic: null == (r = this.session) ? void 0 : r.topic,
                        reason: index_es_U("USER_DISCONNECTED")
                    }), await this.cleanup()
                }
                async connect(r) {
                    if (!this.client) throw Error("Sign Client not initialized");
                    if (this.setNamespaces(r), await this.cleanupPendingPairings(), !r.skipPairing) return await this.pair(r.pairingTopic)
                }
                on(r, l) {
                    this.events.on(r, l)
                }
                once(r, l) {
                    this.events.once(r, l)
                }
                removeListener(r, l) {
                    this.events.removeListener(r, l)
                }
                off(r, l) {
                    this.events.off(r, l)
                }
                get isWalletConnect() {
                    return !0
                }
                async pair(r) {
                    this.shouldAbortPairingAttempt = !1;
                    let l = 0;
                    do {
                        if (this.shouldAbortPairingAttempt) throw Error("Pairing aborted");
                        if (l >= this.maxPairingAttempts) throw Error("Max auto pairing attempts reached");
                        let {
                            uri: C,
                            approval: U
                        } = await this.client.connect({
                            pairingTopic: r,
                            requiredNamespaces: this.namespaces,
                            optionalNamespaces: this.optionalNamespaces,
                            sessionProperties: this.sessionProperties
                        });
                        C && (this.uri = C, this.events.emit("display_uri", C)), await U().then(r => {
                            this.session = r, this.namespaces || (this.namespaces = function(r) {
                                let l = {};
                                for (let [C, U] of Object.entries(r)) {
                                    let r = U.methods || [],
                                        et = U.events || [],
                                        eo = U.accounts || [],
                                        es = oe(C) ? [C] : U.chains ? U.chains : Sa(U.accounts);
                                    l[C] = {
                                        chains: es,
                                        methods: r,
                                        events: et,
                                        accounts: eo
                                    }
                                }
                                return l
                            }(r.namespaces), this.persist("namespaces", this.namespaces))
                        }).catch(r => {
                            if (r.message !== i8) throw r;
                            l++
                        })
                    } while (!this.session);
                    return this.onConnect(), this.session
                }
                setDefaultChain(r, l) {
                    try {
                        if (!this.session) return;
                        let [C, U] = this.validateChain(r);
                        this.getProvider(C).setDefaultChain(U, l)
                    } catch (r) {
                        if (!/Please call connect/.test(r.message)) throw r
                    }
                }
                async cleanupPendingPairings(r = {}) {
                    this.logger.info("Cleaning up inactive pairings...");
                    let l = this.client.pairing.getAll();
                    if (index_es_k(l)) {
                        for (let C of l) r.deletePairings ? this.client.core.expirer.set(C.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(C.topic);
                        this.logger.info(`Inactive pairings cleared: ${l.length}`)
                    }
                }
                abortPairingAttempt() {
                    this.shouldAbortPairingAttempt = !0
                }
                async checkStorage() {
                    if (this.namespaces = await this.getFromStore("namespaces"), this.optionalNamespaces = await this.getFromStore("optionalNamespaces") || {}, this.client.session.length) {
                        let r = this.client.session.keys.length - 1;
                        this.session = this.client.session.get(this.client.session.keys[r]), this.createProviders()
                    }
                }
                async initialize() {
                    this.logger.trace("Initialized"), await this.createClient(), await this.checkStorage(), this.registerEventListeners()
                }
                async createClient() {
                    this.client = this.providerOpts.client || await dist_index_es_Q.init({
                        logger: this.providerOpts.logger || oy,
                        relayUrl: this.providerOpts.relayUrl || "wss://relay.walletconnect.com",
                        projectId: this.providerOpts.projectId,
                        metadata: this.providerOpts.metadata,
                        storageOptions: this.providerOpts.storageOptions,
                        storage: this.providerOpts.storage,
                        name: this.providerOpts.name
                    }), this.logger.trace("SignClient Initialized")
                }
                createProviders() {
                    if (!this.client) throw Error("Sign Client not initialized");
                    if (!this.session) throw Error("Session not initialized. Please call connect() before enable()");
                    let r = [...new Set(Object.keys(this.session.namespaces).map(r => Xe(r)))];
                    Fi("client", this.client), Fi("events", this.events), Fi("disableProviderPing", this.disableProviderPing), r.forEach(r => {
                        if (!this.session) return;
                        let l = function(r, l) {
                                let C = Object.keys(l.namespaces).filter(l => l.includes(r));
                                if (!C.length) return [];
                                let U = [];
                                return C.forEach(r => {
                                    let C = l.namespaces[r].accounts;
                                    U.push(...C)
                                }), U
                            }(r, this.session),
                            C = Sa(l),
                            U = function(r = {}, l = {}) {
                                let C = Oa(r),
                                    U = Oa(l);
                                return ob.exports.merge(C, U)
                            }(this.namespaces, this.optionalNamespaces),
                            et = Mi(index_es_hr({}, U[r]), {
                                accounts: l,
                                chains: C
                            });
                        switch (r) {
                            case "eip155":
                                this.rpcProviders[r] = new kg({
                                    namespace: et
                                });
                                break;
                            case "solana":
                                this.rpcProviders[r] = new jg({
                                    namespace: et
                                });
                                break;
                            case "cosmos":
                                this.rpcProviders[r] = new nv({
                                    namespace: et
                                });
                                break;
                            case "polkadot":
                                this.rpcProviders[r] = new Vg({
                                    namespace: et
                                });
                                break;
                            case "cip34":
                                this.rpcProviders[r] = new tv({
                                    namespace: et
                                });
                                break;
                            case "elrond":
                                this.rpcProviders[r] = new ev({
                                    namespace: et
                                });
                                break;
                            case "multiversx":
                                this.rpcProviders[r] = new rv({
                                    namespace: et
                                });
                                break;
                            case "near":
                                this.rpcProviders[r] = new iv({
                                    namespace: et
                                })
                        }
                    })
                }
                registerEventListeners() {
                    if (typeof this.client > "u") throw Error("Sign Client is not initialized");
                    this.client.on("session_ping", r => {
                        this.events.emit("session_ping", r)
                    }), this.client.on("session_event", r => {
                        let {
                            params: l
                        } = r, {
                            event: C
                        } = l;
                        if ("accountsChanged" === C.name) {
                            let r = C.data;
                            r && index_es_k(r) && this.events.emit("accountsChanged", r.map(Xg))
                        } else if ("chainChanged" === C.name) {
                            let r = l.chainId,
                                C = l.event.data,
                                U = Xe(r),
                                et = index_es_Wi(r) !== index_es_Wi(C) ? `${U}:${index_es_Wi(C)}` : r;
                            this.onChainChanged(et)
                        } else this.events.emit(C.name, C.data);
                        this.events.emit("session_event", r)
                    }), this.client.on("session_update", ({
                        topic: r,
                        params: l
                    }) => {
                        var C;
                        let {
                            namespaces: U
                        } = l, et = null == (C = this.client) ? void 0 : C.session.get(r);
                        this.session = Mi(index_es_hr({}, et), {
                            namespaces: U
                        }), this.onSessionUpdate(), this.events.emit("session_update", {
                            topic: r,
                            params: l
                        })
                    }), this.client.on("session_delete", async r => {
                        await this.cleanup(), this.events.emit("session_delete", r), this.events.emit("disconnect", Mi(index_es_hr({}, index_es_U("USER_DISCONNECTED")), {
                            data: r.topic
                        }))
                    }), this.on(ov.DEFAULT_CHAIN_CHANGED, r => {
                        this.onChainChanged(r, !0)
                    })
                }
                getProvider(r) {
                    if (!this.rpcProviders[r]) throw Error(`Provider not found: ${r}`);
                    return this.rpcProviders[r]
                }
                onSessionUpdate() {
                    Object.keys(this.rpcProviders).forEach(r => {
                        var l;
                        this.getProvider(r).updateNamespace(null == (l = this.session) ? void 0 : l.namespaces[r])
                    })
                }
                setNamespaces(r) {
                    let {
                        namespaces: l,
                        optionalNamespaces: C,
                        sessionProperties: U
                    } = r;
                    l && Object.keys(l).length && (this.namespaces = l), C && Object.keys(C).length && (this.optionalNamespaces = C), this.sessionProperties = U, this.persist("namespaces", l), this.persist("optionalNamespaces", C)
                }
                validateChain(r) {
                    let [l, C] = r ? .split(":") || ["", ""];
                    if (!this.namespaces || !Object.keys(this.namespaces).length) return [l, C];
                    if (l && !Object.keys(this.namespaces || {}).map(r => Xe(r)).includes(l)) throw Error(`Namespace '${l}' is not configured. Please call connect() first with namespace config.`);
                    if (l && C) return [l, C];
                    let U = Xe(Object.keys(this.namespaces)[0]),
                        et = this.rpcProviders[U].getDefaultChain();
                    return [U, et]
                }
                async requestAccounts() {
                    let [r] = this.validateChain();
                    return await this.getProvider(r).requestAccounts()
                }
                onChainChanged(r, l = !1) {
                    var C;
                    if (!this.namespaces) return;
                    let [U, et] = this.validateChain(r);
                    l || this.getProvider(U).setDefaultChain(et), (null != (C = this.namespaces[U]) ? C : this.namespaces[`${U}:${et}`]).defaultChain = et, this.persist("namespaces", this.namespaces), this.events.emit("chainChanged", et)
                }
                onConnect() {
                    this.createProviders(), this.events.emit("connect", {
                        session: this.session
                    })
                }
                async cleanup() {
                    this.session = void 0, this.namespaces = void 0, this.optionalNamespaces = void 0, this.sessionProperties = void 0, this.persist("namespaces", void 0), this.persist("optionalNamespaces", void 0), this.persist("sessionProperties", void 0), await this.cleanupPendingPairings({
                        deletePairings: !0
                    })
                }
                persist(r, l) {
                    this.client.core.storage.setItem(`${om}/${r}`, l)
                }
                async getFromStore(r) {
                    return await this.client.core.storage.getItem(`${om}/${r}`)
                }
            };
            var oD = C(95569);
            let parseIntSafe = (r, l = 10) => {
                    try {
                        let C = parseInt(String(r), l);
                        if (isNaN(C)) {
                            tb.kg.error(`Error parsing ${r}`);
                            return
                        }
                        return C
                    } catch (l) {
                        tb.kg.error(`Error parsing ${r} to int: ${l}`)
                    }
                },
                activeAccountKey = r => `dynamic-wc2-active-account-${r}`,
                sessionTopicKey = r => `dynamic-wc2-session-topic-${r}`,
                swicthedNetworkKey = r => `dynamic-wc2-switched-network-${r}`,
                currentChainKey = r => `dynamic-wc2-current-chain-${r}`,
                oB = new oD.Z;
            let WalletConnectV2 = class WalletConnectV2 extends EthWalletConnector {
                constructor(r) {
                    var l;
                    super(r), this.supportedChains = ["EVM", "ETH"], this.connectedChain = "EVM", this.isInitialized = !1, this.canConnectViaQrCode = !0, this.isWalletConnect = !0, this.preferredChains = [], this._hasSwitchedNetwork = !1, this.name = r.walletName, this.projectId = r.projectId, this.deepLinkPreference = r.deepLinkPreference || "native", this.preferredChains = r.walletConnectPreferredChains || [], this.hasSwitchedNetwork = l = !!localStorage.getItem(this.swicthedNetworkKey);
                    let C = localStorage.getItem(this.currentChainKey);
                    this.currentChainId = C ? parseIntSafe(C) : void 0
                }
                getMappedChains() {
                    return this.evmNetworks.filter(r => 11297108109 !== r.chainId).map(r => `eip155:${r.chainId}`)
                }
                getMappedChainsByPreferredOrder() {
                    let r = this.getMappedChains();
                    r.includes("eip155:1") || r.push("eip155:1");
                    let l = this.preferredChains.filter(l => r.includes(l)),
                        C = r.filter(r => !this.preferredChains.includes(r));
                    return [...l, ...C]
                }
                initConnection() {
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        let {
                            provider: r
                        } = WalletConnectV2;
                        if (!r) throw new tE.kW("No provider found (init connection)");
                        if (null == r ? void 0 : r.uri) return;
                        let l = {
                            eip155: {
                                chains: this.getMappedChainsByPreferredOrder(),
                                events: ["chainChanged", "accountsChanged"],
                                methods: ["eth_chainId", "eth_signTypedData", "eth_signTransaction", "eth_sign", "personal_sign", "eth_sendTransaction", "eth_signTypedData_v4", "wallet_switchEthereumChain", "wallet_addEthereumChain"],
                                rpcMap: this.evmNetworkRpcMap()
                            }
                        };
                        r.connect({
                            optionalNamespaces: l
                        }).catch(r => {
                            tb.kg.error(r), oB.emit("walletconnect_connection_failed", r)
                        })
                    })
                }
                createInitProviderPromise() {
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        let r = yield index_es_lr.init({
                            logger: "debug" === tb.kg.logLevel.toLowerCase() ? "debug" : void 0,
                            projectId: this.projectId
                        });
                        WalletConnectV2.provider = r, this.teardownEventListeners(), this.setupEventListeners()
                    })
                }
                initProvider() {
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        let {
                            provider: r
                        } = WalletConnectV2;
                        r || (void 0 === this.initializePromise && (this.initializePromise = this.createInitProviderPromise()), yield this.initializePromise)
                    })
                }
                refreshSession() {
                    var r, l, C, U, et;
                    (null === (l = null === (r = WalletConnectV2.provider) || void 0 === r ? void 0 : r.session) || void 0 === l ? void 0 : l.topic) && localStorage.getItem(this.sessionTopicKey) === (null === (U = null === (C = WalletConnectV2.provider) || void 0 === C ? void 0 : C.session) || void 0 === U ? void 0 : U.topic) && (this.session = WalletConnectV2.provider.session, this.activeAccount = null !== (et = localStorage.getItem(this.activeAccountKey)) && void 0 !== et ? et : void 0)
                }
                init() {
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        yield this.initProvider(), yield this.initConnection(), this.isInitialized = !0
                    })
                }
                get sessionTopicKey() {
                    return sessionTopicKey(this.key)
                }
                get activeAccountKey() {
                    return activeAccountKey(this.key)
                }
                get swicthedNetworkKey() {
                    return swicthedNetworkKey(this.key)
                }
                get currentChainKey() {
                    return currentChainKey(this.key)
                }
                set currentChainId(r) {
                    this._currentChainId = r, r ? localStorage.setItem(this.currentChainKey, r.toString()) : localStorage.removeItem(this.currentChainKey)
                }
                get currentChainId() {
                    return this._currentChainId
                }
                set hasSwitchedNetwork(r) {
                    this._hasSwitchedNetwork = r, r ? localStorage.setItem(this.swicthedNetworkKey, r.toString()) : localStorage.removeItem(this.swicthedNetworkKey)
                }
                get hasSwitchedNetwork() {
                    return this._hasSwitchedNetwork
                }
                supportsNetworkSwitching() {
                    return !0
                }
                setupEventListeners() {
                    WalletConnectV2.provider && (WalletConnectV2.provider.client.on("session_event", ({
                        params: r
                    }) => {
                        if (tb.kg.debug("session_event was called", {
                                params: r
                            }), !r || !r.event) {
                            tb.kg.debug("session_event was called without params or params.event");
                            return
                        }
                        let {
                            name: l,
                            data: C
                        } = r.event;
                        if ("chainChanged" === l) {
                            let r = parseIntSafe(C);
                            if (void 0 === r) {
                                tb.kg.debug(`received unexpected data for chainChanged: ${C} with type ${typeof C}}`);
                                return
                            }
                            this.currentChainId = r, this.emit("chainChange", {
                                chain: String(r)
                            }), this.switchNetwork({
                                networkChainId: r
                            })
                        } else if ("accountsChanged" === l) {
                            if (!Array.isArray(C)) {
                                tb.kg.debug(`received unexpected data for accountsChanged: ${C} with type ${typeof C}}`);
                                return
                            }
                            let r = C[0].split(":")[2];
                            this.setActiveAccount(r)
                        }
                    }), WalletConnectV2.provider.client.on("session_delete", () => _tslib_awaiter(this, void 0, void 0, function*() {
                        this.endSession(), this.emit("disconnect")
                    })))
                }
                teardownEventListeners() {
                    WalletConnectV2.provider && (WalletConnectV2.provider.client.removeAllListeners("session_event"), WalletConnectV2.provider.client.removeAllListeners("session_delete"))
                }
                getWalletClient() {
                    if (WalletConnectV2.provider) return (0, tB.K)({
                        transport: (0, tU.P)(WalletConnectV2.provider)
                    })
                }
                fetchPublicAddress(r) {
                    var l, C;
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        if (this.activeAccount) return this.activeAccount;
                        if ((!WalletConnectV2.provider || !(null === (l = WalletConnectV2.provider) || void 0 === l ? void 0 : l.uri)) && (tb.kg.debug("No WC2 provider found, re-initializing..."), yield this.endSession(), yield this.init(), yield new Promise(r => setTimeout(r, 1e3)), !WalletConnectV2.provider || !(null === (C = WalletConnectV2.provider) || void 0 === C ? void 0 : C.uri))) throw tb.kg.debug("No WC2 provider found, escaping and throwing error"), new tE.kW("No provider found");
                        let U = (0, tD.MO)(this.walletBook, this.key);
                        return (0, tb.ze)(WalletConnectV2.provider.uri, U, {
                            onDesktopUri: null == r ? void 0 : r.onDesktopUri,
                            onDisplayUri: null == r ? void 0 : r.onDisplayUri
                        }, this.deepLinkPreference), new Promise((r, l) => {
                            if (!WalletConnectV2.provider) {
                                l(new tE.kW("No provider found"));
                                return
                            }
                            oB.on("walletconnect_connection_failed", () => {
                                let r = new tE.kW("Connection rejected. Please try again.");
                                r.code = "connection_rejected", WalletConnectV2.provider && (WalletConnectV2.provider.uri = void 0, this.init()), l(r)
                            }), WalletConnectV2.provider.on("connect", ({
                                session: C
                            }) => {
                                C || l(new tE.kW("No session found")), this.setSession(C), this.setActiveAccount(C.namespaces.eip155.accounts[0].split(":")[2]), r(this.activeAccount)
                            })
                        })
                    })
                }
                waitForSignMessage(r, l) {
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        let C = new Promise(C => {
                                this.on("chainChange", () => C({
                                    success: !1
                                })), r(l).then(r => C({
                                    signedMessage: r,
                                    success: !0
                                }))
                            }),
                            U = yield C;
                        return !1 === U.success ? r(l) : U.signedMessage
                    })
                }
                getDeepLink() {
                    var r;
                    if (!this.session) return;
                    let l = (0, tD.MO)(this.walletBook, this.key),
                        C = (0, tb.bW)({
                            metadata: l,
                            mode: "regular",
                            preference: this.deepLinkPreference,
                            uri: null === (r = WalletConnectV2.provider) || void 0 === r ? void 0 : r.uri
                        });
                    if (C) return `${C}?sessionTopic=${this.session.topic}`
                }
                signMessage(r) {
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        if (!this.session) throw new tE.kW("no session");
                        let l = this.getWalletClient();
                        if (!l) throw new tE.kW("No WalletConnect provider found to handle signing");
                        let C = this.getDeepLink();
                        (0, tE.tq)() && C && (window.location.href = C);
                        let U = yield this.waitForSignMessage(r => _tslib_awaiter(this, void 0, void 0, function*() {
                            let {
                                activeAccount: C
                            } = this;
                            if (C) return l.signMessage({
                                account: C,
                                message: r
                            })
                        }), r);
                        return U
                    })
                }
                clearActiveAccount() {
                    localStorage.removeItem(this.activeAccountKey), this.activeAccount = void 0
                }
                clearSession() {
                    localStorage.removeItem(this.sessionTopicKey), this.session = void 0
                }
                setActiveAccount(r) {
                    localStorage.setItem(this.activeAccountKey, r), this.activeAccount = r, this.emit("accountChange", {
                        accounts: [r]
                    })
                }
                setSession(r) {
                    localStorage.setItem(this.sessionTopicKey, r.topic), this.session = r
                }
                endSession() {
                    var r;
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        if (this.clearActiveAccount(), this.clearSession(), this.hasSwitchedNetwork = !1, this.currentChainId = void 0, null === (r = WalletConnectV2.provider) || void 0 === r ? void 0 : r.session) try {
                            yield WalletConnectV2.provider.disconnect(), WalletConnectV2.provider = void 0
                        } catch (r) {
                            tb.kg.debug(r)
                        }
                    })
                }
                getNetwork() {
                    let r = Object.create(null, {
                        getNetwork: {
                            get: () => super.getNetwork
                        }
                    });
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        return this.currentChainId ? this.currentChainId : (yield this.initProvider(), r.getNetwork.call(this))
                    })
                }
                providerSwitchNetwork({
                    network: r,
                    provider: l
                }) {
                    let C = Object.create(null, {
                        providerSwitchNetwork: {
                            get: () => super.providerSwitchNetwork
                        }
                    });
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        let U = yield this.getNetwork();
                        if (!U || U !== r.chainId) {
                            if (this.switchNetworkOnlyFromWallet) throw new tE.kW("Network switching is only supported through the wallet");
                            if (!this.supportsNetworkSwitching()) throw new tE.kW("Network switching not supported");
                            if (!l) throw new tE.kW("Provider not found");
                            yield C.providerSwitchNetwork.call(this, {
                                network: r,
                                provider: l
                            }), this.currentChainId = r.chainId, this.hasSwitchedNetwork = !0, this.emit("chainChange", {
                                chain: String(r.chainId)
                            })
                        }
                    })
                }
                getConnectedAccounts() {
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        return (!1 === this.isInitialized && (yield this.initProvider(), this.refreshSession(), this.isInitialized = !0), this.activeAccount) ? [this.activeAccount] : []
                    })
                }
                isMetaMask() {
                    var r, l, C, U, et;
                    return null !== (et = null === (U = null === (C = null === (l = null === (r = this.session) || void 0 === r ? void 0 : r.peer) || void 0 === l ? void 0 : l.metadata) || void 0 === C ? void 0 : C.name) || void 0 === U ? void 0 : U.toLowerCase().startsWith("metamask")) && void 0 !== et && et
                }
                getSupportedNetworks() {
                    var r;
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        if (this.isMetaMask() && !this.hasSwitchedNetwork) return this.evmNetworks.map(r => r.chainId.toString());
                        if (yield this.initProvider(), this.refreshSession(), !this.session) return [];
                        let l = [];
                        return Object.keys(this.session.namespaces).forEach(r => {
                            r.startsWith("eip155:") && l.push(r.split(":")[1])
                        }), null === (r = this.session.namespaces.eip155) || void 0 === r || r.accounts.forEach(r => l.push(r.split(":")[1])), l.length ? l : this.evmNetworks.map(r => r.chainId.toString())
                    })
                }
            };
            var oU = C(13319);
            let oL = "87939db78f824920ada5c872db3e56b8";
            var oM = C(95125);
            let initClient = (r, l, C) => {
                    let U = `walletconnect-${r}`,
                        et = localStorage.getItem(U),
                        eo = et ? {
                            session: JSON.parse(et),
                            storageId: U
                        } : {
                            bridge: l,
                            storageId: U
                        };
                    return new oM.Z(Object.assign(Object.assign({}, eo), C))
                },
                setupWalletConnectEventListeners = (r, l) => {
                    let C, U;
                    l && (l.connected && (C = l.accounts[0], U = l.chainId), l.on("disconnect", () => _tslib_awaiter(void 0, void 0, void 0, function*() {
                        r.emit("disconnect")
                    })), l.on("session_update", (l, et) => _tslib_awaiter(void 0, void 0, void 0, function*() {
                        let {
                            accounts: l,
                            chainId: eo
                        } = et.params[0], es = !(0, tb.Wr)(C || "", l[0], "eip155"), el = U !== eo;
                        C = l[0], U = eo, es && r.emit("accountChange", {
                            accounts: l
                        }), el && r.emit("chainChange", {
                            chain: String(eo)
                        })
                    })))
                },
                teardownWalletConnectEventListeners = r => {
                    r.off("disconnect"), r.off("session_update")
                },
                killWalletConnectSession = r => _tslib_awaiter(void 0, void 0, void 0, function*() {
                    try {
                        (null == r ? void 0 : r.connected) && (yield r.killSession())
                    } catch (r) {
                        tb.kg.debug(r)
                    }
                }),
                createSession = r => _tslib_awaiter(void 0, void 0, void 0, function*() {
                    return new Promise((l, C) => {
                        r.on("connect", (r, C) => _tslib_awaiter(void 0, void 0, void 0, function*() {
                            if (r) throw r;
                            l(C)
                        })), r.on("disconnect", (r, l) => {
                            C(r || l.params[0].message)
                        })
                    })
                }),
                fetchWalletConnectEVMPublicAddress = (r, l, C, U) => _tslib_awaiter(void 0, void 0, void 0, function*() {
                    var et;
                    if (l.connected) {
                        let [r] = l.accounts;
                        return r
                    }
                    yield l.createSession(), (0, tb.ze)(l.uri, r, {
                        onDesktopUri: null == U ? void 0 : U.onDesktopUri,
                        onDisplayUri: null == U ? void 0 : U.onDisplayUri
                    }, C);
                    let eo = yield createSession(l);
                    null === (et = null == U ? void 0 : U.onConnect) || void 0 === et || et.call(U, eo);
                    let [es] = eo.params[0].accounts;
                    return es
                }),
                signWalletConnectPersonalMessage = (r, l, C, U, et) => _tslib_awaiter(void 0, void 0, void 0, function*() {
                    var eo, es;
                    let el = (null === (eo = null == C ? void 0 : C.peerMeta) || void 0 === eo ? void 0 : eo.name) === "Crypto.com | DeFi Wallet" || (null === (es = null == C ? void 0 : C.peerMeta) || void 0 === es ? void 0 : es.name) === "DeFi Wallet";
                    if (!C || !C.connected) return;
                    let [ec] = C.accounts;
                    if ((0, tE.tq)()) {
                        let r = (0, tb.bW)({
                            metadata: l,
                            mode: "regular",
                            preference: U,
                            uri: C.uri
                        });
                        window.location.href = r
                    }
                    try {
                        el && (0, tE.tq)() ? yield client_sleep(4e3): yield client_sleep(1e3);
                        let l = yield C.signPersonalMessage([r, ec]);
                        return yield waitForSafeTransactionOrTimeout(ec, l, r, C, et), l
                    } catch (r) {
                        throw tb.kg.debug(r), r
                    }
                }),
                client_sleep = r => new Promise(l => setTimeout(l, r)),
                oj = ["function isValidSignature(bytes32 _message, bytes _signature) public view returns (bytes4)"],
                waitForSafeTransactionOrTimeout = (r, l, C, U, et) => _tslib_awaiter(void 0, void 0, void 0, function*() {
                    var eo;
                    if ("0x" === l && (null === (eo = U.peerMeta) || void 0 === eo ? void 0 : eo.name) === "WalletConnect Safe App") {
                        if (!et) return;
                        let U = waitForSafeTransaction(r, l, C, (yield et())),
                            eo = new Promise(r => {
                                setTimeout(r, 12e4)
                            });
                        yield Promise.race([U, eo])
                    }
                }),
                waitForSafeTransaction = (r, l, C, U) => _tslib_awaiter(void 0, void 0, void 0, function*() {
                    for (let et = 0; et < 120; et++) {
                        try {
                            let et = yield null == U ? void 0 : U.readContract({
                                abi: oj,
                                address: r,
                                args: [(0, eT.r)(C), l],
                                functionName: "isValidSignature"
                            });
                            if ("0x1626ba7e" === et) return
                        } catch (r) {
                            tb.kg.info("Safe transaction cannot be validated yet. Retrying.")
                        }
                        yield client_sleep(2e3)
                    }
                });
            let WalletConnect = class WalletConnect extends EthWalletConnector {
                constructor(r) {
                    var {
                        walletConnectV1Bridge: l,
                        walletName: C
                    } = r, U = __rest(r, ["walletConnectV1Bridge", "walletName"]);
                    super(U), this.supportedChains = ["EVM", "ETH"], this.connectedChain = "EVM", this.bridge = "https://bridge.walletconnect.org", this.canConnectViaQrCode = !0, this.isWalletConnect = !0, this.switchNetworkOnlyFromWallet = !1, this.name = C, l && (this.bridge = l), this.deepLinkPreference = U.deepLinkPreference || "native"
                }
                getClient() {
                    return this.client || (this.client = initClient(this.key, this.bridge, this.clientOptions)), this.client
                }
                supportsNetworkSwitching() {
                    if ("EVM" === this.connectedChain) return !0; {
                        let r = this.getClient();
                        return !!(null == r ? void 0 : r.chainId)
                    }
                }
                setupEventListeners() {
                    setupWalletConnectEventListeners(this, this.getClient())
                }
                teardownEventListeners() {
                    teardownWalletConnectEventListeners(this.getClient())
                }
                getWalletClient() {
                    let r = this.getClient();
                    return r ? (0, tB.K)({
                        transport: (0, tU.P)(new oU.default({
                            connector: r,
                            infuraId: oL,
                            rpc: this.evmNetworkRpcMap()
                        }))
                    }) : void 0
                }
                fetchPublicAddress(r) {
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        return fetchWalletConnectEVMPublicAddress((0, tD.MO)(this.walletBook, this.key), this.getClient(), this.deepLinkPreference, Object.assign(Object.assign({}, r), {
                            onConnect: l => {
                                var C, U;
                                null === (C = null == r ? void 0 : r.onConnect) || void 0 === C || C.call(r, l), this.connectedChain = l.params[0].chainId ? "EVM" : "SOL", (null === (U = l.params[0].accounts) || void 0 === U ? void 0 : U.length) && this.emit("accountChange", {
                                    accounts: l.params[0].accounts
                                })
                            }
                        }))
                    })
                }
                getDeepLink() {
                    var r;
                    let l = (0, tD.MO)(this.walletBook, this.key);
                    if ((0, tE.tq)() || (null === (r = l.desktop) || void 0 === r ? void 0 : r.native)) return (0, tb.bW)({
                        metadata: l,
                        mode: "regular",
                        preference: this.deepLinkPreference,
                        uri: this.getClient().uri
                    })
                }
                signMessage(r) {
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        return signWalletConnectPersonalMessage(r, (0, tD.MO)(this.walletBook, this.key), this.getClient(), this.deepLinkPreference, () => _tslib_awaiter(this, void 0, void 0, function*() {
                            return this.getPublicClient()
                        }))
                    })
                }
                endSession() {
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        killWalletConnectSession(this.getClient())
                    })
                }
                providerSwitchNetwork({
                    network: r,
                    provider: l
                }) {
                    let C = Object.create(null, {
                        providerSwitchNetwork: {
                            get: () => super.providerSwitchNetwork
                        }
                    });
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        let U = this.getClient(),
                            et = yield this.getNetwork();
                        if (!et || et !== r.chainId) {
                            if (void 0 !== this.switchNetworkOnlyFromWallet && this.switchNetworkOnlyFromWallet) throw new tE.kW("Network switching is only supported through the wallet");
                            if (!this.supportsNetworkSwitching()) throw new tE.kW("Network switching not supported");
                            if (!U) throw new tE.kW("Client not found");
                            if ((0, tE.tq)()) {
                                let r = (0, tb.bW)({
                                    metadata: (0, tD.MO)(this.walletBook, this.key),
                                    mode: "regular",
                                    preference: this.deepLinkPreference,
                                    uri: U.uri
                                });
                                window.location.href = r
                            }
                            return C.providerSwitchNetwork.call(this, {
                                network: r,
                                provider: l
                            })
                        }
                    })
                }
                getConnectedAccounts() {
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        let r = this.getClient();
                        return r.connected ? r.accounts : []
                    })
                }
                getSession() {
                    var r;
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        return null === (r = this.client) || void 0 === r ? void 0 : r.session
                    })
                }
            };
            let InjectedWalletBase = class InjectedWalletBase extends EthWalletConnector {
                constructor() {
                    super(...arguments), this.supportedChains = ["ETH", "EVM"], this.connectedChain = "EVM", this.walletConnectorFallback = !1
                }
                getEthProviderHelper() {
                    return this.wallet || (this.wallet = (0, tD.IP)(this.walletBook, this.key)), this.wallet && !this.ethProviderHelper && (this.ethProviderHelper = new EthProviderHelper(this.wallet)), this.ethProviderHelper
                }
                getMobileOrInstalledWallet() {
                    var r, l, C, U;
                    return this.walletConnectorFallback && !this.isInstalledOnBrowser() ? (this.wallet || (this.wallet = (0, tD.IP)(this.walletBook, this.key)), (null === (r = this.constructorProps) || void 0 === r ? void 0 : r.isWalletConnectV2Enabled) && (null === (U = null === (C = null === (l = this.wallet) || void 0 === l ? void 0 : l.walletConnect) || void 0 === C ? void 0 : C.sdks) || void 0 === U ? void 0 : U.includes("sign_v2"))) ? new WalletConnectV2(Object.assign(Object.assign({}, this.constructorProps), {
                        walletName: this.name
                    })) : new WalletConnect(Object.assign(Object.assign({}, this.constructorProps), {
                        walletName: this.name
                    })) : this
                }
                setupEventListeners() {
                    let r = this.getWalletClient();
                    if (!r) return;
                    let l = this.getEthProviderHelper();
                    if (!l) return;
                    let {
                        tearDownEventListeners: C
                    } = l._setupEventListeners(this);
                    this.teardownEventListeners = C
                }
                getWalletClient() {
                    var r;
                    return null === (r = this.getEthProviderHelper()) || void 0 === r ? void 0 : r.findWalletClient()
                }
                isInstalledOnBrowser() {
                    var r;
                    return (null === (r = this.getEthProviderHelper()) || void 0 === r ? void 0 : r.findProvider()) !== void 0
                }
                fetchPublicAddress() {
                    var r;
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        return null === (r = this.getEthProviderHelper()) || void 0 === r ? void 0 : r.fetchPublicAddress()
                    })
                }
                connect() {
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        yield this.fetchPublicAddress()
                    })
                }
                signMessage(r) {
                    var l;
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        return null === (l = this.getEthProviderHelper()) || void 0 === l ? void 0 : l.signMessage(r)
                    })
                }
                proveOwnership(r) {
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        return this.signMessage(r)
                    })
                }
                endSession() {
                    return _tslib_awaiter(this, void 0, void 0, function*() {})
                }
                providerSwitchNetwork({
                    network: r,
                    provider: l
                }) {
                    let C = Object.create(null, {
                        providerSwitchNetwork: {
                            get: () => super.providerSwitchNetwork
                        }
                    });
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        return C.providerSwitchNetwork.call(this, {
                            network: r,
                            provider: l
                        })
                    })
                }
            };
            let oq = [class extends InjectedWalletBase {
                    constructor(r) {
                        super(r), this.name = "PhantomEvm", this.wallet = (0, tD.IP)(this.walletBook, this.key)
                    }
                    fetchPublicAddress() {
                        let r = Object.create(null, {
                            fetchPublicAddress: {
                                get: () => super.fetchPublicAddress
                            }
                        });
                        return _tslib_awaiter(this, void 0, void 0, function*() {
                            if (this.isInstalledOnBrowser()) return r.fetchPublicAddress.call(this);
                            (0, tE.tq)() && (0, tE.Rc)({
                                nativeLink: "phantom://browse",
                                universalLink: "https://phantom.app/ul/browse"
                            })
                        })
                    }
                }, class extends InjectedWalletBase {
                    constructor(r) {
                        super(r), this.name = "ExodusEvm", this.walletConnectorFallback = !0, this.wallet = (0, tD.IP)(this.walletBook, this.key)
                    }
                }],
                o$ = ["phantomevm", "coinbase", "exodusevm"],
                fetchInjectedWalletConnector = ({
                    walletBook: r
                }) => {
                    var l;
                    return Object.entries(null !== (l = null == r ? void 0 : r.wallets) && void 0 !== l ? l : {}).filter(([r, l]) => {
                        var C;
                        return (null === (C = l.injectedConfig) || void 0 === C ? void 0 : C.find(r => "evm" === r.chain)) && !o$.includes(r)
                    }).map(([r, l]) => {
                        let {
                            shortName: C
                        } = l, U = C || l.name, et = !!l.walletConnect;
                        return class extends InjectedWalletBase {
                            constructor(C) {
                                super(Object.assign({}, C)), this.name = U, this.wallet = l, this.walletConnectorFallback = et, this.overrideKey = r
                            }
                        }
                    })
                },
                fetchWalletConnectWallets = ({
                    isWalletConnectV2Enabled: r,
                    walletBook: l
                }) => {
                    var C;
                    return Object.values(null !== (C = null == l ? void 0 : l.wallets) && void 0 !== C ? C : {}).filter(r => r.walletConnect && !r.filterFromWalletConnect).map(l => {
                        var C;
                        let {
                            shortName: U
                        } = l, et = U || l.name;
                        return r && (null === (C = l.walletConnect.sdks) || void 0 === C ? void 0 : C.includes("sign_v2")) ? class extends WalletConnectV2 {
                            constructor(r) {
                                super(Object.assign(Object.assign({}, r), {
                                    walletName: et
                                }))
                            }
                        } : class extends WalletConnect {
                            constructor(r) {
                                super(Object.assign(Object.assign({}, r), {
                                    walletName: et
                                }))
                            }
                        }
                    })
                },
                getWalletConnectConnector = ({
                    isWalletConnectV2Enabled: r
                }) => r ? class extends WalletConnectV2 {
                    constructor(r) {
                        super(Object.assign(Object.assign({}, r), {
                            walletName: "WalletConnect"
                        }))
                    }
                } : class extends WalletConnect {
                    constructor(r) {
                        super(Object.assign(Object.assign({}, r), {
                            walletName: "WalletConnect"
                        }))
                    }
                };
            var oz = C(39376),
                oH = C(79958);
            let oF = `https://mainnet.infura.io/v3/${oL}`,
                getCoinbaseProvider = ({
                    opts: {
                        appLogoUrl: r,
                        appName: l = "",
                        evmNetworks: C = []
                    } = {}
                }) => {
                    var U, et;
                    if (!eo) {
                        let es = new oz.CoinbaseWalletSDK({
                                appLogoUrl: r,
                                appName: l,
                                enableMobileWalletLink: !0,
                                headlessMode: !0,
                                reloadOnDisconnect: !1
                            }),
                            el = null == C ? void 0 : C.find(r => 1 === r.chainId),
                            ec = (null === (U = null == el ? void 0 : el.privateCustomerRpcUrls) || void 0 === U ? void 0 : U[0]) || (null === (et = null == el ? void 0 : el.rpcUrls) || void 0 === et ? void 0 : et[0]) || oF;
                        eo = es.makeWeb3Provider(ec, 1)
                    }
                    return eo
                },
                killCoinbaseSession = () => _tslib_awaiter(void 0, void 0, void 0, function*() {
                    yield null == eo ? void 0 : eo.close(), null == eo || eo.disconnect(), eo = void 0
                }),
                fetchPublicAddress = (r, l) => _tslib_awaiter(void 0, void 0, void 0, function*() {
                    var C;
                    let U = getCoinbaseProvider({
                            opts: r
                        }),
                        {
                            qrUrl: et
                        } = U;
                    if (!et) throw new tE.kW("no qr url available");
                    null === (C = null == l ? void 0 : l.onDisplayUri) || void 0 === C || C.call(l, et);
                    let [eo] = yield U.request({
                        method: "eth_requestAccounts"
                    });
                    return eo
                }),
                client_signMessage = (r, l) => _tslib_awaiter(void 0, void 0, void 0, function*() {
                    let C = getCoinbaseProvider({
                            opts: r
                        }),
                        [U] = yield C.request({
                            method: "eth_requestAccounts"
                        });
                    try {
                        return yield C.request({
                            method: "personal_sign",
                            params: [(0, to.NC)((0, oH.O0)(l)), U.toLowerCase()]
                        })
                    } catch (r) {
                        yield C.close();
                        return
                    }
                });
            let Coinbase = class Coinbase extends EthWalletConnector {
                constructor(r) {
                    var {
                        appName: l,
                        appLogoUrl: C,
                        evmNetworks: U
                    } = r;
                    super(Object.assign({
                        evmNetworks: U
                    }, __rest(r, ["appName", "appLogoUrl", "evmNetworks"]))), this.name = "Coinbase", this.supportedChains = ["EVM", "ETH"], this.connectedChain = "EVM", this.canConnectViaQrCode = !0, this.coinbaseProviderOpts = {
                        appLogoUrl: C,
                        appName: l,
                        evmNetworks: U
                    };
                    let et = (0, tD.IP)(this.walletBook, this.key);
                    if (!et) return;
                    this.ethProviderHelper = new EthProviderHelper(et)
                }
                setupEventListeners() {
                    var r, l, C;
                    let U = null === (r = this.ethProviderHelper) || void 0 === r ? void 0 : r.findProvider();
                    if (!U) return;
                    let et = null === (C = null === (l = this.ethProviderHelper) || void 0 === l ? void 0 : l._setupEventListeners) || void 0 === C ? void 0 : C.call(l, this);
                    (null == et ? void 0 : et.tearDownEventListeners) && (this.teardownEventListeners = et.tearDownEventListeners)
                }
                getWalletClient() {
                    var r;
                    return this.isInstalledOnBrowser() ? null === (r = this.ethProviderHelper) || void 0 === r ? void 0 : r.findWalletClient() : (0, tB.K)({
                        transport: (0, tU.P)(getCoinbaseProvider({
                            opts: this.coinbaseProviderOpts
                        }))
                    })
                }
                isInstalledOnBrowser() {
                    var r;
                    return (null === (r = this.ethProviderHelper) || void 0 === r ? void 0 : r.findProvider()) !== void 0
                }
                fetchPublicAddress(r) {
                    var l;
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        return this.isInstalledOnBrowser() ? null === (l = this.ethProviderHelper) || void 0 === l ? void 0 : l.fetchPublicAddress() : fetchPublicAddress(this.coinbaseProviderOpts, r)
                    })
                }
                signMessage(r) {
                    var l;
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        return this.isInstalledOnBrowser() ? null === (l = this.ethProviderHelper) || void 0 === l ? void 0 : l.signMessage(r) : client_signMessage(this.coinbaseProviderOpts, r)
                    })
                }
                endSession() {
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        this.isInstalledOnBrowser() || killCoinbaseSession()
                    })
                }
            };
            let EthereumWalletConnectors = r => [...oq, ...fetchInjectedWalletConnector(r), ...fetchWalletConnectWallets(r), ...TurnkeyWalletConnectors(r), Coinbase, getWalletConnectConnector(r)]
        },
        98267: function(r, l, C) {
            "use strict";
            let U, et, eo;
            C.d(l, {
                UL: function() {
                    return MagicEvmWalletConnectors
                }
            });
            var es, el, ec, ed, eh, ef, ep, eg, ey, em, e_, eb, ew, eE, eI, eS, ex, eA, eP, eC, ek, eN, eO, eT, eR, eD, eB, eU, eL, eM, ej, e$, ez, eH, eF, eW, eV, eK, eG, eJ = {};

            function _tslib_awaiter(r, l, C, U) {
                return new(C || (C = Promise))(function(et, eo) {
                    function fulfilled(r) {
                        try {
                            step(U.next(r))
                        } catch (r) {
                            eo(r)
                        }
                    }

                    function rejected(r) {
                        try {
                            step(U.throw(r))
                        } catch (r) {
                            eo(r)
                        }
                    }

                    function step(r) {
                        var l;
                        r.done ? et(r.value) : ((l = r.value) instanceof C ? l : new C(function(r) {
                            r(l)
                        })).then(fulfilled, rejected)
                    }
                    step((U = U.apply(r, l || [])).next())
                })
            }
            C.r(eJ), C.d(eJ, {
                Address: function() {
                    return o_
                },
                Array: function() {
                    return _Array
                },
                Bool: function() {
                    return ov
                },
                Character: function() {
                    return om
                },
                Dictionary: function() {
                    return Dictionary
                },
                Enum: function() {
                    return Enum
                },
                Event: function() {
                    return Event
                },
                Fix64: function() {
                    return og
                },
                Identity: function() {
                    return iX
                },
                Int: function() {
                    return i0
                },
                Int128: function() {
                    return oo
                },
                Int16: function() {
                    return i5
                },
                Int256: function() {
                    return ol
                },
                Int32: function() {
                    return i8
                },
                Int64: function() {
                    return i9
                },
                Int8: function() {
                    return i2
                },
                Optional: function() {
                    return Optional
                },
                Path: function() {
                    return oE
                },
                Reference: function() {
                    return ow
                },
                Resource: function() {
                    return Resource
                },
                String: function() {
                    return oy
                },
                Struct: function() {
                    return Struct
                },
                UFix64: function() {
                    return op
                },
                UInt: function() {
                    return iQ
                },
                UInt128: function() {
                    return i7
                },
                UInt16: function() {
                    return i3
                },
                UInt256: function() {
                    return os
                },
                UInt32: function() {
                    return i6
                },
                UInt64: function() {
                    return i4
                },
                UInt8: function() {
                    return i1
                },
                Void: function() {
                    return ob
                },
                Word16: function() {
                    return od
                },
                Word32: function() {
                    return oh
                },
                Word64: function() {
                    return of
                },
                Word8: function() {
                    return oc
                },
                _Array: function() {
                    return _Array
                }
            }), "function" == typeof SuppressedError && SuppressedError;
            var eY = C(95569),
                eZ = C(47969);
            let createEmailMagicWalletConnector = r => {
                var l;
                return (l = class extends r {
                    constructor() {
                        super(...arguments), this.name = "Magic Link", this.canConnectViaEmail = !0
                    }
                    get email() {
                        return this._email
                    }
                    setEmail(r) {
                        this._email = r, r ? localStorage.setItem(l.storageEmailKey, r) : localStorage.removeItem(l.storageEmailKey)
                    }
                    clearEmail() {
                        this.cancelPreviousEmail(), this.setEmail(void 0)
                    }
                    endSession() {
                        let r = Object.create(null, {
                            endSession: {
                                get: () => super.endSession
                            }
                        });
                        return _tslib_awaiter(this, void 0, void 0, function*() {
                            yield r.endSession.call(this), this.clearEmail()
                        })
                    }
                    cancelPreviousEmail() {
                        var r;
                        null === (r = this._currentAuthCancellablePromise) || void 0 === r || r.cancel()
                    }
                    loginWithMagic() {
                        return _tslib_awaiter(this, void 0, void 0, function*() {
                            let r = this.magicClient.getClient(),
                                l = yield this.getUserMetadata();
                            if (l && l.publicAddress) return this.setEmail(null == l ? void 0 : l.email), l.publicAddress;
                            let {
                                email: C
                            } = this;
                            return C ? r.auth.loginWithMagicLink({
                                email: C,
                                showUI: !1
                            }) : null
                        })
                    }
                }).storageEmailKey = "magic-link-email", l
            };
            var eX = ((es = eX || {}).MissingApiKey = "MISSING_API_KEY", es.ModalNotReady = "MODAL_NOT_READY", es.MalformedResponse = "MALFORMED_RESPONSE", es.InvalidArgument = "INVALID_ARGUMENT", es.ExtensionNotInitialized = "EXTENSION_NOT_INITIALIZED", es.IncompatibleExtensions = "INCOMPATIBLE_EXTENSIONS", es),
                eQ = ((el = eQ || {}).SyncWeb3Method = "SYNC_WEB3_METHOD", el.DuplicateIframe = "DUPLICATE_IFRAME", el.ReactNativeEndpointConfiguration = "REACT_NATIVE_ENDPOINT_CONFIGURATION", el.DeprecationNotice = "DEPRECATION_NOTICE", el),
                e0 = ((ec = e0 || {})[ec.ParseError = -32700] = "ParseError", ec[ec.InvalidRequest = -32600] = "InvalidRequest", ec[ec.MethodNotFound = -32601] = "MethodNotFound", ec[ec.InvalidParams = -32602] = "InvalidParams", ec[ec.InternalError = -32603] = "InternalError", ec[ec.MagicLinkFailedVerification = -1e4] = "MagicLinkFailedVerification", ec[ec.MagicLinkExpired = -10001] = "MagicLinkExpired", ec[ec.MagicLinkRateLimited = -10002] = "MagicLinkRateLimited", ec[ec.MagicLinkInvalidRedirectURL = -10006] = "MagicLinkInvalidRedirectURL", ec[ec.UserAlreadyLoggedIn = -10003] = "UserAlreadyLoggedIn", ec[ec.UpdateEmailFailed = -10004] = "UpdateEmailFailed", ec[ec.UserRequestEditEmail = -10005] = "UserRequestEditEmail", ec[ec.InactiveRecipient = -10010] = "InactiveRecipient", ec[ec.AccessDeniedToUser = -10011] = "AccessDeniedToUser", ec[ec.RedirectLoginComplete = -10015] = "RedirectLoginComplete", ec),
                e1 = ((ed = e1 || {}).MetaMask = "metamask", ed.CoinbaseWallet = "coinbase_wallet", ed),
                e2 = ((eh = e2 || {}).WalletSelected = "wallet_selected", eh.WalletConnected = "wallet_connected", eh.WalletRejected = "wallet_rejected", eh),
                e3 = ((ef = e3 || {}).LoginWithSms = "magic_auth_login_with_sms", ef.LoginWithEmailOTP = "magic_auth_login_with_email_otp", ef.LoginWithMagicLink = "magic_auth_login_with_magic_link", ef.LoginWithCredential = "magic_auth_login_with_credential", ef.SetAuthorizationToken = "magic_auth_set_authorization_token", ef.GetIdToken = "magic_auth_get_id_token", ef.GenerateIdToken = "magic_auth_generate_id_token", ef.GetMetadata = "magic_auth_get_metadata", ef.IsLoggedIn = "magic_is_logged_in", ef.Logout = "magic_auth_logout", ef.UpdateEmail = "magic_auth_update_email", ef.UserSettings = "magic_auth_settings", ef.UserSettingsTestMode = "magic_auth_settings_testing_mode", ef.LoginWithSmsTestMode = "magic_auth_login_with_sms_testing_mode", ef.LoginWithEmailOTPTestMode = "magic_auth_login_with_email_otp_testing_mode", ef.LoginWithMagicLinkTestMode = "magic_login_with_magic_link_testing_mode", ef.LoginWithCredentialTestMode = "magic_auth_login_with_credential_testing_mode", ef.GetIdTokenTestMode = "magic_auth_get_id_token_testing_mode", ef.GenerateIdTokenTestMode = "magic_auth_generate_id_token_testing_mode", ef.GetMetadataTestMode = "magic_auth_get_metadata_testing_mode", ef.IsLoggedInTestMode = "magic_auth_is_logged_in_testing_mode", ef.LogoutTestMode = "magic_auth_logout_testing_mode", ef.UpdateEmailTestMode = "magic_auth_update_email_testing_mode", ef.IntermediaryEvent = "magic_intermediary_event", ef.RequestAccounts = "eth_requestAccounts", ef.GetInfo = "magic_get_info", ef.ShowUI = "magic_wallet", ef.NFTPurchase = "magic_nft_purchase", ef.NFTCheckout = "magic_nft_checkout", ef.NFTTransfer = "magic_nft_transfer", ef.RequestUserInfoWithUI = "mc_request_user_info", ef.Disconnect = "mc_disconnect", ef.RecoverAccount = "magic_auth_recover_account", ef.RecoverAccountTestMode = "magic_auth_recover_account_testing_mode", ef.MagicBoxHeartBeat = "magic_box_heart_beat", ef.AutoConnect = "mc_auto_connect", ef.Login = "mc_login", ef.EncryptV1 = "magic_auth_encrypt_v1", ef.DecryptV1 = "magic_auth_decrypt_v1", ef.ShowNFTs = "magic_show_nfts", ef.ShowOnRamp = "magic_show_fiat_onramp", ef.ShowSendTokensUI = "magic_show_send_tokens_ui", ef.ShowAddress = "magic_show_address", ef.ShowBalances = "magic_show_balances", ef.SendGaslessTransaction = "eth_sendGaslessTransaction", ef),
                e5 = ((ep = e5 || {}).MAGIC_HANDLE_RESPONSE = "MAGIC_HANDLE_RESPONSE", ep.MAGIC_OVERLAY_READY = "MAGIC_OVERLAY_READY", ep.MAGIC_SHOW_OVERLAY = "MAGIC_SHOW_OVERLAY", ep.MAGIC_HIDE_OVERLAY = "MAGIC_HIDE_OVERLAY", ep.MAGIC_HANDLE_EVENT = "MAGIC_HANDLE_EVENT", ep.MAGIC_MG_BOX_SEND_RECEIPT = "MAGIC_MG_BOX_SEND_RECEIPT", ep),
                e6 = ((eg = e6 || {}).MAGIC_HANDLE_REQUEST = "MAGIC_HANDLE_REQUEST", eg),
                e8 = ((ey = e8 || {}).UpdateEmail = "update-email", ey.MFA = "mfa", ey.Recovery = "recovery", ey),
                e4 = ((em = e4 || {}).Retry = "retry", em),
                e9 = ((e_ = e9 || {}).EmailSent = "email-sent", e_.EmailNotDeliverable = "email-not-deliverable", e_),
                e7 = ((eb = e7 || {}).VerifyEmailOtp = "verify-email-otp", eb.Cancel = "cancel", eb),
                tn = ((ew = tn || {}).EmailOTPSent = "email-otp-sent", ew.InvalidEmailOtp = "invalid-email-otp", ew.ExpiredEmailOtp = "expired-email-otp", ew),
                to = ((eE = to || {}).Retry = "device-retry", eE),
                ts = ((eI = ts || {}).DeviceApproved = "device-approved", eI.DeviceNeedsApproval = "device-needs-approval", eI.DeviceVerificationLinkExpired = "device-verification-link-expired", eI.DeviceVerificationEmailSent = "device-verification-email-sent", eI),
                ta = ((eS = ta || {}).Harmony = "HARMONY", eS),
                tl = ((ex = tl || {}).PhoneNumber = "phone_number", ex),
                tc = C(9389),
                td = Object.create,
                th = Object.defineProperty,
                tf = Object.defineProperties,
                tp = Object.getOwnPropertyDescriptor,
                tg = Object.getOwnPropertyDescriptors,
                ty = Object.getOwnPropertyNames,
                tm = Object.getOwnPropertySymbols,
                t_ = Object.getPrototypeOf,
                tb = Object.prototype.hasOwnProperty,
                tw = Object.prototype.propertyIsEnumerable,
                He = (r, l, C) => l in r ? th(r, l, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: C
                }) : r[l] = C,
                K = (r, l) => {
                    for (var C in l || (l = {})) tb.call(l, C) && He(r, C, l[C]);
                    if (tm)
                        for (var C of tm(l)) tw.call(l, C) && He(r, C, l[C]);
                    return r
                },
                ae = (r, l) => tf(r, tg(l)),
                es_m = (r, l, C) => new Promise((U, et) => {
                    var o = r => {
                            try {
                                i(C.next(r))
                            } catch (r) {
                                et(r)
                            }
                        },
                        a = r => {
                            try {
                                i(C.throw(r))
                            } catch (r) {
                                et(r)
                            }
                        },
                        i = r => r.done ? U(r.value) : Promise.resolve(r.value).then(o, a);
                    i((C = C.apply(r, l)).next())
                }),
                tE = (eA = (r, l) => {
                    var C = Object.prototype.hasOwnProperty,
                        U = "~";

                    function ne() {}

                    function Vn(r, l, C) {
                        this.fn = r, this.context = l, this.once = C || !1
                    }

                    function Tt(r, l, C, et, eo) {
                        if ("function" != typeof C) throw TypeError("The listener must be a function");
                        var es = new Vn(C, et || r, eo),
                            el = U ? U + l : l;
                        return r._events[el] ? r._events[el].fn ? r._events[el] = [r._events[el], es] : r._events[el].push(es) : (r._events[el] = es, r._eventsCount++), r
                    }

                    function me(r, l) {
                        0 == --r._eventsCount ? r._events = new ne : delete r._events[l]
                    }

                    function I() {
                        this._events = new ne, this._eventsCount = 0
                    }
                    Object.create && (ne.prototype = Object.create(null), new ne().__proto__ || (U = !1)), I.prototype.eventNames = function() {
                        var r, l, et = [];
                        if (0 === this._eventsCount) return et;
                        for (l in r = this._events) C.call(r, l) && et.push(U ? l.slice(1) : l);
                        return Object.getOwnPropertySymbols ? et.concat(Object.getOwnPropertySymbols(r)) : et
                    }, I.prototype.listeners = function(r) {
                        var l = U ? U + r : r,
                            C = this._events[l];
                        if (!C) return [];
                        if (C.fn) return [C.fn];
                        for (var et = 0, eo = C.length, es = Array(eo); et < eo; et++) es[et] = C[et].fn;
                        return es
                    }, I.prototype.listenerCount = function(r) {
                        var l = U ? U + r : r,
                            C = this._events[l];
                        return C ? C.fn ? 1 : C.length : 0
                    }, I.prototype.emit = function(r, l, C, et, eo, es) {
                        var el = U ? U + r : r;
                        if (!this._events[el]) return !1;
                        var ec, ed, eh = this._events[el],
                            ef = arguments.length;
                        if (eh.fn) {
                            switch (eh.once && this.removeListener(r, eh.fn, void 0, !0), ef) {
                                case 1:
                                    return eh.fn.call(eh.context), !0;
                                case 2:
                                    return eh.fn.call(eh.context, l), !0;
                                case 3:
                                    return eh.fn.call(eh.context, l, C), !0;
                                case 4:
                                    return eh.fn.call(eh.context, l, C, et), !0;
                                case 5:
                                    return eh.fn.call(eh.context, l, C, et, eo), !0;
                                case 6:
                                    return eh.fn.call(eh.context, l, C, et, eo, es), !0
                            }
                            for (ed = 1, ec = Array(ef - 1); ed < ef; ed++) ec[ed - 1] = arguments[ed];
                            eh.fn.apply(eh.context, ec)
                        } else {
                            var ep, eg = eh.length;
                            for (ed = 0; ed < eg; ed++) switch (eh[ed].once && this.removeListener(r, eh[ed].fn, void 0, !0), ef) {
                                case 1:
                                    eh[ed].fn.call(eh[ed].context);
                                    break;
                                case 2:
                                    eh[ed].fn.call(eh[ed].context, l);
                                    break;
                                case 3:
                                    eh[ed].fn.call(eh[ed].context, l, C);
                                    break;
                                case 4:
                                    eh[ed].fn.call(eh[ed].context, l, C, et);
                                    break;
                                default:
                                    if (!ec)
                                        for (ep = 1, ec = Array(ef - 1); ep < ef; ep++) ec[ep - 1] = arguments[ep];
                                    eh[ed].fn.apply(eh[ed].context, ec)
                            }
                        }
                        return !0
                    }, I.prototype.on = function(r, l, C) {
                        return Tt(this, r, l, C, !1)
                    }, I.prototype.once = function(r, l, C) {
                        return Tt(this, r, l, C, !0)
                    }, I.prototype.removeListener = function(r, l, C, et) {
                        var eo = U ? U + r : r;
                        if (!this._events[eo]) return this;
                        if (!l) return me(this, eo), this;
                        var es = this._events[eo];
                        if (es.fn) es.fn !== l || et && !es.once || C && es.context !== C || me(this, eo);
                        else {
                            for (var el = 0, ec = [], ed = es.length; el < ed; el++)(es[el].fn !== l || et && !es[el].once || C && es[el].context !== C) && ec.push(es[el]);
                            ec.length ? this._events[eo] = 1 === ec.length ? ec[0] : ec : me(this, eo)
                        }
                        return this
                    }, I.prototype.removeAllListeners = function(r) {
                        var l;
                        return r ? (l = U ? U + r : r, this._events[l] && me(this, l)) : (this._events = new ne, this._eventsCount = 0), this
                    }, I.prototype.off = I.prototype.removeListener, I.prototype.addListener = I.prototype.on, I.prefixed = U, I.EventEmitter = I, "u" > typeof l && (l.exports = I)
                }, () => (eP || eA((eP = {
                    exports: {}
                }).exports, eP), eP.exports)),
                tI = {
                    SEMVER_SPEC_VERSION: "2.0.0",
                    MAX_LENGTH: 256,
                    MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991,
                    MAX_SAFE_COMPONENT_LENGTH: 16
                },
                tS = "object" == typeof tc && tc.env && tc.env.NODE_DEBUG && /\bsemver\b/i.test(tc.env.NODE_DEBUG) ? (...r) => console.error("SEMVER", ...r) : () => {},
                tx = (function(r, l) {
                    let {
                        MAX_SAFE_COMPONENT_LENGTH: C
                    } = tI, U = (l = r.exports = {}).re = [], et = l.src = [], eo = l.t = {}, es = 0, i = (r, l, C) => {
                        let el = es++;
                        tS(el, l), eo[r] = el, et[el] = l, U[el] = new RegExp(l, C ? "g" : void 0)
                    };
                    i("NUMERICIDENTIFIER", "0|[1-9]\\d*"), i("NUMERICIDENTIFIERLOOSE", "[0-9]+"), i("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), i("MAINVERSION", `(${et[eo.NUMERICIDENTIFIER]})\\.(${et[eo.NUMERICIDENTIFIER]})\\.(${et[eo.NUMERICIDENTIFIER]})`), i("MAINVERSIONLOOSE", `(${et[eo.NUMERICIDENTIFIERLOOSE]})\\.(${et[eo.NUMERICIDENTIFIERLOOSE]})\\.(${et[eo.NUMERICIDENTIFIERLOOSE]})`), i("PRERELEASEIDENTIFIER", `(?:${et[eo.NUMERICIDENTIFIER]}|${et[eo.NONNUMERICIDENTIFIER]})`), i("PRERELEASEIDENTIFIERLOOSE", `(?:${et[eo.NUMERICIDENTIFIERLOOSE]}|${et[eo.NONNUMERICIDENTIFIER]})`), i("PRERELEASE", `(?:-(${et[eo.PRERELEASEIDENTIFIER]}(?:\\.${et[eo.PRERELEASEIDENTIFIER]})*))`), i("PRERELEASELOOSE", `(?:-?(${et[eo.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${et[eo.PRERELEASEIDENTIFIERLOOSE]})*))`), i("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), i("BUILD", `(?:\\+(${et[eo.BUILDIDENTIFIER]}(?:\\.${et[eo.BUILDIDENTIFIER]})*))`), i("FULLPLAIN", `v?${et[eo.MAINVERSION]}${et[eo.PRERELEASE]}?${et[eo.BUILD]}?`), i("FULL", `^${et[eo.FULLPLAIN]}$`), i("LOOSEPLAIN", `[v=\\s]*${et[eo.MAINVERSIONLOOSE]}${et[eo.PRERELEASELOOSE]}?${et[eo.BUILD]}?`), i("LOOSE", `^${et[eo.LOOSEPLAIN]}$`), i("GTLT", "((?:<|>)?=?)"), i("XRANGEIDENTIFIERLOOSE", `${et[eo.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), i("XRANGEIDENTIFIER", `${et[eo.NUMERICIDENTIFIER]}|x|X|\\*`), i("XRANGEPLAIN", `[v=\\s]*(${et[eo.XRANGEIDENTIFIER]})(?:\\.(${et[eo.XRANGEIDENTIFIER]})(?:\\.(${et[eo.XRANGEIDENTIFIER]})(?:${et[eo.PRERELEASE]})?${et[eo.BUILD]}?)?)?`), i("XRANGEPLAINLOOSE", `[v=\\s]*(${et[eo.XRANGEIDENTIFIERLOOSE]})(?:\\.(${et[eo.XRANGEIDENTIFIERLOOSE]})(?:\\.(${et[eo.XRANGEIDENTIFIERLOOSE]})(?:${et[eo.PRERELEASELOOSE]})?${et[eo.BUILD]}?)?)?`), i("XRANGE", `^${et[eo.GTLT]}\\s*${et[eo.XRANGEPLAIN]}$`), i("XRANGELOOSE", `^${et[eo.GTLT]}\\s*${et[eo.XRANGEPLAINLOOSE]}$`), i("COERCE", `(^|[^\\d])(\\d{1,${C}})(?:\\.(\\d{1,${C}}))?(?:\\.(\\d{1,${C}}))?(?:$|[^\\d])`), i("COERCERTL", et[eo.COERCE], !0), i("LONETILDE", "(?:~>?)"), i("TILDETRIM", `(\\s*)${et[eo.LONETILDE]}\\s+`, !0), l.tildeTrimReplace = "$1~", i("TILDE", `^${et[eo.LONETILDE]}${et[eo.XRANGEPLAIN]}$`), i("TILDELOOSE", `^${et[eo.LONETILDE]}${et[eo.XRANGEPLAINLOOSE]}$`), i("LONECARET", "(?:\\^)"), i("CARETTRIM", `(\\s*)${et[eo.LONECARET]}\\s+`, !0), l.caretTrimReplace = "$1^", i("CARET", `^${et[eo.LONECARET]}${et[eo.XRANGEPLAIN]}$`), i("CARETLOOSE", `^${et[eo.LONECARET]}${et[eo.XRANGEPLAINLOOSE]}$`), i("COMPARATORLOOSE", `^${et[eo.GTLT]}\\s*(${et[eo.LOOSEPLAIN]})$|^$`), i("COMPARATOR", `^${et[eo.GTLT]}\\s*(${et[eo.FULLPLAIN]})$|^$`), i("COMPARATORTRIM", `(\\s*)${et[eo.GTLT]}\\s*(${et[eo.LOOSEPLAIN]}|${et[eo.XRANGEPLAIN]})`, !0), l.comparatorTrimReplace = "$1$2$3", i("HYPHENRANGE", `^\\s*(${et[eo.XRANGEPLAIN]})\\s+-\\s+(${et[eo.XRANGEPLAIN]})\\s*$`), i("HYPHENRANGELOOSE", `^\\s*(${et[eo.XRANGEPLAINLOOSE]})\\s+-\\s+(${et[eo.XRANGEPLAINLOOSE]})\\s*$`), i("STAR", "(<|>)?=?\\s*\\*"), i("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), i("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$")
                }(eo = {
                    exports: {}
                }, eo.exports), eo.exports),
                tA = /^[0-9]+$/,
                st = (r, l) => {
                    let C = tA.test(r),
                        U = tA.test(l);
                    return C && U && (r = +r, l = +l), r === l ? 0 : C && !U ? -1 : U && !C ? 1 : r < l ? -1 : 1
                },
                {
                    MAX_LENGTH: tP,
                    MAX_SAFE_INTEGER: tC
                } = tI,
                {
                    re: tk,
                    t: tN
                } = tx,
                {
                    compareIdentifiers: tO
                } = {
                    compareIdentifiers: st,
                    rcompareIdentifiers: (r, l) => st(l, r)
                },
                tT = class {
                    constructor(r, l) {
                        if (l && "object" == typeof l || (l = {
                                loose: !!l,
                                includePrerelease: !1
                            }), r instanceof tT) {
                            if (!!l.loose === r.loose && !!l.includePrerelease === r.includePrerelease) return r;
                            r = r.version
                        } else if ("string" != typeof r) throw TypeError(`Invalid Version: ${r}`);
                        if (r.length > tP) throw TypeError(`version is longer than ${tP} characters`);
                        tS("SemVer", r, l), this.options = l, this.loose = !!l.loose, this.includePrerelease = !!l.includePrerelease;
                        let C = r.trim().match(l.loose ? tk[tN.LOOSE] : tk[tN.FULL]);
                        if (!C) throw TypeError(`Invalid Version: ${r}`);
                        if (this.raw = r, this.major = +C[1], this.minor = +C[2], this.patch = +C[3], this.major > tC || this.major < 0) throw TypeError("Invalid major version");
                        if (this.minor > tC || this.minor < 0) throw TypeError("Invalid minor version");
                        if (this.patch > tC || this.patch < 0) throw TypeError("Invalid patch version");
                        C[4] ? this.prerelease = C[4].split(".").map(r => {
                            if (/^[0-9]+$/.test(r)) {
                                let l = +r;
                                if (l >= 0 && l < tC) return l
                            }
                            return r
                        }) : this.prerelease = [], this.build = C[5] ? C[5].split(".") : [], this.format()
                    }
                    format() {
                        return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version
                    }
                    toString() {
                        return this.version
                    }
                    compare(r) {
                        if (tS("SemVer.compare", this.version, this.options, r), !(r instanceof tT)) {
                            if ("string" == typeof r && r === this.version) return 0;
                            r = new tT(r, this.options)
                        }
                        return r.version === this.version ? 0 : this.compareMain(r) || this.comparePre(r)
                    }
                    compareMain(r) {
                        return r instanceof tT || (r = new tT(r, this.options)), tO(this.major, r.major) || tO(this.minor, r.minor) || tO(this.patch, r.patch)
                    }
                    comparePre(r) {
                        if (r instanceof tT || (r = new tT(r, this.options)), this.prerelease.length && !r.prerelease.length) return -1;
                        if (!this.prerelease.length && r.prerelease.length) return 1;
                        if (!this.prerelease.length && !r.prerelease.length) return 0;
                        let l = 0;
                        do {
                            let C = this.prerelease[l],
                                U = r.prerelease[l];
                            if (tS("prerelease compare", l, C, U), void 0 === C && void 0 === U) return 0;
                            if (void 0 === U) return 1;
                            if (void 0 === C) return -1;
                            if (C !== U) return tO(C, U)
                        } while (++l)
                    }
                    compareBuild(r) {
                        r instanceof tT || (r = new tT(r, this.options));
                        let l = 0;
                        do {
                            let C = this.build[l],
                                U = r.build[l];
                            if (tS("prerelease compare", l, C, U), void 0 === C && void 0 === U) return 0;
                            if (void 0 === U) return 1;
                            if (void 0 === C) return -1;
                            if (C !== U) return tO(C, U)
                        } while (++l)
                    }
                    inc(r, l) {
                        switch (r) {
                            case "premajor":
                                this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", l);
                                break;
                            case "preminor":
                                this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", l);
                                break;
                            case "prepatch":
                                this.prerelease.length = 0, this.inc("patch", l), this.inc("pre", l);
                                break;
                            case "prerelease":
                                0 === this.prerelease.length && this.inc("patch", l), this.inc("pre", l);
                                break;
                            case "major":
                                0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                                break;
                            case "minor":
                                0 === this.patch && 0 !== this.prerelease.length || this.minor++, this.patch = 0, this.prerelease = [];
                                break;
                            case "patch":
                                0 === this.prerelease.length && this.patch++, this.prerelease = [];
                                break;
                            case "pre":
                                if (0 === this.prerelease.length) this.prerelease = [0];
                                else {
                                    let r = this.prerelease.length;
                                    for (; --r >= 0;) "number" == typeof this.prerelease[r] && (this.prerelease[r]++, r = -2); - 1 === r && this.prerelease.push(0)
                                }
                                l && (this.prerelease[0] === l ? isNaN(this.prerelease[1]) && (this.prerelease = [l, 0]) : this.prerelease = [l, 0]);
                                break;
                            default:
                                throw Error(`invalid increment argument: ${r}`)
                        }
                        return this.format(), this.raw = this.version, this
                    }
                },
                j = (r, l, C) => new tT(r, C).compare(new tT(l, C)),
                on = (r, l, C) => 0 === j(r, l, C),
                cn = (r, l, C) => 0 !== j(r, l, C),
                un = (r, l, C) => j(r, l, C) > 0,
                pn = (r, l, C) => j(r, l, C) >= 0,
                mn = (r, l, C) => 0 > j(r, l, C),
                En = (r, l, C) => 0 >= j(r, l, C),
                Ne = (r, l, C, U) => {
                    switch (l) {
                        case "===":
                            return "object" == typeof r && (r = r.version), "object" == typeof C && (C = C.version), r === C;
                        case "!==":
                            return "object" == typeof r && (r = r.version), "object" == typeof C && (C = C.version), r !== C;
                        case "":
                        case "=":
                        case "==":
                            return on(r, C, U);
                        case "!=":
                            return cn(r, C, U);
                        case ">":
                            return un(r, C, U);
                        case ">=":
                            return pn(r, C, U);
                        case "<":
                            return mn(r, C, U);
                        case "<=":
                            return En(r, C, U);
                        default:
                            throw TypeError(`Invalid operator: ${l}`)
                    }
                },
                tR = Symbol("SemVer ANY"),
                tD = class {
                    static get ANY() {
                        return tR
                    }
                    constructor(r, l) {
                        if (l && "object" == typeof l || (l = {
                                loose: !!l,
                                includePrerelease: !1
                            }), r instanceof tD) {
                            if (!!l.loose === r.loose) return r;
                            r = r.value
                        }
                        tS("comparator", r, l), this.options = l, this.loose = !!l.loose, this.parse(r), this.semver === tR ? this.value = "" : this.value = this.operator + this.semver.version, tS("comp", this)
                    }
                    parse(r) {
                        let l = this.options.loose ? tB[tU.COMPARATORLOOSE] : tB[tU.COMPARATOR],
                            C = r.match(l);
                        if (!C) throw TypeError(`Invalid comparator: ${r}`);
                        this.operator = void 0 !== C[1] ? C[1] : "", "=" === this.operator && (this.operator = ""), C[2] ? this.semver = new tT(C[2], this.options.loose) : this.semver = tR
                    }
                    toString() {
                        return this.value
                    }
                    test(r) {
                        if (tS("Comparator.test", r, this.options.loose), this.semver === tR || r === tR) return !0;
                        if ("string" == typeof r) try {
                            r = new tT(r, this.options)
                        } catch (r) {
                            return !1
                        }
                        return Ne(r, this.operator, this.semver, this.options)
                    }
                    intersects(r, l) {
                        if (!(r instanceof tD)) throw TypeError("a Comparator is required");
                        if (l && "object" == typeof l || (l = {
                                loose: !!l,
                                includePrerelease: !1
                            }), "" === this.operator) return "" === this.value || new tL(r.value, l).test(this.value);
                        if ("" === r.operator) return "" === r.value || new tL(this.value, l).test(r.semver);
                        let C = !(">=" !== this.operator && ">" !== this.operator || ">=" !== r.operator && ">" !== r.operator),
                            U = !("<=" !== this.operator && "<" !== this.operator || "<=" !== r.operator && "<" !== r.operator),
                            et = this.semver.version === r.semver.version,
                            eo = !(">=" !== this.operator && "<=" !== this.operator || ">=" !== r.operator && "<=" !== r.operator),
                            es = Ne(this.semver, "<", r.semver, l) && (">=" === this.operator || ">" === this.operator) && ("<=" === r.operator || "<" === r.operator),
                            el = Ne(this.semver, ">", r.semver, l) && ("<=" === this.operator || "<" === this.operator) && (">=" === r.operator || ">" === r.operator);
                        return C || U || et && eo || es || el
                    }
                },
                {
                    re: tB,
                    t: tU
                } = tx,
                tL = class {
                    constructor(r, l) {
                        if (l && "object" == typeof l || (l = {
                                loose: !!l,
                                includePrerelease: !1
                            }), r instanceof tL) return !!l.loose === r.loose && !!l.includePrerelease === r.includePrerelease ? r : new tL(r.raw, l);
                        if (r instanceof tD) return this.raw = r.value, this.set = [
                            [r]
                        ], this.format(), this;
                        if (this.options = l, this.loose = !!l.loose, this.includePrerelease = !!l.includePrerelease, this.raw = r, this.set = r.split(/\s*\|\|\s*/).map(r => this.parseRange(r.trim())).filter(r => r.length), !this.set.length) throw TypeError(`Invalid SemVer Range: ${r}`);
                        this.format()
                    }
                    format() {
                        return this.range = this.set.map(r => r.join(" ").trim()).join("||").trim(), this.range
                    }
                    toString() {
                        return this.range
                    }
                    parseRange(r) {
                        let {
                            loose: l
                        } = this.options;
                        r = r.trim();
                        let C = l ? tM[tj.HYPHENRANGELOOSE] : tM[tj.HYPHENRANGE];
                        tS("hyphen replace", r = r.replace(C, An(this.options.includePrerelease))), tS("comparator trim", r = r.replace(tM[tj.COMPARATORTRIM], tq), tM[tj.COMPARATORTRIM]), r = (r = (r = r.replace(tM[tj.TILDETRIM], t$)).replace(tM[tj.CARETTRIM], tz)).split(/\s+/).join(" ");
                        let U = l ? tM[tj.COMPARATORLOOSE] : tM[tj.COMPARATOR];
                        return r.split(" ").map(r => Tn(r, this.options)).join(" ").split(/\s+/).map(r => $n(r, this.options)).filter(this.options.loose ? r => !!r.match(U) : () => !0).map(r => new tD(r, this.options))
                    }
                    intersects(r, l) {
                        if (!(r instanceof tL)) throw TypeError("a Range is required");
                        return this.set.some(C => tt(C, l) && r.set.some(r => tt(r, l) && C.every(C => r.every(r => C.intersects(r, l)))))
                    }
                    test(r) {
                        if (!r) return !1;
                        if ("string" == typeof r) try {
                            r = new tT(r, this.options)
                        } catch (r) {
                            return !1
                        }
                        for (let l = 0; l < this.set.length; l++)
                            if (Cn(this.set[l], r, this.options)) return !0;
                        return !1
                    }
                },
                {
                    re: tM,
                    t: tj,
                    comparatorTrimReplace: tq,
                    tildeTrimReplace: t$,
                    caretTrimReplace: tz
                } = tx,
                tt = (r, l) => {
                    let C = !0,
                        U = r.slice(),
                        et = U.pop();
                    for (; C && U.length;) C = U.every(r => et.intersects(r, l)), et = U.pop();
                    return C
                },
                Tn = (r, l) => (tS("comp", r, l), tS("caret", r = wn(r, l)), tS("tildes", r = In(r, l)), tS("xrange", r = Mn(r, l)), tS("stars", r = Nn(r, l)), r),
                b = r => !r || "x" === r.toLowerCase() || "*" === r,
                In = (r, l) => r.trim().split(/\s+/).map(r => bn(r, l)).join(" "),
                bn = (r, l) => {
                    let C = l.loose ? tM[tj.TILDELOOSE] : tM[tj.TILDE];
                    return r.replace(C, (l, C, U, et, eo) => {
                        let es;
                        return tS("tilde", r, l, C, U, et, eo), b(C) ? es = "" : b(U) ? es = `>=${C}.0.0 <${+C+1}.0.0-0` : b(et) ? es = `>=${C}.${U}.0 <${C}.${+U+1}.0-0` : eo ? (tS("replaceTilde pr", eo), es = `>=${C}.${U}.${et}-${eo} <${C}.${+U+1}.0-0`) : es = `>=${C}.${U}.${et} <${C}.${+U+1}.0-0`, tS("tilde return", es), es
                    })
                },
                wn = (r, l) => r.trim().split(/\s+/).map(r => Pn(r, l)).join(" "),
                Pn = (r, l) => {
                    tS("caret", r, l);
                    let C = l.loose ? tM[tj.CARETLOOSE] : tM[tj.CARET],
                        U = l.includePrerelease ? "-0" : "";
                    return r.replace(C, (l, C, et, eo, es) => {
                        let el;
                        return tS("caret", r, l, C, et, eo, es), b(C) ? el = "" : b(et) ? el = `>=${C}.0.0${U} <${+C+1}.0.0-0` : b(eo) ? el = "0" === C ? `>=${C}.${et}.0${U} <${C}.${+et+1}.0-0` : `>=${C}.${et}.0${U} <${+C+1}.0.0-0` : es ? (tS("replaceCaret pr", es), el = "0" === C ? "0" === et ? `>=${C}.${et}.${eo}-${es} <${C}.${et}.${+eo+1}-0` : `>=${C}.${et}.${eo}-${es} <${C}.${+et+1}.0-0` : `>=${C}.${et}.${eo}-${es} <${+C+1}.0.0-0`) : (tS("no pr"), el = "0" === C ? "0" === et ? `>=${C}.${et}.${eo}${U} <${C}.${et}.${+eo+1}-0` : `>=${C}.${et}.${eo}${U} <${C}.${+et+1}.0-0` : `>=${C}.${et}.${eo} <${+C+1}.0.0-0`), tS("caret return", el), el
                    })
                },
                Mn = (r, l) => (tS("replaceXRanges", r, l), r.split(/\s+/).map(r => xn(r, l)).join(" ")),
                xn = (r, l) => {
                    r = r.trim();
                    let C = l.loose ? tM[tj.XRANGELOOSE] : tM[tj.XRANGE];
                    return r.replace(C, (C, U, et, eo, es, el) => {
                        tS("xRange", r, C, U, et, eo, es, el);
                        let ec = b(et),
                            ed = ec || b(eo),
                            eh = ed || b(es);
                        return "=" === U && eh && (U = ""), el = l.includePrerelease ? "-0" : "", ec ? C = ">" === U || "<" === U ? "<0.0.0-0" : "*" : U && eh ? (ed && (eo = 0), es = 0, ">" === U ? (U = ">=", ed ? (et = +et + 1, eo = 0) : eo = +eo + 1, es = 0) : "<=" === U && (U = "<", ed ? et = +et + 1 : eo = +eo + 1), "<" === U && (el = "-0"), C = `${U+et}.${eo}.${es}${el}`) : ed ? C = `>=${et}.0.0${el} <${+et+1}.0.0-0` : eh && (C = `>=${et}.${eo}.0${el} <${et}.${+eo+1}.0-0`), tS("xRange return", C), C
                    })
                },
                Nn = (r, l) => (tS("replaceStars", r, l), r.trim().replace(tM[tj.STAR], "")),
                $n = (r, l) => (tS("replaceGTE0", r, l), r.trim().replace(tM[l.includePrerelease ? tj.GTE0PRE : tj.GTE0], "")),
                An = r => (l, C, U, et, eo, es, el, ec, ed, eh, ef, ep, eg) => `${C=b(U)?"":b(et)?`>=${U}.0.0${r?"-0":""}`:b(eo)?`>=${U}.${et}.0${r?"-0":""}`:es?`>=${C}`:`>=${C}${r?"-0":""}`} ${ec=b(ed)?"":b(eh)?`<${+ed+1}.0.0-0`:b(ef)?`<${ed}.${+eh+1}.0-0`:ep?`<=${ed}.${eh}.${ef}-${ep}`:r?`<${ed}.${eh}.${+ef+1}-0`:`<=${ec}`}`.trim(),
                Cn = (r, l, C) => {
                    for (let C = 0; C < r.length; C++)
                        if (!r[C].test(l)) return !1;
                    if (l.prerelease.length && !C.includePrerelease) {
                        for (let C = 0; C < r.length; C++)
                            if (tS(r[C].semver), r[C].semver !== tD.ANY && r[C].semver.prerelease.length > 0) {
                                let U = r[C].semver;
                                if (U.major === l.major && U.minor === l.minor && U.patch === l.patch) return !0
                            }
                        return !1
                    }
                    return !0
                },
                ot = (r, l, C) => {
                    try {
                        l = new tL(l, C)
                    } catch (r) {
                        return !1
                    }
                    return l.test(r)
                },
                {
                    MAX_LENGTH: tH
                } = tI,
                {
                    re: tF,
                    t: tW
                } = tx,
                On = (r, l) => {
                    if (l && "object" == typeof l || (l = {
                            loose: !!l,
                            includePrerelease: !1
                        }), r instanceof tT) return r;
                    if ("string" != typeof r || r.length > tH || !(l.loose ? tF[tW.LOOSE] : tF[tW.FULL]).test(r)) return null;
                    try {
                        return new tT(r, l)
                    } catch (r) {
                        return null
                    }
                },
                {
                    re: tV,
                    t: tK
                } = tx,
                it = (r, l) => {
                    if (r instanceof tT) return r;
                    if ("number" == typeof r && (r = String(r)), "string" != typeof r) return null;
                    let C = null;
                    if ((l = l || {}).rtl) {
                        let l;
                        for (;
                            (l = tV[tK.COERCERTL].exec(r)) && (!C || C.index + C[0].length !== r.length);) C && l.index + l[0].length === C.index + C[0].length || (C = l), tV[tK.COERCERTL].lastIndex = l.index + l[1].length + l[2].length;
                        tV[tK.COERCERTL].lastIndex = -1
                    } else C = r.match(tV[tK.COERCE]);
                    return null === C ? null : On(`${C[2]}.${C[3]||"0"}.${C[4]||"0"}`, l)
                };

            function _n(r) {
                return String.fromCharCode(parseInt(r.slice(1), 16))
            }

            function kn(r) {
                return `%${`00${r.charCodeAt(0).toString(16)}`.slice(-2)}`
            }

            function de(r) {
                return btoa(encodeURIComponent(JSON.stringify(r)).replace(/%[0-9A-F]{2}/g, _n))
            }

            function at(r) {
                return JSON.parse(decodeURIComponent(Array.from(atob(r), kn).join("")))
            }

            function O(r) {
                return void 0 === r
            }

            function pe(r) {
                return null === r || O(r)
            }

            function ee(r) {
                if (!r) return !0;
                for (let l in r)
                    if (Object.hasOwnProperty.call(r, l)) return !1;
                return !0
            }
            var tG = {},
                tJ = {
                    "magic-sdk": "magic-sdk",
                    "@magic-sdk/react-native": "magic-sdk-rn",
                    "@magic-sdk/react-native-bare": "magic-sdk-rn-bare",
                    "@magic-sdk/react-native-expo": "magic-sdk-rn-expo"
                },
                tY = class extends Error {
                    constructor(r, l) {
                        super(`Magic SDK Error: [${r}] ${l}`), this.code = r, this.rawMessage = l, this.__proto__ = Error, Object.setPrototypeOf(this, tY.prototype)
                    }
                },
                tZ = class extends Error {
                    constructor(r) {
                        super(), this.__proto__ = Error;
                        let l = Number(null == r ? void 0 : r.code);
                        this.rawMessage = (null == r ? void 0 : r.message) || "Internal error", this.code = !pe(l) && "number" == typeof l && Object.values(e0).includes(l) ? l : e0.InternalError, this.message = `Magic RPC Error: [${this.code}] ${this.rawMessage}`, this.data = (null == r ? void 0 : r.data) || void 0, Object.setPrototypeOf(this, tZ.prototype)
                    }
                },
                tX = class {
                    constructor(r, l) {
                        this.code = r, this.rawMessage = l, this.message = `Magic SDK Warning: [${r}] ${l}`
                    }
                    log() {
                        console.warn(this.message)
                    }
                },
                tQ = class extends Error {
                    constructor(r, l, C, U) {
                        super(`Magic Extension Error (${r.name}): [${l}] ${C}`), this.code = l, this.rawMessage = C, this.data = U, this.__proto__ = Error, Object.setPrototypeOf(this, tQ.prototype)
                    }
                },
                t0 = class {
                    constructor(r, l, C) {
                        this.code = l, this.rawMessage = C, this.message = `Magic Extension Warning (${r.name}): [${l}] ${C}`
                    }
                    log() {
                        console.warn(this.message)
                    }
                };

            function pt() {
                return new tY(eX.ModalNotReady, "Modal is not ready.")
            }

            function k(r) {
                let {
                    method: l,
                    removalVersions: C,
                    useInstead: U
                } = r, et = C[tG.sdkName], eo = U ? ` Use \`${U}\` instead.` : "", es = `\`${l}\` will be removed from \`${tG.sdkName}\` in version \`${et}\`.${eo}`;
                return new tX(eQ.DeprecationNotice, es)
            }
            var t1 = function*() {
                let r = 0;
                for (;;) r < Number.MAX_SAFE_INTEGER ? yield ++r: r = 0
            }();

            function Ae() {
                return t1.next().value
            }
            var t2 = Symbol("Payload pre-processed by Magic SDK");

            function vt(r) {
                return Object.defineProperty(r, t2, {
                    value: !0,
                    enumerable: !1
                }), r
            }

            function G(r) {
                var l, C, U;
                return r[t2] || (r.jsonrpc = null != (l = r.jsonrpc) ? l : "2.0", r.id = Ae(), r.method = null != (C = r.method) ? C : "noop", r.params = null != (U = r.params) ? U : [], vt(r)), r
            }

            function d(r, l = []) {
                return vt({
                    params: l,
                    method: r,
                    jsonrpc: "2.0",
                    id: Ae()
                })
            }
            var t3 = class {
                    constructor(r) {
                        r instanceof t3 ? (this._jsonrpc = r.payload.jsonrpc, this._id = r.payload.id, this._result = r.payload.result, this._error = r.payload.error) : pe(r) || O(r.jsonrpc) || O(r.id) || O(r.result) && O(r.error) ? (this._jsonrpc = r.jsonrpc, this._id = r.id, this._result = void 0, this._error = void 0) : (this._jsonrpc = r.jsonrpc, this._id = r.id, this._result = r.result, this._error = r.error)
                    }
                    applyError(r) {
                        return this._error = r, this
                    }
                    applyResult(r) {
                        return this._result = r, this
                    }
                    get hasError() {
                        return void 0 !== this._error && null !== this._error
                    }
                    get hasResult() {
                        return void 0 !== this._result
                    }
                    get payload() {
                        return {
                            jsonrpc: this._jsonrpc,
                            id: this._id,
                            result: this._result,
                            error: this._error
                        }
                    }
                },
                t5 = (ek = null != (eC = tE()) ? td(t_(eC)) : {}, ((r, l, C, U) => {
                    if (l && "object" == typeof l || "function" == typeof l)
                        for (let C of ty(l)) tb.call(r, C) || void 0 === C || th(r, C, {
                            get: () => l[C],
                            enumerable: !(U = tp(l, C)) || U.enumerable
                        });
                    return r
                })(eC && eC.__esModule ? ek : th(ek, "default", {
                    value: eC,
                    enumerable: !0
                }), eC)),
                t6 = class extends t5.default {};

            function fe() {
                let r = new t6;
                return {
                    emitter: r,
                    createChainingEmitterMethod: (l, C) => (...U) => (r[l].apply(r, U), C),
                    createBoundEmitterMethod: l => (...C) => r[l].apply(r, C)
                }
            }
            var t8 = Symbol("isPromiEvent");

            function Pt(r) {
                return !!r[t8]
            }

            function q(r) {
                let l = Le(r),
                    {
                        createBoundEmitterMethod: C,
                        createChainingEmitterMethod: U
                    } = fe(),
                    et = Symbol("Promise.then"),
                    eo = Symbol("Promise.catch"),
                    es = Symbol("Promise.finally"),
                    i = (r, l) => (...C) => c(l[r].apply(l, C)),
                    c = r => Object.assign(r, {
                        [t8]: !0,
                        [et]: r[et] || r.then,
                        [eo]: r[eo] || r.catch,
                        [es]: r[es] || r.finally,
                        then: i(et, r),
                        catch: i(eo, r),
                        finally: i(es, r),
                        on: U("on", r),
                        once: U("once", r),
                        addListener: U("addListener", r),
                        off: U("off", r),
                        removeListener: U("removeListener", r),
                        removeAllListeners: U("removeAllListeners", r),
                        emit: C("emit"),
                        eventNames: C("eventNames"),
                        listeners: C("listeners"),
                        listenerCount: C("listenerCount")
                    }),
                    el = c(l.then(r => (el.emit("done", r), el.emit("settled"), r), r => {
                        throw el.emit("error", r), el.emit("settled"), r
                    }));
                return el
            }

            function Le(r) {
                return new Promise((l, C) => {
                    Promise.resolve(r(l, C)).catch(C)
                })
            }
            var t4 = class {
                    constructor(r) {
                        this.sdk = r
                    }
                    get overlay() {
                        return this.sdk.overlay
                    }
                    request(r) {
                        let l = this.overlay.post(e6.MAGIC_HANDLE_REQUEST, G(r)),
                            C = q((r, C) => {
                                l.then(l => {
                                    if (U(), l.hasError) C(new tZ(l.payload.error));
                                    else if (l.hasResult) r(l.payload.result);
                                    else throw new tY(eX.MalformedResponse, "Response from the Magic iframe is malformed.")
                                }).catch(r => {
                                    U(), C(r)
                                })
                            }),
                            U = this.overlay.on(e5.MAGIC_HANDLE_EVENT, l => {
                                var U;
                                let {
                                    response: et
                                } = l.data;
                                if (et.id === r.id && (null == (U = et.result) ? void 0 : U.event)) {
                                    let {
                                        event: r,
                                        params: l = []
                                    } = et.result;
                                    C.emit(r, ...l)
                                }
                            });
                        return C
                    }
                    createIntermediaryEvent(r, l) {
                        return C => {
                            let U = d(e3.IntermediaryEvent, [{
                                payloadId: l,
                                eventType: r,
                                args: C
                            }]);
                            this.request(U)
                        }
                    }
                },
                t9 = {
                    "magic-sdk": "v18.0.0",
                    "@magic-sdk/react-native": "v14.0.0",
                    "@magic-sdk/react-native-bare": "v19.0.0",
                    "@magic-sdk/react-native-expo": "v19.0.0"
                },
                t7 = class extends t4 {
                    loginWithMagicLink(r) {
                        let l = "@magic-sdk/react-native" === tG.sdkName || "@magic-sdk/react-native-bare" === tG.sdkName || "@magic-sdk/react-native-expo" === tG.sdkName;
                        if (l && function(r, l) {
                                let [C] = r.split(".").map(Number);
                                return C >= 19
                            }(tG.version, 0)) throw Error("loginWithMagicLink() is deprecated for this package, please utlize a passcode method like loginWithSMS or loginWithEmailOTP instead.");
                        l && k({
                            method: "auth.loginWithMagicLink()",
                            removalVersions: t9,
                            useInstead: "auth.loginWithEmailOTP()"
                        }).log();
                        let {
                            email: C,
                            showUI: U = !0,
                            redirectURI: et,
                            overrides: eo
                        } = r, es = d(this.sdk.testMode ? e3.LoginWithMagicLinkTestMode : e3.LoginWithMagicLink, [{
                            email: C,
                            showUI: U,
                            redirectURI: et,
                            overrides: eo
                        }]);
                        return this.request(es)
                    }
                    loginWithSMS(r) {
                        let {
                            phoneNumber: l
                        } = r, C = d(this.sdk.testMode ? e3.LoginWithSmsTestMode : e3.LoginWithSms, [{
                            phoneNumber: l,
                            showUI: !0
                        }]);
                        return this.request(C)
                    }
                    loginWithEmailOTP(r) {
                        let {
                            email: l,
                            showUI: C,
                            deviceCheckUI: U,
                            overrides: et
                        } = r, eo = d(this.sdk.testMode ? e3.LoginWithEmailOTPTestMode : e3.LoginWithEmailOTP, [{
                            email: l,
                            showUI: C,
                            deviceCheckUI: U,
                            overrides: et
                        }]), es = this.request(eo);
                        return !U && es && es.on(to.Retry, () => {
                            this.createIntermediaryEvent(to.Retry, eo.id)()
                        }), !C && es && (es.on(e7.VerifyEmailOtp, r => {
                            this.createIntermediaryEvent(e7.VerifyEmailOtp, eo.id)(r)
                        }), es.on(e7.Cancel, () => {
                            this.createIntermediaryEvent(e7.Cancel, eo.id)()
                        })), es
                    }
                    loginWithCredential(r) {
                        let l = null != r ? r : "";
                        if (!r && "web" === tG.platform) {
                            l = window.location.search;
                            let r = window.location.origin + window.location.pathname;
                            window.history.replaceState(null, "", r)
                        }
                        let C = d(this.sdk.testMode ? e3.LoginWithCredentialTestMode : e3.LoginWithCredential, [l]);
                        return this.request(C)
                    }
                    setAuthorizationToken(r) {
                        let l = d(e3.SetAuthorizationToken, [{
                            jwt: r
                        }]);
                        return this.request(l)
                    }
                    updateEmailWithUI(r) {
                        let {
                            email: l,
                            showUI: C = !0
                        } = r, U = d(this.sdk.testMode ? e3.UpdateEmailTestMode : e3.UpdateEmail, [{
                            email: l,
                            showUI: C
                        }]);
                        return this.request(U)
                    }
                },
                ro = {};

            function J(r) {
                return (...l) => es_m(this, null, function*() {
                    return eG || (eG = yield tG.configureStorage()), yield eG.ready(), eG[r](...l)
                })
            }((r, l) => {
                for (var C in l) th(r, C, {
                    get: l[C],
                    enumerable: !0
                })
            })(ro, {
                clear: () => rc,
                getItem: () => rs,
                iterate: () => rg,
                key: () => rh,
                keys: () => rp,
                length: () => rd,
                removeItem: () => rl,
                setItem: () => ra
            });
            var rs = J("getItem"),
                ra = J("setItem"),
                rl = J("removeItem"),
                rc = J("clear"),
                rd = J("length"),
                rh = J("key"),
                rp = J("keys"),
                rg = J("iterate"),
                ry = "STORE_KEY_PRIVATE_KEY",
                rm = "STORE_KEY_PUBLIC_JWK",
                r_ = "ECDSA",
                rb = {
                    name: r_,
                    namedCurve: "P-256"
                };

            function se() {
                let r = "undefined" != typeof window && !!window.crypto,
                    l = r && !!window.crypto.subtle;
                return r && l
            }

            function St(r) {
                return btoa(r).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+/g, "")
            }

            function ar(r) {
                return encodeURIComponent(r).replace(/%([0-9A-F]{2})/g, (r, l) => String.fromCharCode(parseInt(l, 16)))
            }
            var rw = "AES-GCM";

            function X() {
                return es_m(this, null, function*() {
                    let r = [];
                    for (let l of (yield rg((l, C, U) => {
                            C.startsWith("ds_") && r.push(C)
                        }), r)) yield rl(l)
                })
            }

            function Lt(r) {
                let l = "",
                    C = new Uint8Array(r),
                    U = C.byteLength;
                for (let r = 0; r < U; r++) l += String.fromCharCode(C[r]);
                return window.btoa(l)
            }

            function Ot(r) {
                let l = window.atob(r),
                    C = l.length,
                    U = new Uint8Array(C);
                for (let r = 0; r < C; r++) U[r] = l.charCodeAt(r);
                return U.buffer
            }

            function We(r, l) {
                return l ? new URL(r, l) : new URL(r)
            }
            var rE = class extends t4 {
                    constructor() {
                        super(...arguments), this.localForageKey = "mc_active_wallet", this.localForageIsLoggedInKey = "magic_auth_is_logged_in", this.userLoggedOutCallbacks = []
                    }
                    getIdToken(r) {
                        let l = d(this.sdk.testMode ? e3.GetIdTokenTestMode : e3.GetIdToken, [r]);
                        return this.request(l)
                    }
                    generateIdToken(r) {
                        let l = d(this.sdk.testMode ? e3.GenerateIdTokenTestMode : e3.GenerateIdToken, [r]);
                        return this.request(l)
                    }
                    getInfo() {
                        return es_m(this, null, function*() {
                            let r = yield rs(this.localForageKey), l = d(e3.GetInfo, [{
                                walletType: r
                            }]);
                            return this.request(l)
                        })
                    }
                    isLoggedIn() {
                        return q((r, l) => es_m(this, null, function*() {
                            try {
                                let l = !1;
                                this.sdk.useStorageCache && (l = (yield rs(this.localForageIsLoggedInKey)) === "true") && r(!0);
                                let C = d(this.sdk.testMode ? e3.IsLoggedInTestMode : e3.IsLoggedIn),
                                    U = yield this.request(C);
                                this.sdk.useStorageCache && (U ? ra(this.localForageIsLoggedInKey, !0) : rl(this.localForageIsLoggedInKey), l && !U && this.emitUserLoggedOut(!0)), r(U)
                            } catch (r) {
                                l(r)
                            }
                        }))
                    }
                    logout() {
                        return rl(this.localForageKey), rl(this.localForageIsLoggedInKey), X(), q((r, l) => es_m(this, null, function*() {
                            try {
                                let l = d(this.sdk.testMode ? e3.LogoutTestMode : e3.Logout),
                                    C = yield this.request(l);
                                this.sdk.useStorageCache && this.emitUserLoggedOut(C), r(C)
                            } catch (r) {
                                l(r)
                            }
                        }))
                    }
                    requestInfoWithUI(r) {
                        let l = d(e3.RequestUserInfoWithUI, r ? [r] : []);
                        return this.request(l)
                    }
                    showSettings(r) {
                        let l = d(this.sdk.testMode ? e3.UserSettingsTestMode : e3.UserSettings, [r]);
                        return this.request(l)
                    }
                    recoverAccount(r) {
                        let l = d(this.sdk.testMode ? e3.RecoverAccountTestMode : e3.RecoverAccount, [r]);
                        return this.request(l)
                    }
                    getMetadata() {
                        k({
                            method: "user.getMetadata()",
                            removalVersions: t9,
                            useInstead: "user.getInfo()"
                        }).log();
                        let r = d(this.sdk.testMode ? e3.GetMetadataTestMode : e3.GetMetadata);
                        return this.request(r)
                    }
                    updateEmail(r) {
                        k({
                            method: "user.updateEmail()",
                            removalVersions: t9,
                            useInstead: "auth.updateEmailWithUI()"
                        }).log();
                        let {
                            email: l,
                            showUI: C = !0
                        } = r, U = d(this.sdk.testMode ? e3.UpdateEmailTestMode : e3.UpdateEmail, [{
                            email: l,
                            showUI: C
                        }]);
                        return this.request(U)
                    }
                    onUserLoggedOut(r) {
                        this.userLoggedOutCallbacks.push(r)
                    }
                    emitUserLoggedOut(r) {
                        this.userLoggedOutCallbacks.forEach(l => {
                            l(r)
                        })
                    }
                },
                rI = class extends t4 {
                    constructor() {
                        super(...arguments), this.localForageKey = "mc_active_wallet"
                    }
                    connectWithUI() {
                        let r = q((l, C) => es_m(this, null, function*() {
                            try {
                                if (this.isMetaMaskBrowser() && (yield this.isWalletEnabled(e1.MetaMask))) {
                                    let r = yield this.autoConnectIfWalletBrowser(e1.MetaMask);
                                    l(r);
                                    return
                                }
                                if (this.isCoinbaseWalletBrowser() && (yield this.isWalletEnabled(e1.CoinbaseWallet))) {
                                    let r = yield this.autoConnectIfWalletBrowser(e1.CoinbaseWallet);
                                    l(r);
                                    return
                                }
                                let U = this.getUserEnv(),
                                    et = d(e3.Login, [U]),
                                    eo = this.request(et);
                                eo.on(e2.WalletSelected, r => this.handleWalletSelected(ae(K({}, r), {
                                    payloadId: et.id
                                }))), eo.on("id-token-created", l => {
                                    r.emit("id-token-created", l)
                                });
                                let es = yield eo;
                                es.error && C(es), l(es)
                            } catch (r) {
                                C(r)
                            }
                        }));
                        return r
                    }
                    showUI() {
                        return this.request(d(e3.ShowUI))
                    }
                    showAddress() {
                        return this.request(d(e3.ShowAddress))
                    }
                    showSendTokensUI() {
                        return this.request(d(e3.ShowSendTokensUI))
                    }
                    showOnRamp() {
                        return this.request(d(e3.ShowOnRamp))
                    }
                    showNFTs() {
                        return this.request(d(e3.ShowNFTs))
                    }
                    showBalances() {
                        return this.request(d(e3.ShowBalances))
                    }
                    sendGaslessTransaction(r, l) {
                        return this.request(d(e3.SendGaslessTransaction, [r, l]))
                    }
                    getInfo() {
                        return es_m(this, null, function*() {
                            k({
                                method: "wallet.getInfo()",
                                removalVersions: t9,
                                useInstead: "user.getInfo()"
                            }).log();
                            let r = yield rs(this.localForageKey), l = d(e3.GetInfo, [{
                                walletType: r
                            }]);
                            return this.request(l)
                        })
                    }
                    disconnect() {
                        k({
                            method: "wallet.disconnect()",
                            removalVersions: t9,
                            useInstead: "user.logout()"
                        }).log(), rl(this.localForageKey), X();
                        let r = d(e3.Disconnect);
                        return this.request(r)
                    }
                    requestUserInfoWithUI(r) {
                        k({
                            method: "wallet.requestUserInfoWithUI()",
                            removalVersions: t9,
                            useInstead: "user.requestUserInfoWithUI()"
                        }).log();
                        let l = d(e3.RequestUserInfoWithUI, r ? [r] : []);
                        return this.request(l)
                    }
                    getProvider() {
                        return es_m(this, null, function*() {
                            switch (yield rs(this.localForageKey)) {
                                case e1.MetaMask:
                                    return this.getMetaMaskProvider();
                                case e1.CoinbaseWallet:
                                    return this.getCoinbaseProvider();
                                default:
                                    return this.sdk.rpcProvider
                            }
                        })
                    }
                    isMetaMaskInstalled() {
                        var r, l, C;
                        return (null == (r = window.ethereum) ? void 0 : r.isMetaMask) || !!(null != (C = null == (l = window.ethereum) ? void 0 : l.providers) && C.find(r => null == r ? void 0 : r.isMetaMask))
                    }
                    isMetaMaskBrowser() {
                        return this.isMobile() && this.isMetaMaskInstalled()
                    }
                    getMetaMaskProvider() {
                        var r, l;
                        return (null == (l = null == (r = window.ethereum) ? void 0 : r.providers) ? void 0 : l.find(r => null == r ? void 0 : r.isMetaMask)) || window.ethereum
                    }
                    connectToMetaMask() {
                        if (this.isMobile() && !this.isMetaMaskInstalled()) {
                            let r = `https://metamask.app.link/dapp/${window.location.href.replace(/(^\w+:|^)\/\//,"")}`;
                            window.location.href = r
                        }
                        return this.getMetaMaskProvider().request({
                            method: "eth_requestAccounts"
                        })
                    }
                    isCoinbaseWalletInstalled() {
                        var r, l, C;
                        return (null == (r = window.ethereum) ? void 0 : r.isCoinbaseWallet) || !!(null != (C = null == (l = window.ethereum) ? void 0 : l.providers) && C.find(r => null == r ? void 0 : r.isCoinbaseWallet))
                    }
                    isCoinbaseWalletBrowser() {
                        var r;
                        return !!(null != (r = window.ethereum) && r.isCoinbaseBrowser)
                    }
                    getCoinbaseProvider() {
                        var r, l;
                        return (null == (l = null == (r = window.ethereum) ? void 0 : r.providers) ? void 0 : l.find(r => null == r ? void 0 : r.isCoinbaseWallet)) || window.ethereum
                    }
                    connectToCoinbaseWallet() {
                        if (this.isMobile() && !this.isCoinbaseWalletBrowser()) {
                            let r = `https://go.cb-w.com/dapp?cb_url=${encodeURIComponent(window.location.href)}`;
                            window.location.href = r
                        }
                        return this.getCoinbaseProvider().request({
                            method: "eth_requestAccounts"
                        })
                    }
                    isMobile() {
                        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|BB|PlayBook|IEMobile|Windows Phone|Silk|Opera Mini/i.test(navigator.userAgent)
                    }
                    getUserEnv() {
                        return {
                            env: {
                                isMetaMaskInstalled: this.isMetaMaskInstalled(),
                                isCoinbaseWalletInstalled: this.isCoinbaseWalletInstalled()
                            }
                        }
                    }
                    connectToThirdPartyWallet(r) {
                        switch (r) {
                            case e1.MetaMask:
                                return this.connectToMetaMask();
                            case e1.CoinbaseWallet:
                                return this.connectToCoinbaseWallet();
                            default:
                                throw Error(`Invalid provider: ${r}. Must be one of "metamask" or "coinbase_wallet".`)
                        }
                    }
                    isWalletEnabled(r) {
                        let l = d("mc_is_wallet_enabled", [{
                            wallet: r
                        }]);
                        return this.request(l)
                    }
                    handleWalletSelected(r) {
                        return es_m(this, null, function*() {
                            try {
                                let l = yield this.connectToThirdPartyWallet(r.wallet);
                                yield ra(this.localForageKey, r.wallet), this.createIntermediaryEvent(e2.WalletConnected, r.payloadId)(l)
                            } catch (l) {
                                console.error(l), this.createIntermediaryEvent(e2.WalletRejected, r.payloadId)()
                            }
                        })
                    }
                    autoConnectIfWalletBrowser(r) {
                        return es_m(this, null, function*() {
                            let l;
                            r === e1.MetaMask && (l = yield this.getMetaMaskProvider().request({
                                method: "eth_requestAccounts"
                            })), r === e1.CoinbaseWallet && (l = yield this.getCoinbaseProvider().request({
                                method: "eth_requestAccounts"
                            })), yield ra(this.localForageKey, r);
                            let C = d(e3.AutoConnect, [{
                                wallet: r,
                                address: l
                            }]);
                            return this.request(C)
                        })
                    }
                },
                {
                    createBoundEmitterMethod: rS,
                    createChainingEmitterMethod: rx
                } = fe(),
                rA = class extends t4 {
                    constructor() {
                        super(...arguments), this.isMagic = !0, this.on = rx("on", this), this.once = rx("once", this), this.addListener = rx("addListener", this), this.off = rx("off", this), this.removeListener = rx("removeListener", this), this.removeAllListeners = rx("removeAllListeners", this), this.emit = rS("emit"), this.eventNames = rS("eventNames"), this.listeners = rS("listeners"), this.listenerCount = rS("listenerCount")
                    }
                    sendAsync(r, l) {
                        if (!l) {
                            var C;
                            let r, U, et;
                            throw C = {
                                procedure: "Magic.rpcProvider.sendAsync",
                                argument: 1,
                                expected: "function",
                                received: null === l ? "null" : typeof l
                            }, new tY(eX.InvalidArgument, `Invalid ${(U=(r=C.argument+1)%10,et=r%100,1===U&&11!==et?`${r}st`:2===U&&12!==et?`${r}nd`:3===U&&13!==et?`${r}rd`:`${r}th`)} argument given to \`${C.procedure}\`.
  Expected: \`${C.expected}\`
  Received: \`${C.received}\``)
                        }
                        if (Array.isArray(r)) this.overlay.post(e6.MAGIC_HANDLE_REQUEST, r.map(r => {
                            let l = G(r);
                            return this.prefixPayloadMethodForTestMode(l), l
                        })).then(r => {
                            l(null, r.map(r => ae(K({}, r.payload), {
                                error: r.hasError ? new tZ(r.payload.error) : null
                            })))
                        });
                        else {
                            let C = G(r);
                            this.prefixPayloadMethodForTestMode(C), this.overlay.post(e6.MAGIC_HANDLE_REQUEST, C).then(r => {
                                l(r.hasError ? new tZ(r.payload.error) : null, r.payload)
                            })
                        }
                    }
                    send(r, l) {
                        if ("string" == typeof r) {
                            let C = d(r, Array.isArray(l) ? l : []);
                            return this.request(C)
                        }
                        if (Array.isArray(r) || l) {
                            this.sendAsync(r, l);
                            return
                        }
                        let C = new tX(eQ.SyncWeb3Method, "Non-async web3 methods are deprecated in web3 > 1.0 and are not supported by the Magic web3 provider. Please use an async method instead.");
                        return C.log(), new t3(r).applyError({
                            code: -32603,
                            message: C.rawMessage
                        }).payload
                    }
                    enable() {
                        let r = d(e3.Login);
                        return this.request(r)
                    }
                    request(r) {
                        return this.prefixPayloadMethodForTestMode(r), super.request(r)
                    }
                    prefixPayloadMethodForTestMode(r) {
                        this.sdk.testMode && (r.method = `testMode/eth/${r.method}`)
                    }
                },
                rP = ["request", "overlay", "sdk"],
                rC = class extends t4 {
                    constructor() {
                        super(void 0), this.__sdk_access_field_descriptors__ = new Map, this.__is_initialized__ = !1, this.utils = {
                            createPromiEvent: q,
                            isPromiEvent: Pt,
                            encodeJSON: de,
                            decodeJSON: at,
                            createJsonRpcRequestPayload: d,
                            standardizeJsonRpcRequestPayload: G,
                            storage: ro
                        };
                        let r = [this, ... function(r) {
                            let l = Object.getPrototypeOf(r),
                                C = [l];
                            for (; l !== t4.prototype;) C.push(l = Object.getPrototypeOf(l));
                            return C
                        }(this)];
                        rP.forEach(l => {
                            let C = r.map(r => Object.getOwnPropertyDescriptor(r, l)),
                                U = C.findIndex(r => !!r),
                                et = C[U];
                            et && (this.__sdk_access_field_descriptors__.set(l, {
                                descriptor: et,
                                isPrototypeField: U > 0
                            }), Object.defineProperty(this, l, {
                                configurable: !0,
                                get: () => {
                                    throw new tY(eX.ExtensionNotInitialized, `Extensions must be initialized with a Magic SDK instance before \`Extension.${l}\` can be accessed. Do not invoke \`Extension.${l}\` inside an extension constructor.`)
                                }
                            }))
                        })
                    }
                    init(r) {
                        this.__is_initialized__ || (rP.forEach(r => {
                            if (this.__sdk_access_field_descriptors__.has(r)) {
                                let {
                                    descriptor: l,
                                    isPrototypeField: C
                                } = this.__sdk_access_field_descriptors__.get(r);
                                C ? delete this[r] : Object.defineProperty(this, r, l)
                            }
                        }), this.sdk = r, this.__is_initialized__ = !0)
                    }
                    createDeprecationWarning(r) {
                        let {
                            method: l,
                            removalVersion: C,
                            useInstead: U
                        } = r, et = U ? ` Use \`${U}\` instead.` : "", eo = `\`${l}\` will be removed from this Extension in version \`${C}\`.${et}`;
                        return new t0(this, "DEPRECATION_NOTICE", eo)
                    }
                    createWarning(r, l) {
                        return new t0(this, r, l)
                    }
                    createError(r, l, C) {
                        return new tQ(this, r, l, C)
                    }
                },
                rk = class extends rC {},
                rN = class extends rC {};
            rN.Internal = rk, rN.Anonymous = "anonymous extension";
            var rO = class extends t4 {
                purchase(r) {
                    let l = d(e3.NFTPurchase, [r]);
                    return this.request(l)
                }
                checkout(r) {
                    let l = d(e3.NFTCheckout, [r]);
                    return this.request(l)
                }
                transfer(r) {
                    let l = d(e3.NFTTransfer, [r]);
                    return this.request(l)
                }
            };

            function Ut(r) {
                return !r.compat || null == r.compat[tG.sdkName] || ("string" == typeof r.compat[tG.sdkName] ? ot(it(tG.version), r.compat[tG.sdkName]) : !!r.compat[tG.sdkName])
            }

            function fr(r) {
                var l;
                let C = null != (l = null == r ? void 0 : r.extensions) ? l : [],
                    U = {},
                    et = [];
                if (Array.isArray(C) ? C.forEach(r => {
                        Ut(r) ? (r.init(this), (r.name || r.name !== rN.Anonymous) && (this[r.name] = r), r instanceof rN.Internal && (ee(r.config) || (U[r.name] = r.config))) : et.push(r)
                    }) : Object.keys(C).forEach(r => {
                        if (Ut(C[r])) {
                            C[r].init(this);
                            let l = C[r];
                            this[r] = l, l instanceof rN.Internal && (ee(l.config) || (U[C[r].name] = l.config))
                        } else et.push(C[r])
                    }), et.length) {
                    let r;
                    throw r = `Some extensions are incompatible with \`${tG.sdkName}@${tG.version}\`:`, et.filter(r => void 0 !== r.compat && null !== r.compat).forEach(l => {
                        let C = l.compat[tG.sdkName];
                        "string" == typeof C ? r += `
  - Extension \`${l.name}\` supports version(s) \`${C}\`` : C || (r += `
  - Extension \`${l.name}\` does not support ${tG.platform} environments.`)
                    }), new tY(eX.IncompatibleExtensions, r)
                }
                return U
            }
            var rT = class {
                constructor(r, l) {
                    var C, U, et, eo;
                    if (this.apiKey = r, !r) throw new tY(eX.MissingApiKey, "Please provide an API key that you acquired from the Magic developer dashboard.");
                    "react-native" === tG.platform && (null == l ? void 0 : l.endpoint) && new tX(eQ.ReactNativeEndpointConfiguration, `CUSTOM DOMAINS ARE NOT SUPPORTED WHEN USING MAGIC SDK WITH REACT NATIVE! The \`endpoint\` parameter SHOULD NOT be provided. The Magic \`<iframe>\` is automatically wrapped by a WebView pointed at \`${tG.defaultEndpoint}\`. Changing this default behavior will lead to unexpected results and potentially security-threatening bugs.`).log();
                    let {
                        defaultEndpoint: es,
                        version: el
                    } = tG;
                    this.testMode = !!(null != l && l.testMode), this.useStorageCache = !!(null != l && l.useStorageCache), this.endpoint = We(null != (C = null == l ? void 0 : l.endpoint) ? C : es).origin, this.auth = new t7(this), this.user = new rE(this), this.wallet = new rI(this), this.nft = new rO(this), this.rpcProvider = new rA(this);
                    let ec = fr.call(this, l);
                    this.parameters = de(K({
                        API_KEY: this.apiKey,
                        DOMAIN_ORIGIN: window.location ? window.location.origin : "",
                        ETH_NETWORK: null == l ? void 0 : l.network,
                        host: We(this.endpoint).host,
                        sdk: tJ[tG.sdkName],
                        version: el,
                        ext: ee(ec) ? void 0 : ec,
                        locale: (null == l ? void 0 : l.locale) || "en_US"
                    }, tG.bundleId ? {
                        bundleId: tG.bundleId
                    } : {})), this.networkHash = (U = this.apiKey, et = null == l ? void 0 : l.network, eo = ee(ec) ? void 0 : ec, et || eo ? eo ? `${U}_${JSON.stringify(eo)}` : et ? "string" == typeof et ? `${U}_eth_${et}` : `${U}_${et.rpcUrl}_${et.chainId}_${et.chainType}` : `${U}_unknown` : `${U}_eth_mainnet`), null != l && l.deferPreload || this.preload()
                }
                get overlay() {
                    if (!rT.__overlays__.has(this.parameters)) {
                        let r = new tG.ViewController(this.endpoint, this.parameters, this.networkHash);
                        r.init(), rT.__overlays__.set(this.parameters, r)
                    }
                    return rT.__overlays__.get(this.parameters)
                }
                preload() {
                    return es_m(this, null, function*() {
                        yield this.overlay.checkIsReadyForRequest
                    })
                }
            };
            rT.__overlays__ = new Map;
            var rR = class {
                    constructor(r, l, C) {
                        this.endpoint = r, this.parameters = l, this.networkHash = C, this.messageHandlers = new Set, this.isConnectedToInternet = !0, this.checkIsReadyForRequest = this.waitForReady(), this.isReadyForRequest = !1, this.listen()
                    }
                    post(r, l) {
                        return es_m(this, null, function*() {
                            return Le((C, U) => es_m(this, null, function*() {
                                var et;
                                this.isConnectedToInternet || U(pt()), this.isReadyForRequest || (yield this.waitForReady());
                                let eo = [],
                                    es = Array.isArray(l) ? l.map(r => r.id) : [],
                                    el = yield function(r, l, C) {
                                        return es_m(this, null, function*() {
                                            var U;
                                            let et = yield rs("rt"), eo;
                                            if ("web" === tG.platform) try {
                                                eo = null != (U = yield rs("jwt")) ? U : yield function() {
                                                    return es_m(this, null, function*() {
                                                        var r, l, C, U;
                                                        let et, eo, es = yield function() {
                                                            return es_m(this, null, function*() {
                                                                if (!se()) {
                                                                    console.info("webcrypto is not supported");
                                                                    return
                                                                }
                                                                return (yield rs(rm)) || (yield function() {
                                                                    return es_m(this, null, function*() {
                                                                        let {
                                                                            subtle: r
                                                                        } = window.crypto, l = yield r.generateKey(rb, !1, ["sign"]), C = yield r.exportKey("jwk", l.publicKey);
                                                                        yield ra(ry, l.privateKey), yield ra(rm, C)
                                                                    })
                                                                }()), rs(rm)
                                                            })
                                                        }();
                                                        if (!es) {
                                                            console.info("unable to create public key or webcrypto is unsupported");
                                                            return
                                                        }
                                                        let {
                                                            subtle: el
                                                        } = window.crypto, ec = yield rs(ry);
                                                        if (!ec || !el) {
                                                            console.info("unable to find private key or webcrypto unsupported");
                                                            return
                                                        }
                                                        let ed = {
                                                                iat: Math.floor(new Date().getTime() / 1e3),
                                                                jti: ((eo = window.crypto.getRandomValues(new Uint8Array(16)))[6] = 15 & eo[6] | 64, eo[8] = 191 & eo[8] | 128, eo[0].toString(16) + eo[1].toString(16) + eo[2].toString(16) + eo[3].toString(16) + "-" + eo[4].toString(16) + eo[5].toString(16) + "-" + eo[6].toString(16) + eo[7].toString(16) + "-" + eo[8].toString(16) + eo[9].toString(16) + "-" + eo[10].toString(16) + eo[11].toString(16) + eo[12].toString(16) + eo[13].toString(16) + eo[14].toString(16) + eo[15].toString(16))
                                                            },
                                                            eh = {
                                                                protected: (r = JSON.stringify({
                                                                    typ: "dpop+jwt",
                                                                    alg: "ES256",
                                                                    jwk: es
                                                                }), St(ar(r))),
                                                                claims: (l = JSON.stringify(ed), St(ar(l)))
                                                            },
                                                            ef = (C = `${eh.protected}.${eh.claims}`, new TextEncoder().encode(C)),
                                                            ep = (U = new Uint8Array((yield el.sign({
                                                                name: r_,
                                                                hash: {
                                                                    name: "SHA-256"
                                                                }
                                                            }, ec, ef))), et = "", U.forEach(r => {
                                                                et += String.fromCharCode(r)
                                                            }), St(et));
                                                        return `${eh.protected}.${eh.claims}.${ep}`
                                                    })
                                                }()
                                            } catch (r) {
                                                console.error("webcrypto error", r)
                                            }
                                            let es = {
                                                msgType: r,
                                                payload: l
                                            };
                                            eo && (es.jwt = eo), eo && et && (es.rt = et);
                                            let el = yield function(r) {
                                                return es_m(this, null, function*() {
                                                    let l = yield rs(`ds_${r}`), C = yield rs("iv"), U = yield rs("ek");
                                                    if (!C || !l || !U || !se()) return;
                                                    let {
                                                        subtle: et
                                                    } = window.crypto;
                                                    return Lt((yield et.decrypt({
                                                        name: rw,
                                                        iv: C
                                                    }, U, Ot(l))))
                                                })
                                            }(C);
                                            return el && (es.deviceShare = el), es
                                        })
                                    }(`${r}-${this.parameters}`, l, this.networkHash);
                                yield this._post(el);
                                let ec = this.on(e5.MAGIC_HANDLE_RESPONSE, (et = () => ec(), r => {
                                    var U, el;
                                    let ec, ed;
                                    let {
                                        id: eh,
                                        response: ef
                                    } = (ed = (ec = null == (el = r.data.response) ? void 0 : el.id) && Array.isArray(l) ? l.find(r => r.id === ec) : l, ec && ed ? {
                                        id: ec,
                                        response: new t3(ed).applyResult(r.data.response.result).applyError(r.data.response.error)
                                    } : {});
                                    if (function(r) {
                                            es_m(this, null, function*() {
                                                r.data.rt && (yield ra("rt", r.data.rt))
                                            })
                                        }(r), (null == (U = null == ef ? void 0 : ef.payload.error) ? void 0 : U.message) === "User denied account access.") X();
                                    else if (r.data.deviceShare) {
                                        let {
                                            deviceShare: l
                                        } = r.data;
                                        ! function(r, l) {
                                            es_m(this, null, function*() {
                                                let C = yield function() {
                                                    return es_m(this, null, function*() {
                                                        if (!se()) {
                                                            console.info("webcrypto is not supported");
                                                            return
                                                        }
                                                        let {
                                                            crypto: r
                                                        } = window;
                                                        return (yield rs("iv")) || r.getRandomValues(new Uint8Array(12))
                                                    })
                                                }(), U = yield function() {
                                                    return es_m(this, null, function*() {
                                                        if (!se()) {
                                                            console.info("webcrypto is not supported");
                                                            return
                                                        }
                                                        let {
                                                            subtle: r
                                                        } = window.crypto;
                                                        return (yield rs("ek")) || (yield r.generateKey({
                                                            name: rw,
                                                            length: 256
                                                        }, !1, ["encrypt", "decrypt"]))
                                                    })
                                                }();
                                                if (!C || !U || !r) return;
                                                let et = Ot(r),
                                                    {
                                                        subtle: eo
                                                    } = window.crypto,
                                                    es = Lt((yield eo.encrypt({
                                                        name: rw,
                                                        iv: C
                                                    }, U, et)));
                                                yield ra(`ds_${l}`, es), yield ra("ek", U), yield ra("iv", C)
                                            })
                                        }(l, this.networkHash)
                                    }
                                    eh && ef && Array.isArray(l) && es.includes(eh) ? (eo.push(ef), eo.length === l.length && (et(), C(eo))) : eh && ef && !Array.isArray(l) && eh === l.id && (et(), C(ef))
                                }))
                            }))
                        })
                    }
                    on(r, l) {
                        let C = l.bind(window),
                            s = l => {
                                l.data.msgType === `${r}-${this.parameters}` && C(l)
                            };
                        return this.messageHandlers.add(s), () => this.messageHandlers.delete(s)
                    }
                    waitForReady() {
                        return new Promise(r => {
                            let l = this.on(e5.MAGIC_OVERLAY_READY, () => {
                                this.isReadyForRequest = !0, r(), l()
                            })
                        })
                    }
                    listen() {
                        this.on(e5.MAGIC_HIDE_OVERLAY, () => {
                            this.hideOverlay()
                        }), this.on(e5.MAGIC_SHOW_OVERLAY, () => {
                            this.showOverlay()
                        })
                    }
                },
                rD = Object.create,
                rB = Object.defineProperty,
                rU = Object.getOwnPropertyDescriptor,
                rL = Object.getOwnPropertyNames,
                rM = Object.getPrototypeOf,
                rj = Object.prototype.hasOwnProperty,
                es_H = (r, l) => () => (l || r((l = {
                    exports: {}
                }).exports, l), l.exports),
                es_se = (r, l, C, U) => {
                    if (l && "object" == typeof l || "function" == typeof l)
                        for (let et of rL(l)) rj.call(r, et) || et === C || rB(r, et, {
                            get: () => l[et],
                            enumerable: !(U = rU(l, et)) || U.enumerable
                        });
                    return r
                },
                dist_es_T = (r, l, C) => (C = null != r ? rD(rM(r)) : {}, es_se(!l && r && r.__esModule ? C : rB(C, "default", {
                    value: r,
                    enumerable: !0
                }), r)),
                es_C = (r, l, C) => new Promise((U, et) => {
                    var w = r => {
                            try {
                                d(C.next(r))
                            } catch (r) {
                                et(r)
                            }
                        },
                        R = r => {
                            try {
                                d(C.throw(r))
                            } catch (r) {
                                et(r)
                            }
                        },
                        d = r => r.done ? U(r.value) : Promise.resolve(r.value).then(w, R);
                    d((C = C.apply(r, l)).next())
                }),
                rq = es_H((r, l) => {
                    var C, U;
                    C = r, U = function() {
                        var r, l, C, U, et, eo, es, el, ec, ed, eh, ef, ep = ep || (r = Math, l = Object.create || function() {
                            function e() {}
                            return function(r) {
                                var l;
                                return e.prototype = r, l = new e, e.prototype = null, l
                            }
                        }(), et = (U = (C = {}).lib = {}).Base = {
                            extend: function(r) {
                                var C = l(this);
                                return r && C.mixIn(r), C.hasOwnProperty("init") && this.init !== C.init || (C.init = function() {
                                    C.$super.init.apply(this, arguments)
                                }), C.init.prototype = C, C.$super = this, C
                            },
                            create: function() {
                                var r = this.extend();
                                return r.init.apply(r, arguments), r
                            },
                            init: function() {},
                            mixIn: function(r) {
                                for (var l in r) r.hasOwnProperty(l) && (this[l] = r[l]);
                                r.hasOwnProperty("toString") && (this.toString = r.toString)
                            },
                            clone: function() {
                                return this.init.prototype.extend(this)
                            }
                        }, eo = U.WordArray = et.extend({
                            init: function(r, l) {
                                r = this.words = r || [], void 0 != l ? this.sigBytes = l : this.sigBytes = 4 * r.length
                            },
                            toString: function(r) {
                                return (r || el).stringify(this)
                            },
                            concat: function(r) {
                                var l = this.words,
                                    C = r.words,
                                    U = this.sigBytes,
                                    et = r.sigBytes;
                                if (this.clamp(), U % 4)
                                    for (var eo = 0; eo < et; eo++) {
                                        var es = C[eo >>> 2] >>> 24 - eo % 4 * 8 & 255;
                                        l[U + eo >>> 2] |= es << 24 - (U + eo) % 4 * 8
                                    } else
                                        for (var eo = 0; eo < et; eo += 4) l[U + eo >>> 2] = C[eo >>> 2];
                                return this.sigBytes += et, this
                            },
                            clamp: function() {
                                var l = this.words,
                                    C = this.sigBytes;
                                l[C >>> 2] &= 4294967295 << 32 - C % 4 * 8, l.length = r.ceil(C / 4)
                            },
                            clone: function() {
                                var r = et.clone.call(this);
                                return r.words = this.words.slice(0), r
                            },
                            random: function(l) {
                                for (var C, U = [], c = function(l) {
                                        var l = l,
                                            C = 987654321;
                                        return function() {
                                            var U = ((C = 36969 * (65535 & C) + (C >> 16) & 4294967295) << 16) + (l = 18e3 * (65535 & l) + (l >> 16) & 4294967295) & 4294967295;
                                            return U /= 4294967296, (U += .5) * (r.random() > .5 ? 1 : -1)
                                        }
                                    }, et = 0; et < l; et += 4) {
                                    var es = c(4294967296 * (C || r.random()));
                                    C = 987654071 * es(), U.push(4294967296 * es() | 0)
                                }
                                return new eo.init(U, l)
                            }
                        }), el = (es = C.enc = {}).Hex = {
                            stringify: function(r) {
                                for (var l = r.words, C = r.sigBytes, U = [], et = 0; et < C; et++) {
                                    var eo = l[et >>> 2] >>> 24 - et % 4 * 8 & 255;
                                    U.push((eo >>> 4).toString(16)), U.push((15 & eo).toString(16))
                                }
                                return U.join("")
                            },
                            parse: function(r) {
                                for (var l = r.length, C = [], U = 0; U < l; U += 2) C[U >>> 3] |= parseInt(r.substr(U, 2), 16) << 24 - U % 8 * 4;
                                return new eo.init(C, l / 2)
                            }
                        }, ec = es.Latin1 = {
                            stringify: function(r) {
                                for (var l = r.words, C = r.sigBytes, U = [], et = 0; et < C; et++) {
                                    var eo = l[et >>> 2] >>> 24 - et % 4 * 8 & 255;
                                    U.push(String.fromCharCode(eo))
                                }
                                return U.join("")
                            },
                            parse: function(r) {
                                for (var l = r.length, C = [], U = 0; U < l; U++) C[U >>> 2] |= (255 & r.charCodeAt(U)) << 24 - U % 4 * 8;
                                return new eo.init(C, l)
                            }
                        }, ed = es.Utf8 = {
                            stringify: function(r) {
                                try {
                                    return decodeURIComponent(escape(ec.stringify(r)))
                                } catch {
                                    throw Error("Malformed UTF-8 data")
                                }
                            },
                            parse: function(r) {
                                return ec.parse(unescape(encodeURIComponent(r)))
                            }
                        }, eh = U.BufferedBlockAlgorithm = et.extend({
                            reset: function() {
                                this._data = new eo.init, this._nDataBytes = 0
                            },
                            _append: function(r) {
                                "string" == typeof r && (r = ed.parse(r)), this._data.concat(r), this._nDataBytes += r.sigBytes
                            },
                            _process: function(l) {
                                var C = this._data,
                                    U = C.words,
                                    et = C.sigBytes,
                                    es = this.blockSize,
                                    el = et / (4 * es),
                                    ec = (el = l ? r.ceil(el) : r.max((0 | el) - this._minBufferSize, 0)) * es,
                                    ed = r.min(4 * ec, et);
                                if (ec) {
                                    for (var eh = 0; eh < ec; eh += es) this._doProcessBlock(U, eh);
                                    var ef = U.splice(0, ec);
                                    C.sigBytes -= ed
                                }
                                return new eo.init(ef, ed)
                            },
                            clone: function() {
                                var r = et.clone.call(this);
                                return r._data = this._data.clone(), r
                            },
                            _minBufferSize: 0
                        }), U.Hasher = eh.extend({
                            cfg: et.extend(),
                            init: function(r) {
                                this.cfg = this.cfg.extend(r), this.reset()
                            },
                            reset: function() {
                                eh.reset.call(this), this._doReset()
                            },
                            update: function(r) {
                                return this._append(r), this._process(), this
                            },
                            finalize: function(r) {
                                return r && this._append(r), this._doFinalize()
                            },
                            blockSize: 16,
                            _createHelper: function(r) {
                                return function(l, C) {
                                    return new r.init(C).finalize(l)
                                }
                            },
                            _createHmacHelper: function(r) {
                                return function(l, C) {
                                    return new ef.HMAC.init(r, C).finalize(l)
                                }
                            }
                        }), ef = C.algo = {}, C);
                        return ep
                    }, "object" == typeof r ? l.exports = r = U() : "function" == typeof define && define.amd ? define([], U) : C.CryptoJS = U()
                }),
                r$ = es_H((r, l) => {
                    var C, U;
                    C = r, U = function(r) {
                        return function(l) {
                            var C = r.lib,
                                U = C.WordArray,
                                et = C.Hasher,
                                eo = r.algo,
                                es = [],
                                el = [];
                            (function() {
                                function f(r) {
                                    return (r - (0 | r)) * 4294967296 | 0
                                }
                                for (var r = 2, C = 0; C < 64;)(function(r) {
                                    for (var C = l.sqrt(r), U = 2; U <= C; U++)
                                        if (!(r % U)) return !1;
                                    return !0
                                })(r) && (C < 8 && (es[C] = f(l.pow(r, .5))), el[C] = f(l.pow(r, 1 / 3)), C++), r++
                            })();
                            var ec = [],
                                ed = eo.SHA256 = et.extend({
                                    _doReset: function() {
                                        this._hash = new U.init(es.slice(0))
                                    },
                                    _doProcessBlock: function(r, l) {
                                        for (var C = this._hash.words, U = C[0], et = C[1], eo = C[2], es = C[3], ed = C[4], eh = C[5], ef = C[6], ep = C[7], eg = 0; eg < 64; eg++) {
                                            if (eg < 16) ec[eg] = 0 | r[l + eg];
                                            else {
                                                var ey = ec[eg - 15],
                                                    em = (ey << 25 | ey >>> 7) ^ (ey << 14 | ey >>> 18) ^ ey >>> 3,
                                                    e_ = ec[eg - 2],
                                                    eb = (e_ << 15 | e_ >>> 17) ^ (e_ << 13 | e_ >>> 19) ^ e_ >>> 10;
                                                ec[eg] = em + ec[eg - 7] + eb + ec[eg - 16]
                                            }
                                            var ew = ed & eh ^ ~ed & ef,
                                                eE = U & et ^ U & eo ^ et & eo,
                                                eI = (U << 30 | U >>> 2) ^ (U << 19 | U >>> 13) ^ (U << 10 | U >>> 22),
                                                eS = ep + ((ed << 26 | ed >>> 6) ^ (ed << 21 | ed >>> 11) ^ (ed << 7 | ed >>> 25)) + ew + el[eg] + ec[eg],
                                                ex = eI + eE;
                                            ep = ef, ef = eh, eh = ed, ed = es + eS | 0, es = eo, eo = et, et = U, U = eS + ex | 0
                                        }
                                        C[0] = C[0] + U | 0, C[1] = C[1] + et | 0, C[2] = C[2] + eo | 0, C[3] = C[3] + es | 0, C[4] = C[4] + ed | 0, C[5] = C[5] + eh | 0, C[6] = C[6] + ef | 0, C[7] = C[7] + ep | 0
                                    },
                                    _doFinalize: function() {
                                        var r = this._data,
                                            C = r.words,
                                            U = 8 * this._nDataBytes,
                                            et = 8 * r.sigBytes;
                                        return C[et >>> 5] |= 128 << 24 - et % 32, C[(et + 64 >>> 9 << 4) + 14] = l.floor(U / 4294967296), C[(et + 64 >>> 9 << 4) + 15] = U, r.sigBytes = 4 * C.length, this._process(), this._hash
                                    },
                                    clone: function() {
                                        var r = et.clone.call(this);
                                        return r._hash = this._hash.clone(), r
                                    }
                                });
                            r.SHA256 = et._createHelper(ed), r.HmacSHA256 = et._createHmacHelper(ed)
                        }(Math), r.SHA256
                    }, "object" == typeof r ? l.exports = r = U(rq()) : "function" == typeof define && define.amd ? define(["./core"], U) : U(C.CryptoJS)
                }),
                rz = es_H((r, l) => {
                    var C, U;
                    C = r, U = function(r) {
                        var l;
                        return l = r.lib.WordArray, r.enc.Base64 = {
                            stringify: function(r) {
                                var l = r.words,
                                    C = r.sigBytes,
                                    U = this._map;
                                r.clamp();
                                for (var et = [], eo = 0; eo < C; eo += 3)
                                    for (var es = l[eo >>> 2] >>> 24 - eo % 4 * 8 & 255, el = l[eo + 1 >>> 2] >>> 24 - (eo + 1) % 4 * 8 & 255, ec = l[eo + 2 >>> 2] >>> 24 - (eo + 2) % 4 * 8 & 255, ed = es << 16 | el << 8 | ec, eh = 0; eh < 4 && eo + .75 * eh < C; eh++) et.push(U.charAt(ed >>> 6 * (3 - eh) & 63));
                                var ef = U.charAt(64);
                                if (ef)
                                    for (; et.length % 4;) et.push(ef);
                                return et.join("")
                            },
                            parse: function(r) {
                                var C = r.length,
                                    U = this._map,
                                    et = this._reverseMap;
                                if (!et) {
                                    et = this._reverseMap = [];
                                    for (var eo = 0; eo < U.length; eo++) et[U.charCodeAt(eo)] = eo
                                }
                                var es = U.charAt(64);
                                if (es) {
                                    var el = r.indexOf(es); - 1 !== el && (C = el)
                                }
                                return function(r, C, U) {
                                    for (var et = [], eo = 0, es = 0; es < C; es++)
                                        if (es % 4) {
                                            var el = U[r.charCodeAt(es - 1)] << es % 4 * 2,
                                                ec = U[r.charCodeAt(es)] >>> 6 - es % 4 * 2;
                                            et[eo >>> 2] |= (el | ec) << 24 - eo % 4 * 8, eo++
                                        }
                                    return l.create(et, eo)
                                }(r, C, et)
                            },
                            _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
                        }, r.enc.Base64
                    }, "object" == typeof r ? l.exports = r = U(rq()) : "function" == typeof define && define.amd ? define(["./core"], U) : U(C.CryptoJS)
                }),
                rH = ((eN = rH || {}).ParseRedirectResult = "magic_oauth_parse_redirect_result", eN),
                rF = ((eO = rF || {}).InvalidRequest = "invalid_request", eO.InvalidClient = "invalid_client", eO.InvalidScope = "invalid_scope", eO.InvalidGrant = "invalid_grant", eO.UnauthorizedClient = "unauthorized_client", eO.UnsupportedResponseType = "unsupported_response_type", eO.UnsupportedGrantType = "unsupported_grant_type", eO.UnsupportedTokenType = "unsupported_token_type", eO.AccessDenied = "access_denied", eO.ServerError = "server_error", eO.TemporarilyUnavailable = "temporarily_unavailable", eO),
                rW = dist_es_T(r$()),
                rV = dist_es_T(rz()),
                rK = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~",
                rG = "undefined" != typeof window && !!window.crypto,
                rJ = rG && !!window.crypto.subtle;

            function es_M(r) {
                var l;
                return l = r instanceof ArrayBuffer ? btoa(Array.from(new Uint8Array(r)).map(r => String.fromCharCode(r)).join("")) : rV.default.stringify(r), l.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "")
            }

            function dist_es_N(r) {
                let l = new Uint8Array(r);
                if (rG) window.crypto.getRandomValues(l);
                else
                    for (let C = 0; C < r; C += 1) l[C] = Math.floor(Math.random() * Math.floor(255));
                return Array.from(l).map(r => rK[r % rK.length]).join("")
            }
            var rY = class extends rN.Internal {
                    constructor() {
                        super(...arguments), this.name = "oauth", this.config = {}, this.compat = {
                            "magic-sdk": ">=2.4.6",
                            "@magic-sdk/react-native": !1,
                            "@magic-sdk/react-native-bare": !1,
                            "@magic-sdk/react-native-expo": !1
                        }
                    }
                    loginWithRedirect(r) {
                        return this.utils.createPromiEvent(l => es_C(this, null, function*() {
                            let {
                                provider: C,
                                query: U
                            } = yield es_pe.call(this, r);
                            window.location.href = new URL(`/v1/oauth2/${C}/start?${U}`, this.sdk.endpoint).href, l()
                        }))
                    }
                    getRedirectResult() {
                        let r = window.location.search,
                            l = window.location.origin + window.location.pathname;
                        return window.history.replaceState(null, "", l), he.call(this, r)
                    }
                },
                rZ = "oauth_redirect_metadata";

            function es_pe(r) {
                return es_C(this, null, function*() {
                    yield this.utils.storage.removeItem(rZ);
                    let {
                        provider: l,
                        redirectURI: C,
                        scope: U,
                        loginHint: et
                    } = r, {
                        verifier: eo,
                        challenge: es,
                        state: el
                    } = yield function() {
                        return es_C(this, null, function*() {
                            let r = dist_es_N(128),
                                l = dist_es_N(128),
                                C = yield function(r) {
                                    return es_C(this, null, function*() {
                                        if (rJ) {
                                            let l = new TextEncoder().encode(r);
                                            return crypto.subtle.digest("SHA-256", l).then(es_M)
                                        }
                                        return es_M((0, rW.default)(r))
                                    })
                                }(l);
                            return {
                                verifier: l,
                                challenge: C,
                                state: r
                            }
                        })
                    }(), ec = JSON.stringify({
                        verifier: eo,
                        state: el
                    });
                    return yield this.utils.storage.setItem(rZ, ec), {
                        query: [`magic_api_key=${encodeURIComponent(this.sdk.apiKey)}`, `magic_challenge=${encodeURIComponent(es)}`, `state=${encodeURIComponent(el)}`, `platform=${encodeURIComponent("web")}`, U && `scope=${encodeURIComponent(U.join(" "))}`, C && `redirect_uri=${encodeURIComponent(C)}`, et && `login_hint=${encodeURIComponent(et)}`].reduce((r, l) => l ? `${r}&${l}` : r),
                        provider: l,
                        redirectURI: C
                    }
                })
            }

            function he(r) {
                return this.utils.createPromiEvent((l, C) => es_C(this, null, function*() {
                    var U;
                    let {
                        verifier: et,
                        state: eo
                    } = JSON.parse((yield this.utils.storage.getItem(rZ)));
                    this.utils.storage.removeItem(rZ);
                    let es = this.utils.createJsonRpcRequestPayload("magic_oauth_parse_redirect_result", [r, et, eo]),
                        el = yield this.request(es);
                    el.error && C(this.createError(el.error, null != (U = el.error_description) ? U : "An error occurred.", {
                        errorURI: el.error_uri,
                        provider: el.provider
                    })), l(el)
                }))
            }
            let EmailOTPMagicWalletConnector_createEmailOTPMagicWalletConnector = r => class extends createEmailMagicWalletConnector(r) {
                    constructor() {
                        super(...arguments), this.name = "Magic Email OTP", this.magicPromiSessionEventEmitter = new eY.Z
                    }
                    cancelLogIn() {
                        var r;
                        null === (r = this._handle) || void 0 === r || r.emit("cancel")
                    }
                    retryOneTypePassword() {
                        return _tslib_awaiter(this, void 0, void 0, function*() {
                            let {
                                email: r
                            } = this;
                            if (r) return this.sendOTP(r)
                        })
                    }
                    verifyOneTimePassword(r) {
                        return _tslib_awaiter(this, void 0, void 0, function*() {
                            let l = this._handle,
                                C = Error("Please double check your code and try again");
                            if (!l) throw Error("Login with email OTP before verifying");
                            return new Promise((U, et) => {
                                l.on("done", () => U(!0)).on("invalid-email-otp", () => et(C)).on("error", et).catch(et).emit("verify-email-otp", r)
                            }).then(r => _tslib_awaiter(this, void 0, void 0, function*() {
                                return yield this.getAndCacheWalletAddress(), r
                            }))
                        })
                    }
                    sendOTP(r) {
                        var l;
                        return _tslib_awaiter(this, void 0, void 0, function*() {
                            let C = this.magicClient.getClient();
                            null === (l = this._handle) || void 0 === l || l.emit("cancel");
                            try {
                                yield this._handle
                            } catch (r) {
                                eZ.kg.debug(r)
                            }
                            this._handle = C.auth.loginWithEmailOTP({
                                email: r,
                                showUI: !1
                            }), this._handle.then(r => {
                                this.magicPromiSessionEventEmitter.emit("token", r)
                            }).catch(r => {
                                if (isCancelledError(r)) {
                                    eZ.kg.debug(r);
                                    return
                                }
                                this.magicPromiSessionEventEmitter.emit("error", r)
                            })
                        })
                    }
                    loginWithMagic() {
                        return _tslib_awaiter(this, void 0, void 0, function*() {
                            let r = yield this.getUserMetadata();
                            if (r && r.publicAddress) return this.setEmail(null == r ? void 0 : r.email), r.publicAddress;
                            let {
                                email: l
                            } = this;
                            return l ? (this.sendOTP(l), new Promise((r, l) => {
                                this.magicPromiSessionEventEmitter.once("token", r), this.magicPromiSessionEventEmitter.once("error", l)
                            })) : null
                        })
                    }
                },
                hasProperty = (r, l) => Object.prototype.hasOwnProperty.call(r, l),
                isCancelledError = r => (!hasProperty(r, "code") || -32603 === r.code) && !!(hasProperty(r, "message") && r.message.includes("Request has been cancelled")),
                MagicSocialWalletConnector_createMagicSocialWalletConnector = r => class extends r {
                    constructor(r) {
                        super(r), this.name = "Magic Social", this.canConnectViaSocial = !0, this.magicClient.use(new rY)
                    }
                    connect(r) {
                        return _tslib_awaiter(this, void 0, void 0, function*() {
                            yield this.loginWithMagic({
                                provider: r
                            })
                        })
                    }
                    loginWithMagic(r) {
                        return _tslib_awaiter(this, void 0, void 0, function*() {
                            if (!r.provider) return eZ.kg.warn("loginWithMagic called without a provider, returning early"), null;
                            let l = this.magicClient.getClient();
                            return (yield l.user.isLoggedIn()) ? (yield l.user.getInfo()).publicAddress : (yield l.oauth.loginWithRedirect({
                                provider: r.provider,
                                redirectURI: window.location.href
                            }), null)
                        })
                    }
                    getSession() {
                        return _tslib_awaiter(this, void 0, void 0, function*() {
                            let r = this.magicClient.getClient();
                            try {
                                let l = yield r.oauth.getRedirectResult(), {
                                    publicAddress: C
                                } = l.magic.userMetadata;
                                return C && localStorage.setItem(this.storedAddressKey, C), Object.assign(Object.assign({}, l.oauth), {
                                    didToken: l.magic.idToken,
                                    oauthId: l.oauth.userInfo.sub
                                })
                            } catch (r) {
                                eZ.kg.error(r);
                                return
                            }
                        })
                    }
                };
            var rX = C(85031),
                rQ = C(36875),
                r0 = C(30274),
                r1 = C(37491),
                r2 = C(56218),
                r3 = C(35749),
                r5 = C(32663),
                r6 = C(70769),
                r8 = C(71311);
            let r4 = new r8.Y("magic");
            let MagicWalletConnectorBase_MagicWalletConnectorBase = class MagicWalletConnectorBase_MagicWalletConnectorBase extends eZ.VY {
                constructor(r) {
                    super(r), this.canConnectViaCustodialService = !0, this.isEmbeddedWallet = !0, this.walletUiUtils = r.walletUiUtils, this.providerProps = this.prepareProps(r)
                }
                get storedAddressKey() {
                    return `${MagicWalletConnectorBase_MagicWalletConnectorBase.storagePrefix}:${this.chain}:address`
                }
                get chain() {
                    switch (this.providerProps.chain) {
                        case "flow":
                            return "FLOW";
                        case "solana":
                            return "SOL";
                        default:
                            return "EVM"
                    }
                }
                get chainId() {
                    var r;
                    return null !== (r = this.providerProps.chainId) && void 0 !== r ? r : this.providerProps.defaultChainId
                }
                getUserMetadata() {
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        if (yield this.isLoggedIn()) {
                            let r = this.magicClient.getClient();
                            return r.user.getInfo()
                        }
                    })
                }
                isLoggedIn() {
                    let r = this.magicClient.getClient();
                    return r.user.isLoggedIn()
                }
                getAndCacheWalletAddress() {
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        let r = this.magicClient.getClient(),
                            l = yield r.user.getInfo();
                        if (!l || !l.publicAddress) throw Error("No public address");
                        return l.issuer && (this.providerResources = [`magic-auth:issuer:${l.issuer}`]), localStorage.setItem(this.storedAddressKey, l.publicAddress), l.publicAddress
                    })
                }
                prepareProps(r) {
                    var l, C, U, et, eo, es, el, ec;
                    let ed = null === (C = null === (l = r.apiProviders) || void 0 === l ? void 0 : l.magicLink) || void 0 === C ? void 0 : C.providerProjectId;
                    if (!ed) throw Error("Missing MagicLink configuration. Add your MagicLink API key to your project configuration via the Dynamic Labs dashboard.");
                    let eh = null === (et = null === (U = r.apiProviders) || void 0 === U ? void 0 : U.magicLink) || void 0 === et ? void 0 : et.defaultChainId,
                        [ef, ep] = null !== (ec = null === (el = null === (es = null === (eo = r.apiProviders) || void 0 === eo ? void 0 : eo.magicLink) || void 0 === es ? void 0 : es.defaultChain) || void 0 === el ? void 0 : el.split(":")) && void 0 !== ec ? ec : [];
                    return {
                        apiKey: ed,
                        chain: ef,
                        chainId: ep,
                        defaultChainId: eh
                    }
                }
                endSession() {
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        localStorage.removeItem(this.storedAddressKey);
                        let r = this.magicClient.getClient();
                        yield r.user.logout()
                    })
                }
                connect() {
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        yield this.fetchPublicAddress()
                    })
                }
                getConnectedAccounts() {
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        let r = localStorage.getItem(this.storedAddressKey);
                        return r ? [r] : []
                    })
                }
                getDeepLink() {}
                fetchPublicAddress() {
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        let r = localStorage.getItem(this.storedAddressKey);
                        if (r) return r;
                        try {
                            return this._currentAuthCancellablePromise = r5.k3.fromPromise(this.loginWithMagic()), this._currentAuthCancellablePromise.onCancel(() => {
                                "cancelLogIn" in this && this.cancelLogIn()
                            }), yield this._currentAuthCancellablePromise, this.getAndCacheWalletAddress()
                        } catch (r) {
                            if (null == r ? void 0 : r.wasCancelled) {
                                let r = Error();
                                throw r.code = "user-cancelled", r
                            }
                            this.endSession(), r4.error(r);
                            return
                        }
                    })
                }
            };
            MagicWalletConnectorBase_MagicWalletConnectorBase.storagePrefix = "dynamic:magic";
            var r9 = Object.create,
                r7 = Object.defineProperty,
                nn = Object.getOwnPropertyDescriptor,
                no = Object.getOwnPropertyNames,
                ns = Object.getPrototypeOf,
                nl = Object.prototype.hasOwnProperty,
                nc = (eT = function(r) {
                    if ("undefined" != typeof require) return require.apply(this, arguments);
                    throw Error('Dynamic require of "' + r + '" is not supported')
                }, "undefined" != typeof require ? require : "undefined" != typeof Proxy ? new Proxy(eT, {
                    get: (r, l) => ("undefined" != typeof require ? require : r)[l]
                }) : eT),
                es_$e = (r, l) => () => (l || r((l = {
                    exports: {}
                }).exports, l), l.exports),
                es_tt = (r, l, C, U) => {
                    if (l && "object" == typeof l || "function" == typeof l)
                        for (let et of no(l)) nl.call(r, et) || et === C || r7(r, et, {
                            get: () => l[et],
                            enumerable: !(U = nn(l, et)) || U.enumerable
                        });
                    return r
                },
                es_Ze = (r, l, C) => (C = null != r ? r9(ns(r)) : {}, es_tt(!l && r && r.__esModule ? C : r7(C, "default", {
                    value: r,
                    enumerable: !0
                }), r)),
                dist_es_se = (r, l, C) => new Promise((U, et) => {
                    var X = r => {
                            try {
                                Y(C.next(r))
                            } catch (r) {
                                et(r)
                            }
                        },
                        P = r => {
                            try {
                                Y(C.throw(r))
                            } catch (r) {
                                et(r)
                            }
                        },
                        Y = r => r.done ? U(r.value) : Promise.resolve(r.value).then(X, P);
                    Y((C = C.apply(r, l)).next())
                }),
                nd = es_$e((r, l) => {
                    ! function(C) {
                        "object" == typeof r && "u" > typeof l ? l.exports = C() : "function" == typeof define && define.amd ? define([], C) : ("u" > typeof window ? window : "u" > typeof global ? global : "u" > typeof self ? self : this).localforage = C()
                    }(function() {
                        return (function L(r, l, C) {
                            function Y(et, eo) {
                                if (!l[et]) {
                                    if (!r[et]) {
                                        var es = "function" == typeof nc && nc;
                                        if (!eo && es) return es(et, !0);
                                        if (U) return U(et, !0);
                                        var el = Error("Cannot find module '" + et + "'");
                                        throw el.code = "MODULE_NOT_FOUND", el
                                    }
                                    var ec = l[et] = {
                                        exports: {}
                                    };
                                    r[et][0].call(ec.exports, function(l) {
                                        return Y(r[et][1][l] || l)
                                    }, ec, ec.exports, L, r, l, C)
                                }
                                return l[et].exports
                            }
                            for (var U = "function" == typeof nc && nc, et = 0; et < C.length; et++) Y(C[et]);
                            return Y
                        })({
                            1: [function(r, l, C) {
                                (function(r) {
                                    var C, U = r.MutationObserver || r.WebKitMutationObserver;
                                    if (U) {
                                        var et = 0,
                                            eo = new U(z),
                                            es = r.document.createTextNode("");
                                        eo.observe(es, {
                                            characterData: !0
                                        }), C = function() {
                                            es.data = et = ++et % 2
                                        }
                                    } else if (!r.setImmediate && "u" > typeof r.MessageChannel) {
                                        var el = new r.MessageChannel;
                                        el.port1.onmessage = z, C = function() {
                                            el.port2.postMessage(0)
                                        }
                                    } else C = "document" in r && "onreadystatechange" in r.document.createElement("script") ? function() {
                                        var l = r.document.createElement("script");
                                        l.onreadystatechange = function() {
                                            z(), l.onreadystatechange = null, l.parentNode.removeChild(l), l = null
                                        }, r.document.documentElement.appendChild(l)
                                    } : function() {
                                        setTimeout(z, 0)
                                    };
                                    var ec, ed = [];

                                    function z() {
                                        ec = !0;
                                        for (var r, l, C = ed.length; C;) {
                                            for (l = ed, ed = [], r = -1; ++r < C;) l[r]();
                                            C = ed.length
                                        }
                                        ec = !1
                                    }
                                    l.exports = function(r) {
                                        1 !== ed.push(r) || ec || C()
                                    }
                                }).call(this, "u" > typeof global ? global : "u" > typeof self ? self : "u" > typeof window ? window : {})
                            }, {}],
                            2: [function(r, l, C) {
                                var U = r(1);

                                function Y() {}
                                var et = {},
                                    eo = ["REJECTED"],
                                    es = ["FULFILLED"],
                                    el = ["PENDING"];

                                function m(r) {
                                    if ("function" != typeof r) throw TypeError("resolver must be a function");
                                    this.state = el, this.queue = [], this.outcome = void 0, r !== Y && Z(this, r)
                                }

                                function _(r, l, C) {
                                    this.promise = r, "function" == typeof l && (this.onFulfilled = l, this.callFulfilled = this.otherCallFulfilled), "function" == typeof C && (this.onRejected = C, this.callRejected = this.otherCallRejected)
                                }

                                function B(r, l, C) {
                                    U(function() {
                                        var U;
                                        try {
                                            U = l(C)
                                        } catch (l) {
                                            return et.reject(r, l)
                                        }
                                        U === r ? et.reject(r, TypeError("Cannot resolve promise with itself")) : et.resolve(r, U)
                                    })
                                }

                                function z(r) {
                                    var l = r && r.then;
                                    if (r && ("object" == typeof r || "function" == typeof r) && "function" == typeof l) return function() {
                                        l.apply(r, arguments)
                                    }
                                }

                                function Z(r, l) {
                                    var C = !1;

                                    function O(l) {
                                        C || (C = !0, et.reject(r, l))
                                    }

                                    function V(l) {
                                        C || (C = !0, et.resolve(r, l))
                                    }
                                    var U = F(function() {
                                        l(V, O)
                                    });
                                    "error" === U.status && O(U.value)
                                }

                                function F(r, l) {
                                    var C = {};
                                    try {
                                        C.value = r(l), C.status = "success"
                                    } catch (r) {
                                        C.status = "error", C.value = r
                                    }
                                    return C
                                }
                                l.exports = m, m.prototype.catch = function(r) {
                                    return this.then(null, r)
                                }, m.prototype.then = function(r, l) {
                                    if ("function" != typeof r && this.state === es || "function" != typeof l && this.state === eo) return this;
                                    var C = new this.constructor(Y);
                                    return this.state !== el ? B(C, this.state === es ? r : l, this.outcome) : this.queue.push(new _(C, r, l)), C
                                }, _.prototype.callFulfilled = function(r) {
                                    et.resolve(this.promise, r)
                                }, _.prototype.otherCallFulfilled = function(r) {
                                    B(this.promise, this.onFulfilled, r)
                                }, _.prototype.callRejected = function(r) {
                                    et.reject(this.promise, r)
                                }, _.prototype.otherCallRejected = function(r) {
                                    B(this.promise, this.onRejected, r)
                                }, et.resolve = function(r, l) {
                                    var C = F(z, l);
                                    if ("error" === C.status) return et.reject(r, C.value);
                                    var U = C.value;
                                    if (U) Z(r, U);
                                    else {
                                        r.state = es, r.outcome = l;
                                        for (var eo = -1, el = r.queue.length; ++eo < el;) r.queue[eo].callFulfilled(l)
                                    }
                                    return r
                                }, et.reject = function(r, l) {
                                    r.state = eo, r.outcome = l;
                                    for (var C = -1, U = r.queue.length; ++C < U;) r.queue[C].callRejected(l);
                                    return r
                                }, m.resolve = function(r) {
                                    return r instanceof this ? r : et.resolve(new this(Y), r)
                                }, m.reject = function(r) {
                                    var l = new this(Y);
                                    return et.reject(l, r)
                                }, m.all = function(r) {
                                    var l = this;
                                    if ("[object Array]" !== Object.prototype.toString.call(r)) return this.reject(TypeError("must be an array"));
                                    var C = r.length,
                                        U = !1;
                                    if (!C) return this.resolve([]);
                                    for (var eo = Array(C), es = 0, el = -1, ec = new this(Y); ++el < C;) ! function(r, el) {
                                        l.resolve(r).then(function(r) {
                                            eo[el] = r, ++es !== C || U || (U = !0, et.resolve(ec, eo))
                                        }, function(r) {
                                            U || (U = !0, et.reject(ec, r))
                                        })
                                    }(r[el], el);
                                    return ec
                                }, m.race = function(r) {
                                    var l = this;
                                    if ("[object Array]" !== Object.prototype.toString.call(r)) return this.reject(TypeError("must be an array"));
                                    var C = r.length,
                                        U = !1;
                                    if (!C) return this.resolve([]);
                                    for (var eo = -1, es = new this(Y); ++eo < C;) ! function(r) {
                                        l.resolve(r).then(function(r) {
                                            U || (U = !0, et.resolve(es, r))
                                        }, function(r) {
                                            U || (U = !0, et.reject(es, r))
                                        })
                                    }(r[eo]);
                                    return es
                                }
                            }, {
                                1: 1
                            }],
                            3: [function(r, l, C) {
                                (function(l) {
                                    "function" != typeof l.Promise && (l.Promise = r(2))
                                }).call(this, "u" > typeof global ? global : "u" > typeof self ? self : "u" > typeof window ? window : {})
                            }, {
                                2: 2
                            }],
                            4: [function(r, l, C) {
                                var U = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(r) {
                                        return typeof r
                                    } : function(r) {
                                        return r && "function" == typeof Symbol && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r
                                    },
                                    et = function() {
                                        try {
                                            if ("u" > typeof indexedDB) return indexedDB;
                                            if ("u" > typeof webkitIndexedDB) return webkitIndexedDB;
                                            if ("u" > typeof mozIndexedDB) return mozIndexedDB;
                                            if ("u" > typeof OIndexedDB) return OIndexedDB;
                                            if ("u" > typeof msIndexedDB) return msIndexedDB
                                        } catch {
                                            return
                                        }
                                    }();

                                function $(r, l) {
                                    r = r || [], l = l || {};
                                    try {
                                        return new Blob(r, l)
                                    } catch (eo) {
                                        if ("TypeError" !== eo.name) throw eo;
                                        for (var C = "u" > typeof BlobBuilder ? BlobBuilder : "u" > typeof MSBlobBuilder ? MSBlobBuilder : "u" > typeof MozBlobBuilder ? MozBlobBuilder : WebKitBlobBuilder, U = new C, et = 0; et < r.length; et += 1) U.append(r[et]);
                                        return U.getBlob(l.type)
                                    }
                                }
                                typeof Promise > "u" && r(3);
                                var eo = Promise;

                                function _(r, l) {
                                    l && r.then(function(r) {
                                        l(null, r)
                                    }, function(r) {
                                        l(r)
                                    })
                                }

                                function B(r, l, C) {
                                    "function" == typeof l && r.then(l), "function" == typeof C && r.catch(C)
                                }

                                function z(r) {
                                    return "string" != typeof r && (console.warn(r + " used as a key, but it is not a string."), r = String(r)), r
                                }

                                function Z() {
                                    if (arguments.length && "function" == typeof arguments[arguments.length - 1]) return arguments[arguments.length - 1]
                                }
                                var es = "local-forage-detect-blob-support",
                                    el = void 0,
                                    ec = {},
                                    ed = Object.prototype.toString,
                                    eh = "readonly",
                                    ef = "readwrite";

                                function V(r) {
                                    var l = ec[r.name],
                                        C = {};
                                    C.promise = new eo(function(r, l) {
                                        C.resolve = r, C.reject = l
                                    }), l.deferredOperations.push(C), l.dbReady ? l.dbReady = l.dbReady.then(function() {
                                        return C.promise
                                    }) : l.dbReady = C.promise
                                }

                                function j(r) {
                                    var l = ec[r.name].deferredOperations.pop();
                                    if (l) return l.resolve(), l.promise
                                }

                                function Q(r, l) {
                                    var C = ec[r.name].deferredOperations.pop();
                                    if (C) return C.reject(l), C.promise
                                }

                                function J(r, l) {
                                    return new eo(function(C, U) {
                                        if (ec[r.name] = ec[r.name] || G(), r.db) {
                                            if (!l) return C(r.db);
                                            V(r), r.db.close()
                                        }
                                        var eo = [r.name];
                                        l && eo.push(r.version);
                                        var el = et.open.apply(et, eo);
                                        l && (el.onupgradeneeded = function(l) {
                                            var C = el.result;
                                            try {
                                                C.createObjectStore(r.storeName), l.oldVersion <= 1 && C.createObjectStore(es)
                                            } catch (C) {
                                                if ("ConstraintError" === C.name) console.warn('The database "' + r.name + '" has been upgraded from version ' + l.oldVersion + " to version " + l.newVersion + ', but the storage "' + r.storeName + '" already exists.');
                                                else throw C
                                            }
                                        }), el.onerror = function(r) {
                                            r.preventDefault(), U(el.error)
                                        }, el.onsuccess = function() {
                                            var l = el.result;
                                            l.onversionchange = function(r) {
                                                r.target.close()
                                            }, C(l), j(r)
                                        }
                                    })
                                }

                                function a(r, l) {
                                    if (!r.db) return !0;
                                    var C = !r.db.objectStoreNames.contains(r.storeName),
                                        U = r.version < r.db.version,
                                        et = r.version > r.db.version;
                                    if (U && (r.version !== l && console.warn('The database "' + r.name + "\" can't be downgraded from version " + r.db.version + " to version " + r.version + "."), r.version = r.db.version), et || C) {
                                        if (C) {
                                            var eo = r.db.version + 1;
                                            eo > r.version && (r.version = eo)
                                        }
                                        return !0
                                    }
                                    return !1
                                }

                                function v(r) {
                                    return $([function(r) {
                                        for (var l = r.length, C = new ArrayBuffer(l), U = new Uint8Array(C), et = 0; et < l; et++) U[et] = r.charCodeAt(et);
                                        return C
                                    }(atob(r.data))], {
                                        type: r.type
                                    })
                                }

                                function p(r) {
                                    return r && r.__local_forage_encoded_blob
                                }

                                function g(r) {
                                    var l = this,
                                        C = l._initReady().then(function() {
                                            var r = ec[l._dbInfo.name];
                                            if (r && r.dbReady) return r.dbReady
                                        });
                                    return B(C, r, r), C
                                }

                                function T(r, l, C, U) {
                                    void 0 === U && (U = 1);
                                    try {
                                        var et = r.db.transaction(r.storeName, l);
                                        C(null, et)
                                    } catch (et) {
                                        if (U > 0 && (!r.db || "InvalidStateError" === et.name || "NotFoundError" === et.name)) return eo.resolve().then(function() {
                                            if (!r.db || "NotFoundError" === et.name && !r.db.objectStoreNames.contains(r.storeName) && r.version <= r.db.version) return r.db && (r.version = r.db.version + 1), J(r, !0)
                                        }).then(function() {
                                            return (function(r) {
                                                V(r);
                                                for (var l = ec[r.name], C = l.forages, U = 0; U < C.length; U++) {
                                                    var et = C[U];
                                                    et._dbInfo.db && (et._dbInfo.db.close(), et._dbInfo.db = null)
                                                }
                                                return r.db = null, J(r, !1).then(function(l) {
                                                    return r.db = l, a(r) ? J(r, !0) : l
                                                }).then(function(U) {
                                                    r.db = l.db = U;
                                                    for (var et = 0; et < C.length; et++) C[et]._dbInfo.db = U
                                                }).catch(function(l) {
                                                    throw Q(r, l), l
                                                })
                                            })(r).then(function() {
                                                T(r, l, C, U - 1)
                                            })
                                        }).catch(C);
                                        C(et)
                                    }
                                }

                                function G() {
                                    return {
                                        forages: [],
                                        db: null,
                                        dbReady: null,
                                        deferredOperations: []
                                    }
                                }
                                var ep = {
                                        _driver: "asyncStorage",
                                        _initStorage: function(r) {
                                            var l = this,
                                                C = {
                                                    db: null
                                                };
                                            if (r)
                                                for (var U in r) C[U] = r[U];
                                            var et = ec[C.name];
                                            et || (et = G(), ec[C.name] = et), et.forages.push(l), l._initReady || (l._initReady = l.ready, l.ready = g);
                                            var es = [];

                                            function f() {
                                                return eo.resolve()
                                            }
                                            for (var el = 0; el < et.forages.length; el++) {
                                                var ed = et.forages[el];
                                                ed !== l && es.push(ed._initReady().catch(f))
                                            }
                                            var eh = et.forages.slice(0);
                                            return eo.all(es).then(function() {
                                                return C.db = et.db, J(C, !1)
                                            }).then(function(r) {
                                                return C.db = r, a(C, l._defaultConfig.version) ? J(C, !0) : r
                                            }).then(function(r) {
                                                C.db = et.db = r, l._dbInfo = C;
                                                for (var U = 0; U < eh.length; U++) {
                                                    var eo = eh[U];
                                                    eo !== l && (eo._dbInfo.db = C.db, eo._dbInfo.version = C.version)
                                                }
                                            })
                                        },
                                        _support: function() {
                                            try {
                                                if (!et || !et.open) return !1;
                                                var r = "u" > typeof openDatabase && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform),
                                                    l = "function" == typeof fetch && -1 !== fetch.toString().indexOf("[native code");
                                                return (!r || l) && "u" > typeof indexedDB && "u" > typeof IDBKeyRange
                                            } catch {
                                                return !1
                                            }
                                        }(),
                                        iterate: function(r, l) {
                                            var C = this,
                                                U = new eo(function(l, U) {
                                                    C.ready().then(function() {
                                                        T(C._dbInfo, eh, function(et, eo) {
                                                            if (et) return U(et);
                                                            try {
                                                                var es = eo.objectStore(C._dbInfo.storeName).openCursor(),
                                                                    el = 1;
                                                                es.onsuccess = function() {
                                                                    var C = es.result;
                                                                    if (C) {
                                                                        var U = C.value;
                                                                        p(U) && (U = v(U));
                                                                        var et = r(U, C.key, el++);
                                                                        void 0 !== et ? l(et) : C.continue()
                                                                    } else l()
                                                                }, es.onerror = function() {
                                                                    U(es.error)
                                                                }
                                                            } catch (r) {
                                                                U(r)
                                                            }
                                                        })
                                                    }).catch(U)
                                                });
                                            return _(U, l), U
                                        },
                                        getItem: function(r, l) {
                                            var C = this;
                                            r = z(r);
                                            var U = new eo(function(l, U) {
                                                C.ready().then(function() {
                                                    T(C._dbInfo, eh, function(et, eo) {
                                                        if (et) return U(et);
                                                        try {
                                                            var es = eo.objectStore(C._dbInfo.storeName).get(r);
                                                            es.onsuccess = function() {
                                                                var r = es.result;
                                                                void 0 === r && (r = null), p(r) && (r = v(r)), l(r)
                                                            }, es.onerror = function() {
                                                                U(es.error)
                                                            }
                                                        } catch (r) {
                                                            U(r)
                                                        }
                                                    })
                                                }).catch(U)
                                            });
                                            return _(U, l), U
                                        },
                                        setItem: function(r, l, C) {
                                            var U = this;
                                            r = z(r);
                                            var et = new eo(function(C, et) {
                                                var ec;
                                                U.ready().then(function() {
                                                    var r;
                                                    return ec = U._dbInfo, "[object Blob]" === ed.call(l) ? (r = ec.db, "boolean" == typeof el ? eo.resolve(el) : new eo(function(l) {
                                                        var C = r.transaction(es, ef),
                                                            U = $([""]);
                                                        C.objectStore(es).put(U, "key"), C.onabort = function(r) {
                                                            r.preventDefault(), r.stopPropagation(), l(!1)
                                                        }, C.oncomplete = function() {
                                                            var r = navigator.userAgent.match(/Chrome\/(\d+)/);
                                                            l(navigator.userAgent.match(/Edge\//) || !r || parseInt(r[1], 10) >= 43)
                                                        }
                                                    }).catch(function() {
                                                        return !1
                                                    }).then(function(r) {
                                                        return el = r
                                                    })).then(function(r) {
                                                        return r ? l : new eo(function(r, C) {
                                                            var U = new FileReader;
                                                            U.onerror = C, U.onloadend = function(C) {
                                                                r({
                                                                    __local_forage_encoded_blob: !0,
                                                                    data: btoa(C.target.result || ""),
                                                                    type: l.type
                                                                })
                                                            }, U.readAsBinaryString(l)
                                                        })
                                                    }) : l
                                                }).then(function(l) {
                                                    T(U._dbInfo, ef, function(eo, es) {
                                                        if (eo) return et(eo);
                                                        try {
                                                            var el = es.objectStore(U._dbInfo.storeName);
                                                            null === l && (l = void 0);
                                                            var ec = el.put(l, r);
                                                            es.oncomplete = function() {
                                                                void 0 === l && (l = null), C(l)
                                                            }, es.onabort = es.onerror = function() {
                                                                var r = ec.error ? ec.error : ec.transaction.error;
                                                                et(r)
                                                            }
                                                        } catch (r) {
                                                            et(r)
                                                        }
                                                    })
                                                }).catch(et)
                                            });
                                            return _(et, C), et
                                        },
                                        removeItem: function(r, l) {
                                            var C = this;
                                            r = z(r);
                                            var U = new eo(function(l, U) {
                                                C.ready().then(function() {
                                                    T(C._dbInfo, ef, function(et, eo) {
                                                        if (et) return U(et);
                                                        try {
                                                            var es = eo.objectStore(C._dbInfo.storeName).delete(r);
                                                            eo.oncomplete = function() {
                                                                l()
                                                            }, eo.onerror = function() {
                                                                U(es.error)
                                                            }, eo.onabort = function() {
                                                                var r = es.error ? es.error : es.transaction.error;
                                                                U(r)
                                                            }
                                                        } catch (r) {
                                                            U(r)
                                                        }
                                                    })
                                                }).catch(U)
                                            });
                                            return _(U, l), U
                                        },
                                        clear: function(r) {
                                            var l = this,
                                                C = new eo(function(r, C) {
                                                    l.ready().then(function() {
                                                        T(l._dbInfo, ef, function(U, et) {
                                                            if (U) return C(U);
                                                            try {
                                                                var eo = et.objectStore(l._dbInfo.storeName).clear();
                                                                et.oncomplete = function() {
                                                                    r()
                                                                }, et.onabort = et.onerror = function() {
                                                                    var r = eo.error ? eo.error : eo.transaction.error;
                                                                    C(r)
                                                                }
                                                            } catch (r) {
                                                                C(r)
                                                            }
                                                        })
                                                    }).catch(C)
                                                });
                                            return _(C, r), C
                                        },
                                        length: function(r) {
                                            var l = this,
                                                C = new eo(function(r, C) {
                                                    l.ready().then(function() {
                                                        T(l._dbInfo, eh, function(U, et) {
                                                            if (U) return C(U);
                                                            try {
                                                                var eo = et.objectStore(l._dbInfo.storeName).count();
                                                                eo.onsuccess = function() {
                                                                    r(eo.result)
                                                                }, eo.onerror = function() {
                                                                    C(eo.error)
                                                                }
                                                            } catch (r) {
                                                                C(r)
                                                            }
                                                        })
                                                    }).catch(C)
                                                });
                                            return _(C, r), C
                                        },
                                        key: function(r, l) {
                                            var C = this,
                                                U = new eo(function(l, U) {
                                                    if (r < 0) {
                                                        l(null);
                                                        return
                                                    }
                                                    C.ready().then(function() {
                                                        T(C._dbInfo, eh, function(et, eo) {
                                                            if (et) return U(et);
                                                            try {
                                                                var es = eo.objectStore(C._dbInfo.storeName),
                                                                    el = !1,
                                                                    ec = es.openKeyCursor();
                                                                ec.onsuccess = function() {
                                                                    var C = ec.result;
                                                                    if (!C) {
                                                                        l(null);
                                                                        return
                                                                    }
                                                                    0 === r || el ? l(C.key) : (el = !0, C.advance(r))
                                                                }, ec.onerror = function() {
                                                                    U(ec.error)
                                                                }
                                                            } catch (r) {
                                                                U(r)
                                                            }
                                                        })
                                                    }).catch(U)
                                                });
                                            return _(U, l), U
                                        },
                                        keys: function(r) {
                                            var l = this,
                                                C = new eo(function(r, C) {
                                                    l.ready().then(function() {
                                                        T(l._dbInfo, eh, function(U, et) {
                                                            if (U) return C(U);
                                                            try {
                                                                var eo = et.objectStore(l._dbInfo.storeName).openKeyCursor(),
                                                                    es = [];
                                                                eo.onsuccess = function() {
                                                                    var l = eo.result;
                                                                    if (!l) {
                                                                        r(es);
                                                                        return
                                                                    }
                                                                    es.push(l.key), l.continue()
                                                                }, eo.onerror = function() {
                                                                    C(eo.error)
                                                                }
                                                            } catch (r) {
                                                                C(r)
                                                            }
                                                        })
                                                    }).catch(C)
                                                });
                                            return _(C, r), C
                                        },
                                        dropInstance: function(r, l) {
                                            l = Z.apply(this, arguments);
                                            var C, U = this.config();
                                            if ((r = "function" != typeof r && r || {}).name || (r.name = r.name || U.name, r.storeName = r.storeName || U.storeName), r.name) {
                                                var es = r.name === U.name && this._dbInfo.db ? eo.resolve(this._dbInfo.db) : J(r, !1).then(function(l) {
                                                    var C = ec[r.name],
                                                        U = C.forages;
                                                    C.db = l;
                                                    for (var et = 0; et < U.length; et++) U[et]._dbInfo.db = l;
                                                    return l
                                                });
                                                C = r.storeName ? es.then(function(l) {
                                                    if (l.objectStoreNames.contains(r.storeName)) {
                                                        var C = l.version + 1;
                                                        V(r);
                                                        var U = ec[r.name],
                                                            es = U.forages;
                                                        l.close();
                                                        for (var el = 0; el < es.length; el++) {
                                                            var ed = es[el];
                                                            ed._dbInfo.db = null, ed._dbInfo.version = C
                                                        }
                                                        return new eo(function(l, U) {
                                                            var eo = et.open(r.name, C);
                                                            eo.onerror = function(r) {
                                                                eo.result.close(), U(r)
                                                            }, eo.onupgradeneeded = function() {
                                                                eo.result.deleteObjectStore(r.storeName)
                                                            }, eo.onsuccess = function() {
                                                                var r = eo.result;
                                                                r.close(), l(r)
                                                            }
                                                        }).then(function(r) {
                                                            U.db = r;
                                                            for (var l = 0; l < es.length; l++) {
                                                                var C = es[l];
                                                                C._dbInfo.db = r, j(C._dbInfo)
                                                            }
                                                        }).catch(function(l) {
                                                            throw (Q(r, l) || eo.resolve()).catch(function() {}), l
                                                        })
                                                    }
                                                }) : es.then(function(l) {
                                                    V(r);
                                                    var C = ec[r.name],
                                                        U = C.forages;
                                                    l.close();
                                                    for (var es = 0; es < U.length; es++) U[es]._dbInfo.db = null;
                                                    return new eo(function(l, C) {
                                                        var U = et.deleteDatabase(r.name);
                                                        U.onerror = function() {
                                                            var r = U.result;
                                                            r && r.close(), C(U.error)
                                                        }, U.onblocked = function() {
                                                            console.warn('dropInstance blocked for database "' + r.name + '" until all open connections are closed')
                                                        }, U.onsuccess = function() {
                                                            var r = U.result;
                                                            r && r.close(), l(r)
                                                        }
                                                    }).then(function(r) {
                                                        C.db = r;
                                                        for (var l = 0; l < U.length; l++) j(U[l]._dbInfo)
                                                    }).catch(function(l) {
                                                        throw (Q(r, l) || eo.resolve()).catch(function() {}), l
                                                    })
                                                })
                                            } else C = eo.reject("Invalid arguments");
                                            return _(C, l), C
                                        }
                                    },
                                    eg = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
                                    ey = /^~~local_forage_type~([^~]+)~/,
                                    em = "__lfsc__:",
                                    e_ = em.length,
                                    eb = "arbf",
                                    ew = "blob",
                                    eE = "si08",
                                    eI = "ui08",
                                    eS = "uic8",
                                    ex = "si16",
                                    eA = "si32",
                                    eP = "ur16",
                                    eC = "ui32",
                                    ek = "fl32",
                                    eN = "fl64",
                                    eO = e_ + eb.length,
                                    eT = Object.prototype.toString;

                                function Ke(r) {
                                    var l, C, U, et, eo, es = .75 * r.length,
                                        el = r.length,
                                        ec = 0;
                                    "=" === r[r.length - 1] && (es--, "=" === r[r.length - 2] && es--);
                                    var ed = new ArrayBuffer(es),
                                        eh = new Uint8Array(ed);
                                    for (l = 0; l < el; l += 4) C = eg.indexOf(r[l]), U = eg.indexOf(r[l + 1]), et = eg.indexOf(r[l + 2]), eo = eg.indexOf(r[l + 3]), eh[ec++] = C << 2 | U >> 4, eh[ec++] = (15 & U) << 4 | et >> 2, eh[ec++] = (3 & et) << 6 | 63 & eo;
                                    return ed
                                }

                                function Ee(r) {
                                    var l, C = new Uint8Array(r),
                                        U = "";
                                    for (l = 0; l < C.length; l += 3) U += eg[C[l] >> 2] + eg[(3 & C[l]) << 4 | C[l + 1] >> 4] + eg[(15 & C[l + 1]) << 2 | C[l + 2] >> 6] + eg[63 & C[l + 2]];
                                    return C.length % 3 == 2 ? U = U.substring(0, U.length - 1) + "=" : C.length % 3 == 1 && (U = U.substring(0, U.length - 2) + "=="), U
                                }
                                var eR = {
                                    serialize: function(r, l) {
                                        var C = "";
                                        if (r && (C = eT.call(r)), r && ("[object ArrayBuffer]" === C || r.buffer && "[object ArrayBuffer]" === eT.call(r.buffer))) {
                                            var U, et = em;
                                            r instanceof ArrayBuffer ? (U = r, et += eb) : (U = r.buffer, "[object Int8Array]" === C ? et += eE : "[object Uint8Array]" === C ? et += eI : "[object Uint8ClampedArray]" === C ? et += eS : "[object Int16Array]" === C ? et += ex : "[object Uint16Array]" === C ? et += eP : "[object Int32Array]" === C ? et += eA : "[object Uint32Array]" === C ? et += eC : "[object Float32Array]" === C ? et += ek : "[object Float64Array]" === C ? et += eN : l(Error("Failed to get type for BinaryArray"))), l(et + Ee(U))
                                        } else if ("[object Blob]" === C) {
                                            var eo = new FileReader;
                                            eo.onload = function() {
                                                l(em + ew + ("~~local_forage_type~" + r.type) + "~" + Ee(this.result))
                                            }, eo.readAsArrayBuffer(r)
                                        } else try {
                                            l(JSON.stringify(r))
                                        } catch (C) {
                                            console.error("Couldn't convert value into a JSON string: ", r), l(null, C)
                                        }
                                    },
                                    deserialize: function(r) {
                                        if (r.substring(0, e_) !== em) return JSON.parse(r);
                                        var l, C = r.substring(eO),
                                            U = r.substring(e_, eO);
                                        if (U === ew && ey.test(C)) {
                                            var et = C.match(ey);
                                            l = et[1], C = C.substring(et[0].length)
                                        }
                                        var eo = Ke(C);
                                        switch (U) {
                                            case eb:
                                                return eo;
                                            case ew:
                                                return $([eo], {
                                                    type: l
                                                });
                                            case eE:
                                                return new Int8Array(eo);
                                            case eI:
                                                return new Uint8Array(eo);
                                            case eS:
                                                return new Uint8ClampedArray(eo);
                                            case ex:
                                                return new Int16Array(eo);
                                            case eP:
                                                return new Uint16Array(eo);
                                            case eA:
                                                return new Int32Array(eo);
                                            case eC:
                                                return new Uint32Array(eo);
                                            case ek:
                                                return new Float32Array(eo);
                                            case eN:
                                                return new Float64Array(eo);
                                            default:
                                                throw Error("Unkown type: " + U)
                                        }
                                    },
                                    stringToBuffer: Ke,
                                    bufferToString: Ee
                                };

                                function He(r, l, C, U) {
                                    r.executeSql("CREATE TABLE IF NOT EXISTS " + l.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], C, U)
                                }

                                function ne(r, l, C, U, et, eo) {
                                    r.executeSql(C, U, et, function(r, es) {
                                        es.code === es.SYNTAX_ERR ? r.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [l.storeName], function(r, el) {
                                            el.rows.length ? eo(r, es) : He(r, l, function() {
                                                r.executeSql(C, U, et, eo)
                                            }, eo)
                                        }, eo) : eo(r, es)
                                    }, eo)
                                }

                                function Ve(r, l, C, U) {
                                    var et = this;
                                    r = z(r);
                                    var es = new eo(function(eo, es) {
                                        et.ready().then(function() {
                                            void 0 === l && (l = null);
                                            var el = l,
                                                ec = et._dbInfo;
                                            ec.serializer.serialize(l, function(l, ed) {
                                                ed ? es(ed) : ec.db.transaction(function(C) {
                                                    ne(C, ec, "INSERT OR REPLACE INTO " + ec.storeName + " (key, value) VALUES (?, ?)", [r, l], function() {
                                                        eo(el)
                                                    }, function(r, l) {
                                                        es(l)
                                                    })
                                                }, function(l) {
                                                    if (l.code === l.QUOTA_ERR) {
                                                        if (U > 0) {
                                                            eo(Ve.apply(et, [r, el, C, U - 1]));
                                                            return
                                                        }
                                                        es(l)
                                                    }
                                                })
                                            })
                                        }).catch(es)
                                    });
                                    return _(es, C), es
                                }
                                var eD = {
                                    _driver: "webSQLStorage",
                                    _initStorage: function(r) {
                                        var l = this,
                                            C = {
                                                db: null
                                            };
                                        if (r)
                                            for (var U in r) C[U] = "string" != typeof r[U] ? r[U].toString() : r[U];
                                        var et = new eo(function(r, U) {
                                            try {
                                                C.db = openDatabase(C.name, String(C.version), C.description, C.size)
                                            } catch (r) {
                                                return U(r)
                                            }
                                            C.db.transaction(function(et) {
                                                He(et, C, function() {
                                                    l._dbInfo = C, r()
                                                }, function(r, l) {
                                                    U(l)
                                                })
                                            }, U)
                                        });
                                        return C.serializer = eR, et
                                    },
                                    _support: "function" == typeof openDatabase,
                                    iterate: function(r, l) {
                                        var C = this,
                                            U = new eo(function(l, U) {
                                                C.ready().then(function() {
                                                    var et = C._dbInfo;
                                                    et.db.transaction(function(C) {
                                                        ne(C, et, "SELECT * FROM " + et.storeName, [], function(C, U) {
                                                            for (var eo = U.rows, es = eo.length, el = 0; el < es; el++) {
                                                                var ec = eo.item(el),
                                                                    ed = ec.value;
                                                                if (ed && (ed = et.serializer.deserialize(ed)), void 0 !== (ed = r(ed, ec.key, el + 1))) {
                                                                    l(ed);
                                                                    return
                                                                }
                                                            }
                                                            l()
                                                        }, function(r, l) {
                                                            U(l)
                                                        })
                                                    })
                                                }).catch(U)
                                            });
                                        return _(U, l), U
                                    },
                                    getItem: function(r, l) {
                                        var C = this;
                                        r = z(r);
                                        var U = new eo(function(l, U) {
                                            C.ready().then(function() {
                                                var et = C._dbInfo;
                                                et.db.transaction(function(C) {
                                                    ne(C, et, "SELECT * FROM " + et.storeName + " WHERE key = ? LIMIT 1", [r], function(r, C) {
                                                        var U = C.rows.length ? C.rows.item(0).value : null;
                                                        U && (U = et.serializer.deserialize(U)), l(U)
                                                    }, function(r, l) {
                                                        U(l)
                                                    })
                                                })
                                            }).catch(U)
                                        });
                                        return _(U, l), U
                                    },
                                    setItem: function(r, l, C) {
                                        return Ve.apply(this, [r, l, C, 1])
                                    },
                                    removeItem: function(r, l) {
                                        var C = this;
                                        r = z(r);
                                        var U = new eo(function(l, U) {
                                            C.ready().then(function() {
                                                var et = C._dbInfo;
                                                et.db.transaction(function(C) {
                                                    ne(C, et, "DELETE FROM " + et.storeName + " WHERE key = ?", [r], function() {
                                                        l()
                                                    }, function(r, l) {
                                                        U(l)
                                                    })
                                                })
                                            }).catch(U)
                                        });
                                        return _(U, l), U
                                    },
                                    clear: function(r) {
                                        var l = this,
                                            C = new eo(function(r, C) {
                                                l.ready().then(function() {
                                                    var U = l._dbInfo;
                                                    U.db.transaction(function(l) {
                                                        ne(l, U, "DELETE FROM " + U.storeName, [], function() {
                                                            r()
                                                        }, function(r, l) {
                                                            C(l)
                                                        })
                                                    })
                                                }).catch(C)
                                            });
                                        return _(C, r), C
                                    },
                                    length: function(r) {
                                        var l = this,
                                            C = new eo(function(r, C) {
                                                l.ready().then(function() {
                                                    var U = l._dbInfo;
                                                    U.db.transaction(function(l) {
                                                        ne(l, U, "SELECT COUNT(key) as c FROM " + U.storeName, [], function(l, C) {
                                                            r(C.rows.item(0).c)
                                                        }, function(r, l) {
                                                            C(l)
                                                        })
                                                    })
                                                }).catch(C)
                                            });
                                        return _(C, r), C
                                    },
                                    key: function(r, l) {
                                        var C = this,
                                            U = new eo(function(l, U) {
                                                C.ready().then(function() {
                                                    var et = C._dbInfo;
                                                    et.db.transaction(function(C) {
                                                        ne(C, et, "SELECT key FROM " + et.storeName + " WHERE id = ? LIMIT 1", [r + 1], function(r, C) {
                                                            l(C.rows.length ? C.rows.item(0).key : null)
                                                        }, function(r, l) {
                                                            U(l)
                                                        })
                                                    })
                                                }).catch(U)
                                            });
                                        return _(U, l), U
                                    },
                                    keys: function(r) {
                                        var l = this,
                                            C = new eo(function(r, C) {
                                                l.ready().then(function() {
                                                    var U = l._dbInfo;
                                                    U.db.transaction(function(l) {
                                                        ne(l, U, "SELECT key FROM " + U.storeName, [], function(l, C) {
                                                            for (var U = [], et = 0; et < C.rows.length; et++) U.push(C.rows.item(et).key);
                                                            r(U)
                                                        }, function(r, l) {
                                                            C(l)
                                                        })
                                                    })
                                                }).catch(C)
                                            });
                                        return _(C, r), C
                                    },
                                    dropInstance: function(r, l) {
                                        l = Z.apply(this, arguments);
                                        var C = this.config();
                                        (r = "function" != typeof r && r || {}).name || (r.name = r.name || C.name, r.storeName = r.storeName || C.storeName);
                                        var U, et = this;
                                        return _(U = r.name ? new eo(function(l) {
                                            var U;
                                            U = r.name === C.name ? et._dbInfo.db : openDatabase(r.name, "", "", 0), l(r.storeName ? {
                                                db: U,
                                                storeNames: [r.storeName]
                                            } : new eo(function(r, l) {
                                                U.transaction(function(C) {
                                                    C.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function(l, C) {
                                                        for (var et = [], eo = 0; eo < C.rows.length; eo++) et.push(C.rows.item(eo).name);
                                                        r({
                                                            db: U,
                                                            storeNames: et
                                                        })
                                                    }, function(r, C) {
                                                        l(C)
                                                    })
                                                }, function(r) {
                                                    l(r)
                                                })
                                            }))
                                        }).then(function(r) {
                                            return new eo(function(l, C) {
                                                r.db.transaction(function(U) {
                                                    for (var et = [], es = 0, el = r.storeNames.length; es < el; es++) et.push(function(r) {
                                                        return new eo(function(l, C) {
                                                            U.executeSql("DROP TABLE IF EXISTS " + r, [], function() {
                                                                l()
                                                            }, function(r, l) {
                                                                C(l)
                                                            })
                                                        })
                                                    }(r.storeNames[es]));
                                                    eo.all(et).then(function() {
                                                        l()
                                                    }).catch(function(r) {
                                                        C(r)
                                                    })
                                                }, function(r) {
                                                    C(r)
                                                })
                                            })
                                        }) : eo.reject("Invalid arguments"), l), U
                                    }
                                };

                                function Ge(r, l) {
                                    var C = r.name + "/";
                                    return r.storeName !== l.storeName && (C += r.storeName + "/"), C
                                }
                                var Kr = function(r, l) {
                                        for (var C, U = r.length, et = 0; et < U;) {
                                            if ((C = r[et]) === l || "number" == typeof C && "number" == typeof l && isNaN(C) && isNaN(l)) return !0;
                                            et++
                                        }
                                        return !1
                                    },
                                    eB = Array.isArray || function(r) {
                                        return "[object Array]" === Object.prototype.toString.call(r)
                                    },
                                    eU = {},
                                    eL = {},
                                    eM = {
                                        INDEXEDDB: ep,
                                        WEBSQL: eD,
                                        LOCALSTORAGE: {
                                            _driver: "localStorageWrapper",
                                            _initStorage: function(r) {
                                                var l = {};
                                                if (r)
                                                    for (var C in r) l[C] = r[C];
                                                return l.keyPrefix = Ge(r, this._defaultConfig), ! function() {
                                                    var r = "_localforage_support_test";
                                                    try {
                                                        return localStorage.setItem(r, !0), localStorage.removeItem(r), !1
                                                    } catch {
                                                        return !0
                                                    }
                                                }() || localStorage.length > 0 ? (this._dbInfo = l, l.serializer = eR, eo.resolve()) : eo.reject()
                                            },
                                            _support: function() {
                                                try {
                                                    return "u" > typeof localStorage && "setItem" in localStorage && !!localStorage.setItem
                                                } catch {
                                                    return !1
                                                }
                                            }(),
                                            iterate: function(r, l) {
                                                var C = this,
                                                    U = C.ready().then(function() {
                                                        for (var l = C._dbInfo, U = l.keyPrefix, et = U.length, eo = localStorage.length, es = 1, el = 0; el < eo; el++) {
                                                            var ec = localStorage.key(el);
                                                            if (0 === ec.indexOf(U)) {
                                                                var ed = localStorage.getItem(ec);
                                                                if (ed && (ed = l.serializer.deserialize(ed)), void 0 !== (ed = r(ed, ec.substring(et), es++))) return ed
                                                            }
                                                        }
                                                    });
                                                return _(U, l), U
                                            },
                                            getItem: function(r, l) {
                                                var C = this;
                                                r = z(r);
                                                var U = C.ready().then(function() {
                                                    var l = C._dbInfo,
                                                        U = localStorage.getItem(l.keyPrefix + r);
                                                    return U && (U = l.serializer.deserialize(U)), U
                                                });
                                                return _(U, l), U
                                            },
                                            setItem: function(r, l, C) {
                                                var U = this;
                                                r = z(r);
                                                var et = U.ready().then(function() {
                                                    void 0 === l && (l = null);
                                                    var C = l;
                                                    return new eo(function(et, eo) {
                                                        var es = U._dbInfo;
                                                        es.serializer.serialize(l, function(l, U) {
                                                            if (U) eo(U);
                                                            else try {
                                                                localStorage.setItem(es.keyPrefix + r, l), et(C)
                                                            } catch (r) {
                                                                ("QuotaExceededError" === r.name || "NS_ERROR_DOM_QUOTA_REACHED" === r.name) && eo(r), eo(r)
                                                            }
                                                        })
                                                    })
                                                });
                                                return _(et, C), et
                                            },
                                            removeItem: function(r, l) {
                                                var C = this;
                                                r = z(r);
                                                var U = C.ready().then(function() {
                                                    var l = C._dbInfo;
                                                    localStorage.removeItem(l.keyPrefix + r)
                                                });
                                                return _(U, l), U
                                            },
                                            clear: function(r) {
                                                var l = this,
                                                    C = l.ready().then(function() {
                                                        for (var r = l._dbInfo.keyPrefix, C = localStorage.length - 1; C >= 0; C--) {
                                                            var U = localStorage.key(C);
                                                            0 === U.indexOf(r) && localStorage.removeItem(U)
                                                        }
                                                    });
                                                return _(C, r), C
                                            },
                                            length: function(r) {
                                                var l = this.keys().then(function(r) {
                                                    return r.length
                                                });
                                                return _(l, r), l
                                            },
                                            key: function(r, l) {
                                                var C = this,
                                                    U = C.ready().then(function() {
                                                        var l, U = C._dbInfo;
                                                        try {
                                                            l = localStorage.key(r)
                                                        } catch {
                                                            l = null
                                                        }
                                                        return l && (l = l.substring(U.keyPrefix.length)), l
                                                    });
                                                return _(U, l), U
                                            },
                                            keys: function(r) {
                                                var l = this,
                                                    C = l.ready().then(function() {
                                                        for (var r = l._dbInfo, C = localStorage.length, U = [], et = 0; et < C; et++) {
                                                            var eo = localStorage.key(et);
                                                            0 === eo.indexOf(r.keyPrefix) && U.push(eo.substring(r.keyPrefix.length))
                                                        }
                                                        return U
                                                    });
                                                return _(C, r), C
                                            },
                                            dropInstance: function(r, l) {
                                                if (l = Z.apply(this, arguments), !(r = "function" != typeof r && r || {}).name) {
                                                    var C = this.config();
                                                    r.name = r.name || C.name, r.storeName = r.storeName || C.storeName
                                                }
                                                var U, et = this;
                                                return _(U = r.name ? new eo(function(l) {
                                                    l(r.storeName ? Ge(r, et._defaultConfig) : r.name + "/")
                                                }).then(function(r) {
                                                    for (var l = localStorage.length - 1; l >= 0; l--) {
                                                        var C = localStorage.key(l);
                                                        0 === C.indexOf(r) && localStorage.removeItem(C)
                                                    }
                                                }) : eo.reject("Invalid arguments"), l), U
                                            }
                                        }
                                    },
                                    ej = [eM.INDEXEDDB._driver, eM.WEBSQL._driver, eM.LOCALSTORAGE._driver],
                                    e$ = ["dropInstance"],
                                    ez = ["clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem"].concat(e$),
                                    eH = {
                                        description: "",
                                        driver: ej.slice(),
                                        name: "localforage",
                                        size: 4980736,
                                        storeName: "keyvaluepairs",
                                        version: 1
                                    };

                                function Ae() {
                                    for (var r = 1; r < arguments.length; r++) {
                                        var l = arguments[r];
                                        if (l)
                                            for (var C in l) l.hasOwnProperty(C) && (eB(l[C]) ? arguments[0][C] = l[C].slice() : arguments[0][C] = l[C])
                                    }
                                    return arguments[0]
                                }
                                var eF = new(function() {
                                    function e(r) {
                                        for (var l in ! function(r, l) {
                                                if (!(r instanceof l)) throw TypeError("Cannot call a class as a function")
                                            }(this, e), eM)
                                            if (eM.hasOwnProperty(l)) {
                                                var C = eM[l],
                                                    U = C._driver;
                                                this[l] = U, eU[U] || this.defineDriver(C)
                                            }
                                        this._defaultConfig = Ae({}, eH), this._config = Ae({}, this._defaultConfig, r), this._driverSet = null, this._initDriver = null, this._ready = !1, this._dbInfo = null, this._wrapLibraryMethodsWithReady(), this.setDriver(this._config.driver).catch(function() {})
                                    }
                                    return e.prototype.config = function(r) {
                                        if ((typeof r > "u" ? "undefined" : U(r)) !== "object") return "string" == typeof r ? this._config[r] : this._config;
                                        if (this._ready) return Error("Can't call config() after localforage has been used.");
                                        for (var l in r) {
                                            if ("storeName" === l && (r[l] = r[l].replace(/\W/g, "_")), "version" === l && "number" != typeof r[l]) return Error("Database version must be a number.");
                                            this._config[l] = r[l]
                                        }
                                        return !("driver" in r) || !r.driver || this.setDriver(this._config.driver)
                                    }, e.prototype.defineDriver = function(r, l, C) {
                                        var U = new eo(function(l, C) {
                                            try {
                                                var U = r._driver,
                                                    et = Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
                                                if (!r._driver) {
                                                    C(et);
                                                    return
                                                }
                                                for (var es = ez.concat("_initStorage"), el = 0, ec = es.length; el < ec; el++) {
                                                    var ed = es[el];
                                                    if ((!Kr(e$, ed) || r[ed]) && "function" != typeof r[ed]) {
                                                        C(et);
                                                        return
                                                    }
                                                }(function() {
                                                    for (var de = function(r) {
                                                            return function() {
                                                                var l = Error("Method " + r + " is not implemented by the current driver"),
                                                                    C = eo.reject(l);
                                                                return _(C, arguments[arguments.length - 1]), C
                                                            }
                                                        }, l = 0, C = e$.length; l < C; l++) {
                                                        var U = e$[l];
                                                        r[U] || (r[U] = de(U))
                                                    }
                                                })();
                                                var W = function(C) {
                                                    eU[U] && console.info("Redefining LocalForage driver: " + U), eU[U] = r, eL[U] = C, l()
                                                };
                                                "_support" in r ? r._support && "function" == typeof r._support ? r._support().then(W, C) : W(!!r._support) : W(!0)
                                            } catch (r) {
                                                C(r)
                                            }
                                        });
                                        return B(U, l, C), U
                                    }, e.prototype.driver = function() {
                                        return this._driver || null
                                    }, e.prototype.getDriver = function(r, l, C) {
                                        var U = eU[r] ? eo.resolve(eU[r]) : eo.reject(Error("Driver not found."));
                                        return B(U, l, C), U
                                    }, e.prototype.getSerializer = function(r) {
                                        var l = eo.resolve(eR);
                                        return B(l, r), l
                                    }, e.prototype.ready = function(r) {
                                        var l = this,
                                            C = l._driverSet.then(function() {
                                                return null === l._ready && (l._ready = l._initDriver()), l._ready
                                            });
                                        return B(C, r, r), C
                                    }, e.prototype.setDriver = function(r, l, C) {
                                        var U = this;
                                        eB(r) || (r = [r]);
                                        var et = this._getSupportedDrivers(r);

                                        function u() {
                                            U._config.driver = U.driver()
                                        }

                                        function c(r) {
                                            return U._extend(r), u(), U._ready = U._initStorage(U._config), U._ready
                                        }
                                        var es = null !== this._driverSet ? this._driverSet.catch(function() {
                                            return eo.resolve()
                                        }) : eo.resolve();
                                        return this._driverSet = es.then(function() {
                                            var r = et[0];
                                            return U._dbInfo = null, U._ready = null, U.getDriver(r).then(function(r) {
                                                U._driver = r._driver, u(), U._wrapLibraryMethodsWithReady(), U._initDriver = function() {
                                                    var r = 0;
                                                    return function x() {
                                                        for (; r < et.length;) {
                                                            var l = et[r];
                                                            return r++, U._dbInfo = null, U._ready = null, U.getDriver(l).then(c).catch(x)
                                                        }
                                                        u();
                                                        var C = Error("No available storage method found.");
                                                        return U._driverSet = eo.reject(C), U._driverSet
                                                    }()
                                                }
                                            })
                                        }).catch(function() {
                                            u();
                                            var r = Error("No available storage method found.");
                                            return U._driverSet = eo.reject(r), U._driverSet
                                        }), B(this._driverSet, l, C), this._driverSet
                                    }, e.prototype.supports = function(r) {
                                        return !!eL[r]
                                    }, e.prototype._extend = function(r) {
                                        Ae(this, r)
                                    }, e.prototype._getSupportedDrivers = function(r) {
                                        for (var l = [], C = 0, U = r.length; C < U; C++) {
                                            var et = r[C];
                                            this.supports(et) && l.push(et)
                                        }
                                        return l
                                    }, e.prototype._wrapLibraryMethodsWithReady = function() {
                                        for (var r = 0, l = ez.length; r < l; r++)(function(r, l) {
                                            r[l] = function() {
                                                var C = arguments;
                                                return r.ready().then(function() {
                                                    return r[l].apply(r, C)
                                                })
                                            }
                                        })(this, ez[r])
                                    }, e.prototype.createInstance = function(r) {
                                        return new e(r)
                                    }, e
                                }());
                                l.exports = eF
                            }, {
                                3: 3
                            }]
                        }, {}, [4])(4)
                    })
                }),
                nh = es_$e((r, l) => {
                    var C, U;
                    C = "u" > typeof self ? self : r, U = function(r) {
                        var l = /^~~local_forage_type~([^~]+)~/,
                            C = Object.prototype.toString;

                        function I(r) {
                            var l = .75 * r.length,
                                C = r.length;
                            "=" === r[r.length - 1] && (l--, "=" === r[r.length - 2] && l--);
                            for (var U = new ArrayBuffer(l), et = new Uint8Array(U), eo = 0, es = 0; eo < C; eo += 4) {
                                var el = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(r[eo]),
                                    ec = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(r[eo + 1]),
                                    ed = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(r[eo + 2]),
                                    eh = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(r[eo + 3]);
                                et[es++] = el << 2 | ec >> 4, et[es++] = (15 & ec) << 4 | ed >> 2, et[es++] = (3 & ed) << 6 | 63 & eh
                            }
                            return U
                        }

                        function M(r) {
                            for (var l = new Uint8Array(r), C = "", U = 0; U < l.length; U += 3) C += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/" [l[U] >> 2] + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/" [(3 & l[U]) << 4 | l[U + 1] >> 4] + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/" [(15 & l[U + 1]) << 2 | l[U + 2] >> 6] + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/" [63 & l[U + 2]];
                            return l.length % 3 == 2 ? C = C.substring(0, C.length - 1) + "=" : l.length % 3 == 1 && (C = C.substring(0, C.length - 2) + "=="), C
                        }

                        function _(r, l) {
                            return (r.name || l.name) + "/" + (r.storeName || l.storeName) + "/"
                        }

                        function B(r, l) {
                            l && r.then(function(r) {
                                l(null, r)
                            }, function(r) {
                                l(r)
                            })
                        }

                        function z() {
                            for (var r = [], l = 0; l < arguments.length; l++) r[l] = arguments[l];
                            if (arguments.length && "function" == typeof arguments[arguments.length - 1]) return arguments[arguments.length - 1]
                        }

                        function Z(r, l) {
                            var C = this;
                            if (l = z.apply(this, arguments), !(r = "function" != typeof r && r || {}).name) {
                                var U = this.config();
                                r.name = r.name || U.name, r.storeName = r.storeName || U.storeName
                            }
                            return {
                                promise: r.name ? new Promise(function(l) {
                                    l(r.storeName ? _(r, C._defaultConfig) : r.name + "/")
                                }) : Promise.reject("Invalid arguments"),
                                callback: l
                            }
                        }

                        function F(r) {
                            return "string" != typeof r && (console.warn(r + " used as a key, but it is not a string."), r = String(r)), r
                        }
                        var U = {
                                bufferToString: M,
                                deserialize: function(r) {
                                    if ("__lfsc__:" !== r.substring(0, 9)) return JSON.parse(r);
                                    var C, U = r.substring(13),
                                        et = r.substring(9, 13);
                                    if ("blob" === et && l.test(U)) {
                                        var eo = U.match(l);
                                        C = eo[1], U = U.substring(eo[0].length)
                                    }
                                    var es = I(U);
                                    switch (et) {
                                        case "arbf":
                                            return es;
                                        case "blob":
                                            return function(r, l) {
                                                r = r || [], l = l || {};
                                                try {
                                                    return new Blob(r, l)
                                                } catch (eo) {
                                                    if ("TypeError" !== eo.name) throw eo;
                                                    for (var C = "u" > typeof BlobBuilder ? BlobBuilder : "u" > typeof MSBlobBuilder ? MSBlobBuilder : "u" > typeof MozBlobBuilder ? MozBlobBuilder : WebKitBlobBuilder, U = new C, et = 0; et < r.length; et += 1) U.append(r[et]);
                                                    return U.getBlob(l.type)
                                                }
                                            }([es], {
                                                type: C
                                            });
                                        case "si08":
                                            return new Int8Array(es);
                                        case "ui08":
                                            return new Uint8Array(es);
                                        case "uic8":
                                            return new Uint8ClampedArray(es);
                                        case "si16":
                                            return new Int16Array(es);
                                        case "ur16":
                                            return new Uint16Array(es);
                                        case "si32":
                                            return new Int32Array(es);
                                        case "ui32":
                                            return new Uint32Array(es);
                                        case "fl32":
                                            return new Float32Array(es);
                                        case "fl64":
                                            return new Float64Array(es);
                                        default:
                                            throw Error("Unkown type: " + et)
                                    }
                                },
                                serialize: function(r, l) {
                                    var U = "";
                                    if (r && (U = C.call(r)), r && ("[object ArrayBuffer]" === U || r.buffer && "[object ArrayBuffer]" === C.call(r.buffer))) {
                                        var et = void 0,
                                            eo = "__lfsc__:";
                                        r instanceof ArrayBuffer ? (et = r, eo += "arbf") : (et = r.buffer, "[object Int8Array]" === U ? eo += "si08" : "[object Uint8Array]" === U ? eo += "ui08" : "[object Uint8ClampedArray]" === U ? eo += "uic8" : "[object Int16Array]" === U ? eo += "si16" : "[object Uint16Array]" === U ? eo += "ur16" : "[object Int32Array]" === U ? eo += "si32" : "[object Uint32Array]" === U ? eo += "ui32" : "[object Float32Array]" === U ? eo += "fl32" : "[object Float64Array]" === U ? eo += "fl64" : l(Error("Failed to get type for BinaryArray"))), l(eo + M(et))
                                    } else if ("[object Blob]" === U) {
                                        var es = new FileReader;
                                        es.onload = function() {
                                            l("__lfsc__:blob~~local_forage_type~" + r.type + "~" + M(this.result))
                                        }, es.readAsArrayBuffer(r)
                                    } else try {
                                        l(JSON.stringify(r))
                                    } catch (C) {
                                        console.error("Couldn't convert value into a JSON string: ", r), l(null, C)
                                    }
                                },
                                stringToBuffer: I
                            },
                            et = {},
                            eo = function() {
                                function a(r) {
                                    this.kp = r, this.data = {}
                                }
                                return a.resolve = function(r) {
                                    return et[r] || (et[r] = new a(r)), et[r]
                                }, a.prototype.clear = function() {
                                    this.data = {}
                                }, a.prototype.drop = function() {
                                    this.clear(), delete et[this.kp]
                                }, a.prototype.get = function(r) {
                                    return this.data[r]
                                }, a.prototype.key = function(r) {
                                    return this.keys()[r]
                                }, a.prototype.keys = function() {
                                    return Object.keys(this.data)
                                }, a.prototype.rm = function(r) {
                                    delete this.data[r]
                                }, a.prototype.set = function(r, l) {
                                    this.data[r] = l
                                }, a
                            }();
                        r._support = !0, r._driver = "localforage-driver-memory", r._initStorage = function(r) {
                            var l = r ? function m(r) {
                                    if (null === r || "object" != typeof r || "isActiveClone" in r) return r;
                                    var l, C, U = r instanceof Date ? new Date(r) : r.constructor();
                                    try {
                                        for (var et, eo, es, el = (et = Object.keys(r), eo = "function" == typeof Symbol && et[Symbol.iterator], es = 0, eo ? eo.call(et) : {
                                                next: function() {
                                                    return et && es >= et.length && (et = void 0), {
                                                        value: et && et[es++],
                                                        done: !et
                                                    }
                                                }
                                            }), ec = el.next(); !ec.done; ec = el.next()) {
                                            var ed = ec.value;
                                            Object.prototype.hasOwnProperty.call(r, ed) && (r.isActiveClone = null, U[ed] = m(r[ed]), delete r.isActiveClone)
                                        }
                                    } catch (r) {
                                        l = {
                                            error: r
                                        }
                                    } finally {
                                        try {
                                            ec && !ec.done && (C = el.return) && C.call(el)
                                        } finally {
                                            if (l) throw l.error
                                        }
                                    }
                                    return U
                                }(r) : {},
                                C = _(l, this._defaultConfig),
                                et = eo.resolve(C);
                            return this._dbInfo = l, this._dbInfo.serializer = U, this._dbInfo.keyPrefix = C, this._dbInfo.mStore = et, Promise.resolve()
                        }, r.clear = function(r) {
                            var l = this,
                                C = this.ready().then(function() {
                                    l._dbInfo.mStore.clear()
                                });
                            return B(C, r), C
                        }, r.dropInstance = function(r, l) {
                            var C = Z.apply(this, arguments),
                                U = C.promise,
                                et = C.callback;
                            return B(U.then(function(r) {
                                eo.resolve(r).drop()
                            }), et), U
                        }, r.getItem = function(r, l) {
                            var C = this;
                            r = F(r);
                            var U = this.ready().then(function() {
                                var l = C._dbInfo.mStore.get(r);
                                return null == l ? null : C._dbInfo.serializer.deserialize(l)
                            });
                            return B(U, l), U
                        }, r.iterate = function(r, l) {
                            var C = this,
                                U = this.ready().then(function() {
                                    for (var l = C._dbInfo.mStore, U = l.keys(), et = 0; et < U.length; et++) {
                                        var eo = l.get(U[et]);
                                        if (eo && (eo = C._dbInfo.serializer.deserialize(eo)), void 0 !== (eo = r(eo, U[et], et + 1))) return eo
                                    }
                                });
                            return B(U, l), U
                        }, r.key = function(r, l) {
                            var C = this,
                                U = this.ready().then(function() {
                                    var l;
                                    try {
                                        l = C._dbInfo.mStore.key(r), void 0 === l && (l = null)
                                    } catch {
                                        l = null
                                    }
                                    return l
                                });
                            return B(U, l), U
                        }, r.keys = function(r) {
                            var l = this,
                                C = this.ready().then(function() {
                                    return l._dbInfo.mStore.keys()
                                });
                            return B(C, r), C
                        }, r.length = function(r) {
                            var l = this.keys().then(function(r) {
                                return r.length
                            });
                            return B(l, r), l
                        }, r.removeItem = function(r, l) {
                            var C = this;
                            r = F(r);
                            var U = this.ready().then(function() {
                                C._dbInfo.mStore.rm(r)
                            });
                            return B(U, l), U
                        }, r.setItem = function(r, l, C) {
                            var U = this;
                            r = F(r);
                            var et = this.ready().then(function() {
                                void 0 === l && (l = null);
                                var C = l;
                                return new Promise(function(et, eo) {
                                    U._dbInfo.serializer.serialize(l, function(l, es) {
                                        if (es) eo(es);
                                        else try {
                                            U._dbInfo.mStore.set(r, l), et(C)
                                        } catch (r) {
                                            eo(r)
                                        }
                                    })
                                })
                            });
                            return B(et, C), et
                        }, Object.defineProperty(r, "__esModule", {
                            value: !0
                        })
                    }, "object" == typeof r && "u" > typeof l ? U(r) : "function" == typeof define && define.amd ? define("localforage-driver-memory", ["exports"], U) : U(C.LocalforageDriverMemory = {})
                }),
                nf = es_Ze(nd()),
                np = es_Ze(nh()),
                ng = {
                    display: "none",
                    position: "fixed",
                    top: "0",
                    right: "0",
                    width: "100%",
                    height: "100%",
                    borderRadius: "0",
                    border: "none",
                    zIndex: "2147483647"
                },
                ny = (Object.assign(tG, {
                    platform: "web",
                    sdkName: "magic-sdk",
                    version: "21.3.0",
                    defaultEndpoint: "https://auth.magic.link/",
                    ViewController: class extends rR {
                        constructor() {
                            super(...arguments), this.activeElement = null
                        }
                        init() {
                            this.test = "hello", this.iframe = new Promise(r => {
                                let L = () => {
                                    var l;
                                    if (l = encodeURIComponent(this.parameters), [].slice.call(document.querySelectorAll(".magic-iframe")).find(r => r.src.includes(l))) new tX(eQ.DuplicateIframe, "Duplicate iframes found.").log();
                                    else {
                                        let l = document.createElement("iframe");
                                        l.classList.add("magic-iframe"), l.dataset.magicIframeLabel = We(this.endpoint).host, l.title = "Secure Modal", l.src = We(`/send?params=${encodeURIComponent(this.parameters)}`, this.endpoint).href,
                                            function(r) {
                                                for (let [l, C] of Object.entries(ng)) r.style[l] = C
                                            }(l), document.body.appendChild(l), r(l)
                                    }
                                };
                                ["loaded", "interactive", "complete"].includes(document.readyState) ? L() : window.addEventListener("load", L, !1)
                            }), window.addEventListener("message", r => {
                                var l;
                                if (r.origin === this.endpoint && r.data && r.data.msgType && this.messageHandlers.size)
                                    for (let C of (r.data.response = null != (l = r.data.response) ? l : {}, this.messageHandlers.values())) C(r)
                            })
                        }
                        showOverlay() {
                            return dist_es_se(this, null, function*() {
                                let r = yield this.iframe;
                                r.style.display = "block", this.activeElement = document.activeElement, r.focus()
                            })
                        }
                        hideOverlay() {
                            return dist_es_se(this, null, function*() {
                                var r;
                                (yield this.iframe).style.display = "none", null != (r = this.activeElement) && r.focus && this.activeElement.focus(), this.activeElement = null
                            })
                        }
                        _post(r) {
                            return dist_es_se(this, null, function*() {
                                let l = yield this.iframe;
                                if (l && l.contentWindow) l.contentWindow.postMessage(r, this.endpoint);
                                else throw pt()
                            })
                        }
                    },
                    configureStorage: () => dist_es_se(void 0, null, function*() {
                        let r = nf.default.createInstance({
                            name: "MagicAuthLocalStorageDB",
                            storeName: "MagicAuthLocalStorage"
                        });
                        return yield r.defineDriver(np), yield r.setDriver([nf.default.INDEXEDDB, nf.default.LOCALSTORAGE, np._driver]), r
                    })
                }), rT);
            let MagicClientBase_MagicClientBase = class MagicClientBase_MagicClientBase {
                constructor(r) {
                    this.magicClients = {}, this.extensions = [], this.apiKey = r.apiKey
                }
                createClient(r) {
                    return new ny(this.apiKey, Object.assign(Object.assign({}, r), {
                        extensions: [...this.extensions, ...(null == r ? void 0 : r.extensions) && Array.isArray(null == r ? void 0 : r.extensions) ? r.extensions : []]
                    }))
                }
                getClient() {
                    if (this.magicClients.default) return this.magicClients.default;
                    let r = this.getClientConfig();
                    return this.magicClients.default = this.createClient(r), this.magicClients.default
                }
                use(r) {
                    this.extensions.push(r), Object.keys(this.magicClients).forEach(r => {
                        delete this.magicClients[r]
                    })
                }
            };
            let EvmMagicClient = class EvmMagicClient extends MagicClientBase_MagicClientBase {
                constructor(r) {
                    var l, C;
                    super({
                        apiKey: r.apiKey
                    }), this.evmNetworks = [], this.evmNetworks = r.evmNetworks, this._networkId = null !== (C = null !== (l = this.lastUsedNetworkId) && void 0 !== l ? l : r.defaultChainId) && void 0 !== C ? C : 1, this.walletConnector = r.walletConnector
                }
                get networkId() {
                    return this._networkId
                }
                get lastUsedNetworkId() {
                    let r = localStorage.getItem(EvmMagicClient.lastUsedNetworkIdStorageKey);
                    if (!r) return;
                    let l = parseInt(r);
                    if (isNaN(l)) {
                        localStorage.removeItem(EvmMagicClient.lastUsedNetworkIdStorageKey);
                        return
                    }
                    return l
                }
                set lastUsedNetworkId(r) {
                    void 0 === r ? localStorage.removeItem(EvmMagicClient.lastUsedNetworkIdStorageKey) : localStorage.setItem(EvmMagicClient.lastUsedNetworkIdStorageKey, r.toString())
                }
                getClient() {
                    let r = this._networkId,
                        l = this.magicClients[r];
                    if (l) return l;
                    let C = this.getClientConfig();
                    return this.magicClients[r] = this.createClient(C), this.magicClients[r]
                }
                getClientConfig() {
                    let r = this._getRpcUrlByNetworkId();
                    if (r) return {
                        network: {
                            chainId: this._getChainIdByNetworkId(),
                            rpcUrl: r
                        }
                    }
                }
                _getRpcUrlByNetworkId() {
                    var r;
                    let l = this.evmNetworks.find(r => r.networkId === this._networkId);
                    return (null === (r = null == l ? void 0 : l.privateCustomerRpcUrls) || void 0 === r ? void 0 : r[0]) || (null == l ? void 0 : l.rpcUrls[0])
                }
                _getChainIdByNetworkId() {
                    var r;
                    return null === (r = this.evmNetworks.find(r => r.networkId === this.networkId)) || void 0 === r ? void 0 : r.chainId
                }
                selectNetwork(r) {
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        this._networkId = r, this.lastUsedNetworkId = r, this.walletConnector.emit("chainChange", {
                            chain: r.toString()
                        })
                    })
                }
            };
            EvmMagicClient.lastUsedNetworkIdStorageKey = "magic-last-used-network-id";
            let MagicEvmWalletConnector = class MagicEvmWalletConnector extends MagicWalletConnectorBase_MagicWalletConnectorBase {
                constructor(r) {
                    var l;
                    super(r), this.connectedChain = "EVM", this.supportedChains = ["ETH", "EVM"], this.evmNetworks = (0, r5.fu)(r.evmNetworks), this.magicClient = new EvmMagicClient({
                        apiKey: this.providerProps.apiKey,
                        defaultChainId: this.chainId,
                        evmNetworks: this.evmNetworks,
                        walletConnector: this
                    }), this.chainRpcProviders = r.chainRpcProviders, null === (l = this.chainRpcProviders) || void 0 === l || l.registerChainProviders(r6.r.EVM, r => {
                        let l = {};
                        return (null == r ? void 0 : r.evm) && (l.evm = (0, r5.fu)(r.evm).map(r => {
                            var l;
                            let C = (null === (l = r.privateCustomerRpcUrls) || void 0 === l ? void 0 : l[0]) || r.rpcUrls[0],
                                U = (0, rX.v)({
                                    chain: (0, r5.uy)(r),
                                    transport: (0, rQ.d)(C)
                                });
                            return {
                                chainId: r.chainId,
                                chainName: r.name,
                                provider: U
                            }
                        })), l.evm
                    })
                }
                get chainId() {
                    return this.providerProps.chainId ? parseInt(this.providerProps.chainId) : this.providerProps.defaultChainId
                }
                filter() {
                    let r = super.filter() && "EVM" === this.chain;
                    return r || r4.warn(`MagicEvmWalletConnector: Magic is configured for a different chain: ${this.chain}. This wallet connector will be disabled.`), r
                }
                getDeepLink() {}
                getBalance() {
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        let r = yield this.isLoggedIn();
                        if (!r) return;
                        let l = this.getPublicClientSync();
                        if (!l) throw this.generateDynamicErrorOnMissingProvider();
                        let C = yield this.fetchPublicAddress();
                        if (C) return (0, r0.d)((yield l.getBalance({
                            address: C
                        })))
                    })
                }
                getNetworkSync() {
                    return this.magicClient.networkId
                }
                getNetwork() {
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        return this.getNetworkSync()
                    })
                }
                getSignerSync(r) {
                    let l = this.magicClient.getClient(),
                        C = this.getPublicClientSync();
                    if (!C) throw this.generateDynamicErrorOnMissingProvider();
                    let U = (0, r3.Nh)({
                            publicClient: C,
                            transport: (0, r1.P)(l.rpcProvider),
                            walletUiUtils: this.walletUiUtils
                        }),
                        et = (0, r2.K)({
                            account: r,
                            transport: U
                        });
                    return et
                }
                getSigner() {
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        let r = this.getPublicClientSync();
                        if (!r) throw this.generateDynamicErrorOnMissingProvider();
                        let l = yield this.fetchPublicAddress();
                        return this.getSignerSync(l)
                    })
                }
                getWalletClient() {
                    return this.getSignerSync()
                }
                getPublicClientSync() {
                    var r, l;
                    let C = this.getNetworkSync();
                    if (0 === this.evmNetworks.length) return;
                    let U = {
                        cosmos: [],
                        evm: this.evmNetworks,
                        solana: [],
                        starknet: void 0
                    };
                    return null === (l = null === (r = this.chainRpcProviders) || void 0 === r ? void 0 : r.getEvmProviderByChainId(U, C)) || void 0 === l ? void 0 : l.provider
                }
                generateDynamicErrorOnMissingProvider() {
                    return new r5.kW(`No provider found for the current configured magic network.
      magic configured network_id: ${this.getNetworkSync()}, configured evmNetworks: ${this.evmNetworks} `)
                }
                getPublicClient() {
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        return this.getPublicClientSync()
                    })
                }
                signMessage(r) {
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        let l = this.getSignerSync(),
                            C = yield this.fetchPublicAddress();
                        if (C && l) return l.signMessage({
                            account: C,
                            message: r
                        })
                    })
                }
                supportsNetworkSwitching() {
                    return !0
                }
                switchNetwork({
                    networkChainId: r
                }) {
                    return _tslib_awaiter(this, void 0, void 0, function*() {
                        r && this.magicClient.selectNetwork(r)
                    })
                }
            };
            let MagicEvmWalletConnectors = r => {
                    var l;
                    return (null === (l = r.apiProviders.magicLink) || void 0 === l ? void 0 : l.providerProjectId) ? [EmailOTPMagicWalletConnector_createEmailOTPMagicWalletConnector(MagicEvmWalletConnector), MagicSocialWalletConnector_createMagicSocialWalletConnector(MagicEvmWalletConnector)] : []
                },
                mailbox = () => {
                    let r;
                    let l = [];
                    return {
                        async deliver(C) {
                            l.push(C), r && (r(l.shift()), r = void 0)
                        },
                        receive: () => new Promise(function(C) {
                            let U = l.shift();
                            if (U) return C(U);
                            r = C
                        })
                    }
                },
                _queueMicrotask = r => (U || (U = Promise.resolve())).then(r).catch(r => setTimeout(() => {
                    throw r
                }, 0)),
                nm = "INIT",
                n_ = "SUBSCRIBE",
                nb = "UNSUBSCRIBE",
                nw = "UPDATED",
                nE = "SNAPSHOT",
                nI = "EXIT",
                nS = "TERMINATE",
                nx = "object" == typeof self && self.self === self && self || "object" == typeof C.g && C.g.global === C.g && C.g || "object" == typeof window && window.window === window && window || {
                    FCL_REGISTRY: null
                };
            nx.FCL_REGISTRY = null == nx.FCL_REGISTRY ? {} : nx.FCL_REGISTRY;
            let nA = nx.FCL_REGISTRY,
                nP = 0;

            function actor_module_send(r, l, C) {
                let U = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {
                    expectReply: !1
                };
                return new Promise((et, eo) => {
                    let es = U.expectReply || !1,
                        el = null != U.timeout ? U.timeout : 5e3;
                    es && el && setTimeout(() => eo(Error(`Timeout: ${el}ms passed without a response.`)), el);
                    let ec = {
                        to: r,
                        from: U.from,
                        tag: l,
                        data: C,
                        timeout: el,
                        reply: et,
                        reject: eo
                    };
                    try {
                        nA[r] && nA[r].mailbox.deliver(ec), es || et(!0)
                    } catch (l) {
                        console.error("FCL.Actor -- Could Not Deliver Message", ec, nA[r], l), eo(l)
                    }
                })
            }
            let kill = r => {
                    delete nA[r]
                },
                fromHandlers = r => async l => {
                    for ("function" == typeof r[nm] && await r[nm](l);;) {
                        let C = await l.receive();
                        try {
                            if (C.tag === nI) {
                                "function" == typeof r[nS] && await r[nS](l, C, C.data || {});
                                break
                            }
                            await r[C.tag] ? .(l, C, C.data || {})
                        } catch (r) {
                            console.error(`${l.self()} Error`, C, r)
                        } finally {
                            continue
                        }
                    }
                },
                parseAddr = r => null == r ? String(++nP) : String(r),
                actor_module_spawn = function(r) {
                    let l, C = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                        U = parseAddr(C);
                    if (null != nA[U]) return U;
                    nA[U] = {
                        addr: U,
                        mailbox: mailbox(),
                        subs: new Set,
                        kvs: {},
                        error: null
                    };
                    let et = createCtx(U);
                    return l = "object" == typeof r ? fromHandlers(r) : r, _queueMicrotask(async () => {
                        await l(et), kill(U)
                    }), U
                },
                createCtx = r => ({
                    self: () => r,
                    receive: () => nA[r].mailbox.receive(),
                    send: function(l, C, U) {
                        let et = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
                        if (null != l) return et.from = r, actor_module_send(l, C, U, et)
                    },
                    sendSelf: function(l, C) {
                        let U = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                        nA[r] && actor_module_send(r, l, C, U)
                    },
                    broadcast: function(l, C) {
                        let U = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                        for (let et of (U.from = r, nA[r].subs)) actor_module_send(et, l, C, U)
                    },
                    subscribe: l => null != l && nA[r].subs.add(l),
                    unsubscribe: l => null != l && nA[r].subs.delete(l),
                    subscriberCount: () => nA[r].subs.size,
                    hasSubs: () => !!nA[r].subs.size,
                    put: (l, C) => {
                        null != l && (nA[r].kvs[l] = C)
                    },
                    get: function(l) {
                        let C = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0,
                            U = nA[r].kvs[l];
                        return null == U ? C : U
                    },
                    delete: l => {
                        delete nA[r].kvs[l]
                    },
                    update: (l, C) => {
                        null != l && (nA[r].kvs[l] = C(nA[r].kvs[l]))
                    },
                    keys: () => Object.keys(nA[r].kvs),
                    all: () => nA[r].kvs,
                    where: l => Object.keys(nA[r].kvs).reduce((C, U) => l.test(U) ? { ...C,
                        [U]: nA[r].kvs[U]
                    } : C, {}),
                    merge: function() {
                        let l = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                        Object.keys(l).forEach(C => nA[r].kvs[C] = l[C])
                    },
                    fatalError: l => {
                        for (let C of (nA[r].error = l, nA[r].subs)) actor_module_send(C, nw)
                    }
                });

            function actor_module_subscriber(r, l, C) {
                l(r);
                let U = actor_module_spawn(async l => {
                    for (l.send(r, n_);;) {
                        let U = await l.receive(),
                            et = nA[r].error;
                        if (U.tag === nI) {
                            l.send(r, nb);
                            return
                        }
                        if (et) {
                            C(null, et), l.send(r, nb);
                            return
                        }
                        C(U.data, null)
                    }
                });
                return () => actor_module_send(U, nI)
            }
            let nC = null,
                nk = ((eR = {})[eR.debug = 5] = "debug", eR[eR.info = 4] = "info", eR[eR.log = 3] = "log", eR[eR.warn = 2] = "warn", eR[eR.error = 1] = "error", eR),
                buildLoggerMessageArgs = r => {
                    let {
                        title: l,
                        message: C
                    } = r;
                    return [`
    %c${l}
    ============================

    ${C}

    ============================
    `.replace(/\n[^\S\r\n]+/g, "\n").trim(), "font-weight:bold;font-family:monospace;"]
                },
                log = async r => {
                    let {
                        title: l,
                        message: C,
                        level: U,
                        always: et
                    } = r, eo = await nC ? .() ? .get("logger.level") ? ? nk.warn;
                    if (!et && eo < U) return;
                    let es = buildLoggerMessageArgs({
                        title: l,
                        message: C
                    });
                    switch (U) {
                        case nk.debug:
                            console.debug(...es);
                            break;
                        case nk.info:
                            console.info(...es);
                            break;
                        case nk.warn:
                            console.warn(...es);
                            break;
                        case nk.error:
                            console.error(...es);
                            break;
                        default:
                            console.log(...es)
                    }
                };

            function invariant(r, l) {
                if (!r) {
                    let r = Error(`INVARIANT ${l}`);
                    r.stack = r.stack ? .split("\n") ? .filter(r => !/at invariant/.test(r)) ? .join("\n");
                    for (var C = arguments.length, U = Array(C > 2 ? C - 2 : 0), et = 2; et < C; et++) U[et - 2] = arguments[et];
                    throw console.error("\n\n---\n\n", r, "\n\n", ...U, "\n\n---\n\n"), r
                }
            }
            log.deprecate = r => {
                let {
                    pkg: l,
                    subject: C,
                    transition: U,
                    level: et = nk.warn,
                    message: eo = "",
                    callback: es = null
                } = r, capitalizeFirstLetter = r => r.charAt(0).toUpperCase() + r.slice(1), logMessage = () => log({
                    title: `${l?l+" ":""}Deprecation Notice`,
                    message: `
      ${C?`${capitalizeFirstLetter(C)} is deprecated and will cease to work in future releases${l?" of "+l:""}.`:""}${eo?"\n"+eo:""}${U?`
You can learn more (including a guide on common transition paths) here: ${U}`:""}
    `.trim(),
                    level: et
                });
                return "function" == typeof es ? async function() {
                    return await logMessage(), await es(...arguments)
                } : logMessage()
            };
            let config_module_pipe = function() {
                    for (var r = arguments.length, l = Array(r), C = 0; C < r; C++) l[C] = arguments[C];
                    return r => l.reduce((r, l) => l(r), r)
                },
                mergePipe = function() {
                    for (var r = arguments.length, l = Array(r), C = 0; C < r; C++) l[C] = arguments[C];
                    return r => l.reduce((l, C) => ({ ...l,
                        ...C(r)
                    }), {})
                },
                isObject = r => r && "object" == typeof r && !Array.isArray(r),
                mergeDeep = function(r) {
                    for (var l = arguments.length, C = Array(l > 1 ? l - 1 : 0), U = 1; U < l; U++) C[U - 1] = arguments[U];
                    if (!C.length) return r;
                    let et = C.shift();
                    if (isObject(r) && isObject(et))
                        for (let l in et) isObject(et[l]) ? (r[l] || Object.assign(r, {
                            [l]: {}
                        }), mergeDeep(r[l], et[l])) : Object.assign(r, {
                            [l]: et[l]
                        });
                    return mergeDeep(r, ...C)
                },
                mergeFlowJSONs = r => Array.isArray(r) ? mergeDeep({}, ...r) : r,
                filterContracts = r => r.contracts ? r.contracts : {},
                mapContractAliasesToNetworkAddress = r => l => Object.entries(l).reduce((l, C) => {
                    let [U, et] = C, eo = et ? .aliases ? .[r];
                    return eo && (l[U] = eo), l
                }, {}),
                mapDeploymentsToNetworkAddress = r => l => {
                    let {
                        deployments: C = {},
                        accounts: U = {}
                    } = l, et = C ? .[r];
                    return et ? Object.entries(et).reduce((r, l) => {
                        let [C, et] = l, eo = U[C] ? .address;
                        return eo ? et.reduce((r, l) => ({ ...r,
                            [l]: eo
                        }), {}) : r
                    }, {}) : {}
                },
                getContracts = (r, l) => config_module_pipe(mergeFlowJSONs, mergePipe(mapDeploymentsToNetworkAddress(l), config_module_pipe(filterContracts, mapContractAliasesToNetworkAddress(l))))(r),
                isHexidecimal = r => "string" == typeof r && /^[0-9A-Fa-f]+$/.test(r),
                hasPrivateKeys = r => Object.entries(r ? .accounts ? ? []).reduce((r, l) => {
                    let [, C] = l;
                    return !!r || C && Object.prototype.hasOwnProperty.call(C, "key") && isHexidecimal(C ? .key)
                }, !1),
                anyHasPrivateKeys = r => Array.isArray(r) ? r.some(hasPrivateKeys) : hasPrivateKeys(r),
                cleanNetwork = r => {
                    let l = r ? .toLowerCase() === "local" ? "emulator" : r ? .toLowerCase();
                    if ("emulator" === l || "testnet" === l || "mainnet" === l) return l;
                    throw Error(`Invalid network "${r}". Must be one of "emulator", "local", "testnet", or "mainnet"`)
                };
            nC = config_module_config;
            let nN = "config",
                nO = "PUT_CONFIG",
                nT = "GET_CONFIG",
                nR = "GET_ALL_CONFIG",
                nD = "UPDATE_CONFIG",
                nB = "DELETE_CONFIG",
                nU = "CLEAR_CONFIG",
                nL = "WHERE_CONFIG",
                nM = "CONFIG/UPDATED",
                identity = r => r,
                nj = {
                    [nO]: (r, l, C) => {
                        let {
                            key: U,
                            value: et
                        } = C;
                        if (null == U) throw Error("Missing 'key' for config/put.");
                        r.put(U, et), r.broadcast(nM, { ...r.all()
                        })
                    },
                    [nT]: (r, l, C) => {
                        let {
                            key: U,
                            fallback: et
                        } = C;
                        if (null == U) throw Error("Missing 'key' for config/get");
                        l.reply(r.get(U, et))
                    },
                    [nR]: (r, l) => {
                        l.reply({ ...r.all()
                        })
                    },
                    [nD]: (r, l, C) => {
                        let {
                            key: U,
                            fn: et
                        } = C;
                        if (null == U) throw Error("Missing 'key' for config/update");
                        r.update(U, et || identity), r.broadcast(nM, { ...r.all()
                        })
                    },
                    [nB]: (r, l, C) => {
                        let {
                            key: U
                        } = C;
                        if (null == U) throw Error("Missing 'key' for config/delete");
                        r.delete(U), r.broadcast(nM, { ...r.all()
                        })
                    },
                    [nU]: r => {
                        let l = Object.keys(r.all());
                        for (let C of l) r.delete(C);
                        r.broadcast(nM, { ...r.all()
                        })
                    },
                    [nL]: (r, l, C) => {
                        let {
                            pattern: U
                        } = C;
                        if (null == U) throw Error("Missing 'pattern' for config/where");
                        l.reply(r.where(U))
                    },
                    [n_]: (r, l) => {
                        r.subscribe(l.from), r.send(l.from, nM, { ...r.all()
                        })
                    },
                    [nb]: (r, l) => {
                        r.unsubscribe(l.from)
                    }
                };

            function put(r, l) {
                return actor_module_send(nN, nO, {
                    key: r,
                    value: l
                }), config_module_config()
            }

            function get(r, l) {
                return actor_module_send(nN, nT, {
                    key: r,
                    fallback: l
                }, {
                    expectReply: !0,
                    timeout: 10
                })
            }
            async function first() {
                let r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                    l = arguments.length > 1 ? arguments[1] : void 0;
                if (!r.length) return l;
                let [C, ...U] = r, et = await get(C);
                return null == et ? first(U, l) : et
            }

            function config_module_all() {
                return actor_module_send(nN, nR, null, {
                    expectReply: !0,
                    timeout: 10
                })
            }

            function update(r) {
                let l = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : identity;
                return actor_module_send(nN, nD, {
                    key: r,
                    fn: l
                }), config_module_config()
            }

            function _delete(r) {
                return actor_module_send(nN, nB, {
                    key: r
                }), config_module_config()
            }

            function where(r) {
                return actor_module_send(nN, nL, {
                    pattern: r
                }, {
                    expectReply: !0,
                    timeout: 10
                })
            }

            function subscribe(r) {
                return actor_module_subscriber(nN, () => actor_module_spawn(nj, nN), r)
            }
            async function clearConfig() {
                await actor_module_send(nN, nU)
            }
            async function resetConfig(r) {
                return clearConfig().then(() => config_module_config(r))
            }
            async function load(r) {
                let l = await get("flow.network"),
                    C = cleanNetwork(l),
                    {
                        flowJSON: U
                    } = r;
                if (invariant(!!U, "config.load -- 'flowJSON' must be defined"), invariant(!!C, 'Flow Network Required -- In order for FCL to load your contracts please define "flow.network" to "emulator", "local", "testnet", or "mainnet" in your config. See more here: https://developers.flow.com/tools/fcl-js/reference/configure-fcl'), anyHasPrivateKeys(U)) {
                    let r = "emulator" === C;
                    log({
                        title: "Private Keys Detected",
                        message: "Private keys should be stored in a separate flow.json file for security. See more here: https://developers.flow.com/tools/flow-cli/security",
                        level: r ? nk.warn : nk.error
                    }), invariant(r, "Private keys should be stored in a separate flow.json file for security. See more here: https://developers.flow.com/tools/flow-cli/security")
                }
                for (let [r, l] of Object.entries(getContracts(U, C))) {
                    let C = `0x${r}`,
                        U = await get(C);
                    U && U !== l ? log({
                        title: "Contract Placeholder Conflict Detected",
                        message: "A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.",
                        level: nk.warn
                    }) : put(C, l);
                    let et = `system.contracts.${r}`,
                        eo = await get(et);
                    eo && eo !== l ? log({
                        title: "Contract Placeholder Conflict Detected",
                        message: "A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.",
                        level: nk.warn
                    }) : put(et, l)
                }
            }

            function config_module_config(r) {
                return null != r && "object" == typeof r && Object.keys(r).map(l => put(l, r[l])), {
                    put,
                    get,
                    all: config_module_all,
                    first,
                    update,
                    delete: _delete,
                    where,
                    subscribe,
                    overload,
                    load
                }
            }
            async function overload(r, l) {
                let C = await config_module_all();
                try {
                    config_module_config(r);
                    let C = await l(await config_module_all());
                    return C
                } finally {
                    await resetConfig(C)
                }
            }
            actor_module_spawn(nj, nN), config_module_config.put = put, config_module_config.get = get, config_module_config.all = config_module_all, config_module_config.first = first, config_module_config.update = update, config_module_config.delete = _delete, config_module_config.where = where, config_module_config.subscribe = subscribe, config_module_config.overload = overload, config_module_config.load = load;
            let nq = "undefined" != typeof crypto && crypto.randomUUID && crypto.randomUUID.bind(crypto);
            var n$ = {
                randomUUID: nq
            };
            let nz = new Uint8Array(16),
                nH = [];
            for (let r = 0; r < 256; ++r) nH.push((r + 256).toString(16).slice(1));
            var esm_browser_v4 = function(r, l, C) {
                    if (n$.randomUUID && !l && !r) return n$.randomUUID();
                    r = r || {};
                    let U = r.random || (r.rng || function() {
                        if (!et && !(et = "undefined" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto))) throw Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
                        return et(nz)
                    })();
                    if (U[6] = 15 & U[6] | 64, U[8] = 63 & U[8] | 128, l) {
                        C = C || 0;
                        for (let r = 0; r < 16; ++r) l[C + r] = U[r];
                        return l
                    }
                    return function(r, l = 0) {
                        return nH[r[l + 0]] + nH[r[l + 1]] + nH[r[l + 2]] + nH[r[l + 3]] + "-" + nH[r[l + 4]] + nH[r[l + 5]] + "-" + nH[r[l + 6]] + nH[r[l + 7]] + "-" + nH[r[l + 8]] + nH[r[l + 9]] + "-" + nH[r[l + 10]] + nH[r[l + 11]] + nH[r[l + 12]] + nH[r[l + 13]] + nH[r[l + 14]] + nH[r[l + 15]]
                    }(U)
                },
                nF = C(97115);

            function encode(r) {
                if (Array.isArray(r)) {
                    let l = [];
                    for (let C = 0; C < r.length; C++) l.push(encode(r[C]));
                    let C = nF.Buffer.concat(l);
                    return nF.Buffer.concat([encodeLength(C.length, 192), C])
                } {
                    let l = function(r) {
                        if (!nF.Buffer.isBuffer(r)) {
                            if ("string" == typeof r) {
                                var l;
                                return isHexPrefixed(r) ? nF.Buffer.from((l = "string" != typeof r ? r : isHexPrefixed(r) ? r.slice(2) : r).length % 2 ? "0" + l : l, "hex") : nF.Buffer.from(r)
                            }
                            if ("number" == typeof r) return r ? function(r) {
                                let l = intToHex(r);
                                return nF.Buffer.from(l, "hex")
                            }(r) : nF.Buffer.from([]);
                            if (null == r) return nF.Buffer.from([]);
                            if (r instanceof Uint8Array) return nF.Buffer.from(r);
                            else throw Error("invalid type")
                        }
                        return r
                    }(r);
                    return 1 === l.length && l[0] < 128 ? l : nF.Buffer.concat([encodeLength(l.length, 128), l])
                }
            }

            function encodeLength(r, l) {
                if (r < 56) return nF.Buffer.from([r + l]); {
                    let C = intToHex(r),
                        U = C.length / 2,
                        et = intToHex(l + 55 + U);
                    return nF.Buffer.from(et + C, "hex")
                }
            }

            function isHexPrefixed(r) {
                return "0x" === r.slice(0, 2)
            }

            function intToHex(r) {
                if (r < 0) throw Error("Invalid integer as argument, must be unsigned!");
                let l = r.toString(16);
                return l.length % 2 ? "0" + l : l
            }
            var nW = C(11239),
                nV = C.n(nW);

            function util_address_module_sansPrefix(r) {
                return null == r ? null : r.replace(/^0x/, "").replace(/^Fx/, "")
            }

            function util_address_module_withPrefix(r) {
                return null == r ? null : "0x" + util_address_module_sansPrefix(r)
            }
            let nK = globalThis.AbortController || C(11782);
            let HTTPRequestError = class HTTPRequestError extends Error {
                constructor(r) {
                    let {
                        error: l,
                        hostname: C,
                        path: U,
                        method: et,
                        requestBody: eo,
                        responseBody: es,
                        responseStatusText: el,
                        statusCode: ec
                    } = r, ed = `
      HTTP Request Error: An error occurred when interacting with the Access API.
      ${l?`error=${l}`:""}
      ${C?`hostname=${C}`:""}
      ${U?`path=${U}`:""}
      ${et?`method=${et}`:""}
      ${eo?`requestBody=${eo}`:""}
      ${es?`responseBody=${es}`:""}
      ${el?`responseStatusText=${el}`:""}
      ${ec?`statusCode=${ec}`:""}
    `;
                    super(ed), this.name = "HTTP Request Error", this.statusCode = ec, this.errorMessage = l
                }
            };
            async function httpRequest(r) {
                let {
                    hostname: l,
                    path: C,
                    method: U,
                    body: et,
                    headers: eo,
                    retryLimit: es = 5,
                    retryIntervalMs: el = 1e3,
                    timeoutLimit: ec = 3e4,
                    enableRequestLogging: ed = !0
                } = r, eh = et ? JSON.stringify(et) : null;
                async function requestLoop() {
                    let r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                    try {
                        let r = await
                        function() {
                            let r = new nK,
                                et = setTimeout(() => {
                                    r.abort()
                                }, ec);
                            return nV()(`${l}${C}`, {
                                method: U,
                                body: eh,
                                headers: eo,
                                signal: r.signal
                            }).then(async r => {
                                if (r.ok) return r.json();
                                let et = await r.text().catch(() => null),
                                    eo = function(r) {
                                        try {
                                            return JSON.parse(r)
                                        } catch {
                                            return null
                                        }
                                    }(et);
                                throw new HTTPRequestError({
                                    error: eo ? .message,
                                    hostname: l,
                                    path: C,
                                    method: U,
                                    requestBody: eh,
                                    responseBody: et,
                                    responseStatusText: r.statusText,
                                    statusCode: r.status
                                })
                            }).catch(async r => {
                                if (r instanceof HTTPRequestError || "AbortError" === r.name) throw r;
                                throw ed && await log({
                                    title: "Access Node Error",
                                    message: `The provided access node ${l} does not appear to be a valid REST/HTTP access node.
  Please verify that you are not unintentionally using a GRPC access node.
  See more here: https://docs.onflow.org/fcl/reference/sdk-guidelines/#connect`,
                                    level: nk.error
                                }), new HTTPRequestError({
                                    error: r ? .message,
                                    hostname: l,
                                    path: C,
                                    method: U,
                                    requestBody: eh
                                })
                            }).finally(() => {
                                clearTimeout(et)
                            })
                        }();
                        return r
                    } catch (l) {
                        if ("AbortError" === l.name || [408, 429, 500, 502, 503, 504].includes(l.statusCode)) return await new Promise((C, U) => {
                            r < es ? (ed && console.warn(`Access node unavailable, retrying in ${el} ms...`), setTimeout(() => {
                                C(requestLoop(r + 1))
                            }, el)) : U(l)
                        });
                        throw l
                    }
                }
                return await requestLoop()
            }
            async function sendExecuteScriptAtBlockIDRequest(r, l, C) {
                let U = C.httpRequest || httpRequest,
                    et = await U({
                        hostname: C.node,
                        path: `/v1/scripts?block_id=${r.block.id}`,
                        method: "POST",
                        body: {
                            script: l.Buffer.from(r.message.cadence).toString("base64"),
                            arguments: r.message.arguments.map(C => l.Buffer.from(JSON.stringify(r.arguments[C].asArgument)).toString("base64"))
                        }
                    });
                return constructResponse$4(r, l, et)
            }
            async function sendExecuteScriptAtBlockHeightRequest(r, l, C) {
                let U = C.httpRequest || httpRequest,
                    et = await U({
                        hostname: C.node,
                        path: `/v1/scripts?block_height=${r.block.height}`,
                        method: "POST",
                        body: {
                            script: l.Buffer.from(r.message.cadence).toString("base64"),
                            arguments: r.message.arguments.map(C => l.Buffer.from(JSON.stringify(r.arguments[C].asArgument)).toString("base64"))
                        }
                    });
                return constructResponse$4(r, l, et)
            }
            async function sendExecuteScriptAtLatestBlockRequest(r, l, C) {
                let U = C.httpRequest || httpRequest,
                    et = await U({
                        hostname: C.node,
                        path: "/v1/scripts?block_height=sealed",
                        method: "POST",
                        body: {
                            script: l.Buffer.from(r.message.cadence).toString("base64"),
                            arguments: r.message.arguments.map(C => l.Buffer.from(JSON.stringify(r.arguments[C].asArgument)).toString("base64"))
                        }
                    });
                return constructResponse$4(r, l, et)
            }

            function constructResponse$4(r, l, C) {
                let U = l.response();
                return U.tag = r.tag, U.encodedData = JSON.parse(l.Buffer.from(C, "base64").toString()), U
            }
            async function sendExecuteScript(r) {
                let l = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                    C = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                return (invariant(C.node, "SDK Send Execute Script Error: opts.node must be defined."), invariant(l.response, "SDK Send Execute Script Error: context.response must be defined."), invariant(l.Buffer, "SDK Send Execute Script Error: context.Buffer must be defined."), (r = await r).block.id) ? await sendExecuteScriptAtBlockIDRequest(r, l, C) : r.block.height ? await sendExecuteScriptAtBlockHeightRequest(r, l, C) : await sendExecuteScriptAtLatestBlockRequest(r, l, C)
            }
            let nG = {
                    SHA2_256: 1,
                    SHA2_384: 2,
                    SHA3_256: 3,
                    SHA3_384: 4,
                    KMAC128_BLS_BLS12_381: 5
                },
                nJ = {
                    ECDSA_P256: 1,
                    ECDSA_secp256k1: 2,
                    BLS_BLS12_381: 3
                };
            async function sendGetAccountAtBlockHeightRequest(r, l, C) {
                let U = C.httpRequest || httpRequest,
                    et = await U({
                        hostname: C.node,
                        path: `/v1/accounts/${r.account.addr}?block_height=${r.block.height}&expand=contracts,keys`,
                        method: "GET",
                        body: null
                    });
                return constructResponse$3(r, l, et)
            }
            async function sendGetAccountAtLatestBlockRequest(r, l, C) {
                let U = C.httpRequest || httpRequest,
                    et = await U({
                        hostname: C.node,
                        path: `/v1/accounts/${r.account.addr}?block_height=sealed&expand=contracts,keys`,
                        method: "GET",
                        body: null
                    });
                return constructResponse$3(r, l, et)
            }

            function constructResponse$3(r, l, C) {
                let U = l.response();
                return U.tag = r.tag, U.account = {
                    address: C.address,
                    balance: Number(C.balance),
                    code: "",
                    contracts: (r => {
                        let C = {};
                        if (!r) return C;
                        for (let U of Object.keys(r)) C[U] = l.Buffer.from(r[U], "base64").toString();
                        return C
                    })(C.contracts),
                    keys: C.keys ? .map(r => ({
                        index: Number(r.index),
                        publicKey: r.public_key.replace(/^0x/, ""),
                        signAlgo: nJ[r.signing_algorithm],
                        signAlgoString: r.signing_algorithm,
                        hashAlgo: nG[r.hashing_algorithm],
                        hashAlgoString: r.hashing_algorithm,
                        sequenceNumber: Number(r.sequence_number),
                        weight: Number(r.weight),
                        revoked: r.revoked
                    })) ? ? []
                }, U
            }
            async function sendGetAccount(r) {
                let l = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                    C = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                return (invariant(C.node, "SDK Send Get Account Error: opts.node must be defined."), invariant(l.response, "SDK Send Get Account Error: context.response must be defined."), invariant(l.Buffer, "SDK Send Get Account Error: context.Buffer must be defined."), null !== (r = await r).block.height) ? await sendGetAccountAtBlockHeightRequest(r, l, C) : await sendGetAccountAtLatestBlockRequest(r, l, C)
            }
            async function sendGetBlockHeaderByIDRequest(r, l, C) {
                let U = C.httpRequest || httpRequest,
                    et = await U({
                        hostname: C.node,
                        path: `/v1/blocks/${r.block.id}`,
                        method: "GET",
                        body: null
                    });
                return constructResponse$2(r, l, et)
            }
            async function sendGetBlockHeaderByHeightRequest(r, l, C) {
                let U = C.httpRequest || httpRequest,
                    et = await U({
                        hostname: C.node,
                        path: `/v1/blocks?height=${r.block.height}`,
                        method: "GET",
                        body: null
                    });
                return constructResponse$2(r, l, et)
            }
            async function sendGetLatestBlockHeaderRequest(r, l, C) {
                let U = C.httpRequest || httpRequest,
                    et = r.block ? .isSealed ? "sealed" : "final",
                    eo = await U({
                        hostname: C.node,
                        path: `/v1/blocks?height=${et}`,
                        method: "GET",
                        body: null
                    });
                return constructResponse$2(r, l, eo)
            }

            function constructResponse$2(r, l, C) {
                let U = C.length ? C[0] : null,
                    et = l.response();
                return et.tag = r.tag, et.blockHeader = {
                    id: U.header.id,
                    parentId: U.header.parent_id,
                    height: Number(U.header.height),
                    timestamp: U.header.timestamp
                }, et
            }
            async function sendGetBlockHeader(r) {
                let l = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                    C = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                invariant(C.node, "SDK Send Get Block Header Error: opts.node must be defined."), invariant(l.response, "SDK Send Get Block Header Error: context.response must be defined."), r = await r;
                let U = null !== r.block.id,
                    et = null !== r.block.height;
                return U ? await sendGetBlockHeaderByIDRequest(r, l, C) : et ? await sendGetBlockHeaderByHeightRequest(r, l, C) : await sendGetLatestBlockHeaderRequest(r, l, C)
            }
            async function sendGetBlockByIDRequest(r, l, C) {
                let U = C.httpRequest || httpRequest,
                    et = await U({
                        hostname: C.node,
                        path: `/v1/blocks/${r.block.id}?expand=payload`,
                        method: "GET",
                        body: null
                    });
                return constructResponse$1(r, l, et)
            }
            async function sendGetBlockByHeightRequest(r, l, C) {
                let U = C.httpRequest || httpRequest,
                    et = await U({
                        hostname: C.node,
                        path: `/v1/blocks?height=${r.block.height}&expand=payload`,
                        method: "GET",
                        body: null
                    });
                return constructResponse$1(r, l, et)
            }
            async function sendGetBlockRequest(r, l, C) {
                let U = C.httpRequest || httpRequest,
                    et = r.block ? .isSealed ? "sealed" : "final",
                    eo = await U({
                        hostname: C.node,
                        path: `/v1/blocks?height=${et}&expand=payload`,
                        method: "GET",
                        body: null
                    });
                return constructResponse$1(r, l, eo)
            }

            function constructResponse$1(r, l, C) {
                let U = C.length ? C[0] : null,
                    et = l.response();
                return et.tag = r.tag, et.block = {
                    id: U.header.id,
                    parentId: U.header.parent_id,
                    height: Number(U.header.height),
                    timestamp: U.header.timestamp,
                    collectionGuarantees: U.payload.collection_guarantees.map(r => ({
                        collectionId: r.collection_id,
                        signerIds: r.signer_ids
                    })),
                    blockSeals: U.payload.block_seals.map(r => ({
                        blockId: r.block_id,
                        executionReceiptId: r.result_id
                    }))
                }, et
            }
            async function sendGetBlock(r) {
                let l = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                    C = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                invariant(C.node, "SDK Send Get Block Error: opts.node must be defined."), invariant(l.response, "SDK Send Get Block Error: context.response must be defined."), r = await r;
                let U = null !== r.block.id,
                    et = null !== r.block.height;
                return U ? await sendGetBlockByIDRequest(r, l, C) : et ? await sendGetBlockByHeightRequest(r, l, C) : await sendGetBlockRequest(r, l, C)
            }
            async function sendGetCollection(r) {
                let l = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                    C = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                invariant(C.node, "SDK Send Get Collection Error: opts.node must be defined."), invariant(l.response, "SDK Send Get Collection Error: context.response must be defined.");
                let U = C.httpRequest || httpRequest,
                    et = await U({
                        hostname: C.node,
                        path: `/v1/collections/${r.collection.id}?expand=transactions`,
                        method: "GET",
                        body: null
                    }),
                    eo = l.response();
                return eo.tag = r.tag, eo.collection = {
                    id: et.id,
                    transactionIds: et.transactions.map(r => r.id)
                }, eo
            }
            async function sendGetEventsForHeightRangeRequest(r, l, C) {
                let U = C.httpRequest || httpRequest,
                    et = await U({
                        hostname: C.node,
                        path: `/v1/events?type=${r.events.eventType}&start_height=${r.events.start}&end_height=${r.events.end}`,
                        method: "GET",
                        body: null
                    });
                return constructResponse(r, l, et)
            }
            async function sendGetEventsForBlockIDsRequest(r, l, C) {
                let U = C.httpRequest || httpRequest,
                    et = await U({
                        hostname: C.node,
                        path: `/v1/events?type=${r.events.eventType}&block_ids=${r.events.blockIds.join(",")}`,
                        method: "GET",
                        body: null
                    });
                return constructResponse(r, l, et)
            }

            function constructResponse(r, l, C) {
                let U = l.response();
                return U.tag = r.tag, U.events = [], C.forEach(r => r.events ? r.events.forEach(C => U.events.push({
                    blockId: r.block_id,
                    blockHeight: Number(r.block_height),
                    blockTimestamp: r.block_timestamp,
                    type: C.type,
                    transactionId: C.transaction_id,
                    transactionIndex: Number(C.transaction_index),
                    eventIndex: Number(C.event_index),
                    payload: JSON.parse(l.Buffer.from(C.payload, "base64").toString())
                })) : null), U
            }
            async function sendGetEvents(r) {
                let l = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                    C = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                invariant(C.node, "SDK Send Get Events Error: opts.node must be defined."), invariant(l.response, "SDK Send Get Events Error: context.response must be defined."), invariant(l.Buffer, "SDK Send Get Events Error: context.Buffer must be defined."), r = await r;
                let U = null !== r.events.start,
                    et = Array.isArray(r.events.blockIds) && r.events.blockIds.length > 0;
                return (invariant(U || et, "SendGetEventsError: Unable to determine which get events request to send. Either a block height range, or block IDs must be specified."), U) ? await sendGetEventsForHeightRangeRequest(r, l, C) : await sendGetEventsForBlockIDsRequest(r, l, C)
            }
            async function sendGetTransaction(r) {
                var l;
                let C = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                    U = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                invariant(U.node, "SDK Send Get Transaction Error: opts.node must be defined."), invariant(C.response, "SDK Send Get Transaction Error: context.response must be defined."), invariant(C.Buffer, "SDK Send Get Transaction Error: context.Buffer must be defined.");
                let et = U.httpRequest || httpRequest;
                r = await r;
                let eo = await et({
                        hostname: U.node,
                        path: `/v1/transactions/${r.transaction.id}`,
                        method: "GET",
                        body: null
                    }),
                    unwrapSignature = r => ({
                        address: r.address,
                        keyId: Number(r.key_index),
                        signature: r.signature
                    }),
                    es = C.response();
                return es.tag = r.tag, es.transaction = {
                    script: C.Buffer.from(eo.script, "base64").toString(),
                    args: [...eo.arguments.map(r => JSON.parse(C.Buffer.from(r, "base64").toString()))],
                    referenceBlockId: eo.reference_block_id,
                    gasLimit: Number(eo.gas_limit),
                    payer: eo.payer,
                    proposalKey: eo.proposal_key ? {
                        address: (l = eo.proposal_key).address,
                        keyId: Number(l.key_id),
                        sequenceNumber: Number(l.sequence_number)
                    } : eo.proposal_key,
                    authorizers: eo.authorizers,
                    payloadSignatures: [...eo.payload_signatures.map(unwrapSignature)],
                    envelopeSignatures: [...eo.envelope_signatures.map(unwrapSignature)]
                }, es
            }
            let nY = {
                UNKNOWN: 0,
                PENDING: 1,
                FINALIZED: 2,
                EXECUTED: 3,
                SEALED: 4,
                EXPIRED: 5
            };
            async function sendGetTransactionStatus(r) {
                let l = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                    C = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                invariant(C.node, "SDK Send Get Transaction Status Error: opts.node must be defined."), invariant(l.response, "SDK Send Get Transaction Status Error: context.response must be defined."), invariant(l.Buffer, "SDK Send Get Transaction Status Error: context.Buffer must be defined.");
                let U = C.httpRequest || httpRequest;
                r = await r;
                let et = await U({
                        hostname: C.node,
                        path: `/v1/transaction_results/${r.transaction.id}`,
                        method: "GET",
                        body: null
                    }),
                    eo = l.response();
                return eo.tag = r.tag, eo.transactionStatus = {
                    blockId: et.block_id,
                    status: nY[et.status.toUpperCase()] || "",
                    statusString: et.status.toUpperCase(),
                    statusCode: et.status_code,
                    errorMessage: et.error_message,
                    events: et.events.map(r => ({
                        type: r.type,
                        transactionId: r.transaction_id,
                        transactionIndex: Number(r.transaction_index),
                        eventIndex: Number(r.event_index),
                        payload: JSON.parse(l.Buffer.from(r.payload, "base64").toString())
                    }))
                }, eo
            }
            async function sendPing(r) {
                let l = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                    C = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                invariant(C.node, "SDK Send Ping Error: opts.node must be defined."), invariant(l.response, "SDK Send Ping Error: context.response must be defined.");
                let U = C.httpRequest || httpRequest;
                await U({
                    hostname: C.node,
                    path: "/v1/blocks?height=sealed",
                    method: "GET",
                    body: null
                });
                let et = l.response();
                return et.tag = r.tag, et
            }
            let idof = r => `${withPrefix(r.addr)}-${r.keyId}`;
            async function sendTransaction(r) {
                let l = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                    C = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                invariant(C.node, "SDK Send Transaction Error: opts.node must be defined."), invariant(l.response, "SDK Send Transaction Error: context.response must be defined."), invariant(l.Buffer, "SDK Send Transaction Error: context.Buffer must be defined.");
                let U = C.httpRequest || httpRequest;
                r = await r;
                let et = [];
                for (let C of Object.values(r.accounts)) try {
                    if (!C.role.payer && null != C.signature) {
                        let r = {
                            address: util_address_module_sansPrefix(C.addr),
                            key_index: String(C.keyId),
                            signature: l.Buffer.from(C.signature, "hex").toString("base64")
                        };
                        et.find(l => l.address === r.address && l.key_index === r.key_index && l.signature === r.signature) || et.push(r)
                    }
                } catch (l) {
                    throw console.error("SDK HTTP Send Error: Trouble applying payload signature", {
                        acct: C,
                        ix: r
                    }), l
                }
                let eo = {};
                for (let C of Object.values(r.accounts)) try {
                    if (C.role.payer && null != C.signature) {
                        let r = C.tempId || idof(C);
                        eo[r] = eo[r] || {
                            address: util_address_module_sansPrefix(C.addr),
                            key_index: String(C.keyId),
                            signature: l.Buffer.from(C.signature, "hex").toString("base64")
                        }
                    }
                } catch (l) {
                    throw console.error("SDK HTTP Send Error: Trouble applying envelope signature", {
                        acct: C,
                        ix: r
                    }), l
                }
                eo = Object.values(eo);
                var es = Date.now();
                let el = await U({
                    hostname: C.node,
                    path: "/v1/transactions",
                    method: "POST",
                    body: {
                        script: l.Buffer.from(r.message.cadence).toString("base64"),
                        arguments: [...r.message.arguments.map(C => l.Buffer.from(JSON.stringify(r.arguments[C].asArgument)).toString("base64"))],
                        reference_block_id: r.message.refBlock ? r.message.refBlock : null,
                        gas_limit: String(r.message.computeLimit),
                        payer: util_address_module_sansPrefix(r.accounts[Array.isArray(r.payer) ? r.payer[0] : r.payer].addr),
                        proposal_key: {
                            address: util_address_module_sansPrefix(r.accounts[r.proposer].addr),
                            key_index: String(r.accounts[r.proposer].keyId),
                            sequence_number: String(r.accounts[r.proposer].sequenceNum)
                        },
                        authorizers: r.authorizations.map(l => r.accounts[l].addr).reduce((r, l) => r.find(r => r === l) ? r : [...r, l], []).map(util_address_module_sansPrefix),
                        payload_signatures: et,
                        envelope_signatures: eo
                    }
                });
                var ec = Date.now();
                let ed = l.response();
                return ed.tag = r.tag, ed.transactionId = el.id, "undefined" != typeof window && "undefined" != typeof CustomEvent && window.dispatchEvent(new CustomEvent("FLOW::TX", {
                    detail: {
                        txId: ed.transactionId,
                        delta: ec - es
                    }
                })), ed
            }
            async function sendGetNetworkParameters(r) {
                let l = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                    C = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                invariant(C.node, "SDK Send Get Network Parameters Error: opts.node must be defined."), invariant(l.response, "SDK Send Get Network Parameters Error: context.response must be defined.");
                let U = C.httpRequest || httpRequest;
                r = await r;
                let et = await U({
                        hostname: C.node,
                        path: "/v1/network/parameters",
                        method: "GET",
                        body: null,
                        enableRequestLogging: C.enableRequestLogging ? ? !0
                    }),
                    eo = l.response();
                return eo.tag = r.tag, eo.networkParameters = {
                    chainId: et.chain_id
                }, eo
            }
            let sdk_send_http_module_send = async function(r) {
                let l = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                    C = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                switch (invariant(C.node, 'SDK Send Error: Either opts.node or "accessNode.api" in config must be defined.'), invariant(l.ix, "SDK Send Error: context.ix must be defined."), r = await r, !0) {
                    case l.ix.isTransaction(r):
                        return C.sendTransaction ? C.sendTransaction(r, l, C) : sendTransaction(r, l, C);
                    case l.ix.isGetTransactionStatus(r):
                        return C.sendGetTransactionStatus ? C.sendGetTransactionStatus(r, l, C) : sendGetTransactionStatus(r, l, C);
                    case l.ix.isGetTransaction(r):
                        return C.sendGetTransaction ? C.sendGetTransaction(r, l, C) : sendGetTransaction(r, l, C);
                    case l.ix.isScript(r):
                        return C.sendExecuteScript ? C.sendExecuteScript(r, l, C) : sendExecuteScript(r, l, C);
                    case l.ix.isGetAccount(r):
                        return C.sendGetAccount ? C.sendGetAccount(r, l, C) : sendGetAccount(r, l, C);
                    case l.ix.isGetEvents(r):
                        return C.sendGetEvents ? C.sendGetEvents(r, l, C) : sendGetEvents(r, l, C);
                    case l.ix.isGetBlock(r):
                        return C.sendGetBlock ? C.sendGetBlock(r, l, C) : sendGetBlock(r, l, C);
                    case l.ix.isGetBlockHeader(r):
                        return C.sendGetBlockHeader ? C.sendGetBlockHeader(r, l, C) : sendGetBlockHeader(r, l, C);
                    case l.ix.isGetCollection(r):
                        return C.sendGetCollection ? C.sendGetCollection(r, l, C) : sendGetCollection(r, l, C);
                    case l.ix.isPing(r):
                        return C.sendPing ? C.sendPing(r, l, C) : sendPing(r, l, C);
                    case l.ix.isGetNetworkParameters(r):
                        return C.sendGetNetworkParameters ? C.sendGetNetworkParameters(r, l, C) : sendGetNetworkParameters(r, l, C);
                    default:
                        return r
                }
            };
            C(30915);
            let nZ = "UNKNOWN",
                nX = "SCRIPT",
                nQ = "TRANSACTION",
                n0 = "GET_TRANSACTION_STATUS",
                n1 = "GET_ACCOUNT",
                n2 = "GET_EVENTS",
                n3 = "PING",
                n5 = "GET_TRANSACTION",
                n6 = "GET_BLOCK",
                n8 = "GET_BLOCK_HEADER",
                n4 = "GET_COLLECTION",
                n9 = "GET_NETWORK_PARAMETERS",
                n7 = "ACCOUNT",
                io = "PARAM",
                iu = "ARGUMENT",
                il = "authorizer",
                ic = "payer",
                id = `{
  "kind":"${n7}",
  "tempId":null,
  "addr":null,
  "keyId":null,
  "sequenceNum":null,
  "signature":null,
  "signingFunction":null,
  "resolve":null,
  "role": {
    "proposer":false,
    "authorizer":false,
    "payer":false,
    "param":false
  }
}`,
                ih = `{
  "kind":"${iu}",
  "tempId":null,
  "value":null,
  "asArgument":null,
  "xform":null,
  "resolve": null,
  "resolveArgument": null
}`,
                ip = `{
  "tag":"${nZ}",
  "assigns":{},
  "status":"OK",
  "reason":null,
  "accounts":{},
  "params":{},
  "arguments":{},
  "message": {
    "cadence":null,
    "refBlock":null,
    "computeLimit":null,
    "proposer":null,
    "payer":null,
    "authorizations":[],
    "params":[],
    "arguments":[]
  },
  "proposer":null,
  "authorizations":[],
  "payer":[],
  "events": {
    "eventType":null,
    "start":null,
    "end":null,
    "blockIds":[]
  },
  "transaction": {
    "id":null
  },
  "block": {
    "id":null,
    "height":null,
    "isSealed":null
  },
  "account": {
    "addr":null
  },
  "collection": {
    "id":null
  }
}`,
                ig = new Set(Object.keys(JSON.parse(ip))),
                sdk_module_interaction = () => JSON.parse(ip),
                isNumber$1 = r => "number" == typeof r,
                isArray$1 = r => Array.isArray(r),
                isObj = r => null !== r && "object" == typeof r,
                isNull = r => null == r,
                isFn$3 = r => "function" == typeof r,
                isInteraction = r => {
                    if (!isObj(r) || isNull(r) || isNumber$1(r)) return !1;
                    for (let l of ig)
                        if (!r.hasOwnProperty(l)) return !1;
                    return !0
                },
                Ok = r => (r.status = "OK", r),
                Bad = (r, l) => (r.status = "BAD", r.reason = l, r),
                makeIx = r => l => (l.tag = r, Ok(l)),
                prepAccountKeyId = r => null == r.keyId ? r : (invariant(!isNaN(parseInt(r.keyId)), "account.keyId must be an integer"), { ...r,
                    keyId: parseInt(r.keyId)
                }),
                makeArgument = r => l => {
                    let C = esm_browser_v4();
                    return l.message.arguments.push(C), l.arguments[C] = JSON.parse(ih), l.arguments[C].tempId = C, l.arguments[C].value = r.value, l.arguments[C].asArgument = r.asArgument, l.arguments[C].xform = r.xform, l.arguments[C].resolve = r.resolve, l.arguments[C].resolveArgument = isFn$3(r.resolveArgument) ? r.resolveArgument.bind(r) : r.resolveArgument, Ok(l)
                },
                iy = makeIx(nZ),
                im = makeIx(nX),
                i_ = makeIx(nQ),
                ib = makeIx(n0),
                iw = makeIx(n5),
                iE = makeIx(n1),
                iI = makeIx(n2),
                iS = makeIx(n3),
                ix = makeIx(n6),
                iA = makeIx(n8),
                iP = makeIx(n4),
                iC = makeIx(n9),
                is = r => l => l.tag === r,
                ik = is(nZ),
                iN = is(nX),
                iO = is(nQ),
                iT = is(n0),
                iR = is(n5),
                iD = is(n1),
                iB = is(n2),
                iU = is(n3),
                iL = is(n6),
                iM = is(n8),
                ij = is(n4),
                iq = is(n9),
                isBad = r => "BAD" === r.status,
                hardMode = r => {
                    for (let l of Object.keys(r))
                        if (!ig.has(l)) throw Error(`"${l}" is an invalid root level Interaction property.`);
                    return r
                },
                recPipe = async function(r) {
                    let l = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
                    try {
                        if (r = hardMode(await r), isBad(r)) throw Error(`Interaction Error: ${r.reason}`);
                        if (!l.length) return r;
                        let [C, ...U] = l, et = await C;
                        if (isFn$3(et)) return recPipe(et(r), U);
                        if (isNull(et) || !et) return recPipe(r, U);
                        if (isInteraction(et)) return recPipe(et, U);
                        throw Error("Invalid Interaction Composition")
                    } catch (r) {
                        throw r
                    }
                },
                sdk_module_pipe = function() {
                    for (var r = arguments.length, l = Array(r), C = 0; C < r; C++) l[C] = arguments[C];
                    let [U, et] = l;
                    return isArray$1(U) && null == et ? r => sdk_module_pipe(r, U) : recPipe(U, et)
                },
                identity$1 = r => r,
                sdk_module_get = (r, l, C) => null == r.assigns[l] ? C : r.assigns[l],
                sdk_module_put = (r, l) => C => (C.assigns[r] = l, Ok(C)),
                sdk_module_update = function(r) {
                    let l = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : identity$1;
                    return C => (C.assigns[r] = l(C.assigns[r], C), Ok(C))
                };
            var i$ = Object.freeze({
                __proto__: null,
                UNKNOWN: nZ,
                SCRIPT: nX,
                TRANSACTION: nQ,
                GET_TRANSACTION_STATUS: n0,
                GET_ACCOUNT: n1,
                GET_EVENTS: n2,
                PING: n3,
                GET_TRANSACTION: n5,
                GET_BLOCK: n6,
                GET_BLOCK_HEADER: n8,
                GET_COLLECTION: n4,
                GET_NETWORK_PARAMETERS: n9,
                BAD: "BAD",
                OK: "OK",
                ACCOUNT: n7,
                PARAM: io,
                ARGUMENT: iu,
                AUTHORIZER: il,
                PAYER: ic,
                PROPOSER: "proposer",
                interaction: sdk_module_interaction,
                isNumber: isNumber$1,
                isArray: isArray$1,
                isObj: isObj,
                isNull: isNull,
                isFn: isFn$3,
                isInteraction: isInteraction,
                Ok: Ok,
                Bad: Bad,
                prepAccount: function(r) {
                    let l = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    return C => {
                        invariant("function" == typeof r || "object" == typeof r, "prepAccount must be passed an authorization function or an account object"), invariant(null != l.role, "Account must have a role");
                        let U = JSON.parse(id),
                            et = l.role,
                            eo = esm_browser_v4();
                        r.authorization && isFn$3(r.authorization) && (r = {
                            resolve: r.authorization
                        }), !r.authorization && isFn$3(r) && (r = {
                            resolve: r
                        });
                        let es = r.resolve;
                        return es && (r.resolve = function(r) {
                            for (var l = arguments.length, C = Array(l > 1 ? l - 1 : 0), U = 1; U < l; U++) C[U - 1] = arguments[U];
                            return [es, prepAccountKeyId].reduce(async (r, l) => l(await r, ...C), r)
                        }), r = prepAccountKeyId(r), C.accounts[eo] = { ...U,
                            tempId: eo,
                            ...r,
                            role: { ...U.role,
                                ..."object" == typeof r.role ? r.role : {},
                                [et]: !0
                            }
                        }, et === il ? C.authorizations.push(eo) : et === ic ? C.payer.push(eo) : C[et] = eo, C
                    }
                },
                makeArgument: makeArgument,
                makeUnknown: iy,
                makeScript: im,
                makeTransaction: i_,
                makeGetTransactionStatus: ib,
                makeGetTransaction: iw,
                makeGetAccount: iE,
                makeGetEvents: iI,
                makePing: iS,
                makeGetBlock: ix,
                makeGetBlockHeader: iA,
                makeGetCollection: iP,
                makeGetNetworkParameters: iC,
                isUnknown: ik,
                isScript: iN,
                isTransaction: iO,
                isGetTransactionStatus: iT,
                isGetTransaction: iR,
                isGetAccount: iD,
                isGetEvents: iB,
                isPing: iU,
                isGetBlock: iL,
                isGetBlockHeader: iM,
                isGetCollection: ij,
                isGetNetworkParameters: iq,
                isOk: r => "OK" === r.status,
                isBad: isBad,
                why: r => r.reason,
                isAccount: r => r.kind === n7,
                isParam: r => r.kind === io,
                isArgument: r => r.kind === iu,
                pipe: sdk_module_pipe,
                get: sdk_module_get,
                put: sdk_module_put,
                update: sdk_module_update,
                destroy: r => l => (delete l.assigns[r], Ok(l))
            });

            function build() {
                let r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                return sdk_module_pipe(sdk_module_interaction(), r)
            }
            let iz = `{
    "tag":null,
    "transaction":null,
    "transactionStatus":null,
    "transactionId":null,
    "encodedData":null,
    "events":null,
    "account":null,
    "block":null,
    "blockHeader":null,
    "latestBlock":null,
    "collection":null,
    "networkParameters":null
}`,
                response = () => JSON.parse(iz);

            function getAccount(r) {
                return sdk_module_pipe([iE, l => (l.account.addr = util_address_module_sansPrefix(r), Ok(l))])
            }
            let latestBlockDeprecationNotice = () => {
                    log.deprecate({
                        pkg: "@onflow/decode",
                        subject: "Operating upon data of the latestBlock field of the response object",
                        transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/decode/WARNINGS.md#0001-Deprecating-latestBlock-field"
                    })
                },
                decodeImplicit = async r => r,
                decodeVoid = async () => null,
                decodeType = async r => r.staticType,
                decodePath = async r => ({
                    domain: r.domain,
                    identifier: r.identifier
                }),
                decodeCapability = async r => ({
                    path: r.path,
                    address: r.address,
                    borrowType: r.borrowType
                }),
                decodeOptional = async (r, l, C) => r ? await recurseDecode(r, l, C) : null,
                decodeReference = async r => ({
                    address: r.address,
                    type: r.type
                }),
                decodeArray = async (r, l, C) => await Promise.all(r.map(r => new Promise(async U => U(await recurseDecode(r, l, [...C, r.type]))))),
                decodeDictionary = async (r, l, C) => await r.reduce(async (r, U) => ((r = await r)[await recurseDecode(U.key, l, [...C, U.key])] = await recurseDecode(U.value, l, [...C, U.key]), r), Promise.resolve({})),
                decodeComposite = async (r, l, C) => {
                    let U = await r.fields.reduce(async (r, U) => ((r = await r)[U.name] = await recurseDecode(U.value, l, [...C, U.name]), r), Promise.resolve({})),
                        et = r.id && decoderLookup(l, r.id);
                    return et ? await et(U) : U
                },
                iH = {
                    UInt: decodeImplicit,
                    Int: decodeImplicit,
                    UInt8: decodeImplicit,
                    Int8: decodeImplicit,
                    UInt16: decodeImplicit,
                    Int16: decodeImplicit,
                    UInt32: decodeImplicit,
                    Int32: decodeImplicit,
                    UInt64: decodeImplicit,
                    Int64: decodeImplicit,
                    UInt128: decodeImplicit,
                    Int128: decodeImplicit,
                    UInt256: decodeImplicit,
                    Int256: decodeImplicit,
                    Word8: decodeImplicit,
                    Word16: decodeImplicit,
                    Word32: decodeImplicit,
                    Word64: decodeImplicit,
                    UFix64: decodeImplicit,
                    Fix64: decodeImplicit,
                    String: decodeImplicit,
                    Character: decodeImplicit,
                    Bool: decodeImplicit,
                    Address: decodeImplicit,
                    Void: decodeVoid,
                    Optional: decodeOptional,
                    Reference: decodeReference,
                    Array: decodeArray,
                    Dictionary: decodeDictionary,
                    Event: decodeComposite,
                    Resource: decodeComposite,
                    Struct: decodeComposite,
                    Enum: decodeComposite,
                    Type: decodeType,
                    Path: decodePath,
                    Capability: decodeCapability
                },
                decoderLookup = (r, l) => {
                    let C = Object.keys(r).find(r => {
                        if (/^\/.*\/$/.test(r)) {
                            let C = new RegExp(r.substring(1, r.length - 1));
                            return C.test(l)
                        }
                        return r === l
                    });
                    return l && C && r[C]
                },
                recurseDecode = async (r, l, C) => {
                    let U = decoderLookup(l, r.type);
                    if (!U) throw Error(`Undefined Decoder Error: ${r.type}@${C.join(".")}`);
                    return await U(r.value, l, C)
                },
                decode$1 = async function(r) {
                    let l = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                        C = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [],
                        U = Object.keys(iH).filter(r => !Object.keys(l).find(l => new RegExp(l).test(r))).reduce((r, l) => (r[l] = iH[l], r), l),
                        et = { ...U,
                            ...l
                        };
                    return recurseDecode(r, et, C)
                },
                decodeResponse = async function(r) {
                    let l = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    if (r.encodedData) return decode$1(r.encodedData, l);
                    if (r.transactionStatus) return { ...r.transactionStatus,
                        events: await Promise.all(r.transactionStatus.events.map(async function(r) {
                            return {
                                type: r.type,
                                transactionId: r.transactionId,
                                transactionIndex: r.transactionIndex,
                                eventIndex: r.eventIndex,
                                data: await decode$1(r.payload, l)
                            }
                        }))
                    };
                    if (r.transaction) return r.transaction;
                    if (r.events) return await Promise.all(r.events.map(async function(r) {
                        return {
                            blockId: r.blockId,
                            blockHeight: r.blockHeight,
                            blockTimestamp: r.blockTimestamp,
                            type: r.type,
                            transactionId: r.transactionId,
                            transactionIndex: r.transactionIndex,
                            eventIndex: r.eventIndex,
                            data: await decode$1(r.payload, l)
                        }
                    }));
                    if (r.account) return r.account;
                    if (r.block) return r.block;
                    if (r.blockHeader) return r.blockHeader;
                    else if (r.latestBlock) return latestBlockDeprecationNotice(), r.latestBlock;
                    else if (r.transactionId) return r.transactionId;
                    else if (r.collection) return r.collection;
                    else if (r.networkParameters) return {
                        chainId: ({
                            "flow-testnet": "testnet",
                            "flow-mainnet": "mainnet",
                            "flow-emulator": "local"
                        })[r.networkParameters.chainId]
                    };
                    return null
                },
                isFn$2 = r => "function" == typeof r,
                isString$1 = r => "string" == typeof r,
                oldIdentifierPatternFn = () => /\b(0x\w+)\b/g,
                newIdentifierPatternFn = () => /import\s+"(\w+)"/g;
            async function resolveCadence(r) {
                if (!iO(r) && !iN(r)) return r;
                var l, C, U, et, eo = sdk_module_get(r, "ix.cadence");
                if (invariant(isFn$2(eo) || isString$1(eo), "Cadence needs to be a function or a string."), isFn$2(eo) && (eo = await eo({})), invariant(isString$1(eo), "Cadence needs to be a string at this point."), invariant((l = eo, !oldIdentifierPatternFn().test(l) || (C = eo, !newIdentifierPatternFn().test(C))), "Both account identifier and contract identifier syntax not simultaneously supported."), U = eo, oldIdentifierPatternFn().test(U) && (eo = await config_module_config().where(/^0x/).then(r => Object.entries(r).reduce((r, l) => {
                        let [C, U] = l, et = RegExp("(\\b" + C + "\\b)", "g");
                        return r.replace(et, U)
                    }, eo))), et = eo, newIdentifierPatternFn().test(et))
                    for (let [r, l] of eo.matchAll(newIdentifierPatternFn())) {
                        let C = await config_module_config().get(`system.contracts.${l}`);
                        C ? eo = eo.replace(r, `import ${l} from ${util_address_module_withPrefix(C)}`) : log({
                            title: "Contract Placeholder not found",
                            message: `Cannot find a value for contract placeholder ${l}. Please add to your flow.json or explicitly add it to the config 'contracts.*' namespace.`,
                            level: nk.warn
                        })
                    }
                return r.message.cadence = eo, r
            }
            let isFn$1 = r => "function" == typeof r;
            async function handleArgResolution(r) {
                let l = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 3;
                if (invariant(l > 0, `Argument Resolve Recursion Limit Exceeded for Arg: ${r.tempId}`), !isFn$1(r.resolveArgument)) return r; {
                    let C = await r.resolveArgument();
                    return handleArgResolution(C, l - 1)
                }
            }
            async function resolveArguments(r) {
                if (iO(r) || iN(r))
                    for (let [l, C] of Object.entries(r.arguments)) {
                        let U = await handleArgResolution(C);
                        invariant((U.xform, !0), `No type specified for argument: ${U.value}`), r.arguments[l].asArgument = isFn$1(U.xform) ? U.xform(U.value) : isFn$1(U.xform.asArgument) ? U.xform.asArgument(U.value) : void invariant(!1, "Invalid Argument", U)
                    }
                return r
            }
            let encodeTransactionPayload = r => prependTransactionDomainTag(rlpEncode(preparePayload(r))),
                encodeTransactionEnvelope = r => prependTransactionDomainTag(rlpEncode(prepareEnvelope(r))),
                leftPaddedHexBuffer = (r, l) => nF.Buffer.from(r.padStart(2 * l, 0), "hex"),
                iF = (eD = nF.Buffer.from("FLOW-V0.0-transaction").toString("hex"), nF.Buffer.from(eD.padEnd(64, 0), "hex")).toString("hex"),
                prependTransactionDomainTag = r => iF + r,
                addressBuffer = r => leftPaddedHexBuffer(r, 8),
                blockBuffer = r => leftPaddedHexBuffer(r, 32),
                argumentToString = r => nF.Buffer.from(JSON.stringify(r), "utf8"),
                scriptBuffer = r => nF.Buffer.from(r, "utf8"),
                signatureBuffer = r => nF.Buffer.from(r, "hex"),
                rlpEncode = r => encode(r).toString("hex"),
                preparePayload = r => (validatePayload(r), [scriptBuffer(r.cadence), r.arguments.map(argumentToString), blockBuffer(r.refBlock), r.computeLimit, addressBuffer(util_address_module_sansPrefix(r.proposalKey.address)), r.proposalKey.keyId, r.proposalKey.sequenceNum, addressBuffer(util_address_module_sansPrefix(r.payer)), r.authorizers.map(r => addressBuffer(util_address_module_sansPrefix(r)))]),
                prepareEnvelope = r => (validateEnvelope(r), [preparePayload(r), preparePayloadSignatures(r)]),
                preparePayloadSignatures = r => {
                    let l = collectSigners(r);
                    return r.payloadSigs.map(r => ({
                        signerIndex: l.get(r.address),
                        keyId: r.keyId,
                        sig: r.sig
                    })).sort((r, l) => r.signerIndex > l.signerIndex ? 1 : r.signerIndex < l.signerIndex ? -1 : r.keyId > l.keyId ? 1 : r.keyId < l.keyId ? -1 : void 0).map(r => [r.signerIndex, r.keyId, signatureBuffer(r.sig)])
                },
                collectSigners = r => {
                    let l = new Map,
                        C = 0,
                        addSigner = r => {
                            !l.has(r) && (l.set(r, C), C++)
                        };
                    return addSigner(r.proposalKey.address), addSigner(r.payer), r.authorizers.forEach(addSigner), l
                },
                validatePayload = r => {
                    iW.forEach(l => checkField(r, l)), iV.forEach(l => checkField(r.proposalKey, l, "proposalKey"))
                },
                validateEnvelope = r => {
                    iK.forEach(l => checkField(r, l)), r.payloadSigs.forEach((r, l) => {
                        iG.forEach(C => checkField(r, C, "payloadSigs", l))
                    })
                },
                isNumber = r => "number" == typeof r,
                isString = r => "string" == typeof r,
                sdk_module_isObject = r => null !== r && "object" == typeof r,
                isArray = r => sdk_module_isObject(r) && r instanceof Array,
                iW = [{
                    name: "cadence",
                    check: isString
                }, {
                    name: "arguments",
                    check: isArray
                }, {
                    name: "refBlock",
                    check: isString,
                    defaultVal: "0"
                }, {
                    name: "computeLimit",
                    check: isNumber
                }, {
                    name: "proposalKey",
                    check: sdk_module_isObject
                }, {
                    name: "payer",
                    check: isString
                }, {
                    name: "authorizers",
                    check: isArray
                }],
                iV = [{
                    name: "address",
                    check: isString
                }, {
                    name: "keyId",
                    check: isNumber
                }, {
                    name: "sequenceNum",
                    check: isNumber
                }],
                iK = [{
                    name: "payloadSigs",
                    check: isArray
                }],
                iG = [{
                    name: "address",
                    check: isString
                }, {
                    name: "keyId",
                    check: isNumber
                }, {
                    name: "sig",
                    check: isString
                }],
                checkField = (r, l, C, U) => {
                    let {
                        name: et,
                        check: eo,
                        defaultVal: es
                    } = l;
                    if (null == r[et] && null != es && (r[et] = es), null == r[et]) throw missingFieldError(et, C, U);
                    if (!eo(r[et])) throw invalidFieldError(et, C, U)
                },
                printFieldName = (r, l, C) => l ? null == C ? `${l}.${r}` : `${l}.${C}.${r}` : r,
                missingFieldError = (r, l, C) => Error(`Missing field ${printFieldName(r,l,C)}`),
                invalidFieldError = (r, l, C) => Error(`Invalid field ${printFieldName(r,l,C)}`);

            function findInsideSigners(r) {
                let l = new Set(r.authorizations);
                return l.add(r.proposer), Array.isArray(r.payer) ? r.payer.forEach(r => l.delete(r)) : l.delete(r.payer), Array.from(l)
            }

            function findOutsideSigners(r) {
                return Array.from(new Set(Array.isArray(r.payer) ? r.payer : [r.payer]))
            }
            let sdk_module_createSignableVoucher = r => ({
                    cadence: r.message.cadence,
                    refBlock: r.message.refBlock || null,
                    computeLimit: r.message.computeLimit,
                    arguments: r.message.arguments.map(l => r.arguments[l].asArgument),
                    proposalKey: {
                        address: util_address_module_withPrefix(r.accounts[r.proposer].addr),
                        keyId: r.accounts[r.proposer].keyId,
                        sequenceNum: r.accounts[r.proposer].sequenceNum
                    },
                    payer: util_address_module_withPrefix(r.accounts[Array.isArray(r.payer) ? r.payer[0] : r.payer].addr),
                    authorizers: (() => {
                        let l = r.authorizations.map(l => util_address_module_withPrefix(r.accounts[l].addr)).reduce((r, l) => r.find(r => r === l) ? r : [...r, l], []);
                        return l[0] ? l : []
                    })(),
                    payloadSigs: findInsideSigners(r).map(l => ({
                        address: util_address_module_withPrefix(r.accounts[l].addr),
                        keyId: r.accounts[l].keyId,
                        sig: r.accounts[l].signature
                    })),
                    envelopeSigs: findOutsideSigners(r).map(l => ({
                        address: util_address_module_withPrefix(r.accounts[l].addr),
                        keyId: r.accounts[l].keyId,
                        sig: r.accounts[l].signature
                    }))
                }),
                idof$1 = r => `${util_address_module_withPrefix(r.addr)}-${r.keyId}`,
                isFn = r => r && ("[object Function]" === Object.prototype.toString.call(r) || "function" == typeof r || r instanceof Function),
                genAccountId = function() {
                    for (var r = arguments.length, l = Array(r), C = 0; C < r; C++) l[C] = arguments[C];
                    return l.join("-")
                },
                iJ = {
                    PAYER: "payer",
                    PROPOSER: "proposer",
                    AUTHORIZATIONS: "authorizations"
                };

            function recurseFlatMap(r) {
                let l = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 3;
                return l <= 0 || !Array.isArray(r) ? r : recurseFlatMap(r.flatMap(r => r), l - 1)
            }
            async function removeUnusedIxAccounts(r) {
                let l = Array.isArray(r.payer) ? r.payer : [r.payer],
                    C = Array.isArray(r.authorizations) ? r.authorizations : [r.authorizations],
                    U = Array.isArray(r.proposer) ? r.proposer : [r.proposer],
                    et = Object.keys(r.accounts),
                    eo = [...new Set(l.concat(C, U))];
                for (let l of et) eo.find(r => r === l) || delete r.accounts[l]
            }

            function addAccountToIx(r, l) {
                "string" == typeof l.addr && ("number" == typeof l.keyId || "string" == typeof l.keyId) ? l.tempId = idof$1(l) : l.tempId = l.tempId || esm_browser_v4();
                let C = r.accounts[l.tempId] || l;
                return r.accounts[l.tempId] || (r.accounts[l.tempId] = l), r.accounts[l.tempId].role.proposer = C.role.proposer || l.role.proposer, r.accounts[l.tempId].role.payer = C.role.payer || l.role.payer, r.accounts[l.tempId].role.authorizer = C.role.authorizer || l.role.authorizer, r.accounts[l.tempId]
            }
            async function recurseResolveAccount(r, l) {
                let C = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 5,
                    {
                        debugLogger: U
                    } = arguments.length > 3 ? arguments[3] : void 0;
                if (C <= 0) throw Error("recurseResolveAccount Error: Depth limit (5) reached. Ensure your authorization functions resolve to an account after 5 resolves.");
                let et = r.accounts[l];
                if (!et) return null;
                if (U(`account: ${et.tempId}`, Math.max(5 - C, 0)), et ? .resolve) {
                    if (!isFn(et ? .resolve)) return U(`account: ${et.tempId} -- cache HIT`, Math.max(5 - C, 0)), et.resolve; {
                        U(`account: ${et.tempId} -- cache MISS`, Math.max(5 - C, 0));
                        let {
                            resolve: l,
                            ...eo
                        } = et, es = await l(eo, function(r, l) {
                            try {
                                return {
                                    f_type: "PreSignable",
                                    f_vsn: "1.0.1",
                                    roles: r.role,
                                    cadence: l.message.cadence,
                                    args: l.message.arguments.map(r => l.arguments[r].asArgument),
                                    data: {},
                                    interaction: l,
                                    voucher: sdk_module_createSignableVoucher(l)
                                }
                            } catch (r) {
                                throw console.error("buildPreSignable", r), r
                            }
                        }(eo, r)), el = recurseFlatMap(es = Array.isArray(es) ? es : [es]);
                        el = el.map(l => addAccountToIx(r, l)), et.resolve = el.map(r => r.tempId), et = addAccountToIx(r, et);
                        let ec = await Promise.all(el.map(async l => await recurseResolveAccount(r, l.tempId, C - 1, {
                            debugLogger: U
                        })));
                        return ec ? recurseFlatMap(ec) : et.tempId
                    }
                }
                return et.tempId
            }
            async function resolveAccountType(r, l, C) {
                let {
                    debugLogger: U
                } = C;
                invariant(r && "object" == typeof r, "resolveAccountType Error: ix not defined"), invariant(l === iJ.PAYER || l === iJ.PROPOSER || l === iJ.AUTHORIZATIONS, "resolveAccountType Error: type must be 'payer', 'proposer' or 'authorizations'");
                let et = Array.isArray(r[l]) ? r[l] : [r[l]],
                    eo = [];
                for (let l of et) {
                    invariant(r.accounts[l], "resolveAccountType Error: account not found");
                    let C = await recurseResolveAccount(r, l, 5, {
                            debugLogger: U
                        }),
                        et = function(r) {
                            let l = recurseFlatMap(r),
                                C = new Set,
                                U = l.map(r => {
                                    let l = genAccountId(r.tempId, r.role.payer, r.role.proposer, r.role.authorizer, r.role.param);
                                    return C.has(l) ? null : (C.add(l), r)
                                }).filter(r => null !== r);
                            return U
                        }((C = Array.isArray(C) ? C : [C]).map(l => r.accounts[l]));
                    eo = eo.concat(et)
                }
                if (invariant(eo.length > 0, "resolveAccountType Error: failed to resolve any accounts"), l === iJ.PAYER && (eo = eo.filter(r => !0 === r.role.payer)), l === iJ.PROPOSER && (eo = eo.filter(r => !0 === r.role.proposer)), l === iJ.AUTHORIZATIONS && (eo = eo.filter(r => !0 === r.role.authorizer)), r[l] = Array.isArray(r[l]) ? [...new Set(eo.map(r => r.tempId))] : eo[0].tempId, l === iJ.PAYER) {
                    let l;
                    for (let C of r[iJ.PAYER]) {
                        let U = r.accounts[C];
                        if (l) {
                            if (l !== U.addr) throw Error("resolveAccountType Error: payers from different accounts detected")
                        } else l = U.addr
                    }
                }
            }
            async function resolveAccounts(r) {
                let l = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                if (iO(r)) {
                    Array.isArray(r.payer) || log.deprecate({
                        pkg: "FCL",
                        subject: '"ix.payer" must be an array. Support for ix.payer as a singular',
                        message: "See changelog for more info."
                    });
                    let [C, U] = function() {
                        let r = [];
                        return [function(l) {
                            let C = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                            r.push(Array(4 * C).fill(" ").join("-") + l)
                        }, function() {
                            return r.reduce((r, l) => r + "\n" + l)
                        }]
                    }();
                    try {
                        await resolveAccountType(r, iJ.PROPOSER, {
                            debugLogger: C
                        }), await resolveAccountType(r, iJ.AUTHORIZATIONS, {
                            debugLogger: C
                        }), await resolveAccountType(r, iJ.PAYER, {
                            debugLogger: C
                        }), await removeUnusedIxAccounts(r, {
                            debugLogger: C
                        }), l.enableDebug && console.debug(U())
                    } catch (r) {
                        throw console.error("=== SAD PANDA ===\n\n", r, "\n\n=== SAD PANDA ==="), r
                    }
                }
                return r
            }
            async function resolveSignatures(r) {
                if (iO(r)) try {
                    let l = findInsideSigners(r),
                        C = encodeTransactionPayload(prepForEncoding(r));
                    await Promise.all(l.map(fetchSignature(r, C)));
                    let U = findOutsideSigners(r),
                        et = encodeTransactionEnvelope({ ...prepForEncoding(r),
                            payloadSigs: l.map(l => ({
                                address: r.accounts[l].addr,
                                keyId: r.accounts[l].keyId,
                                sig: r.accounts[l].signature
                            }))
                        });
                    await Promise.all(U.map(fetchSignature(r, et)))
                } catch (l) {
                    throw console.error("Signatures", l, {
                        ix: r
                    }), l
                }
                return r
            }

            function fetchSignature(r, l) {
                return async function(C) {
                    let U = r.accounts[C];
                    if (null != U.signature && void 0 !== U.signature) return;
                    let {
                        signature: et
                    } = await U.signingFunction(function(r, l, C) {
                        try {
                            return {
                                f_type: "Signable",
                                f_vsn: "1.0.1",
                                message: l,
                                addr: util_address_module_sansPrefix(r.addr),
                                keyId: r.keyId,
                                roles: r.role,
                                cadence: C.message.cadence,
                                args: C.message.arguments.map(r => C.arguments[r].asArgument),
                                data: {},
                                interaction: C,
                                voucher: sdk_module_createSignableVoucher(C)
                            }
                        } catch (r) {
                            throw console.error("buildSignable", r), r
                        }
                    }(U, l, r));
                    r.accounts[C].signature = et
                }
            }

            function prepForEncoding(r) {
                let l = util_address_module_sansPrefix((Array.isArray(r.payer) ? r.accounts[r.payer[0]] : r.accounts[r.payer]).addr);
                return {
                    cadence: r.message.cadence,
                    refBlock: r.message.refBlock || null,
                    computeLimit: r.message.computeLimit,
                    arguments: r.message.arguments.map(l => r.arguments[l].asArgument),
                    proposalKey: {
                        address: util_address_module_sansPrefix(r.accounts[r.proposer].addr),
                        keyId: r.accounts[r.proposer].keyId,
                        sequenceNum: r.accounts[r.proposer].sequenceNum
                    },
                    payer: l,
                    authorizers: r.authorizations.map(l => util_address_module_sansPrefix(r.accounts[l].addr)).reduce((r, l) => r.find(r => r === l) ? r : [...r, l], [])
                }
            }
            async function resolveValidators(r) {
                let l = sdk_module_get(r, "ix.validators", []);
                return sdk_module_pipe(r, l.map(r => l => r(l, {
                    Ok,
                    Bad
                })))
            }
            async function resolveFinalNormalization(r) {
                for (let l of Object.keys(r.accounts)) r.accounts[l].addr = util_address_module_sansPrefix(r.accounts[l].addr);
                return r
            }
            async function resolveVoucherIntercept(r) {
                let l = sdk_module_get(r, "ix.voucher-intercept");
                return isFn$3(l) && await l(sdk_module_createSignableVoucher(r)), r
            }
            async function resolveComputeLimit(r) {
                return iO(r) && (r.message.computeLimit = r.message.computeLimit || await config_module_config.get("fcl.limit"), r.message.computeLimit || (log.deprecate({
                    pkg: "FCL/SDK",
                    subject: "The built-in default compute limit (DEFAULT_COMPUTE_LIMIT=10)",
                    transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0009-deprecate-default-compute-limit"
                }), r.message.computeLimit = 100)), r
            }
            let noop = r => r,
                debug = function(r) {
                    let l = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : noop;
                    return async C => (await config_module_config.get(`debug.${r}`) && await l(C, function() {
                        for (var l = arguments.length, C = Array(l), U = 0; U < l; U++) C[U] = arguments[U];
                        console.log(`debug[${r}] ---
`, ...C, "\n\n\n---")
                    }, r => ["\nAccounts:", {
                        proposer: r.proposer,
                        authorizations: r.authorizations,
                        payer: r.payer
                    }, "\n\nDetails:", r.accounts].filter(Boolean)), C)
                },
                iY = sdk_module_pipe([resolveCadence, debug("cadence", (r, l) => l(r.message.cadence)), resolveComputeLimit, debug("compute limit", (r, l) => l(r.message.computeLimit)), resolveArguments, debug("arguments", (r, l) => l(r.message.arguments, r.message)), resolveAccounts, debug("accounts", (r, l, C) => l(...C(r))), execFetchRef, execFetchSequenceNumber, resolveSignatures, debug("signatures", (r, l, C) => l(...C(r))), resolveFinalNormalization, resolveValidators, resolveVoucherIntercept, debug("resolved", (r, l) => l(r))]);
            async function execFetchRef(r) {
                if (iO(r) && null == r.message.refBlock) {
                    let l = await config_module_config().get("accessNode.api"),
                        C = await config_module_config.first(["sdk.transport", "sdk.send"], sdk_send_http_module_send);
                    invariant(C, "Required value for sdk.transport is not defined in config. See: https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21"), r.message.refBlock = (await C(build([function() {
                        let r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                        return sdk_module_pipe([ix, l => (l.block.isSealed = r, Ok(l))])
                    }()]), {
                        config: config_module_config,
                        response,
                        Buffer: nF.Buffer,
                        ix: i$
                    }, {
                        node: l
                    }).then(decodeResponse)).id
                }
                return r
            }
            async function execFetchSequenceNumber(r) {
                if (iO(r)) {
                    var l = Object.values(r.accounts).find(r => r.role.proposer);
                    if (invariant(l, "Transactions require a proposer"), null == l.sequenceNum) {
                        let C = await config_module_config().get("accessNode.api"),
                            U = await config_module_config.first(["sdk.transport", "sdk.send"], sdk_send_http_module_send);
                        invariant(U, "Required value for sdk.transport is not defined in config. See: https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21"), r.accounts[l.tempId].sequenceNum = await U(await build([getAccount(l.addr)]), {
                            config: config_module_config,
                            response,
                            Buffer: nF.Buffer,
                            ix: i$
                        }, {
                            node: C
                        }).then(decodeResponse).then(r => r.keys).then(r => r.find(r => r.index === l.keyId)).then(r => r.sequenceNumber)
                    }
                }
                return r
            }

            function sdk_module_invariant() {
                for (var r = arguments.length, l = Array(r), C = 0; C < r; C++) l[C] = arguments[C];
                if (l.length > 1) {
                    let [r, C] = l;
                    return sdk_module_invariant((l, U) => {
                        let {
                            Ok: et,
                            Bad: eo
                        } = U;
                        return r ? et(l) : eo(l, C)
                    })
                }
                let [U] = l;
                return r => U(r, {
                    Ok,
                    Bad
                })
            }
            let sdk_module_send = async function() {
                let r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                    l = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                    C = await config_module_config.first(["sdk.transport", "sdk.send"], l.send || sdk_send_http_module_send);
                sdk_module_invariant(C, "Required value for sdk.transport is not defined in config. See: https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21");
                let U = await config_module_config.first(["sdk.resolve"], l.resolve || iY);
                return l.node = l.node || await config_module_config().get("accessNode.api"), Array.isArray(r) && (r = sdk_module_pipe(sdk_module_interaction(), r)), C(await U(r), {
                    config: config_module_config,
                    response,
                    ix: i$,
                    Buffer: nF.Buffer
                }, l)
            };
            async function sdk_module_decode(r) {
                let l = await config_module_config().where(/^decoder\./),
                    C = Object.entries(l).map(r => {
                        let [l, C] = r;
                        return [l = `/${l.replace(/^decoder\./,"")}$/`, C]
                    });
                return decodeResponse(r, Object.fromEntries(C))
            }

            function arg(r, l) {
                return {
                    value: r,
                    xform: l
                }
            }
            let typedef = (r, l, C) => ({
                    label: r,
                    asArgument: l,
                    asInjection: l => (log.deprecate({
                        pkg: "@onflow/types",
                        subject: `Passing in ${r} as value for ${r}`,
                        message: `Going forward, use ${r} as value for ${r}.`
                    }), C(l))
                }),
                types_module_isArray = r => Array.isArray(r),
                types_module_isObj = r => "object" == typeof r,
                types_module_isNull = r => null == r,
                isBoolean = r => "boolean" == typeof r,
                types_module_isNumber = r => "number" == typeof r,
                isInteger = r => Number.isInteger(r),
                types_module_isString = r => "string" == typeof r,
                throwTypeError = r => {
                    throw Error("Type Error: " + r)
                },
                numberValuesDeprecationNotice = r => {
                    log.deprecate({
                        pkg: "@onflow/types",
                        subject: `Passing in Number as value for ${r}`,
                        message: `Going forward, use String as value for ${r}.`,
                        transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/types/WARNINGS.md#0002-[U]Int*-and-Word*-as-Number"
                    })
                },
                iZ = !1,
                iX = {
                    label: "Identity",
                    asArgument: r => (iZ || (log.deprecate({
                        pkg: "@onflow/types",
                        subject: "Identity",
                        message: "Identity type is deprecated and will be removed in v2.0.0.  Please remove it from your code."
                    }), iZ = !0), r),
                    asInjection: r => r
                },
                iQ = typedef("UInt", r => types_module_isNumber(r) && isInteger(r) ? (numberValuesDeprecationNotice("UInt"), {
                    type: "UInt",
                    value: r.toString()
                }) : types_module_isString(r) ? {
                    type: "UInt",
                    value: r
                } : throwTypeError("Expected Positive Integer for type Unsigned Int"), r => r),
                i0 = typedef("Int", r => types_module_isNumber(r) && isInteger(r) ? (numberValuesDeprecationNotice("Int"), {
                    type: "Int",
                    value: r.toString()
                }) : types_module_isString(r) ? {
                    type: "Int",
                    value: r
                } : throwTypeError("Expected Integer for type Int"), r => r),
                i1 = typedef("UInt8", r => types_module_isNumber(r) && isInteger(r) ? (numberValuesDeprecationNotice("UInt8"), {
                    type: "UInt8",
                    value: r.toString()
                }) : types_module_isString(r) ? {
                    type: "UInt8",
                    value: r
                } : throwTypeError("Expected integer for UInt8"), r => r),
                i2 = typedef("Int8", r => types_module_isNumber(r) && isInteger(r) ? (numberValuesDeprecationNotice("Int8"), {
                    type: "Int8",
                    value: r.toString()
                }) : types_module_isString(r) ? {
                    type: "Int8",
                    value: r
                } : throwTypeError("Expected positive integer for Int8"), r => r),
                i3 = typedef("UInt16", r => types_module_isNumber(r) && isInteger(r) ? (numberValuesDeprecationNotice("UInt16"), {
                    type: "UInt16",
                    value: r.toString()
                }) : types_module_isString(r) ? {
                    type: "UInt16",
                    value: r
                } : throwTypeError("Expected integer for UInt16"), r => r),
                i5 = typedef("Int16", r => types_module_isNumber(r) && isInteger(r) ? (numberValuesDeprecationNotice("Int16"), {
                    type: "Int16",
                    value: r.toString()
                }) : types_module_isString(r) ? {
                    type: "Int16",
                    value: r
                } : throwTypeError("Expected positive integer for Int16"), r => r),
                i6 = typedef("UInt32", r => types_module_isNumber(r) && isInteger(r) ? (numberValuesDeprecationNotice("UInt32"), {
                    type: "UInt32",
                    value: r.toString()
                }) : types_module_isString(r) ? {
                    type: "UInt32",
                    value: r
                } : throwTypeError("Expected integer for UInt32"), r => r),
                i8 = typedef("Int32", r => types_module_isNumber(r) && isInteger(r) ? (numberValuesDeprecationNotice("Int32"), {
                    type: "Int32",
                    value: r.toString()
                }) : types_module_isString(r) ? {
                    type: "Int32",
                    value: r
                } : throwTypeError("Expected positive integer for Int32"), r => r),
                i4 = typedef("UInt64", r => types_module_isNumber(r) && isInteger(r) ? (numberValuesDeprecationNotice("UInt64"), {
                    type: "UInt64",
                    value: r.toString()
                }) : types_module_isString(r) ? {
                    type: "UInt64",
                    value: r
                } : throwTypeError("Expected integer for UInt64"), r => r),
                i9 = typedef("Int64", r => types_module_isNumber(r) && isInteger(r) ? (numberValuesDeprecationNotice("Int64"), {
                    type: "Int64",
                    value: r.toString()
                }) : types_module_isString(r) ? {
                    type: "Int64",
                    value: r
                } : throwTypeError("Expected positive integer for Int64"), r => r),
                i7 = typedef("UInt128", r => types_module_isNumber(r) && isInteger(r) ? (numberValuesDeprecationNotice("UInt128"), {
                    type: "UInt128",
                    value: r.toString()
                }) : types_module_isString(r) ? {
                    type: "UInt128",
                    value: r
                } : throwTypeError("Expected integer for UInt128"), r => r),
                oo = typedef("Int128", r => types_module_isNumber(r) && isInteger(r) ? (numberValuesDeprecationNotice("Int128"), {
                    type: "Int128",
                    value: r.toString()
                }) : types_module_isString(r) ? {
                    type: "Int128",
                    value: r
                } : throwTypeError("Expected positive integer for Int128"), r => r),
                os = typedef("UInt256", r => types_module_isNumber(r) && isInteger(r) ? (numberValuesDeprecationNotice("UInt256"), {
                    type: "UInt256",
                    value: r.toString()
                }) : types_module_isString(r) ? {
                    type: "UInt256",
                    value: r
                } : throwTypeError("Expected integer for UInt256"), r => r),
                ol = typedef("Int256", r => types_module_isNumber(r) && isInteger(r) ? (numberValuesDeprecationNotice("Int256"), {
                    type: "Int256",
                    value: r.toString()
                }) : types_module_isString(r) ? {
                    type: "Int256",
                    value: r
                } : throwTypeError("Expected integer for Int256"), r => r),
                oc = typedef("Word8", r => types_module_isNumber(r) && isInteger(r) ? (numberValuesDeprecationNotice("Word8"), {
                    type: "Word8",
                    value: r.toString()
                }) : types_module_isString(r) ? {
                    type: "Word8",
                    value: r
                } : throwTypeError("Expected positive number for Word8"), r => r),
                od = typedef("Word16", r => types_module_isNumber(r) && isInteger(r) ? (numberValuesDeprecationNotice("Word16"), {
                    type: "Word16",
                    value: r.toString()
                }) : types_module_isString(r) ? {
                    type: "Word16",
                    value: r
                } : throwTypeError("Expected positive number for Word16"), r => r),
                oh = typedef("Word32", r => types_module_isNumber(r) && isInteger(r) ? (numberValuesDeprecationNotice("Word32"), {
                    type: "Word32",
                    value: r.toString()
                }) : types_module_isString(r) ? {
                    type: "Word32",
                    value: r
                } : throwTypeError("Expected positive number for Word32"), r => r),
                of = typedef("Word64", r => types_module_isNumber(r) && isInteger(r) ? (numberValuesDeprecationNotice("Word64"), {
                    type: "Word64",
                    value: r.toString()
                }) : types_module_isString(r) ? {
                    type: "Word64",
                    value: r
                } : throwTypeError("Expected positive number for Word64"), r => r),
                UFix64AndFix64NumberDeprecationNotice = () => {
                    log.deprecate({
                        subject: "Passing in Numbers as values for Fix64 and UFix64 types",
                        pkg: "@onflow/types",
                        transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/types/WARNINGS.md#0001-[U]Fix64-as-Number"
                    })
                },
                op = typedef("UFix64", r => {
                    if (types_module_isString(r)) {
                        let l = r.split(".");
                        return 2 !== l.length ? throwTypeError(`Expected one decimal but found ${l.length} in the [U]Fix64 value. Find out more about [U]Fix64 types here: https://docs.onflow.org/cadence/json-cadence-spec/#fixed-point-numbers`) : 0 == l[1].length || l[1].length > 8 ? throwTypeError(`Expected at least one digit, and at most 8 digits following the decimal of the [U]Fix64 value but found ${l[1].length} digits. Find out more about [U]Fix64 types here: https://docs.onflow.org/cadence/json-cadence-spec/#fixed-point-numbers`) : (l[1] = l[1].padEnd(8, "0"), {
                            type: "UFix64",
                            value: r = l.join(".")
                        })
                    }
                    return types_module_isNumber(r) ? (UFix64AndFix64NumberDeprecationNotice(), {
                        type: "UFix64",
                        value: r.toString()
                    }) : throwTypeError("Expected String for UFix64")
                }, r => r),
                og = typedef("Fix64", r => {
                    if (types_module_isString(r)) {
                        let l = r.split(".");
                        return 2 !== l.length ? throwTypeError(`Expected one decimal but found ${l.length} in the [U]Fix64 value. Find out more about [U]Fix64 types here: https://docs.onflow.org/cadence/json-cadence-spec/#fixed-point-numbers`) : 0 == l[1].length || l[1].length > 8 ? throwTypeError(`Expected at least one digit, and at most 8 digits following the decimal of the [U]Fix64 value but found ${l[1].length} digits. Find out more about [U]Fix64 types here: https://docs.onflow.org/cadence/json-cadence-spec/#fixed-point-numbers`) : (l[1] = l[1].padEnd(8, "0"), {
                            type: "Fix64",
                            value: r = l.join(".")
                        })
                    }
                    return types_module_isNumber(r) ? (UFix64AndFix64NumberDeprecationNotice(), {
                        type: "Fix64",
                        value: r.toString()
                    }) : throwTypeError("Expected String for Fix64")
                }, r => r),
                oy = typedef("String", r => types_module_isString(r) ? {
                    type: "String",
                    value: r
                } : throwTypeError("Expected String for type String"), r => r),
                om = typedef("Character", r => types_module_isString(r) ? {
                    type: "Character",
                    value: r
                } : throwTypeError("Expected Character for type Character"), r => r),
                ov = typedef("Bool", r => isBoolean(r) ? {
                    type: "Bool",
                    value: r
                } : throwTypeError("Expected Boolean for type Bool"), r => r),
                o_ = typedef("Address", r => types_module_isString(r) ? {
                    type: "Address",
                    value: r
                } : throwTypeError("Expected Address for type Address"), r => r),
                ob = typedef("Void", r => !r || types_module_isNull(r) ? {
                    type: "Void",
                    value: null
                } : throwTypeError("Expected Void for type Void"), r => r),
                Optional = r => typedef("Optional", l => ({
                    type: "Optional",
                    value: types_module_isNull(l) ? null : r.asArgument(l)
                }), r => r),
                ow = typedef("Reference", r => types_module_isObj(r) ? {
                    type: "Reference",
                    value: r
                } : throwTypeError("Expected Object for type Reference"), r => r),
                _Array = function() {
                    let r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                    return typedef("Array", l => ({
                        type: "Array",
                        value: types_module_isArray(r) ? r.map((r, C) => r.asArgument(l[C])) : l.map(l => r.asArgument(l))
                    }), r => r)
                },
                Dictionary = function() {
                    let r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                    return typedef("Dictionary", l => {
                        let C = types_module_isArray(l),
                            U = types_module_isArray(r);
                        return types_module_isObj(l) ? {
                            type: "Dictionary",
                            value: U && C ? r.map((r, C) => ({
                                key: r.key.asArgument(l[C].key),
                                value: r.value.asArgument(l[C].value)
                            })) : C && !U ? l.map(l => ({
                                key: r.key.asArgument(l.key),
                                value: r.value.asArgument(l.value)
                            })) : C || U ? throwTypeError("Invalid arguments for Dictionary.") : [{
                                key: r.key.asArgument(l.key),
                                value: r.value.asArgument(l.value)
                            }]
                        } : throwTypeError("Expected Object for type Dictionary")
                    }, r => r)
                },
                Event = function(r) {
                    let l = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
                    return typedef("Event", C => types_module_isObj(C) ? {
                        type: "Event",
                        value: {
                            id: r,
                            fields: types_module_isArray(l) ? l.map((r, l) => ({
                                name: C.fields[l].name,
                                value: r.value.asArgument(C.fields[l].value)
                            })) : C.fields.map(r => ({
                                name: r.name,
                                value: l.value.asArgument(r.value)
                            }))
                        }
                    } : throwTypeError("Expected Object for type Event"), r => r)
                },
                Resource = function(r) {
                    let l = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
                    return typedef("Resource", C => types_module_isObj(C) ? {
                        type: "Resource",
                        value: {
                            id: r,
                            fields: types_module_isArray(l) ? l.map((r, l) => ({
                                name: C.fields[l].name,
                                value: r.value.asArgument(C.fields[l].value)
                            })) : C.fields.map(r => ({
                                name: r.name,
                                value: l.value.asArgument(r.value)
                            }))
                        }
                    } : throwTypeError("Expected Object for type Resource"), r => r)
                },
                Struct = function(r) {
                    let l = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
                    return typedef("Struct", C => types_module_isObj(C) ? {
                        type: "Struct",
                        value: {
                            id: r,
                            fields: types_module_isArray(l) ? l.map((r, l) => ({
                                name: C.fields[l].name,
                                value: r.value.asArgument(C.fields[l].value)
                            })) : C.fields.map(r => ({
                                name: r.name,
                                value: l.value.asArgument(r.value)
                            }))
                        }
                    } : throwTypeError("Expected Object for type Struct"), r => r)
                },
                Enum = function(r) {
                    let l = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
                    return typedef("Enum", C => types_module_isObj(C) ? {
                        type: "Enum",
                        value: {
                            id: r,
                            fields: types_module_isArray(l) ? l.map((r, l) => ({
                                name: C.fields[l].name,
                                value: r.value.asArgument(C.fields[l].value)
                            })) : C.fields.map(r => ({
                                name: r.name,
                                value: l.value.asArgument(r.value)
                            }))
                        }
                    } : throwTypeError("Expected Object for type Enum"), r => r)
                },
                oE = typedef("Path", r => types_module_isObj(r) ? types_module_isString(r.domain) ? "storage" === r.domain || "private" === r.domain || "public" === r.domain ? types_module_isString(r.identifier) ? {
                    type: "Path",
                    value: {
                        domain: r.domain,
                        identifier: r.identifier
                    }
                } : throwTypeError(`Expected a string for the Path identifier but found ${r.identifier}. Find out more about the Path type here: https://docs.onflow.org/cadence/json-cadence-spec/#path`) : throwTypeError(`Expected either "storage", "private" or "public" as the Path domain but found ${r.domain}. Find out more about the Path type here: https://docs.onflow.org/cadence/json-cadence-spec/#path`) : throwTypeError(`Expected a string for the Path domain but found ${r.domain}. Find out more about the Path type here: https://docs.onflow.org/cadence/json-cadence-spec/#path`) : throwTypeError("Expected Object for type Path"), r => r),
                oI = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789",
                oS = oI.length;

            function uid() {
                let r = "",
                    l = 32;
                for (; l--;) r += oI[Math.random() * oS | 0];
                return r
            }
            async function getChainIdFromAccessNode() {
                let r = await sdk_module_send([sdk_module_pipe([iC, r => Ok(r)])]).then(sdk_module_decode);
                return r.chainId
            }
            async function setChainIdDefault() {
                let r = await getChainIdFromAccessNode();
                return config_module_config.put("flow.network.default", r), r
            }
            async function getChainId() {
                let r = await config_module_config.get("flow.network.default");
                return r || (r = await setChainIdDefault()) || ((r = await config_module_config.get("flow.network")) ? log.deprecate({
                    pkg: "FCL",
                    subject: 'Using the "flow.network" configuration key for specifying the flow network',
                    message: "Configuring flow.network is no longer required",
                    transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/TRANSITIONS.md#0002-deprecate-flow.network-config-key"
                }) : (r = await config_module_config.get("env")) && log.deprecate({
                    pkg: "FCL",
                    subject: 'Using the "env" configuration key for specifying the flow network',
                    message: "Configuring to specify flow network is no longer required",
                    transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/TRANSITIONS.md#0001-deprecate-env-config-key"
                })), invariant(r, "Error getting chainId from access node. Please configure flow.network instead"), r
            }
            let ox = {
                can: "undefined" != typeof window,
                get: async r => JSON.parse(sessionStorage.getItem(r)),
                put: async (r, l) => sessionStorage.setItem(r, JSON.stringify(l))
            };
            async function configLens(r) {
                return Object.fromEntries(Object.entries(await config_module_config().where(r)).map(l => {
                    let [C, U] = l;
                    return [C.replace(r, ""), U]
                }))
            }
            config_module_config({
                "discovery.wallet.method.default": "IFRAME/RPC",
                "fcl.storage.default": ox
            }), config_module_config.subscribe((function(r) {
                let l = r ? .["accessNode.api"];
                this.prevAccessNode !== l && setChainIdDefault(), this.prevAccessNode = l
            }).bind({}));
            let oA = "1.4.1",
                fcl_module_is = r => l => typeof l === r,
                isRequired = r => null != r,
                oP = fcl_module_is("object"),
                oC = fcl_module_is("string"),
                ok = fcl_module_is("function");
            async function httpDocumentResolver(r) {
                let l, {
                    url: C
                } = r;
                invariant(void 0 !== C, "retrieve({ url }) -- url must be defined");
                try {
                    l = await nV()(C)
                } catch (r) {
                    throw Error("httpDocumentResolver Error: Failed to retrieve document.")
                }
                return l.ok ? await l.json() : null
            }
            fcl_module_is("number");
            let oN = new Map([
                ["http", httpDocumentResolver],
                ["https", httpDocumentResolver]
            ]);
            async function retrieve(r) {
                let {
                    url: l
                } = r;
                invariant(void 0 !== l, "retrieve({ url }) -- url must be defined"), invariant("string" == typeof l, "retrieve({ url }) -- url must be a string");
                let C = await config_module_config().where(/^document\.resolver\./);
                Object.keys(C).map(r => {
                    let l = C[r],
                        U = r.replace(/^document\.resolver\./, "");
                    oN.set(U, l)
                });
                let U = /^(.*):\/\/([A-Za-z0-9\-\.]+)(:[0-9]+)?(.*)$/.exec(l);
                invariant(U, "Failed to parse URL");
                let et = U[1];
                invariant(U, "Failed to parse URL protocol");
                let eo = oN.get(et);
                return invariant(eo, `No resolver found for protcol=${et}`), await eo({
                    url: l
                })
            }

            function normalizeInteractionTemplate(r) {
                if (null == r) return null;
                if ("1.0.0" === r.f_version) return r;
                throw Error("normalizeInteractionTemplate Error: Invalid InteractionTemplate")
            }
            async function deriveDependencies(r) {
                let {
                    template: l
                } = r, C = await getChainId();
                invariant(C, "FCL configureDependencies Error: Missing configuration value for 'flow.network'");
                let U = {};
                if ("1.0.0" === l.f_version) {
                    let r = Object.keys(l ? .data ? .dependencies);
                    for (let et of r) {
                        let r = l ? .data ? .dependencies[et],
                            eo = Object.keys(r);
                        invariant(eo.length > 0, `FCL configureDependencies Error: No contracts found in template for placeholder=${et}`);
                        let es = r[eo[0]],
                            el = es[C];
                        invariant(el, `FCL configureDependencies Error: No dependency information for placeholder=${et} contract=${eo[0]} network=${C}`), invariant(el ? .address, `FCL configureDependencies Error: No address information for placeholder=${et} contract=${eo[0]} network=${C}`), U[et] = util_address_module_withPrefix(el ? .address)
                    }
                    return U
                }
                throw Error("FCL configureDependencies Error: Unsupported template version")
            }
            async function prepTemplateOpts(r) {
                oC(r ? .template) && (r.template = await retrieve({
                    url: r ? .template
                }));
                let l = {};
                r ? .template && (r.template = normalizeInteractionTemplate(r ? .template), l = await deriveDependencies({
                    template: r.template
                }));
                let C = r.cadence || function(r) {
                    let {
                        network: l,
                        template: C
                    } = r;
                    if (sdk_module_invariant(void 0 != l, "deriveCadenceByNetwork({ network }) -- network must be defined"), sdk_module_invariant("string" == typeof l, "deriveCadenceByNetwork({ network }) -- network must be a string"), sdk_module_invariant(void 0 != C, "generateDependencyPin({ template }) -- template must be defined"), sdk_module_invariant("object" == typeof C, "generateDependencyPin({ template }) -- template must be an object"), sdk_module_invariant("InteractionTemplate" === C.f_type, "generateDependencyPin({ template }) -- template must be an InteractionTemplate"), "1.0.0" === (C = normalizeInteractionTemplate(C)).f_version) return Object.keys(C ? .data ? .dependencies).map(r => {
                        let U = Object.values(C ? .data ? .dependencies ? .[r]);
                        sdk_module_invariant(U, `deriveCadenceByNetwork -- Could not find contracts for dependency placeholder: ${r}`), sdk_module_invariant(0 === U.length, `deriveCadenceByNetwork -- Could not find contracts for dependency placeholder: ${r}`);
                        let et = U[0],
                            eo = et ? .[l];
                        return sdk_module_invariant(eo, `deriveCadenceByNetwork -- Could not find ${l} network information for dependency: ${r}`), [r, eo.address]
                    }).reduce((r, l) => {
                        let [C, U] = l, et = RegExp("(\\b" + C + "\\b)", "g");
                        return r.replace(et, U)
                    }, C.data.cadence);
                    throw Error("deriveCadenceByNetwork Error: Unsupported template version")
                }({
                    template: r.template,
                    network: await getChainId()
                });
                return r.cadence = C, r.dependencies = l, r
            }
            async function pre(r, l) {
                invariant(isRequired(l), `${r}(opts) -- opts is required`), invariant(oP(l), `${r}(opts) -- opts must be an object`), invariant(!(l.cadence && l.template), `${r}({ template, cadence }) -- cannot pass both cadence and template`), invariant(isRequired(l.cadence || l ? .template), `${r}({ cadence }) -- cadence is required`), invariant(oC(l.cadence) || l ? .template, `${r}({ cadence }) -- cadence must be a string`), invariant(l.cadence || await config_module_config().get("flow.network"), `${r}(opts) -- Required value for "flow.network" not defined in config. See: https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/src/exec/query.md#configuration`), invariant(await config_module_config().get("accessNode.api"), `${r}(opts) -- Required value for "accessNode.api" not defined in config. See: https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/src/exec/query.md#configuration`)
            }
            async function preQuery(r) {
                return pre("query", r)
            }
            async function query() {
                let r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                return await preQuery(r), r = await prepTemplateOpts(r), config_module_config().overload(r.dependencies || {}, async () => {
                    var l, C;
                    return sdk_module_send([function() {
                        return sdk_module_pipe([im, sdk_module_put("ix.cadence", function(r) {
                            for (var l = arguments.length, C = Array(l > 1 ? l - 1 : 0), U = 1; U < l; U++) C[U - 1] = arguments[U];
                            return "string" == typeof r ? () => r : "function" == typeof r ? r : l => (function interleave() {
                                let r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                                    l = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],
                                    C = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];
                                if (!r.length && !l.length || !r.length) return C;
                                if (!l.length) return C.push(...r), C;
                                let [U, ...et] = r, [eo, ...es] = l;
                                return void 0 !== U && C.push(U), void 0 !== eo && C.push(eo), interleave(et, es, C)
                            })([...r], C.map(function recApply(r) {
                                return function(l) {
                                    return "function" == typeof l ? (log.deprecate({
                                        pkg: "FCL/SDK",
                                        subject: "Interopolation of functions into template literals",
                                        transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0001-deprecate-params"
                                    }), recApply(r)(l(r))) : String(l)
                                }
                            }(l))).join("").trim()
                        }(...arguments))])
                    }(r.cadence), function() {
                        let r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                        return sdk_module_pipe(r.map(makeArgument))
                    }(ok(l = r.args || []) ? l(arg, eJ) : []), r.limit && "number" == typeof r.limit && (C = r.limit, r => (r.message.computeLimit = C, r))]).then(sdk_module_decode)
                })
            }
            async function fetchServices(r, l) {
                if (null == r || null == l) return [];
                let C = new URL(r);
                C.searchParams.append("code", l);
                let U = await fetch(C, {
                    method: "GET",
                    headers: {
                        "Content-Type": "application/json"
                    }
                }).then(r => r.json());
                if (Array.isArray(U)) return U;
                let et = [];
                if (Array.isArray(U.authorizations))
                    for (let r of U.authorizations) et.push({
                        type: "authz",
                        keyId: U.keyId,
                        ...r
                    });
                return null != U.provider && et.push({
                    type: "authn",
                    id: "wallet-provider#authn",
                    ...U.provider
                }), et
            }
            let oO = {
                    f_type: "Service",
                    f_vsn: "1.0.0"
                },
                oT = {
                    f_type: "Identity",
                    f_vsn: "1.0.0"
                },
                oR = {
                    f_type: "USER",
                    f_vsn: "1.0.0"
                },
                oD = {
                    f_type: "PollingResponse",
                    f_vsn: "1.0.0"
                },
                oB = {
                    f_type: "CompositeSignature",
                    f_vsn: "1.0.0"
                };

            function normalizeFrame(r) {
                return null == r ? null : "1.0.0" === r.f_vsn ? r : {
                    old: r,
                    ...oO,
                    type: "frame",
                    endpoint: r.endpoint,
                    params: r.params || {},
                    data: r.data || {}
                }
            }

            function normalizeBackChannelRpc(r) {
                return null == r ? null : "1.0.0" === r.f_vsn ? r : { ...oO,
                    type: "back-channel-rpc",
                    endpoint: r.endpoint,
                    method: r.method,
                    params: r.params || {},
                    data: r.data || {}
                }
            }

            function normalizeLocalView(r) {
                return null == r ? null : (null == r.method && (r = { ...r,
                    type: "local-view",
                    method: "VIEW/IFRAME"
                }), "1.0.0" === r.f_vsn) ? r : { ...oO,
                    type: r.type || "local-view",
                    method: r.method,
                    endpoint: r.endpoint,
                    data: r.data || {},
                    params: r.params || {}
                }
            }
            let oU = {
                "back-channel-rpc": normalizeBackChannelRpc,
                "pre-authz": function(r) {
                    return null == r ? null : "1.0.0" === r.f_vsn ? r : { ...oO,
                        type: r.type,
                        uid: r.id,
                        endpoint: r.endpoint,
                        method: r.method,
                        identity: { ...oT,
                            address: util_address_module_withPrefix(r.addr),
                            keyId: r.keyId
                        },
                        params: r.params,
                        data: r.data
                    }
                },
                authz: function(r) {
                    return null == r ? null : "1.0.0" === r.f_vsn ? r : { ...oO,
                        type: r.type,
                        uid: r.id,
                        endpoint: r.endpoint,
                        method: r.method,
                        identity: { ...oT,
                            address: util_address_module_withPrefix(r.addr),
                            keyId: r.keyId
                        },
                        params: r.params,
                        data: r.data
                    }
                },
                authn: function(r) {
                    return null == r ? null : "1.0.0" === r.f_vsn ? r : { ...oO,
                        type: r.type,
                        uid: r.id,
                        endpoint: r.authn,
                        id: r.pid,
                        provider: {
                            address: util_address_module_withPrefix(r.addr),
                            name: r.name,
                            icon: r.icon
                        }
                    }
                },
                frame: normalizeFrame,
                "open-id": function(r) {
                    return null == r ? null : "1.0.0" === r.f_vsn ? r : null
                },
                "user-signature": function(r) {
                    if (null == r) return null;
                    if ("1.0.0" === r.f_vsn) return r;
                    throw Error("Invalid user-signature service")
                },
                "local-view": normalizeLocalView,
                "account-proof": function(r) {
                    if (null == r) return null;
                    if ("1.0.0" === r.f_vsn) return r;
                    throw Error("FCL Normalizer Error: Invalid account-proof service")
                },
                "authn-refresh": function(r) {
                    if (null == r) return null;
                    if ("1.0.0" === r.f_vsn) return r;
                    throw Error("Invalid authn-refresh service")
                }
            };
            async function buildUser(r) {
                (l = r).addr = l.addr ? util_address_module_withPrefix(l.addr) : null, l.paddr = l.paddr ? util_address_module_withPrefix(l.paddr) : null;
                var l, C = (function() {
                    let r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                        l = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
                    return [...r, ...l]
                })((r = l).services || [], await fetchServices(r.hks, r.code)).map(l => (function(r, l) {
                    try {
                        return oU[r.type](r, l)
                    } catch (l) {
                        return console.error(`Unrecognized FCL Service Type [${r.type}]`, r, l), r
                    }
                })(l, r));
                let U = C.find(r => "authn" === r.type);
                return { ...oR,
                    addr: util_address_module_withPrefix(r.addr),
                    cid: encode([U.provider.address || U.provider.name || "UNSPECIFIED", U.id]).toString("hex"),
                    loggedIn: !0,
                    services: C,
                    expiresAt: r.expires
                }
            }

            function serviceOfType() {
                let r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                    l = arguments.length > 1 ? arguments[1] : void 0;
                return r.find(r => r.type === l)
            }

            function serviceEndpoint(r) {
                let l = new URL(r.endpoint);
                if (window ? .location ? .origin && l.searchParams.append("l6n", window.location.origin), null != r.params)
                    for (let [C, U] of Object.entries(r.params || {})) l.searchParams.append(C, U);
                return l
            }

            function fetchService(r) {
                let l = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                    C = l.method || "POST",
                    U = "GET" === C ? void 0 : JSON.stringify(l.data || r.data || {});
                return fetch(serviceEndpoint(r), {
                    method: C,
                    headers: { ...r.headers || {},
                        ...l.headers || {},
                        "Content-Type": "application/json"
                    },
                    body: U
                }).then(r => r.json())
            }

            function normalizePollingResponse(r) {
                return null == r ? null : "1.0.0" === r.f_vsn ? r : { ...oD,
                    status: r.status ? ? "APPROVED",
                    reason: r.reason ? ? null,
                    data: r.compositeSignature || r.data || { ...r
                    },
                    updates: normalizeBackChannelRpc(r.authorizationUpdates),
                    local: normalizeFrame((r.local || [])[0])
                }
            }
            let oL = {
                    "HTTP/GET": "GET",
                    "HTTP/POST": "POST"
                },
                serviceMethod = r => (invariant(oL[r.method], "Invalid Service Method for type back-channel-rpc", {
                    service: r
                }), oL[r.method]);
            async function poll(r) {
                let l, C = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : () => !0;
                if (invariant(r, "Missing Polling Service", {
                        service: r
                    }), !C()) throw Error("Externally Halted");
                try {
                    if ("undefined" != typeof document && "hidden" === document.visibilityState) return await new Promise(r => setTimeout(r, 500)), poll(r, C);
                    l = await fetchService(r, {
                        method: serviceMethod(r)
                    }).then(normalizePollingResponse)
                } catch (r) {
                    throw r
                }
                switch (l.status) {
                    case "APPROVED":
                        return l.data;
                    case "DECLINED":
                        throw Error(`Declined: ${l.reason||"No reason supplied."}`);
                    default:
                        return await new Promise(r => setTimeout(r, 500)), poll(l.updates, C)
                }
            }
            let oM = "FCL_IFRAME",
                oj = `
  position:fixed;
  top: 0px;
  right: 0px;
  bottom: 0px;
  left: 0px;
  height: 100%;
  width: 100vw;
  display:block;
  background:rgba(0,0,0,0.25);
  z-index: 2147483647;
  box-sizing: border-box;
  color-scheme: light;
`;

            function renderFrame(r) {
                invariant(!document.getElementById(oM), "Attempt at triggering multiple Frames", {
                    src: r
                });
                let l = document.createElement("iframe");
                return l.src = r, l.id = oM, l.allow = "usb *; hid *", l.frameBorder = "0", l.style.cssText = oj, document.body.append(l), [l.contentWindow, () => {
                    document.getElementById(oM) && document.getElementById(oM).remove()
                }]
            }
            let oq = null,
                o$ = null;

            function renderPop(r) {
                return null == oq || oq ? .closed ? oq = function(r, l, C, U, et) {
                    let eo = C.top.outerHeight / 2 + C.top.screenY - et / 2,
                        es = C.top.outerWidth / 2 + C.top.screenX - U / 2,
                        el = C.open(r, l, `toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no, width=${U}, height=${et}, top=${eo}, left=${es}`);
                    if (!el) throw Error("Popup failed to open (was it blocked by a popup blocker?)");
                    return el
                }(r, "FCL_POP", window, 640, 770) : (o$ !== r && oq.location.replace(r), oq.focus()), o$ = r, [oq, () => {
                    oq && !oq.closed && oq.close(), oq = null
                }]
            }
            let oz = null,
                oH = null;

            function renderTab(r) {
                if (null == oz || oz ? .closed) {
                    if (!(oz = window.open(r, "_blank"))) throw Error("Tab failed to open (was it blocked by the browser?)")
                } else oH !== r && oz.location.replace(r), oz.focus();
                return oH = r, [oz, () => {
                    oz && !oz.closed && oz.close(), oz = null
                }]
            }
            let oF = {
                "VIEW/IFRAME": renderFrame,
                "VIEW/POP": renderPop,
                "VIEW/TAB": renderTab
            };
            async function execLocal(r) {
                let l = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                try {
                    return oF[r.method](serviceEndpoint(r), l)
                } catch (C) {
                    throw console.error("execLocal({service, opts = {}})", C, {
                        service: r,
                        opts: l
                    }), C
                }
            }
            async function execHttpPost(r) {
                let {
                    service: l,
                    body: C,
                    config: U,
                    opts: et
                } = r, eo = await fetchService(l, {
                    data: {
                        fclVersion: oA,
                        service: {
                            params: l.params,
                            data: l.data,
                            type: l.type
                        },
                        config: U,
                        ...C
                    }
                }).then(normalizePollingResponse);
                if ("APPROVED" === eo.status) return eo.data;
                if ("DECLINED" === eo.status) throw Error(`Declined: ${eo.reason||"No reason supplied."}`);
                if ("REDIRECT" === eo.status) return eo;
                if ("PENDING" === eo.status) {
                    var es = !0;
                    let [r, l] = await execLocal(normalizeLocalView(eo.local)), close = () => {
                        try {
                            l(), es = !1
                        } catch (r) {
                            console.error("Frame Close Error", r)
                        }
                    };
                    return poll(eo.updates, () => es).then(r => (close(), r)).catch(r => {
                        throw console.error(r), close(), r
                    })
                }
                throw console.error("Auto Decline: Invalid Response", {
                    service: l,
                    resp: eo
                }), Error("Auto Decline: Invalid Response")
            }
            let oW = "FCL:VIEW:CLOSE",
                oV = "FCL:VIEW:READY",
                oK = "FCL:VIEW:RESPONSE",
                fcl_module_ = r => "string" == typeof r && r.toLowerCase(),
                oG = new Set(["monetizationstart", "monetizationpending", "monetizationprogress", "monetizationstop"]),
                deprecate = (r, l) => console.warn("DEPRECATION NOTICE", `Received ${r}, please use ${l} for this and future versions of FCL`),
                buildMessageHandler = r => {
                    let {
                        close: l,
                        send: C,
                        onReady: U,
                        onResponse: et,
                        onMessage: eo
                    } = r;
                    return r => {
                        try {
                            if ("object" != typeof r.data || oG.has(r.data.type)) return;
                            fcl_module_(r.data.type) === fcl_module_(oW) && l(), fcl_module_(r.data.type) === fcl_module_(oV) && U(r, {
                                send: C,
                                close: l
                            }), fcl_module_(r.data.type) === fcl_module_(oK) && et(r, {
                                send: C,
                                close: l
                            }), eo(r, {
                                send: C,
                                close: l
                            }), fcl_module_(r.data.type) === fcl_module_("FCL:FRAME:READY") && (deprecate(r.data.type, oV), U(r, {
                                send: C,
                                close: l
                            })), fcl_module_(r.data.type) === fcl_module_("FCL:FRAME:RESPONSE") && (deprecate(r.data.type, oK), et(r, {
                                send: C,
                                close: l
                            })), fcl_module_(r.data.type) === fcl_module_("FCL:FRAME:CLOSE") && (deprecate(r.data.type, oW), l()), fcl_module_(r.data.type) === fcl_module_("FCL::CHALLENGE::RESPONSE") && (deprecate(r.data.type, oK), et(r, {
                                send: C,
                                close: l
                            })), fcl_module_(r.data.type) === fcl_module_("FCL::AUTHZ_READY") && (deprecate(r.data.type, oV), U(r, {
                                send: C,
                                close: l
                            })), fcl_module_(r.data.type) === fcl_module_("FCL::CHALLENGE::CANCEL") && (deprecate(r.data.type, oW), l()), fcl_module_(r.data.type) === fcl_module_("FCL::CANCEL") && (deprecate(r.data.type, oW), l())
                        } catch (r) {
                            console.error("Frame Callback Error", r), l()
                        }
                    }
                },
                noop$3 = () => {},
                noop$2 = () => {},
                noop$1 = () => {},
                fcl_module_noop = () => {},
                oJ = {
                    "HTTP/RPC": execHttpPost,
                    "HTTP/POST": execHttpPost,
                    "IFRAME/RPC": function(r) {
                        let {
                            service: l,
                            body: C,
                            config: U,
                            opts: et
                        } = r;
                        return new Promise((r, eo) => {
                            let es = uid(),
                                el = et.includeOlderJsonRpcCall;
                            ! function(r) {
                                let l = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                                if (null == r) return;
                                let C = l.onClose || noop$3,
                                    U = l.onMessage || noop$3,
                                    et = l.onReady || noop$3,
                                    eo = l.onResponse || noop$3,
                                    es = buildMessageHandler({
                                        close: function() {
                                            try {
                                                window.removeEventListener("message", es), ec(), C()
                                            } catch (r) {
                                                console.error("Frame Close Error", r)
                                            }
                                        },
                                        send: function(r) {
                                            try {
                                                el.postMessage(JSON.parse(JSON.stringify(r || {})), "*")
                                            } catch (l) {
                                                console.error("Frame Send Error", r, l)
                                            }
                                        },
                                        onReady: et,
                                        onResponse: eo,
                                        onMessage: U
                                    });
                                window.addEventListener("message", es);
                                let [el, ec] = renderFrame(serviceEndpoint(r))
                            }(l, {
                                async onReady(r, et) {
                                    let {
                                        send: eo
                                    } = et;
                                    try {
                                        eo({
                                            type: "FCL:VIEW:READY:RESPONSE",
                                            fclVersion: oA,
                                            body: C,
                                            service: {
                                                params: l.params,
                                                data: l.data,
                                                type: l.type
                                            },
                                            config: U
                                        }), eo({
                                            fclVersion: oA,
                                            type: "FCL:FRAME:READY:RESPONSE",
                                            body: C,
                                            service: {
                                                params: l.params,
                                                data: l.data,
                                                type: l.type
                                            },
                                            config: U,
                                            deprecated: {
                                                message: "FCL:FRAME:READY:RESPONSE is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE"
                                            }
                                        }), el && eo({
                                            jsonrpc: "2.0",
                                            id: es,
                                            method: "fcl:sign",
                                            params: [C, l.params],
                                            deprecated: {
                                                message: "jsonrpc is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE"
                                            }
                                        })
                                    } catch (r) {
                                        throw r
                                    }
                                },
                                onResponse(l, C) {
                                    let {
                                        close: U
                                    } = C;
                                    try {
                                        if ("object" != typeof l.data) return;
                                        let C = normalizePollingResponse(l.data);
                                        switch (C.status) {
                                            case "APPROVED":
                                                r(C.data), U();
                                                break;
                                            case "DECLINED":
                                                eo(`Declined: ${C.reason||"No reason supplied"}`), U();
                                                break;
                                            case "REDIRECT":
                                                r(C), U();
                                                break;
                                            default:
                                                eo("Declined: No reason supplied"), U()
                                        }
                                    } catch (r) {
                                        throw console.error("execIframeRPC onResponse error", r), r
                                    }
                                },
                                onMessage(l, C) {
                                    let {
                                        close: U
                                    } = C;
                                    try {
                                        if ("object" != typeof l.data || "2.0" !== l.data.jsonrpc || l.data.id !== es) return;
                                        let C = normalizePollingResponse(l.data.result);
                                        switch (C.status) {
                                            case "APPROVED":
                                                r(C.data), U();
                                                break;
                                            case "DECLINED":
                                                eo(`Declined: ${C.reason||"No reason supplied"}`), U();
                                                break;
                                            case "REDIRECT":
                                                r(C), U();
                                                break;
                                            default:
                                                eo("Declined: No reason supplied"), U()
                                        }
                                    } catch (r) {
                                        throw console.error("execIframeRPC onMessage error", r), r
                                    }
                                },
                                onClose() {
                                    eo("Declined: Externally Halted")
                                }
                            })
                        })
                    },
                    "POP/RPC": function(r) {
                        let {
                            service: l,
                            body: C,
                            config: U,
                            opts: et
                        } = r;
                        return new Promise((r, eo) => {
                            let es = uid(),
                                {
                                    redir: el,
                                    includeOlderJsonRpcCall: ec
                                } = et;
                            ! function(r) {
                                let l = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                                if (null == r) return;
                                let C = l.onClose || noop$2,
                                    U = l.onMessage || noop$2,
                                    et = l.onReady || noop$2,
                                    eo = l.onResponse || noop$2,
                                    es = buildMessageHandler({
                                        close,
                                        send: function(r) {
                                            try {
                                                el.postMessage(JSON.parse(JSON.stringify(r || {})), "*")
                                            } catch (l) {
                                                console.error("Popup Send Error", r, l)
                                            }
                                        },
                                        onReady: et,
                                        onResponse: eo,
                                        onMessage: U
                                    });
                                window.addEventListener("message", es);
                                let [el, ec] = renderPop(serviceEndpoint(r)), ed = setInterval(function() {
                                    el && el.closed && close()
                                }, 500);

                                function close() {
                                    try {
                                        window.removeEventListener("message", es), clearInterval(ed), ec(), C()
                                    } catch (r) {
                                        console.error("Popup Close Error", r)
                                    }
                                }
                            }(l, {
                                async onReady(r, et) {
                                    let {
                                        send: eo
                                    } = et;
                                    try {
                                        eo({
                                            fclVersion: oA,
                                            type: "FCL:VIEW:READY:RESPONSE",
                                            body: C,
                                            service: {
                                                params: l.params,
                                                data: l.data,
                                                type: l.type
                                            },
                                            config: U
                                        }), eo({
                                            fclVersion: oA,
                                            type: "FCL:FRAME:READY:RESPONSE",
                                            body: C,
                                            service: {
                                                params: l.params,
                                                data: l.data,
                                                type: l.type
                                            },
                                            config: U,
                                            deprecated: {
                                                message: "FCL:FRAME:READY:RESPONSE is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE"
                                            }
                                        }), ec && eo({
                                            jsonrpc: "2.0",
                                            id: es,
                                            method: "fcl:sign",
                                            params: [C, l.params]
                                        })
                                    } catch (r) {
                                        throw r
                                    }
                                },
                                onResponse(l, C) {
                                    let {
                                        close: U
                                    } = C;
                                    try {
                                        if ("object" != typeof l.data) return;
                                        let C = normalizePollingResponse(l.data);
                                        switch (C.status) {
                                            case "APPROVED":
                                                r(C.data), el || U();
                                                break;
                                            case "DECLINED":
                                                eo(`Declined: ${C.reason||"No reason supplied"}`), U();
                                                break;
                                            case "REDIRECT":
                                                r(C), U();
                                                break;
                                            default:
                                                eo("Declined: No reason supplied"), U()
                                        }
                                    } catch (r) {
                                        throw console.error("execPopRPC onResponse error", r), r
                                    }
                                },
                                onMessage(l, C) {
                                    let {
                                        close: U
                                    } = C;
                                    try {
                                        if ("object" != typeof l.data || "2.0" !== l.data.jsonrpc || l.data.id !== es) return;
                                        let C = normalizePollingResponse(l.data.result);
                                        switch (C.status) {
                                            case "APPROVED":
                                                r(C.data), el || U();
                                                break;
                                            case "DECLINED":
                                                eo(`Declined: ${C.reason||"No reason supplied"}`), U();
                                                break;
                                            case "REDIRECT":
                                                r(C), U();
                                                break;
                                            default:
                                                eo("Declined: No reason supplied"), U()
                                        }
                                    } catch (r) {
                                        throw console.error("execPopRPC onMessage error", r), r
                                    }
                                },
                                onClose() {
                                    eo("Declined: Externally Halted")
                                }
                            })
                        })
                    },
                    "TAB/RPC": function(r) {
                        let {
                            service: l,
                            body: C,
                            config: U,
                            opts: et
                        } = r;
                        return new Promise((r, eo) => {
                            let es = uid(),
                                {
                                    redir: el,
                                    includeOlderJsonRpcCall: ec
                                } = et;
                            ! function(r) {
                                let l = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                                if (null == r) return;
                                let C = l.onClose || noop$1,
                                    U = l.onMessage || noop$1,
                                    et = l.onReady || noop$1,
                                    eo = l.onResponse || noop$1,
                                    es = buildMessageHandler({
                                        close,
                                        send: function(r) {
                                            try {
                                                el.postMessage(JSON.parse(JSON.stringify(r || {})), "*")
                                            } catch (l) {
                                                console.error("Tab Send Error", r, l)
                                            }
                                        },
                                        onReady: et,
                                        onResponse: eo,
                                        onMessage: U
                                    });
                                window.addEventListener("message", es);
                                let [el, ec] = renderTab(serviceEndpoint(r)), ed = setInterval(function() {
                                    el && el.closed && close()
                                }, 500);

                                function close() {
                                    try {
                                        window.removeEventListener("message", es), clearInterval(ed), ec(), C()
                                    } catch (r) {
                                        console.error("Tab Close Error", r)
                                    }
                                }
                            }(l, {
                                async onReady(r, et) {
                                    let {
                                        send: eo
                                    } = et;
                                    try {
                                        eo({
                                            fclVersion: oA,
                                            type: "FCL:VIEW:READY:RESPONSE",
                                            body: C,
                                            service: {
                                                params: l.params,
                                                data: l.data,
                                                type: l.type
                                            },
                                            config: U
                                        }), eo({
                                            fclVersion: oA,
                                            type: "FCL:FRAME:READY:RESPONSE",
                                            body: C,
                                            service: {
                                                params: l.params,
                                                data: l.data,
                                                type: l.type
                                            },
                                            config: U,
                                            deprecated: {
                                                message: "FCL:FRAME:READY:RESPONSE is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE"
                                            }
                                        }), ec && eo({
                                            jsonrpc: "2.0",
                                            id: es,
                                            method: "fcl:sign",
                                            params: [C, l.params]
                                        })
                                    } catch (r) {
                                        throw r
                                    }
                                },
                                onResponse(l, C) {
                                    let {
                                        close: U
                                    } = C;
                                    try {
                                        if ("object" != typeof l.data) return;
                                        let C = normalizePollingResponse(l.data);
                                        switch (C.status) {
                                            case "APPROVED":
                                                r(C.data), el || U();
                                                break;
                                            case "DECLINED":
                                                eo(`Declined: ${C.reason||"No reason supplied"}`), U();
                                                break;
                                            case "REDIRECT":
                                                r(C), U();
                                                break;
                                            default:
                                                eo("Declined: No reason supplied"), U()
                                        }
                                    } catch (r) {
                                        throw console.error("execPopRPC onResponse error", r), r
                                    }
                                },
                                onMessage(l, C) {
                                    let {
                                        close: U
                                    } = C;
                                    try {
                                        if ("object" != typeof l.data || "2.0" !== l.data.jsonrpc || l.data.id !== es) return;
                                        let C = normalizePollingResponse(l.data.result);
                                        switch (C.status) {
                                            case "APPROVED":
                                                r(C.data), el || U();
                                                break;
                                            case "DECLINED":
                                                eo(`Declined: ${C.reason||"No reason supplied"}`), U();
                                                break;
                                            case "REDIRECT":
                                                r(C), U();
                                                break;
                                            default:
                                                eo("Declined: No reason supplied"), U()
                                        }
                                    } catch (r) {
                                        throw console.error("execPopRPC onMessage error", r), r
                                    }
                                },
                                onClose() {
                                    eo("Declined: Externally Halted")
                                }
                            })
                        })
                    },
                    "EXT/RPC": function(r) {
                        let {
                            service: l,
                            body: C,
                            config: U,
                            opts: et
                        } = r;
                        return new Promise((r, et) => {
                            ! function(r) {
                                let l = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                                if (null == r) return;
                                let C = l.onClose || fcl_module_noop,
                                    U = l.onMessage || fcl_module_noop,
                                    et = l.onReady || fcl_module_noop,
                                    eo = l.onResponse || fcl_module_noop,
                                    es = buildMessageHandler({
                                        close: function() {
                                            try {
                                                window.removeEventListener("message", es), C()
                                            } catch (r) {
                                                console.error("Ext Close Error", r)
                                            }
                                        },
                                        send,
                                        onReady: et,
                                        onResponse: eo,
                                        onMessage: U
                                    });
                                return window.addEventListener("message", es), send({
                                    service: r
                                });

                                function send(r) {
                                    try {
                                        window && window.postMessage(JSON.parse(JSON.stringify(r || {})), "*")
                                    } catch (l) {
                                        console.error("Ext Send Error", r, l)
                                    }
                                }
                            }(l, {
                                async onReady(r, et) {
                                    let {
                                        send: eo
                                    } = et;
                                    try {
                                        eo({
                                            fclVersion: oA,
                                            type: "FCL:VIEW:READY:RESPONSE",
                                            body: C,
                                            service: {
                                                params: l.params,
                                                data: l.data,
                                                type: l.type
                                            },
                                            config: U
                                        })
                                    } catch (r) {
                                        throw r
                                    }
                                },
                                onResponse(l, C) {
                                    let {
                                        close: U
                                    } = C;
                                    try {
                                        if ("object" != typeof l.data) return;
                                        let C = normalizePollingResponse(l.data);
                                        switch (C.status) {
                                            case "APPROVED":
                                                r(C.data), U();
                                                break;
                                            case "DECLINED":
                                                et(`Declined: ${C.reason||"No reason supplied"}`), U();
                                                break;
                                            case "REDIRECT":
                                                r(C), U();
                                                break;
                                            default:
                                                et("Declined: No reason supplied"), U()
                                        }
                                    } catch (r) {
                                        throw console.error("execExtRPC onResponse error", r), r
                                    }
                                },
                                onClose() {
                                    et("Declined: Externally Halted")
                                }
                            })
                        })
                    }
                },
                oY = ["ServicePlugin"],
                oZ = ["discovery-service"],
                validateDiscoveryPlugin = r => {
                    let {
                        services: l,
                        serviceStrategy: C
                    } = r;
                    for (let r of (invariant(Array.isArray(l) && l.length, "Array of Discovery Services is required"), l)) invariant(isRequired(r.f_type) && "Service" === r.f_type, "Service is required"), invariant(isRequired(r.type) && "authn" === r.type, `Service must be type authn. Received ${r.type}`), invariant(r.method in oJ || C.method === r.method, `Service method ${r.method} is not supported`);
                    return invariant(isRequired(C), "Service strategy is required"), invariant(isRequired(C.method) && oC(C.method), "Service strategy method is required"), invariant(isRequired(C.exec) && ok(C.exec), "Service strategy exec function is required"), {
                        discoveryServices: l,
                        serviceStrategy: C
                    }
                },
                validatePlugins = r => {
                    let l;
                    for (let C of (invariant(r, "No plugins supplied"), l = Array.isArray(r) ? [...r] : [r])) invariant(isRequired(C.name), "Plugin name is required"), invariant(isRequired(C.f_type), "Plugin f_type is required"), invariant(oY.includes(C.f_type), `Plugin type ${C.f_type} is not supported`);
                    return l
                },
                oX = (() => {
                    let r = new Set,
                        l = new Map(Object.entries(oJ)),
                        setServices = l => r = new Set([...l]);
                    return Object.freeze({
                        add: r => {
                            if (invariant(oZ.includes(r.type), `Service Plugin type ${r.type} is not supported`), "discovery-service" === r.type) {
                                let {
                                    discoveryServices: C,
                                    serviceStrategy: U
                                } = validateDiscoveryPlugin(r);
                                setServices(C), l.has(U.method) ? log({
                                    title: "Add Service Plugin",
                                    message: `Service strategy for ${U.method} already exists`,
                                    level: nk.warn
                                }) : l.set(U.method, U.exec)
                            }
                        },
                        getServices: () => [...r],
                        getStrategy: r => l.get(r),
                        getStrategies: () => [...l.keys()]
                    })
                })();
            (() => {
                let r = new Map;
                return Object.freeze({
                    add: l => {
                        let C = validatePlugins(l);
                        for (let l of C) r.set(l.name, l), "ServicePlugin" === l.f_type && oX.add(l)
                    },
                    getPlugins: () => r
                })
            })();
            let execStrategy = async r => {
                let {
                    service: l,
                    body: C,
                    config: U,
                    opts: et
                } = r, eo = oX.getStrategy(l.method);
                return eo({
                    service: l,
                    body: C,
                    config: U,
                    opts: et
                })
            };
            async function execService(r) {
                let {
                    service: l,
                    msg: C = {},
                    config: U = {},
                    opts: et = {}
                } = r;
                C.data = l.data;
                let eo = {
                    services: await configLens(/^service\./),
                    app: await configLens(/^app\.detail\./),
                    client: { ...U.client,
                        fclVersion: oA,
                        fclLibrary: "https://github.com/onflow/fcl-js",
                        hostname: window ? .location ? .hostname ? ? null,
                        network: await getChainId()
                    }
                };
                try {
                    let r = await execStrategy({
                        service: l,
                        body: C,
                        config: eo,
                        opts: et
                    });
                    if ("REDIRECT" === r.status) return invariant(l.type === r.data.type, "Cannot shift recursive service type in execService"), await execService({
                        service: r.data,
                        msg: C,
                        config: eo,
                        opts: et
                    });
                    return r
                } catch (r) {
                    throw log({
                        title: `Error on execService ${l?.type}`,
                        message: r,
                        level: nk.error
                    }), r
                }
            }

            function normalizeCompositeSignature(r) {
                return null == r ? null : "1.0.0" === r.f_vsn ? r : { ...oB,
                    addr: util_address_module_sansPrefix(r.addr || r.address),
                    signature: r.signature || r.sig,
                    keyId: r.keyId
                }
            }
            let makeDiscoveryServices = async () => {
                let r = window ? .fcl_extensions || [];
                return [...r, ...oX.getServices()]
            };
            async function getDiscoveryService(r) {
                let l = await config_module_config.get("discovery.authn.include", []),
                    C = await config_module_config.first(["discovery.wallet.method", "discovery.wallet.method.default"]),
                    U = r ? .method ? r.method : C,
                    et = r ? .endpoint ? ? await config_module_config.first(["discovery.wallet", "challenge.handshake"]);
                return invariant(et, `
    If no service is passed to "authenticate," then "discovery.wallet" must be defined in fcl config.
    See: "https://docs.onflow.org/fcl/reference/api/#setting-configuration-values"
    `), { ...r,
                    type: "authn",
                    endpoint: et,
                    method: U,
                    discoveryAuthnInclude: l
                }
            }
            async function getServices(r) {
                let {
                    types: l
                } = r, C = await config_module_config.get("discovery.authn.endpoint");
                invariant(!!C, '"discovery.authn.endpoint" in config must be defined.');
                let U = await config_module_config.get("discovery.authn.include", []),
                    et = new URL(C);
                return fetch(et, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({
                        type: l,
                        fclVersion: oA,
                        include: U,
                        clientServices: await makeDiscoveryServices(),
                        supportedStrategies: oX.getStrategies(),
                        userAgent: window ? .navigator ? .userAgent,
                        network: await getChainId()
                    })
                }).then(r => r.json())
            }
            let oQ = {
                    AUTHN: "authn",
                    SNAPSHOT: "SNAPSHOT",
                    UPDATED: "UPDATED",
                    UPDATE_RESULTS: "UPDATE_RESULTS"
                },
                warn = (r, l) => {
                    r && console.warn(`
      %cFCL Warning
      ============================
      ${l}
      For more info, please see the docs: https://docs.onflow.org/fcl/
      ============================
      `, "font-weight:bold;font-family:monospace;")
                },
                fetchServicesFromDiscovery = async () => {
                    try {
                        let r = await getServices({
                            types: [oQ.AUTHN]
                        });
                        actor_module_send(oQ.AUTHN, oQ.UPDATE_RESULTS, {
                            results: r
                        })
                    } catch (r) {
                        log({
                            title: `${r.name} Error fetching Discovery API services.`,
                            message: r.message,
                            level: nk.error
                        })
                    }
                };
            oQ.UPDATE_RESULTS, oQ.SNAPSHOT, async (r, l) => l.reply({ ...r.all()
            });
            let fcl_module_isFn = r => "function" == typeof r,
                o0 = "CURRENT_USER",
                o1 = "CURRENT_USER/UPDATED",
                o2 = "SNAPSHOT",
                o3 = "SET_CURRENT_USER",
                o5 = "DEL_CURRENT_USER",
                o6 = `{
  "f_type": "User",
  "f_vsn": "1.0.0",
  "addr":null,
  "cid":null,
  "loggedIn":null,
  "expiresAt":null,
  "services":[]
}`,
                getStoredUser = async r => {
                    let l = JSON.parse(o6),
                        C = await r.get(o0);
                    return null != C && l.f_vsn !== C.f_vsn ? (r.removeItem(o0), l) : C || l
                },
                o8 = {
                    [nm]: async r => {
                        "undefined" == typeof window && console.warn(`
        %cFCL Warning
        ============================
        "currentUser" is only available in the browser.
        For more info, please see the docs: https://docs.onflow.org/fcl/
        ============================
        `, "font-weight:bold;font-family:monospace;"), r.merge(JSON.parse(o6));
                        let l = await config_module_config.first(["fcl.storage", "fcl.storage.default"]);
                        if (l.can) {
                            let C = await getStoredUser(l);
                            (null == C.expiresAt || 0 === C.expiresAt || C.expiresAt > Date.now()) && r.merge(C)
                        }
                    },
                    [n_]: (r, l) => {
                        r.subscribe(l.from), r.send(l.from, o1, { ...r.all()
                        })
                    },
                    [nb]: (r, l) => {
                        r.unsubscribe(l.from)
                    },
                    [o2]: async (r, l) => {
                        l.reply({ ...r.all()
                        })
                    },
                    [o3]: async (r, l, C) => {
                        r.merge(C);
                        let U = await config_module_config.first(["fcl.storage", "fcl.storage.default"]);
                        U.can && U.put(o0, r.all()), r.broadcast(o1, { ...r.all()
                        })
                    },
                    [o5]: async (r, l) => {
                        r.merge(JSON.parse(o6));
                        let C = await config_module_config.first(["fcl.storage", "fcl.storage.default"]);
                        C.can && C.put(o0, r.all()), r.broadcast(o1, { ...r.all()
                        })
                    }
                },
                spawnCurrentUser = () => actor_module_spawn(o8, o0);
            async function getAccountProofData() {
                let r = await config_module_config.get("fcl.accountProof.resolver");
                if (null == r) return;
                if (!fcl_module_isFn(r)) {
                    log({
                        title: "Account Proof Data Resolver must be a function",
                        message: `Check fcl.accountProof.resolver configuration.
                Expected: fcl.accountProof.resolver: async () => { ... }
                Received: fcl.accountProof.resolver: ${typeof r}
                `,
                        level: nk.warn
                    });
                    return
                }
                let l = await r();
                if (null != l) return invariant("string" == typeof l.appIdentifier, "appIdentifier must be a string"), invariant(/^[0-9a-f]+$/i.test(l.nonce), "Nonce must be a hex string"), l
            }
            let makeConfig = async r => {
                let {
                    discoveryAuthnInclude: l
                } = r;
                return {
                    client: {
                        discoveryAuthnInclude: l,
                        clientServices: await makeDiscoveryServices(),
                        supportedStrategies: oX.getStrategies()
                    }
                }
            };
            async function authenticate$1() {
                let {
                    service: r,
                    redir: l = !1
                } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                if (r && !r ? .provider ? .is_installed && r ? .provider ? .requires_install) {
                    window.location.href = r ? .provider ? .install_link;
                    return
                }
                return new Promise(async (C, U) => {
                    let et;
                    spawnCurrentUser();
                    let eo = {
                            redir: l
                        },
                        es = await snapshot(),
                        el = await getDiscoveryService(r),
                        ec = serviceOfType(es.services, "authn-refresh");
                    if (es.loggedIn) {
                        if (!ec) return C(es);
                        try {
                            let r = await execService({
                                service: ec,
                                msg: et,
                                opts: eo
                            });
                            actor_module_send(o0, o3, await buildUser(r))
                        } catch (r) {
                            log({
                                title: `${r.name} Could not refresh wallet authentication.`,
                                message: r.message,
                                level: nk.error
                            })
                        } finally {
                            return C(await snapshot())
                        }
                    }
                    try {
                        et = await getAccountProofData()
                    } catch (r) {
                        return log({
                            title: `${r.name} On Authentication: Could not resolve account proof data.`,
                            message: r.message,
                            level: nk.error
                        }), U(r)
                    }
                    try {
                        let r = await execService({
                            service: el,
                            msg: et,
                            config: await makeConfig(el),
                            opts: eo
                        });
                        actor_module_send(o0, o3, await buildUser(r))
                    } catch (r) {
                        log({
                            title: `${r} On Authentication`,
                            message: r,
                            level: nk.error
                        })
                    } finally {
                        C(await snapshot())
                    }
                })
            }

            function unauthenticate$1() {
                spawnCurrentUser(), actor_module_send(o0, o5)
            }
            let normalizePreAuthzResponse = r => ({
                f_type: "PreAuthzResponse",
                f_vsn: "1.0.0",
                proposer: (r || {}).proposer,
                payer: (r || {}).payer || [],
                authorization: (r || {}).authorization || []
            });
            async function fcl_module_authorization(r) {
                return spawnCurrentUser(), { ...r,
                    tempId: "CURRENT_USER",
                    async resolve(r, l) {
                        let C = await authenticate$1({
                                redir: !0
                            }),
                            U = serviceOfType(C.services, "authz"),
                            et = serviceOfType(C.services, "pre-authz");
                        if (et) return function(r) {
                            let l = normalizePreAuthzResponse(r),
                                C = [];
                            for (let r of (null != l.proposer && C.push(["PROPOSER", l.proposer]), l.payer || [])) C.push(["PAYER", r]);
                            for (let r of l.authorization || []) C.push(["AUTHORIZER", r]);
                            return C.map(r => {
                                let [l, C] = r;
                                return {
                                    tempId: [C.identity.address, C.identity.keyId].join("|"),
                                    addr: C.identity.address,
                                    keyId: C.identity.keyId,
                                    signingFunction: r => execService({
                                        service: C,
                                        msg: r
                                    }),
                                    role: {
                                        proposer: "PROPOSER" === l,
                                        payer: "PAYER" === l,
                                        authorizer: "AUTHORIZER" === l
                                    }
                                }
                            })
                        }(await execService({
                            service: et,
                            msg: l
                        }));
                        if (U) {
                            let l;
                            return ("undefined" != typeof navigator && /android/i.test(navigator.userAgent) || "undefined" != typeof navigator && /iPhone|iPod/.test(navigator.userAgent) || "undefined" != typeof navigator && /iPad/.test(navigator.userAgent)) && "WC/RPC" === U.method && (l = window.open("", "_blank")), { ...r,
                                tempId: "CURRENT_USER",
                                resolve: null,
                                addr: util_address_module_sansPrefix(U.identity.address),
                                keyId: U.identity.keyId,
                                sequenceNum: null,
                                signature: null,
                                signingFunction: async r => normalizeCompositeSignature(await execService({
                                    service: U,
                                    msg: r,
                                    opts: {
                                        includeOlderJsonRpcCall: !0,
                                        windowRef: l
                                    }
                                }))
                            }
                        }
                        throw Error("No Authz or PreAuthz Service configured for CURRENT_USER")
                    }
                }
            }

            function fcl_module_subscribe(r) {
                spawnCurrentUser();
                let l = "@EXIT",
                    C = actor_module_spawn(async C => {
                        for (C.send(o0, n_);;) {
                            let U = await C.receive();
                            if (U.tag === l) {
                                C.send(o0, nb);
                                return
                            }
                            r(U.data)
                        }
                    });
                return () => actor_module_send(C, l)
            }

            function snapshot() {
                return spawnCurrentUser(), actor_module_send(o0, o2, null, {
                    expectReply: !0,
                    timeout: 0
                })
            }
            async function resolveArgument() {
                let {
                    addr: r
                } = await authenticate$1();
                return arg(util_address_module_withPrefix(r), o_)
            }
            let makeSignable = r => (invariant(/^[0-9a-f]+$/i.test(r), "Message must be a hex string"), {
                message: r
            });
            async function signUserMessage(r) {
                spawnCurrentUser();
                let l = await authenticate$1({
                        redir: !0
                    }),
                    C = serviceOfType(l.services, "user-signature");
                invariant(C, "Current user must have authorized a signing service.");
                try {
                    let l = await execService({
                        service: C,
                        msg: makeSignable(r)
                    });
                    if (Array.isArray(l)) return l.map(r => normalizeCompositeSignature(r));
                    return [normalizeCompositeSignature(l)]
                } catch (r) {
                    return r
                }
            }
            let currentUser = () => ({
                authenticate: authenticate$1,
                unauthenticate: unauthenticate$1,
                authorization: fcl_module_authorization,
                signUserMessage,
                subscribe: fcl_module_subscribe,
                snapshot,
                resolveArgument
            });
            currentUser.authenticate = authenticate$1, currentUser.unauthenticate = unauthenticate$1, currentUser.authorization = fcl_module_authorization, currentUser.signUserMessage = signUserMessage, currentUser.subscribe = fcl_module_subscribe, currentUser.snapshot = snapshot, currentUser.resolveArgument = resolveArgument;
            let fcl_module_leftPaddedHexBuffer = (r, l) => nF.Buffer.from(r.padStart(2 * l, "0"), "hex"),
                validateArgs = r => {
                    if (r.appIdentifier) {
                        let {
                            appIdentifier: l,
                            address: C,
                            nonce: U,
                            signatures: et
                        } = r;
                        return invariant(oC(l), "verifyAccountProof({ appIdentifier }) -- appIdentifier must be a string"), invariant(oC(C) && 16 === util_address_module_sansPrefix(C).length, "verifyAccountProof({ address }) -- address must be a valid address"), invariant(/^[0-9a-f]+$/i.test(U), "nonce must be a hex string"), invariant(Array.isArray(et) && et.every((r, l, C) => "CompositeSignature" === r.f_type), "Must include an Array of CompositeSignatures to verify"), invariant(et.map(r => r.addr).every((r, l, C) => r === C[0]), "User signatures to be verified must be from a single account address"), !0
                    } {
                        let {
                            message: l,
                            address: C,
                            compSigs: U
                        } = r;
                        return invariant(/^[0-9a-f]+$/i.test(l), "Signed message must be a hex string"), invariant(oC(C) && 16 === util_address_module_sansPrefix(C).length, "verifyUserSignatures({ address }) -- address must be a valid address"), invariant(Array.isArray(U) && U.every((r, l, C) => "CompositeSignature" === r.f_type), "Must include an Array of CompositeSignatures to verify"), invariant(U.map(r => r.addr).every((r, l, C) => r === C[0]), "User signatures to be verified must be from a single account address"), !0
                    }
                },
                getVerifySignaturesScript = async (r, l) => {
                    let C;
                    let U = await getChainId();
                    return invariant(l.fclCryptoContract || "testnet" === U || "mainnet" === U, "${verifyFunction}({ fclCryptoContract }) -- config.flow.network must be specified (testnet || mainnet) or contract address provided via opts.fclCryptoContract"), C = l.fclCryptoContract ? l.fclCryptoContract : "testnet" === U ? "0x74daa6f9c7ef24b1" : "0xb4b82a1c9d21d284", `
      import FCLCrypto from ${C}

      pub fun main(
          address: Address, 
          message: String, 
          keyIndices: [Int], 
          signatures: [String]
      ): Bool {
        return FCLCrypto.${"ACCOUNT_PROOF"===r?"verifyAccountProofSignatures":"verifyUserSignatures"}(address: address, message: message, keyIndices: keyIndices, signatures: signatures)
      }
    `
                };
            async function verifyUserSignatures$1(r, l) {
                let C = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
                    U = util_address_module_withPrefix(l[0].addr);
                validateArgs({
                    message: r,
                    address: U,
                    compSigs: l
                });
                let et = [],
                    eo = [];
                for (let r of l) et.push(r.signature), eo.push(r.keyId.toString());
                return query({
                    cadence: await getVerifySignaturesScript("USER_SIGNATURE", C),
                    args: (l, C) => [l(U, C.Address), l(r, C.String), l(eo, C.Array(C.Int)), l(et, C.Array(C.String))]
                })
            }
            log.deprecate({
                pkg: "FCL",
                subject: "fcl.verifyUserSignatures()",
                message: "Please use fcl.AppUtils.verifyUserSignatures()",
                callback: function(r, l) {
                    return verifyUserSignatures$1(r, l)
                }
            });
            let o4 = "POLL",
                fetchTxStatus = async r => sdk_module_send([sdk_module_pipe([ib, l => (l.transaction.id = r, Ok(l))])]).then(sdk_module_decode),
                isSealed = r => r.status >= 4,
                isExecuted = r => r.status >= 3,
                isFinalized = r => r.status >= 2,
                isDiff = (r, l) => JSON.stringify(r) !== JSON.stringify(l),
                o9 = {
                    [nm]: async r => {
                        r.sendSelf(o4)
                    },
                    [n_]: (r, l) => {
                        r.subscribe(l.from), r.send(l.from, nw, r.all())
                    },
                    [nb]: (r, l) => {
                        r.unsubscribe(l.from)
                    },
                    [nE]: async (r, l) => {
                        l.reply(r.all())
                    },
                    [o4]: async r => {
                        let l;
                        try {
                            l = await fetchTxStatus(r.self())
                        } catch (l) {
                            return r.fatalError(l)
                        }
                        isSealed(l) || setTimeout(() => r.sendSelf(o4), 2500), isDiff(r.all(), l) && r.broadcast(nw, l), r.merge(l)
                    }
                },
                scoped = r => {
                    if ("object" == typeof r && (r = r.transactionId), null == r) throw Error("transactionId required");
                    return r
                },
                spawnTransaction = r => actor_module_spawn(o9, scoped(r));

            function fcl_module_transaction(r) {
                function subscribe(l) {
                    return actor_module_subscriber(scoped(r), spawnTransaction, l)
                }

                function once(r) {
                    return function() {
                        let l = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                            C = l.suppress || !1;
                        return new Promise((l, U) => {
                            let et = subscribe((eo, es) => {
                                (es || eo.statusCode) && !C ? (U(es || eo.errorMessage), et()) : r(eo) && (l(eo), et())
                            })
                        })
                    }
                }
                return {
                    snapshot: function() {
                        return spawnTransaction(r), actor_module_send(r, nE, null, {
                            expectReply: !0,
                            timeout: 0
                        })
                    },
                    subscribe,
                    onceFinalized: once(isFinalized),
                    onceExecuted: once(isExecuted),
                    onceSealed: once(isSealed)
                }
            }
            fcl_module_transaction.isUnknown = r => r.status >= 0, fcl_module_transaction.isPending = r => r.status >= 1, fcl_module_transaction.isFinalized = isFinalized, fcl_module_transaction.isExecuted = isExecuted, fcl_module_transaction.isSealed = isSealed, fcl_module_transaction.isExpired = r => 5 === r.status;
            var o7 = {},
                sn = {},
                so = {},
                ss = {},
                copy_1 = function(r, l) {
                    return function(C, U) {
                        var et = 2 * U,
                            eo = 2 * l;
                        C[et] = r[eo], C[et + 1] = r[eo + 1]
                    }
                };
            Object.defineProperty(ss, "__esModule", {
                value: !0
            }), ss.default = void 0, eB = copy_1 && copy_1.__esModule ? copy_1 : {
                default: copy_1
            }, ss.default = function(r) {
                for (var l = r.A, C = r.C, U = 0; U < 25; U += 5) {
                    for (var et = 0; et < 5; et++)(0, eB.default)(l, U + et)(C, et);
                    for (var eo = 0; eo < 5; eo++) {
                        var es = (U + eo) * 2,
                            el = (eo + 1) % 5 * 2,
                            ec = (eo + 2) % 5 * 2;
                        l[es] ^= ~C[el] & C[ec], l[es + 1] ^= ~C[el + 1] & C[ec + 1]
                    }
                }
            };
            var sa = {},
                sl = {};
            Object.defineProperty(sl, "__esModule", {
                value: !0
            }), sl.default = void 0, eU = new Uint32Array([0, 1, 0, 32898, 2147483648, 32906, 2147483648, 2147516416, 0, 32907, 0, 2147483649, 2147483648, 2147516545, 2147483648, 32777, 0, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 2147483648, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 0, 32778, 2147483648, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 0, 2147483649, 2147483648, 2147516424]), sl.default = eU, Object.defineProperty(sa, "__esModule", {
                value: !0
            }), sa.default = void 0, eL = sl && sl.__esModule ? sl : {
                default: sl
            }, sa.default = function(r) {
                var l = r.A,
                    C = 2 * r.roundIndex;
                l[0] ^= eL.default[C], l[1] ^= eL.default[C + 1]
            };
            var sc = {},
                sd = {};
            Object.defineProperty(sd, "__esModule", {
                value: !0
            }), sd.default = void 0, sd.default = [10, 7, 11, 17, 18, 3, 5, 16, 8, 21, 24, 4, 15, 23, 19, 13, 12, 2, 20, 14, 22, 9, 6, 1];
            var sh = {};
            Object.defineProperty(sh, "__esModule", {
                    value: !0
                }), sh.default = void 0, sh.default = [1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 2, 14, 27, 41, 56, 8, 25, 43, 62, 18, 39, 61, 20, 44],
                function(r) {
                    Object.defineProperty(r, "__esModule", {
                        value: !0
                    }), r.default = void 0;
                    var l = _interopRequireDefault(sd),
                        C = _interopRequireDefault(sh),
                        U = _interopRequireDefault(copy_1);

                    function _interopRequireDefault(r) {
                        return r && r.__esModule ? r : {
                            default: r
                        }
                    }
                    r.default = function(r) {
                        var et = r.A,
                            eo = r.C,
                            es = r.W;
                        (0, U.default)(et, 1)(es, 0);
                        for (var el = 0, ec = 0, ed = 0, eh = 32, ef = 0; ef < 24; ef++) {
                            var ep = l.default[ef],
                                eg = C.default[ef];
                            (0, U.default)(et, ep)(eo, 0), el = es[0], ec = es[1], eh = 32 - eg, es[ed = eg < 32 ? 0 : 1] = el << eg | ec >>> eh, es[(ed + 1) % 2] = ec << eg | el >>> eh, (0, U.default)(es, 0)(et, ep), (0, U.default)(eo, 0)(es, 0)
                        }
                    }
                }(sc);
            var sf = {};
            async function genHash(r) {
                let l = new o7.SHA3(256);
                return l.update(nF.Buffer.from(r, "utf8")), l.digest("hex")
            }

            function generateImport(r) {
                let {
                    contractName: l,
                    address: C
                } = r;
                return {
                    contractName: l,
                    address: C,
                    contract: ""
                }
            }
            Object.defineProperty(sf, "__esModule", {
                    value: !0
                }), sf.default = void 0, eM = copy_1 && copy_1.__esModule ? copy_1 : {
                    default: copy_1
                }, sf.default = function(r) {
                    for (var l = r.A, C = r.C, U = r.D, et = r.W, eo = 0, es = 0, el = 0; el < 5; el++) {
                        var ec = 2 * el,
                            ed = (el + 5) * 2,
                            eh = (el + 10) * 2,
                            ef = (el + 15) * 2,
                            ep = (el + 20) * 2;
                        C[ec] = l[ec] ^ l[ed] ^ l[eh] ^ l[ef] ^ l[ep], C[ec + 1] = l[ec + 1] ^ l[ed + 1] ^ l[eh + 1] ^ l[ef + 1] ^ l[ep + 1]
                    }
                    for (var eg = 0; eg < 5; eg++) {
                        (0, eM.default)(C, (eg + 1) % 5)(et, 0), eo = et[0], es = et[1], et[0] = eo << 1 | es >>> 31, et[1] = es << 1 | eo >>> 31, U[2 * eg] = C[(eg + 4) % 5 * 2] ^ et[0], U[2 * eg + 1] = C[(eg + 4) % 5 * 2 + 1] ^ et[1];
                        for (var ey = 0; ey < 25; ey += 5) l[(ey + eg) * 2] ^= U[2 * eg], l[(ey + eg) * 2 + 1] ^= U[2 * eg + 1]
                    }
                },
                function(r) {
                    Object.defineProperty(r, "__esModule", {
                        value: !0
                    }), r.default = void 0;
                    var l = _interopRequireDefault(ss),
                        C = _interopRequireDefault(sa),
                        U = _interopRequireDefault(sc),
                        et = _interopRequireDefault(sf);

                    function _interopRequireDefault(r) {
                        return r && r.__esModule ? r : {
                            default: r
                        }
                    }
                    r.default = function() {
                        var r = new Uint32Array(10),
                            eo = new Uint32Array(10),
                            es = new Uint32Array(2);
                        return function(el) {
                            for (var ec = 0; ec < 24; ec++)(0, et.default)({
                                A: el,
                                C: r,
                                D: eo,
                                W: es
                            }), (0, U.default)({
                                A: el,
                                C: r,
                                W: es
                            }), (0, l.default)({
                                A: el,
                                C: r
                            }), (0, C.default)({
                                A: el,
                                roundIndex: ec
                            });
                            r.fill(0), eo.fill(0), es.fill(0)
                        }
                    }
                }(so), Object.defineProperty(sn, "__esModule", {
                    value: !0
                }), sn.default = void 0, ej = so && so.__esModule ? so : {
                    default: so
                }, e$ = function(r, l) {
                    for (var C = 0; C < r.length; C += 8) {
                        var U = C / 4;
                        l[U] ^= r[C + 7] << 24 | r[C + 6] << 16 | r[C + 5] << 8 | r[C + 4], l[U + 1] ^= r[C + 3] << 24 | r[C + 2] << 16 | r[C + 1] << 8 | r[C]
                    }
                    return l
                }, ez = function(r, l) {
                    for (var C = 0; C < l.length; C += 8) {
                        var U = C / 4;
                        l[C] = r[U + 1], l[C + 1] = r[U + 1] >>> 8, l[C + 2] = r[U + 1] >>> 16, l[C + 3] = r[U + 1] >>> 24, l[C + 4] = r[U], l[C + 5] = r[U] >>> 8, l[C + 6] = r[U] >>> 16, l[C + 7] = r[U] >>> 24
                    }
                    return l
                }, sn.default = function(r) {
                    var l = this,
                        C = r.capacity,
                        U = r.padding,
                        et = (0, ej.default)(),
                        eo = C / 8,
                        es = 200 - C / 4,
                        el = 0,
                        ec = new Uint32Array(50),
                        ed = nF.Buffer.allocUnsafe(es);
                    return this.absorb = function(r) {
                        for (var C = 0; C < r.length; C++) ed[el] = r[C], (el += 1) >= es && (e$(ed, ec), et(ec), el = 0);
                        return l
                    }, this.squeeze = function() {
                        var r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                            l = {
                                buffer: r.buffer || nF.Buffer.allocUnsafe(eo),
                                padding: r.padding || U,
                                queue: nF.Buffer.allocUnsafe(ed.length),
                                state: new Uint32Array(ec.length)
                            };
                        ed.copy(l.queue);
                        for (var C = 0; C < ec.length; C++) l.state[C] = ec[C];
                        l.queue.fill(0, el), l.queue[el] |= l.padding, l.queue[es - 1] |= 128, e$(l.queue, l.state);
                        for (var eh = 0; eh < l.buffer.length; eh += es) et(l.state), ez(l.state, l.buffer.slice(eh, eh + es));
                        return l.buffer
                    }, this.reset = function() {
                        return ed.fill(0), ec.fill(0), el = 0, l
                    }, this
                }, Object.defineProperty(o7, "__esModule", {
                    value: !0
                }), o7.default = o7.SHAKE = o7.SHA3Hash = o7.SHA3 = o7.Keccak = void 0, eH = sn && sn.__esModule ? sn : {
                    default: sn
                }, eW = (eF = function(r) {
                    var l = r.allowedSizes,
                        C = r.defaultSize,
                        U = r.padding;
                    return function Hash() {
                        var r = this,
                            et = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : C;
                        if (!this || this.constructor !== Hash) return new Hash(et);
                        if (l && !l.includes(et)) throw Error("Unsupported hash length");
                        var eo = new eH.default({
                            capacity: et
                        });
                        return this.update = function(l) {
                            var C = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "utf8";
                            if (nF.Buffer.isBuffer(l)) return eo.absorb(l), r;
                            if ("string" == typeof l) return r.update(nF.Buffer.from(l, C));
                            throw TypeError("Not a string or buffer")
                        }, this.digest = function() {
                            var r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "binary",
                                l = "string" == typeof r ? {
                                    format: r
                                } : r,
                                C = eo.squeeze({
                                    buffer: l.buffer,
                                    padding: l.padding || U
                                });
                            return l.format && "binary" !== l.format ? C.toString(l.format) : C
                        }, this.reset = function() {
                            return eo.reset(), r
                        }, this
                    }
                })({
                    allowedSizes: [224, 256, 384, 512],
                    defaultSize: 512,
                    padding: 1
                }), o7.Keccak = eW, eV = eF({
                    allowedSizes: [224, 256, 384, 512],
                    defaultSize: 512,
                    padding: 6
                }), o7.SHA3 = eV, eK = eF({
                    allowedSizes: [128, 256],
                    defaultSize: 256,
                    padding: 31
                }), o7.SHAKE = eK, o7.SHA3Hash = eW, eV.SHA3Hash = eW, o7.default = eV, currentUser().authorization;
            var sp = Object.defineProperty;
            Object.prototype.hasOwnProperty, Object.prototype.propertyIsEnumerable, rN.Internal;
            let PrepareMessage_PrepareMessage = class PrepareMessage_PrepareMessage {
                static userMessage(r) {
                    let l = new PrepareMessage_PrepareMessage(r);
                    return l.prepare(PrepareMessage_PrepareMessage.USER_TAG)
                }
                static transactionMessage(r) {
                    let l = new PrepareMessage_PrepareMessage(r);
                    return l.prepare(PrepareMessage_PrepareMessage.TRANSACTION_TAG)
                }
                constructor(r) {
                    this.messageToSign = r, "undefined" != typeof window && void 0 === window.Buffer && Object.assign(window, {
                        Buffer: nF.Buffer
                    })
                }
                prependTag(r) {
                    let l = nF.Buffer.from(r),
                        C = Math.max(32, r.length),
                        U = nF.Buffer.alloc(C, 0);
                    return l.copy(U), U
                }
                prepare(r) {
                    let l = this.prependTag(r),
                        C = nF.Buffer.from(this.messageToSign),
                        U = nF.Buffer.concat([l, C]);
                    return U.toString("hex")
                }
            };
            PrepareMessage_PrepareMessage.TRANSACTION_TAG = "FLOW-V0.0-transaction", PrepareMessage_PrepareMessage.USER_TAG = "FLOW-V0.0-user", C(20924), rN.Internal, C(97115).Buffer
        },
        95828: function(r, l, C) {
            "use strict";
            C.d(l, {
                z: function() {
                    return DynamicWagmiConnector
                }
            });
            var U = {};
            C.r(U), C.d(U, {
                acala: function() {
                    return em.acala
                },
                arbitrum: function() {
                    return em.arbitrum
                },
                arbitrumGoerli: function() {
                    return em.arbitrumGoerli
                },
                arbitrumNova: function() {
                    return em.arbitrumNova
                },
                arbitrumSepolia: function() {
                    return em.arbitrumSepolia
                },
                astar: function() {
                    return em.astar
                },
                astarZkatana: function() {
                    return em.astarZkatana
                },
                aurora: function() {
                    return em.aurora
                },
                auroraTestnet: function() {
                    return em.auroraTestnet
                },
                avalanche: function() {
                    return em.avalanche
                },
                avalancheFuji: function() {
                    return em.avalancheFuji
                },
                bahamut: function() {
                    return em.bahamut
                },
                base: function() {
                    return em.base
                },
                baseGoerli: function() {
                    return em.baseGoerli
                },
                baseSepolia: function() {
                    return em.baseSepolia
                },
                bearNetworkChainMainnet: function() {
                    return em.bearNetworkChainMainnet
                },
                bearNetworkChainTestnet: function() {
                    return em.bearNetworkChainTestnet
                },
                bitTorrent: function() {
                    return em.bitTorrent
                },
                bitTorrentTestnet: function() {
                    return em.bitTorrentTestnet
                },
                boba: function() {
                    return em.boba
                },
                bronos: function() {
                    return em.bronos
                },
                bronosTestnet: function() {
                    return em.bronosTestnet
                },
                bsc: function() {
                    return em.bsc
                },
                bscTestnet: function() {
                    return em.bscTestnet
                },
                bxn: function() {
                    return em.bxn
                },
                bxnTestnet: function() {
                    return em.bxnTestnet
                },
                canto: function() {
                    return em.canto
                },
                celo: function() {
                    return em.celo
                },
                celoAlfajores: function() {
                    return em.celoAlfajores
                },
                celoCannoli: function() {
                    return em.celoCannoli
                },
                chiliz: function() {
                    return em.chiliz
                },
                classic: function() {
                    return em.classic
                },
                confluxESpace: function() {
                    return em.confluxESpace
                },
                confluxESpaceTestnet: function() {
                    return em.confluxESpaceTestnet
                },
                coreDao: function() {
                    return em.coreDao
                },
                cronos: function() {
                    return em.cronos
                },
                cronosTestnet: function() {
                    return em.cronosTestnet
                },
                crossbell: function() {
                    return em.crossbell
                },
                dfk: function() {
                    return em.dfk
                },
                dogechain: function() {
                    return em.dogechain
                },
                edgeware: function() {
                    return em.edgeware
                },
                edgewareTestnet: function() {
                    return em.edgewareTestnet
                },
                ekta: function() {
                    return em.ekta
                },
                ektaTestnet: function() {
                    return em.ektaTestnet
                },
                eos: function() {
                    return em.eos
                },
                eosTestnet: function() {
                    return em.eosTestnet
                },
                evmos: function() {
                    return em.evmos
                },
                evmosTestnet: function() {
                    return em.evmosTestnet
                },
                fantom: function() {
                    return em.fantom
                },
                fantomSonicTestnet: function() {
                    return em.fantomSonicTestnet
                },
                fantomTestnet: function() {
                    return em.fantomTestnet
                },
                fibo: function() {
                    return em.fibo
                },
                filecoin: function() {
                    return em.filecoin
                },
                filecoinCalibration: function() {
                    return em.filecoinCalibration
                },
                filecoinHyperspace: function() {
                    return em.filecoinHyperspace
                },
                flare: function() {
                    return em.flare
                },
                flareTestnet: function() {
                    return em.flareTestnet
                },
                foundry: function() {
                    return em.foundry
                },
                fuse: function() {
                    return em.fuse
                },
                fuseSparknet: function() {
                    return em.fuseSparknet
                },
                gnosis: function() {
                    return em.gnosis
                },
                gnosisChiado: function() {
                    return em.gnosisChiado
                },
                gobi: function() {
                    return em.gobi
                },
                goerli: function() {
                    return em.goerli
                },
                haqqMainnet: function() {
                    return em.haqqMainnet
                },
                haqqTestedge2: function() {
                    return em.haqqTestedge2
                },
                hardhat: function() {
                    return em.hardhat
                },
                harmonyOne: function() {
                    return em.harmonyOne
                },
                holesky: function() {
                    return em.holesky
                },
                iotex: function() {
                    return em.iotex
                },
                iotexTestnet: function() {
                    return em.iotexTestnet
                },
                jbc: function() {
                    return em.jbc
                },
                karura: function() {
                    return em.karura
                },
                kava: function() {
                    return em.kava
                },
                kavaTestnet: function() {
                    return em.kavaTestnet
                },
                klaytn: function() {
                    return em.klaytn
                },
                klaytnBaobab: function() {
                    return em.klaytnBaobab
                },
                kroma: function() {
                    return em.kroma
                },
                kromaSepolia: function() {
                    return em.kromaSepolia
                },
                linea: function() {
                    return em.linea
                },
                lineaTestnet: function() {
                    return em.lineaTestnet
                },
                localhost: function() {
                    return em.localhost
                },
                lukso: function() {
                    return em.lukso
                },
                mainnet: function() {
                    return em.mainnet
                },
                mandala: function() {
                    return em.mandala
                },
                manta: function() {
                    return em.manta
                },
                mantaTestnet: function() {
                    return em.mantaTestnet
                },
                mantle: function() {
                    return em.mantle
                },
                mantleTestnet: function() {
                    return em.mantleTestnet
                },
                meter: function() {
                    return em.meter
                },
                meterTestnet: function() {
                    return em.meterTestnet
                },
                metis: function() {
                    return em.metis
                },
                metisGoerli: function() {
                    return em.metisGoerli
                },
                mev: function() {
                    return em.mev
                },
                mevTestnet: function() {
                    return em.mevTestnet
                },
                modeTestnet: function() {
                    return em.modeTestnet
                },
                moonbaseAlpha: function() {
                    return em.moonbaseAlpha
                },
                moonbeam: function() {
                    return em.moonbeam
                },
                moonbeamDev: function() {
                    return em.moonbeamDev
                },
                moonriver: function() {
                    return em.moonriver
                },
                neonDevnet: function() {
                    return em.neonDevnet
                },
                neonMainnet: function() {
                    return em.neonMainnet
                },
                nexi: function() {
                    return em.nexi
                },
                nexilix: function() {
                    return em.nexilix
                },
                oasisTestnet: function() {
                    return em.oasisTestnet
                },
                oasys: function() {
                    return em.oasys
                },
                okc: function() {
                    return em.okc
                },
                opBNB: function() {
                    return em.opBNB
                },
                opBNBTestnet: function() {
                    return em.opBNBTestnet
                },
                optimism: function() {
                    return em.optimism
                },
                optimismGoerli: function() {
                    return em.optimismGoerli
                },
                optimismSepolia: function() {
                    return em.optimismSepolia
                },
                pgn: function() {
                    return em.pgn
                },
                pgnTestnet: function() {
                    return em.pgnTestnet
                },
                plinga: function() {
                    return em.plinga
                },
                polygon: function() {
                    return em.polygon
                },
                polygonMumbai: function() {
                    return em.polygonMumbai
                },
                polygonZkEvm: function() {
                    return em.polygonZkEvm
                },
                polygonZkEvmTestnet: function() {
                    return em.polygonZkEvmTestnet
                },
                pulsechain: function() {
                    return em.pulsechain
                },
                pulsechainV4: function() {
                    return em.pulsechainV4
                },
                qMainnet: function() {
                    return em.qMainnet
                },
                qTestnet: function() {
                    return em.qTestnet
                },
                rollux: function() {
                    return em.rollux
                },
                rolluxTestnet: function() {
                    return em.rolluxTestnet
                },
                ronin: function() {
                    return em.ronin
                },
                rootstock: function() {
                    return em.rootstock
                },
                saigon: function() {
                    return em.saigon
                },
                sapphire: function() {
                    return em.sapphire
                },
                sapphireTestnet: function() {
                    return em.sapphireTestnet
                },
                scroll: function() {
                    return em.scroll
                },
                scrollSepolia: function() {
                    return em.scrollSepolia
                },
                scrollTestnet: function() {
                    return em.scrollTestnet
                },
                sepolia: function() {
                    return em.sepolia
                },
                shardeumSphinx: function() {
                    return em.shardeumSphinx
                },
                shibarium: function() {
                    return em.shibarium
                },
                shimmer: function() {
                    return em.shimmer
                },
                shimmerTestnet: function() {
                    return em.shimmerTestnet
                },
                skaleBlockBrawlers: function() {
                    return em.skaleBlockBrawlers
                },
                skaleCalypso: function() {
                    return em.skaleCalypso
                },
                skaleCalypsoTestnet: function() {
                    return em.skaleCalypsoTestnet
                },
                skaleChaosTestnet: function() {
                    return em.skaleChaosTestnet
                },
                skaleCryptoBlades: function() {
                    return em.skaleCryptoBlades
                },
                skaleCryptoColosseum: function() {
                    return em.skaleCryptoColosseum
                },
                skaleEuropa: function() {
                    return em.skaleEuropa
                },
                skaleEuropaTestnet: function() {
                    return em.skaleEuropaTestnet
                },
                skaleExorde: function() {
                    return em.skaleExorde
                },
                skaleHumanProtocol: function() {
                    return em.skaleHumanProtocol
                },
                skaleNebula: function() {
                    return em.skaleNebula
                },
                skaleNebulaTestnet: function() {
                    return em.skaleNebulaTestnet
                },
                skaleRazor: function() {
                    return em.skaleRazor
                },
                skaleTitan: function() {
                    return em.skaleTitan
                },
                skaleTitanTestnet: function() {
                    return em.skaleTitanTestnet
                },
                songbird: function() {
                    return em.songbird
                },
                songbirdTestnet: function() {
                    return em.songbirdTestnet
                },
                spicy: function() {
                    return em.spicy
                },
                syscoin: function() {
                    return em.syscoin
                },
                syscoinTestnet: function() {
                    return em.syscoinTestnet
                },
                taikoJolnir: function() {
                    return em.taikoJolnir
                },
                taikoTestnetSepolia: function() {
                    return em.taikoTestnetSepolia
                },
                taraxa: function() {
                    return em.taraxa
                },
                taraxaTestnet: function() {
                    return em.taraxaTestnet
                },
                telos: function() {
                    return em.telos
                },
                telosTestnet: function() {
                    return em.telosTestnet
                },
                tenet: function() {
                    return em.tenet
                },
                thunderTestnet: function() {
                    return em.thunderTestnet
                },
                vechain: function() {
                    return em.vechain
                },
                wanchain: function() {
                    return em.wanchain
                },
                wanchainTestnet: function() {
                    return em.wanchainTestnet
                },
                wemix: function() {
                    return em.wemix
                },
                wemixTestnet: function() {
                    return em.wemixTestnet
                },
                xdc: function() {
                    return em.xdc
                },
                xdcTestnet: function() {
                    return em.xdcTestnet
                },
                zetachainAthensTestnet: function() {
                    return em.zetachainAthensTestnet
                },
                zhejiang: function() {
                    return em.zhejiang
                },
                zilliqa: function() {
                    return em.zilliqa
                },
                zilliqaTestnet: function() {
                    return em.zilliqaTestnet
                },
                zkFair: function() {
                    return em.zkFair
                },
                zkFairTestnet: function() {
                    return em.zkFairTestnet
                },
                zkSync: function() {
                    return em.zkSync
                },
                zkSyncSepoliaTestnet: function() {
                    return em.zkSyncSepoliaTestnet
                },
                zkSyncTestnet: function() {
                    return em.zkSyncTestnet
                },
                zora: function() {
                    return em.zora
                },
                zoraSepolia: function() {
                    return em.zoraSepolia
                },
                zoraTestnet: function() {
                    return em.zoraTestnet
                }
            });
            var et = C(16356),
                eo = C(97352),
                es = C(91798),
                el = C(44333),
                ec = C(59665);

            function publicProvider() {
                return function(r) {
                    return r.rpcUrls.public.http[0] ? {
                        chain: r,
                        rpcUrls: r.rpcUrls.public
                    } : null
                }
            }
            var ed = C(13866);

            function __awaiter(r, l, C, U) {
                return new(C || (C = Promise))(function(et, eo) {
                    function fulfilled(r) {
                        try {
                            step(U.next(r))
                        } catch (r) {
                            eo(r)
                        }
                    }

                    function rejected(r) {
                        try {
                            step(U.throw(r))
                        } catch (r) {
                            eo(r)
                        }
                    }

                    function step(r) {
                        var l;
                        r.done ? et(r.value) : ((l = r.value) instanceof C ? l : new C(function(r) {
                            r(l)
                        })).then(fulfilled, rejected)
                    }
                    step((U = U.apply(r, l || [])).next())
                })
            }
            "function" == typeof SuppressedError && SuppressedError;
            var eh = C(17051),
                ef = C(70278),
                ep = C(56218),
                eg = C(37491),
                ey = C(19473);
            let Connector = class Connector extends eh.wR {
                constructor({
                    chains: r,
                    handleLogOut: l,
                    walletConnector: C,
                    preventWagmiSyncFromCallingLogout: U
                }) {
                    super({
                        chains: r,
                        options: void 0
                    }), this.id = "dynamic", this.name = "Dynamic", this.ready = !1, this.onAccountsChanged = r => __awaiter(this, void 0, void 0, function*() {
                        this.emit("change", {
                            account: (0, ef.K)(r[0])
                        })
                    }), this.onChainChanged = r => __awaiter(this, void 0, void 0, function*() {
                        this.emit("change", {
                            chain: {
                                id: Number(r),
                                unsupported: !1
                            }
                        })
                    }), this.onDisconnect = () => __awaiter(this, void 0, void 0, function*() {}), this.handleLogOut = l, this.walletConnector = C, this.id = `dynamic-${C.key}`, this.preventWagmiSyncFromCallingLogout = U
                }
                _onAccountsChanged({
                    accounts: r
                }) {
                    this.onAccountsChanged(r)
                }
                _onChainChanged({
                    chain: r
                }) {
                    this.onChainChanged(r)
                }
                _onDisconnect() {
                    this.onDisconnect()
                }
                setupEventListeners() {
                    this.walletConnector.on("accountChange", this._onAccountsChanged, this), this.walletConnector.on("chainChange", this._onChainChanged, this), this.walletConnector.on("disconnect", this._onDisconnect, this)
                }
                connect(r) {
                    return __awaiter(this, void 0, void 0, function*() {
                        if (!this.walletConnector) throw Error("WalletConnector is not defined");
                        let r = yield this.getAccount();
                        return this.setupEventListeners(), this.emit("message", {
                            type: "connecting"
                        }), {
                            account: r,
                            chain: {
                                id: yield this.getChainId(), unsupported: !1
                            }
                        }
                    })
                }
                disconnect() {
                    return __awaiter(this, void 0, void 0, function*() {
                        this.walletConnector.removeListener("accountChange", this._onAccountsChanged, this), this.walletConnector.removeListener("chainChange", this._onChainChanged, this), this.walletConnector.removeListener("disconnect", this._onDisconnect, this), this.preventWagmiSyncFromCallingLogout.current || (yield this.walletConnector.endSession(), yield this.handleLogOut()), this.preventWagmiSyncFromCallingLogout.current = !1
                    })
                }
                getAccount() {
                    var r;
                    return __awaiter(this, void 0, void 0, function*() {
                        let l = yield null === (r = this.walletConnector) || void 0 === r ? void 0 : r.fetchPublicAddress();
                        if (!l) throw Error("Not connected");
                        return (0, ef.K)(l)
                    })
                }
                getChainId() {
                    return __awaiter(this, void 0, void 0, function*() {
                        if (!this.walletConnector) throw Error("WalletConnector is not defined");
                        let r = yield this.walletConnector.getNetwork();
                        if (!r) throw Error("Network is not defined");
                        return Number(r)
                    })
                }
                getProvider(r) {
                    var l;
                    return __awaiter(this, void 0, void 0, function*() {
                        return null === (l = this.walletConnector) || void 0 === l ? void 0 : l.getWalletClient()
                    })
                }
                getWalletClient(r) {
                    var l;
                    return __awaiter(this, void 0, void 0, function*() {
                        let C = yield this.walletConnector.getSigner();
                        if (C.account && C.chain) return C;
                        let U = (0, ep.K)({
                            account: yield this.getAccount(), chain: null !== (l = this.chains.find(l => l.id === (null == r ? void 0 : r.chainId))) && void 0 !== l ? l : this.chains[0], transport: (0, eg.P)(C)
                        });
                        return U
                    })
                }
                isAuthorized() {
                    var r, l;
                    return __awaiter(this, void 0, void 0, function*() {
                        let C = null !== (l = yield null === (r = this.walletConnector) || void 0 === r ? void 0 : r.getConnectedAccounts()) && void 0 !== l ? l : [];
                        return C.length > 0
                    })
                }
                switchChain(r) {
                    var l, C;
                    return __awaiter(this, void 0, void 0, function*() {
                        yield null === (l = this.walletConnector) || void 0 === l ? void 0 : l.switchNetwork({
                            networkChainId: r
                        });
                        let U = (0, ey.NC)(r);
                        return null !== (C = this.chains.find(l => l.id === r)) && void 0 !== C ? C : {
                            id: r,
                            name: `Chain ${U}`,
                            nativeCurrency: {
                                decimals: 18,
                                name: "Ether",
                                symbol: "ETH"
                            },
                            network: `${U}`,
                            rpcUrls: {
                                default: {
                                    http: [""]
                                },
                                public: {
                                    http: [""]
                                }
                            }
                        }
                    })
                }
                watchAsset(r) {
                    throw Error("Method not implemented.")
                }
            };
            let getConnector = (r, l) => {
                for (let C of r)
                    if (C.connected && "EVM" === C.connector.connectedChain) return l(C)
            };
            var em = C(52659);
            let mapCustomProviderOptionsToString = r => "string" == typeof r ? r : r.http,
                resolveRpcUrlFromEvmNetworks = r => {
                    var l;
                    let C = null !== (l = r.privateCustomerRpcUrls) && void 0 !== l ? l : [],
                        U = C.map(mapCustomProviderOptionsToString);
                    return U.length ? U : r.rpcUrls
                },
                updateRpcProvider = (r, l, C) => {
                    let U = null == l ? void 0 : l.find(r => "string" == typeof r ? r.includes(C) : "string" == typeof r.http && r.http.includes(C));
                    "string" == typeof U ? r[C] = {
                        http: [U]
                    } : "string" == typeof(null == U ? void 0 : U.http) && (r[C] = {
                        http: [U.http]
                    })
                },
                mapDynamicChainToWagmi = r => {
                    let l = Object.values(U).find(l => l.id === r.chainId);
                    return overrideWagmiChainWithDynamicSettings(l, r)
                },
                generateRpcUrls = r => {
                    let l = resolveRpcUrlFromEvmNetworks(r),
                        C = {
                            default: {
                                http: l
                            },
                            public: {
                                http: l
                            }
                        };
                    return ["alchemy", "infura"].forEach(l => updateRpcProvider(C, r.privateCustomerRpcUrls, l)), C
                },
                overrideWagmiChainWithDynamicSettings = (r, l) => {
                    var C, U, et, eo, es, el, ec, ed, eh, ef;
                    return Object.assign(Object.assign({}, r), {
                        blockExplorers: Object.assign(Object.assign({}, null == r ? void 0 : r.blockExplorers), {
                            default: Object.assign(Object.assign({}, null === (C = null == r ? void 0 : r.blockExplorers) || void 0 === C ? void 0 : C.default), {
                                name: "",
                                url: null !== (et = null === (U = l.blockExplorerUrls) || void 0 === U ? void 0 : U[0]) && void 0 !== et ? et : ""
                            })
                        }),
                        contracts: null !== (eo = l.contracts) && void 0 !== eo ? eo : null == r ? void 0 : r.contracts,
                        id: null !== (es = null == r ? void 0 : r.id) && void 0 !== es ? es : l.chainId,
                        name: null !== (ec = null !== (el = l.vanityName) && void 0 !== el ? el : l.name) && void 0 !== ec ? ec : null == r ? void 0 : r.name,
                        nativeCurrency: null !== (ed = l.nativeCurrency) && void 0 !== ed ? ed : null == r ? void 0 : r.nativeCurrency,
                        network: null !== (ef = null !== (eh = null == r ? void 0 : r.network) && void 0 !== eh ? eh : l.chainName) && void 0 !== ef ? ef : "",
                        rpcUrls: generateRpcUrls(l)
                    })
                },
                getWagmiChainsFromDynamicChains = r => {
                    let l = r.map(mapDynamicChainToWagmi);
                    return l.length > 0 ? l : [el.R]
                },
                getProvider = (r, l) => {
                    let C, U;
                    return "string" != typeof l ? (C = l.http, U = l.webSocket) : C = l, l => l.id !== r.chainId ? null : (function({
                        rpc: r
                    }) {
                        return function(l) {
                            let C = r(l);
                            return C && "" !== C.http ? {
                                chain: { ...l,
                                    rpcUrls: { ...l.rpcUrls,
                                        default: {
                                            http: [C.http]
                                        }
                                    }
                                },
                                rpcUrls: {
                                    http: [C.http],
                                    webSocket: C.webSocket ? [C.webSocket] : void 0
                                }
                            } : null
                        }
                    })({
                        rpc: () => ({
                            http: C,
                            webSocket: U
                        })
                    })(l)
                },
                getWagmiProvidersFromDynamicChains = r => {
                    let l = [];
                    return r.forEach(r => {
                        var C;
                        (null !== (C = r.privateCustomerRpcUrls) && void 0 !== C ? C : []).forEach(C => {
                            l.push(getProvider(r, C))
                        })
                    }), [...l, publicProvider()]
                },
                SyncDynamicWagmi = ({
                    children: r,
                    connector: l,
                    wallets: C,
                    preventWagmiSyncFromCallingLogout: U
                }) => {
                    let {
                        status: es
                    } = (0, ec.ZR)(), {
                        connect: el
                    } = (0, ec.$4)(), {
                        disconnect: eh
                    } = (0, ec.qL)(), {
                        walletConnector: ef
                    } = (0, ed.SX)(), ep = (0, eo.useRef)(void 0);
                    return ((0, eo.useEffect)(() => {
                        let r = !!ep.current;
                        if (!C.length) {
                            r && (U.current = !0, eh(), ep.current = void 0);
                            return
                        }
                        ef && l && (null == l ? void 0 : l.id) !== ep.current && (ep.current = l.id, el({
                            connector: l
                        }))
                    }, [es, el, l, eh, ep, U, ef, C]), eo.version.startsWith("18")) ? (0, et.jsx)(et.Fragment, {
                        children: r
                    }) : eo.createElement(eo.Fragment, null, r)
                },
                evmWalletsFilter = r => "EVM" === r.connector.connectedChain,
                findAndOrderEvmWallets = (r, l) => {
                    let C = (null == r ? void 0 : r.connector.connectedChain) === "EVM";
                    if (C) {
                        let C = l.filter(evmWalletsFilter).filter(l => l.address !== r.address);
                        return [r, ...C]
                    }
                    return l.filter(evmWalletsFilter)
                },
                {
                    publicClient: e_
                } = (0, es.QB)([el.R], [publicProvider()]),
                eb = (0, ec._g)({
                    autoConnect: !0,
                    publicClient: e_
                }),
                DynamicWagmiConnector = ({
                    evmNetworks: r,
                    children: l
                }) => {
                    let {
                        networkConfigurations: C,
                        handleLogOut: U,
                        sendWagmiSettings: el,
                        primaryWallet: eh
                    } = (0, ed.SX)(), ef = (0, eo.useRef)(!1), ep = (0, ed.wC)().sort(r => r.address === (null == eh ? void 0 : eh.address) ? -1 : 1), eg = (0, eo.useMemo)(() => findAndOrderEvmWallets(eh, ep), [eh, ep]);
                    (0, eo.useEffect)(() => {
                        el({
                            dynamicWagmiSettings: r
                        })
                    }, []);
                    let {
                        chains: ey,
                        publicClient: em,
                        webSocketPublicClient: e_
                    } = (0, eo.useMemo)(() => {
                        var l;
                        let U = (null !== (l = null != r ? r : null == C ? void 0 : C.evm) && void 0 !== l ? l : []).map(r => (r.chainId = parseInt(r.chainId.toString()), r)),
                            et = getWagmiChainsFromDynamicChains(U),
                            eo = getWagmiProvidersFromDynamicChains(U);
                        return (0, es.QB)(et, eo)
                    }, [r, null == C ? void 0 : C.evm]), ew = (0, eo.useMemo)(() => getConnector(eg, r => new Connector({
                        chains: ey,
                        handleLogOut: U,
                        preventWagmiSyncFromCallingLogout: ef,
                        walletConnector: r.connector
                    })), [eg, ey, U, ef]);
                    return ((0, eo.useEffect)(() => {
                        eb.setPublicClient(em), eb.setWebSocketPublicClient(e_), eb.setConnectors(ew ? [ew] : [])
                    }, [ew, em, e_]), eo.version.startsWith("18")) ? (0, et.jsx)(ec.eM, {
                        config: eb,
                        children: (0, et.jsx)(SyncDynamicWagmi, {
                            connector: ew,
                            preventWagmiSyncFromCallingLogout: ef,
                            wallets: ep,
                            children: l
                        })
                    }) : eo.createElement(ec.eM, {
                        config: eb
                    }, eo.createElement(SyncDynamicWagmi, {
                        connector: ew,
                        preventWagmiSyncFromCallingLogout: ef,
                        wallets: ep
                    }, l))
                }
        },
        4918: function(r, l, C) {
            "use strict";
            C.d(l, {
                K: function() {
                    return validateBasic
                },
                M: function() {
                    return wNAF
                }
            });
            var U = C(56836),
                et = C(14909); /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
            let eo = BigInt(0),
                es = BigInt(1);

            function wNAF(r, l) {
                let constTimeNegate = (r, l) => {
                        let C = l.negate();
                        return r ? C : l
                    },
                    opts = r => {
                        let C = Math.ceil(l / r) + 1;
                        return {
                            windows: C,
                            windowSize: 2 ** (r - 1)
                        }
                    };
                return {
                    constTimeNegate,
                    unsafeLadder(l, C) {
                        let U = r.ZERO,
                            et = l;
                        for (; C > eo;) C & es && (U = U.add(et)), et = et.double(), C >>= es;
                        return U
                    },
                    precomputeWindow(r, l) {
                        let {
                            windows: C,
                            windowSize: U
                        } = opts(l), et = [], eo = r, es = eo;
                        for (let r = 0; r < C; r++) {
                            es = eo, et.push(es);
                            for (let r = 1; r < U; r++) es = es.add(eo), et.push(es);
                            eo = es.double()
                        }
                        return et
                    },
                    wNAF(l, C, U) {
                        let {
                            windows: et,
                            windowSize: eo
                        } = opts(l), el = r.ZERO, ec = r.BASE, ed = BigInt(2 ** l - 1), eh = 2 ** l, ef = BigInt(l);
                        for (let r = 0; r < et; r++) {
                            let l = r * eo,
                                et = Number(U & ed);
                            U >>= ef, et > eo && (et -= eh, U += es);
                            let ep = l + Math.abs(et) - 1,
                                eg = r % 2 != 0,
                                ey = et < 0;
                            0 === et ? ec = ec.add(constTimeNegate(eg, C[l])) : el = el.add(constTimeNegate(ey, C[ep]))
                        }
                        return {
                            p: el,
                            f: ec
                        }
                    },
                    wNAFCached(r, l, C, U) {
                        let et = r._WINDOW_SIZE || 1,
                            eo = l.get(r);
                        return eo || (eo = this.precomputeWindow(r, et), 1 !== et && l.set(r, U(eo))), this.wNAF(et, eo, C)
                    }
                }
            }

            function validateBasic(r) {
                return (0, U.OP)(r.Fp), (0, et.FF)(r, {
                    n: "bigint",
                    h: "bigint",
                    Gx: "field",
                    Gy: "field"
                }, {
                    nBitLength: "isSafeInteger",
                    nByteLength: "isSafeInteger"
                }), Object.freeze({ ...(0, U.kK)(r.n, r.nBitLength),
                    ...r,
                    p: r.Fp.ORDER
                })
            }
        },
        56836: function(r, l, C) {
            "use strict";
            C.d(l, {
                DV: function() {
                    return FpSqrtEven
                },
                OP: function() {
                    return validateField
                },
                PS: function() {
                    return getMinHashLength
                },
                Tu: function() {
                    return isNegativeLE
                },
                U_: function() {
                    return invert
                },
                Us: function() {
                    return mapHashToField
                },
                gN: function() {
                    return Field
                },
                kK: function() {
                    return nLength
                },
                oA: function() {
                    return pow2
                },
                wQ: function() {
                    return mod
                }
            });
            var U = C(14909); /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
            let et = BigInt(0),
                eo = BigInt(1),
                es = BigInt(2),
                el = BigInt(3),
                ec = BigInt(4),
                ed = BigInt(5),
                eh = BigInt(8);

            function mod(r, l) {
                let C = r % l;
                return C >= et ? C : l + C
            }

            function pow2(r, l, C) {
                let U = r;
                for (; l-- > et;) U *= U, U %= C;
                return U
            }

            function invert(r, l) {
                if (r === et || l <= et) throw Error(`invert: expected positive integers, got n=${r} mod=${l}`);
                let C = mod(r, l),
                    U = l,
                    es = et,
                    el = eo,
                    ec = eo,
                    ed = et;
                for (; C !== et;) {
                    let r = U / C,
                        l = U % C,
                        et = es - ec * r,
                        eo = el - ed * r;
                    U = C, C = l, es = ec, el = ed, ec = et, ed = eo
                }
                let eh = U;
                if (eh !== eo) throw Error("invert: does not exist");
                return mod(es, l)
            }
            BigInt(9), BigInt(16);
            let isNegativeLE = (r, l) => (mod(r, l) & eo) === eo,
                ef = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];

            function validateField(r) {
                let l = ef.reduce((r, l) => (r[l] = "function", r), {
                    ORDER: "bigint",
                    MASK: "bigint",
                    BYTES: "isSafeInteger",
                    BITS: "isSafeInteger"
                });
                return (0, U.FF)(r, l)
            }

            function nLength(r, l) {
                let C = void 0 !== l ? l : r.toString(2).length,
                    U = Math.ceil(C / 8);
                return {
                    nBitLength: C,
                    nByteLength: U
                }
            }

            function Field(r, l, C = !1, ef = {}) {
                if (r <= et) throw Error(`Expected Field ORDER > 0, got ${r}`);
                let {
                    nBitLength: ep,
                    nByteLength: eg
                } = nLength(r, l);
                if (eg > 2048) throw Error("Field lengths over 2048 bytes are not supported");
                let ey = function(r) {
                        if (r % ec === el) {
                            let l = (r + eo) / ec;
                            return function(r, C) {
                                let U = r.pow(C, l);
                                if (!r.eql(r.sqr(U), C)) throw Error("Cannot find square root");
                                return U
                            }
                        }
                        if (r % eh === ed) {
                            let l = (r - ed) / eh;
                            return function(r, C) {
                                let U = r.mul(C, es),
                                    et = r.pow(U, l),
                                    eo = r.mul(C, et),
                                    el = r.mul(r.mul(eo, es), et),
                                    ec = r.mul(eo, r.sub(el, r.ONE));
                                if (!r.eql(r.sqr(ec), C)) throw Error("Cannot find square root");
                                return ec
                            }
                        }
                        return function(r) {
                            let l, C, U;
                            let el = (r - eo) / es;
                            for (l = r - eo, C = 0; l % es === et; l /= es, C++);
                            for (U = es; U < r && function(r, l, C) {
                                    if (C <= et || l < et) throw Error("Expected power/modulo > 0");
                                    if (C === eo) return et;
                                    let U = eo;
                                    for (; l > et;) l & eo && (U = U * r % C), r = r * r % C, l >>= eo;
                                    return U
                                }(U, el, r) !== r - eo; U++);
                            if (1 === C) {
                                let l = (r + eo) / ec;
                                return function(r, C) {
                                    let U = r.pow(C, l);
                                    if (!r.eql(r.sqr(U), C)) throw Error("Cannot find square root");
                                    return U
                                }
                            }
                            let ed = (l + eo) / es;
                            return function(r, et) {
                                if (r.pow(et, el) === r.neg(r.ONE)) throw Error("Cannot find square root");
                                let es = C,
                                    ec = r.pow(r.mul(r.ONE, U), l),
                                    eh = r.pow(et, ed),
                                    ef = r.pow(et, l);
                                for (; !r.eql(ef, r.ONE);) {
                                    if (r.eql(ef, r.ZERO)) return r.ZERO;
                                    let l = 1;
                                    for (let C = r.sqr(ef); l < es && !r.eql(C, r.ONE); l++) C = r.sqr(C);
                                    let C = r.pow(ec, eo << BigInt(es - l - 1));
                                    ec = r.sqr(C), eh = r.mul(eh, C), ef = r.mul(ef, ec), es = l
                                }
                                return eh
                            }
                        }(r)
                    }(r),
                    em = Object.freeze({
                        ORDER: r,
                        BITS: ep,
                        BYTES: eg,
                        MASK: (0, U.dQ)(ep),
                        ZERO: et,
                        ONE: eo,
                        create: l => mod(l, r),
                        isValid: l => {
                            if ("bigint" != typeof l) throw Error(`Invalid field element: expected bigint, got ${typeof l}`);
                            return et <= l && l < r
                        },
                        is0: r => r === et,
                        isOdd: r => (r & eo) === eo,
                        neg: l => mod(-l, r),
                        eql: (r, l) => r === l,
                        sqr: l => mod(l * l, r),
                        add: (l, C) => mod(l + C, r),
                        sub: (l, C) => mod(l - C, r),
                        mul: (l, C) => mod(l * C, r),
                        pow: (r, l) => (function(r, l, C) {
                            if (C < et) throw Error("Expected power > 0");
                            if (C === et) return r.ONE;
                            if (C === eo) return l;
                            let U = r.ONE,
                                es = l;
                            for (; C > et;) C & eo && (U = r.mul(U, es)), es = r.sqr(es), C >>= eo;
                            return U
                        })(em, r, l),
                        div: (l, C) => mod(l * invert(C, r), r),
                        sqrN: r => r * r,
                        addN: (r, l) => r + l,
                        subN: (r, l) => r - l,
                        mulN: (r, l) => r * l,
                        inv: l => invert(l, r),
                        sqrt: ef.sqrt || (r => ey(em, r)),
                        invertBatch: r => (function(r, l) {
                            let C = Array(l.length),
                                U = l.reduce((l, U, et) => r.is0(U) ? l : (C[et] = l, r.mul(l, U)), r.ONE),
                                et = r.inv(U);
                            return l.reduceRight((l, U, et) => r.is0(U) ? l : (C[et] = r.mul(l, C[et]), r.mul(l, U)), et), C
                        })(em, r),
                        cmov: (r, l, C) => C ? l : r,
                        toBytes: r => C ? (0, U.S5)(r, eg) : (0, U.tL)(r, eg),
                        fromBytes: r => {
                            if (r.length !== eg) throw Error(`Fp.fromBytes: expected ${eg}, got ${r.length}`);
                            return C ? (0, U.ty)(r) : (0, U.bytesToNumberBE)(r)
                        }
                    });
                return Object.freeze(em)
            }

            function FpSqrtEven(r, l) {
                if (!r.isOdd) throw Error("Field doesn't have isOdd");
                let C = r.sqrt(l);
                return r.isOdd(C) ? r.neg(C) : C
            }

            function getFieldBytesLength(r) {
                if ("bigint" != typeof r) throw Error("field order must be bigint");
                let l = r.toString(2).length;
                return Math.ceil(l / 8)
            }

            function getMinHashLength(r) {
                let l = getFieldBytesLength(r);
                return l + Math.ceil(l / 2)
            }

            function mapHashToField(r, l, C = !1) {
                let et = r.length,
                    es = getFieldBytesLength(l),
                    el = getMinHashLength(l);
                if (et < 16 || et < el || et > 1024) throw Error(`expected ${el}-1024 bytes of input, got ${et}`);
                let ec = C ? (0, U.bytesToNumberBE)(r) : (0, U.ty)(r),
                    ed = mod(ec, l - eo) + eo;
                return C ? (0, U.S5)(ed, es) : (0, U.tL)(ed, es)
            }
        },
        14909: function(r, l, C) {
            "use strict";
            C.d(l, {
                FF: function() {
                    return validateObject
                },
                S5: function() {
                    return numberToBytesLE
                },
                _t: function() {
                    return isBytes
                },
                bytesToNumberBE: function() {
                    return bytesToNumberBE
                },
                ci: function() {
                    return bytesToHex
                },
                dQ: function() {
                    return bitMask
                },
                eV: function() {
                    return concatBytes
                },
                hexToBytes: function() {
                    return hexToBytes
                },
                n$: function() {
                    return createHmacDrbg
                },
                ql: function() {
                    return ensureBytes
                },
                tL: function() {
                    return numberToBytesBE
                },
                ty: function() {
                    return bytesToNumberLE
                }
            }), BigInt(0);
            let U = BigInt(1),
                et = BigInt(2);

            function isBytes(r) {
                return r instanceof Uint8Array || null != r && "object" == typeof r && "Uint8Array" === r.constructor.name
            }
            let eo = Array.from({
                length: 256
            }, (r, l) => l.toString(16).padStart(2, "0"));

            function bytesToHex(r) {
                if (!isBytes(r)) throw Error("Uint8Array expected");
                let l = "";
                for (let C = 0; C < r.length; C++) l += eo[r[C]];
                return l
            }

            function hexToNumber(r) {
                if ("string" != typeof r) throw Error("hex string expected, got " + typeof r);
                return BigInt("" === r ? "0" : `0x${r}`)
            }
            let es = {
                _0: 48,
                _9: 57,
                _A: 65,
                _F: 70,
                _a: 97,
                _f: 102
            };

            function asciiToBase16(r) {
                return r >= es._0 && r <= es._9 ? r - es._0 : r >= es._A && r <= es._F ? r - (es._A - 10) : r >= es._a && r <= es._f ? r - (es._a - 10) : void 0
            }

            function hexToBytes(r) {
                if ("string" != typeof r) throw Error("hex string expected, got " + typeof r);
                let l = r.length,
                    C = l / 2;
                if (l % 2) throw Error("padded hex string expected, got unpadded hex of length " + l);
                let U = new Uint8Array(C);
                for (let l = 0, et = 0; l < C; l++, et += 2) {
                    let C = asciiToBase16(r.charCodeAt(et)),
                        eo = asciiToBase16(r.charCodeAt(et + 1));
                    if (void 0 === C || void 0 === eo) {
                        let l = r[et] + r[et + 1];
                        throw Error('hex string expected, got non-hex character "' + l + '" at index ' + et)
                    }
                    U[l] = 16 * C + eo
                }
                return U
            }

            function bytesToNumberBE(r) {
                return hexToNumber(bytesToHex(r))
            }

            function bytesToNumberLE(r) {
                if (!isBytes(r)) throw Error("Uint8Array expected");
                return hexToNumber(bytesToHex(Uint8Array.from(r).reverse()))
            }

            function numberToBytesBE(r, l) {
                return hexToBytes(r.toString(16).padStart(2 * l, "0"))
            }

            function numberToBytesLE(r, l) {
                return numberToBytesBE(r, l).reverse()
            }

            function ensureBytes(r, l, C) {
                let U;
                if ("string" == typeof l) try {
                        U = hexToBytes(l)
                    } catch (C) {
                        throw Error(`${r} must be valid hex string, got "${l}". Cause: ${C}`)
                    } else if (isBytes(l)) U = Uint8Array.from(l);
                    else throw Error(`${r} must be hex string or Uint8Array`);
                let et = U.length;
                if ("number" == typeof C && et !== C) throw Error(`${r} expected ${C} bytes, got ${et}`);
                return U
            }

            function concatBytes(...r) {
                let l = 0;
                for (let C = 0; C < r.length; C++) {
                    let U = r[C];
                    if (!isBytes(U)) throw Error("Uint8Array expected");
                    l += U.length
                }
                let C = new Uint8Array(l),
                    U = 0;
                for (let l = 0; l < r.length; l++) {
                    let et = r[l];
                    C.set(et, U), U += et.length
                }
                return C
            }
            let bitMask = r => (et << BigInt(r - 1)) - U,
                u8n = r => new Uint8Array(r),
                u8fr = r => Uint8Array.from(r);

            function createHmacDrbg(r, l, C) {
                if ("number" != typeof r || r < 2) throw Error("hashLen must be a number");
                if ("number" != typeof l || l < 2) throw Error("qByteLen must be a number");
                if ("function" != typeof C) throw Error("hmacFn must be a function");
                let U = u8n(r),
                    et = u8n(r),
                    eo = 0,
                    reset = () => {
                        U.fill(1), et.fill(0), eo = 0
                    },
                    h = (...r) => C(et, U, ...r),
                    reseed = (r = u8n()) => {
                        et = h(u8fr([0]), r), U = h(), 0 !== r.length && (et = h(u8fr([1]), r), U = h())
                    },
                    gen = () => {
                        if (eo++ >= 1e3) throw Error("drbg: tried 1000 values");
                        let r = 0,
                            C = [];
                        for (; r < l;) {
                            U = h();
                            let l = U.slice();
                            C.push(l), r += U.length
                        }
                        return concatBytes(...C)
                    };
                return (r, l) => {
                    let C;
                    for (reset(), reseed(r); !(C = l(gen()));) reseed();
                    return reset(), C
                }
            }
            let el = {
                bigint: r => "bigint" == typeof r,
                function: r => "function" == typeof r,
                boolean: r => "boolean" == typeof r,
                string: r => "string" == typeof r,
                stringOrUint8Array: r => "string" == typeof r || isBytes(r),
                isSafeInteger: r => Number.isSafeInteger(r),
                array: r => Array.isArray(r),
                field: (r, l) => l.Fp.isValid(r),
                hash: r => "function" == typeof r && Number.isSafeInteger(r.outputLen)
            };

            function validateObject(r, l, C = {}) {
                let checkField = (l, C, U) => {
                    let et = el[C];
                    if ("function" != typeof et) throw Error(`Invalid validator "${C}", expected function`);
                    let eo = r[l];
                    if ((!U || void 0 !== eo) && !et(eo, r)) throw Error(`Invalid param ${String(l)}=${eo} (${typeof eo}), expected ${C}`)
                };
                for (let [r, C] of Object.entries(l)) checkField(r, C, !1);
                for (let [r, l] of Object.entries(C)) checkField(r, l, !0);
                return r
            }
        },
        36838: function(r, l, C) {
            "use strict";
            C.d(l, {
                UN: function() {
                    return eC
                }
            });
            var U = C(77074),
                et = C(41966),
                eo = C(56836),
                es = C(14909),
                el = C(4918); /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
            let ec = BigInt(0),
                ed = BigInt(1),
                eh = BigInt(2),
                ef = BigInt(8),
                ep = {
                    zip215: !0
                },
                eg = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),
                ey = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),
                em = BigInt(0),
                e_ = BigInt(1),
                eb = BigInt(2),
                ew = BigInt(5),
                eE = BigInt(10),
                eI = BigInt(20),
                eS = BigInt(40),
                ex = BigInt(80);

            function uvRatio(r, l) {
                let C = (0, eo.wQ)(l * l * l, eg),
                    U = (0, eo.wQ)(C * C * l, eg),
                    et = function(r) {
                        let l = r * r % eg,
                            C = l * r % eg,
                            U = (0, eo.oA)(C, eb, eg) * C % eg,
                            et = (0, eo.oA)(U, e_, eg) * r % eg,
                            es = (0, eo.oA)(et, ew, eg) * et % eg,
                            el = (0, eo.oA)(es, eE, eg) * es % eg,
                            ec = (0, eo.oA)(el, eI, eg) * el % eg,
                            ed = (0, eo.oA)(ec, eS, eg) * ec % eg,
                            eh = (0, eo.oA)(ed, ex, eg) * ed % eg,
                            ef = (0, eo.oA)(eh, ex, eg) * ed % eg,
                            ep = (0, eo.oA)(ef, eE, eg) * es % eg,
                            ey = (0, eo.oA)(ep, eb, eg) * r % eg;
                        return {
                            pow_p_5_8: ey,
                            b2: C
                        }
                    }(r * U).pow_p_5_8,
                    es = (0, eo.wQ)(r * C * et, eg),
                    el = (0, eo.wQ)(l * es * es, eg),
                    ec = es,
                    ed = (0, eo.wQ)(es * ey, eg),
                    eh = el === r,
                    ef = el === (0, eo.wQ)(-r, eg),
                    ep = el === (0, eo.wQ)(-r * ey, eg);
                return eh && (es = ec), (ef || ep) && (es = ed), (0, eo.Tu)(es, eg) && (es = (0, eo.wQ)(-es, eg)), {
                    isValid: eh || ef,
                    value: es
                }
            }
            let eA = (0, eo.gN)(eg, void 0, !0),
                eP = {
                    a: BigInt(-1),
                    d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
                    Fp: eA,
                    n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
                    h: BigInt(8),
                    Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
                    Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
                    hash: U.o,
                    randomBytes: et.O6,
                    adjustScalarBytes: function(r) {
                        return r[0] &= 248, r[31] &= 127, r[31] |= 64, r
                    },
                    uvRatio
                },
                eC = function(r) {
                    let l = function(r) {
                            let l = (0, el.K)(r);
                            return es.FF(r, {
                                hash: "function",
                                a: "bigint",
                                d: "bigint",
                                randomBytes: "function"
                            }, {
                                adjustScalarBytes: "function",
                                domain: "function",
                                uvRatio: "function",
                                mapToCurve: "function"
                            }), Object.freeze({ ...l
                            })
                        }(r),
                        {
                            Fp: C,
                            n: U,
                            prehash: et,
                            hash: eg,
                            randomBytes: ey,
                            nByteLength: em,
                            h: e_
                        } = l,
                        eb = eh << BigInt(8 * em) - ed,
                        ew = C.create,
                        eE = l.uvRatio || ((r, l) => {
                            try {
                                return {
                                    isValid: !0,
                                    value: C.sqrt(r * C.inv(l))
                                }
                            } catch (r) {
                                return {
                                    isValid: !1,
                                    value: ec
                                }
                            }
                        }),
                        eI = l.adjustScalarBytes || (r => r),
                        eS = l.domain || ((r, l, C) => {
                            if (l.length || C) throw Error("Contexts/pre-hash are not supported");
                            return r
                        }),
                        inBig = r => "bigint" == typeof r && ec < r,
                        inRange = (r, l) => inBig(r) && inBig(l) && r < l,
                        in0MaskRange = r => r === ec || inRange(r, eb);

                    function assertInRange(r, l) {
                        if (inRange(r, l)) return r;
                        throw Error(`Expected valid scalar < ${l}, got ${typeof r} ${r}`)
                    }

                    function assertGE0(r) {
                        return r === ec ? r : assertInRange(r, U)
                    }
                    let ex = new Map;

                    function isPoint(r) {
                        if (!(r instanceof Point)) throw Error("ExtendedPoint expected")
                    }
                    let Point = class Point {
                        constructor(r, l, C, U) {
                            if (this.ex = r, this.ey = l, this.ez = C, this.et = U, !in0MaskRange(r)) throw Error("x required");
                            if (!in0MaskRange(l)) throw Error("y required");
                            if (!in0MaskRange(C)) throw Error("z required");
                            if (!in0MaskRange(U)) throw Error("t required")
                        }
                        get x() {
                            return this.toAffine().x
                        }
                        get y() {
                            return this.toAffine().y
                        }
                        static fromAffine(r) {
                            if (r instanceof Point) throw Error("extended point not allowed");
                            let {
                                x: l,
                                y: C
                            } = r || {};
                            if (!in0MaskRange(l) || !in0MaskRange(C)) throw Error("invalid affine point");
                            return new Point(l, C, ed, ew(l * C))
                        }
                        static normalizeZ(r) {
                            let l = C.invertBatch(r.map(r => r.ez));
                            return r.map((r, C) => r.toAffine(l[C])).map(Point.fromAffine)
                        }
                        _setWindowSize(r) {
                            this._WINDOW_SIZE = r, ex.delete(this)
                        }
                        assertValidity() {
                            let {
                                a: r,
                                d: C
                            } = l;
                            if (this.is0()) throw Error("bad point: ZERO");
                            let {
                                ex: U,
                                ey: et,
                                ez: eo,
                                et: es
                            } = this, el = ew(U * U), ec = ew(et * et), ed = ew(eo * eo), eh = ew(ed * ed), ef = ew(el * r), ep = ew(ed * ew(ef + ec)), eg = ew(eh + ew(C * ew(el * ec)));
                            if (ep !== eg) throw Error("bad point: equation left != right (1)");
                            let ey = ew(U * et),
                                em = ew(eo * es);
                            if (ey !== em) throw Error("bad point: equation left != right (2)")
                        }
                        equals(r) {
                            isPoint(r);
                            let {
                                ex: l,
                                ey: C,
                                ez: U
                            } = this, {
                                ex: et,
                                ey: eo,
                                ez: es
                            } = r, el = ew(l * es), ec = ew(et * U), ed = ew(C * es), eh = ew(eo * U);
                            return el === ec && ed === eh
                        }
                        is0() {
                            return this.equals(Point.ZERO)
                        }
                        negate() {
                            return new Point(ew(-this.ex), this.ey, this.ez, ew(-this.et))
                        }
                        double() {
                            let {
                                a: r
                            } = l, {
                                ex: C,
                                ey: U,
                                ez: et
                            } = this, eo = ew(C * C), es = ew(U * U), el = ew(eh * ew(et * et)), ec = ew(r * eo), ed = C + U, ef = ew(ew(ed * ed) - eo - es), ep = ec + es, eg = ep - el, ey = ec - es, em = ew(ef * eg), e_ = ew(ep * ey), eb = ew(ef * ey), eE = ew(eg * ep);
                            return new Point(em, e_, eE, eb)
                        }
                        add(r) {
                            isPoint(r);
                            let {
                                a: C,
                                d: U
                            } = l, {
                                ex: et,
                                ey: eo,
                                ez: es,
                                et: el
                            } = this, {
                                ex: ed,
                                ey: ef,
                                ez: ep,
                                et: eg
                            } = r;
                            if (C === BigInt(-1)) {
                                let r = ew((eo - et) * (ef + ed)),
                                    l = ew((eo + et) * (ef - ed)),
                                    C = ew(l - r);
                                if (C === ec) return this.double();
                                let U = ew(es * eh * eg),
                                    ey = ew(el * eh * ep),
                                    em = ey + U,
                                    e_ = l + r,
                                    eb = ey - U,
                                    eE = ew(em * C),
                                    eI = ew(e_ * eb),
                                    eS = ew(em * eb),
                                    ex = ew(C * e_);
                                return new Point(eE, eI, ex, eS)
                            }
                            let ey = ew(et * ed),
                                em = ew(eo * ef),
                                e_ = ew(el * U * eg),
                                eb = ew(es * ep),
                                eE = ew((et + eo) * (ed + ef) - ey - em),
                                eI = eb - e_,
                                eS = eb + e_,
                                ex = ew(em - C * ey),
                                eA = ew(eE * eI),
                                eP = ew(eS * ex),
                                eC = ew(eE * ex),
                                ek = ew(eI * eS);
                            return new Point(eA, eP, ek, eC)
                        }
                        subtract(r) {
                            return this.add(r.negate())
                        }
                        wNAF(r) {
                            return eC.wNAFCached(this, ex, r, Point.normalizeZ)
                        }
                        multiply(r) {
                            let {
                                p: l,
                                f: C
                            } = this.wNAF(assertInRange(r, U));
                            return Point.normalizeZ([l, C])[0]
                        }
                        multiplyUnsafe(r) {
                            let l = assertGE0(r);
                            return l === ec ? eP : this.equals(eP) || l === ed ? this : this.equals(eA) ? this.wNAF(l).p : eC.unsafeLadder(this, l)
                        }
                        isSmallOrder() {
                            return this.multiplyUnsafe(e_).is0()
                        }
                        isTorsionFree() {
                            return eC.unsafeLadder(this, U).is0()
                        }
                        toAffine(r) {
                            let {
                                ex: l,
                                ey: U,
                                ez: et
                            } = this, eo = this.is0();
                            null == r && (r = eo ? ef : C.inv(et));
                            let es = ew(l * r),
                                el = ew(U * r),
                                eh = ew(et * r);
                            if (eo) return {
                                x: ec,
                                y: ed
                            };
                            if (eh !== ed) throw Error("invZ was invalid");
                            return {
                                x: es,
                                y: el
                            }
                        }
                        clearCofactor() {
                            let {
                                h: r
                            } = l;
                            return r === ed ? this : this.multiplyUnsafe(r)
                        }
                        static fromHex(r, U = !1) {
                            let {
                                d: et,
                                a: eo
                            } = l, el = C.BYTES;
                            r = (0, es.ql)("pointHex", r, el);
                            let eh = r.slice(),
                                ef = r[el - 1];
                            eh[el - 1] = -129 & ef;
                            let ep = es.ty(eh);
                            ep === ec || (U ? assertInRange(ep, eb) : assertInRange(ep, C.ORDER));
                            let eg = ew(ep * ep),
                                ey = ew(eg - ed),
                                em = ew(et * eg - eo),
                                {
                                    isValid: e_,
                                    value: eI
                                } = eE(ey, em);
                            if (!e_) throw Error("Point.fromHex: invalid y coordinate");
                            let eS = (eI & ed) === ed,
                                ex = (128 & ef) != 0;
                            if (!U && eI === ec && ex) throw Error("Point.fromHex: x=0 and x_0=1");
                            return ex !== eS && (eI = ew(-eI)), Point.fromAffine({
                                x: eI,
                                y: ep
                            })
                        }
                        static fromPrivateKey(r) {
                            return getExtendedPublicKey(r).point
                        }
                        toRawBytes() {
                            let {
                                x: r,
                                y: l
                            } = this.toAffine(), U = es.S5(l, C.BYTES);
                            return U[U.length - 1] |= r & ed ? 128 : 0, U
                        }
                        toHex() {
                            return es.ci(this.toRawBytes())
                        }
                    };
                    Point.BASE = new Point(l.Gx, l.Gy, ed, ew(l.Gx * l.Gy)), Point.ZERO = new Point(ec, ed, ed, ec);
                    let {
                        BASE: eA,
                        ZERO: eP
                    } = Point, eC = (0, el.M)(Point, 8 * em);

                    function modN_LE(r) {
                        var l;
                        return l = es.ty(r), (0, eo.wQ)(l, U)
                    }

                    function getExtendedPublicKey(r) {
                        r = (0, es.ql)("private key", r, em);
                        let l = (0, es.ql)("hashed private key", eg(r), 2 * em),
                            C = eI(l.slice(0, em)),
                            U = l.slice(em, 2 * em),
                            et = modN_LE(C),
                            eo = eA.multiply(et),
                            el = eo.toRawBytes();
                        return {
                            head: C,
                            prefix: U,
                            scalar: et,
                            point: eo,
                            pointBytes: el
                        }
                    }

                    function hashDomainToScalar(r = new Uint8Array, ...l) {
                        let C = es.eV(...l);
                        return modN_LE(eg(eS(C, (0, es.ql)("context", r), !!et)))
                    }
                    return eA._setWindowSize(8), {
                        CURVE: l,
                        getPublicKey: function(r) {
                            return getExtendedPublicKey(r).pointBytes
                        },
                        sign: function(r, l, el = {}) {
                            var ec;
                            r = (0, es.ql)("message", r), et && (r = et(r));
                            let {
                                prefix: ed,
                                scalar: eh,
                                pointBytes: ef
                            } = getExtendedPublicKey(l), ep = hashDomainToScalar(el.context, ed, r), eg = eA.multiply(ep).toRawBytes(), ey = hashDomainToScalar(el.context, eg, ef, r), e_ = (ec = ep + ey * eh, (0, eo.wQ)(ec, U));
                            assertGE0(e_);
                            let eb = es.eV(eg, es.S5(e_, C.BYTES));
                            return (0, es.ql)("result", eb, 2 * em)
                        },
                        verify: function(r, l, U, eo = ep) {
                            let el, ec, ed;
                            let {
                                context: eh,
                                zip215: ef
                            } = eo, eg = C.BYTES;
                            r = (0, es.ql)("signature", r, 2 * eg), l = (0, es.ql)("message", l), et && (l = et(l));
                            let ey = es.ty(r.slice(eg, 2 * eg));
                            try {
                                el = Point.fromHex(U, ef), ec = Point.fromHex(r.slice(0, eg), ef), ed = eA.multiplyUnsafe(ey)
                            } catch (r) {
                                return !1
                            }
                            if (!ef && el.isSmallOrder()) return !1;
                            let em = hashDomainToScalar(eh, ec.toRawBytes(), el.toRawBytes(), l),
                                e_ = ec.add(el.multiplyUnsafe(em));
                            return e_.subtract(ed).clearCofactor().equals(Point.ZERO)
                        },
                        ExtendedPoint: Point,
                        utils: {
                            getExtendedPublicKey,
                            randomPrivateKey: () => ey(C.BYTES),
                            precompute: (r = 8, l = Point.BASE) => (l._setWindowSize(r), l.multiply(BigInt(3)), l)
                        }
                    }
                }(eP);
            ({ ...eP,
                prehash: U.o
            });
            let ek = (eA.ORDER + BigInt(3)) / BigInt(8);

            function assertRstPoint(r) {
                if (!(r instanceof RistPoint)) throw Error("RistrettoPoint expected")
            }
            eA.pow(eb, ek), eA.sqrt(eA.neg(eA.ONE)), eA.ORDER, BigInt(5), BigInt(8), BigInt(486662), (0, eo.DV)(eA, eA.neg(BigInt(486664)));
            let eN = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"),
                eO = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"),
                eT = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"),
                eR = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952"),
                invertSqrt = r => uvRatio(e_, r),
                eD = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),
                bytes255ToNumberLE = r => eC.CURVE.Fp.create(bytesToNumberLE(r) & eD);

            function calcElligatorRistrettoMap(r) {
                let {
                    d: l
                } = eC.CURVE, C = eC.CURVE.Fp.ORDER, U = eC.CURVE.Fp.create, et = U(null * r * r), eo = U((et + e_) * eT), es = BigInt(-1), el = U((es - l * et) * U(et + l)), {
                    isValid: ec,
                    value: ed
                } = uvRatio(eo, el), eh = U(ed * r);
                isNegativeLE(eh, C) || (eh = U(-eh)), ec || (ed = eh), ec || (es = et);
                let ef = U(es * (et - e_) * eR - el),
                    ep = ed * ed,
                    eg = U((ed + ed) * el),
                    ey = U(ef * eN),
                    em = U(e_ - ep),
                    eb = U(e_ + ep);
                return new eC.ExtendedPoint(U(eg * eb), U(em * ey), U(ey * eb), U(eg * em))
            }
            let RistPoint = class RistPoint {
                constructor(r) {
                    this.ep = r
                }
                static fromAffine(r) {
                    return new RistPoint(eC.ExtendedPoint.fromAffine(r))
                }
                static hashToCurve(r) {
                    r = ensureBytes("ristrettoHash", r, 64);
                    let l = bytes255ToNumberLE(r.slice(0, 32)),
                        C = calcElligatorRistrettoMap(l),
                        U = bytes255ToNumberLE(r.slice(32, 64)),
                        et = calcElligatorRistrettoMap(U);
                    return new RistPoint(C.add(et))
                }
                static fromHex(r) {
                    r = ensureBytes("ristrettoHex", r, 32);
                    let {
                        a: l,
                        d: C
                    } = eC.CURVE, U = eC.CURVE.Fp.ORDER, et = eC.CURVE.Fp.create, eo = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint", es = bytes255ToNumberLE(r);
                    if (!equalBytes(numberToBytesLE(es, 32), r) || isNegativeLE(es, U)) throw Error(eo);
                    let el = et(es * es),
                        ec = et(e_ + l * el),
                        ed = et(e_ - l * el),
                        eh = et(ec * ec),
                        ef = et(ed * ed),
                        ep = et(l * C * eh - ef),
                        {
                            isValid: eg,
                            value: ey
                        } = invertSqrt(et(ep * ef)),
                        eb = et(ey * ed),
                        ew = et(ey * eb * ep),
                        eE = et((es + es) * eb);
                    isNegativeLE(eE, U) && (eE = et(-eE));
                    let eI = et(ec * ew),
                        eS = et(eE * eI);
                    if (!eg || isNegativeLE(eS, U) || eI === em) throw Error(eo);
                    return new RistPoint(new eC.ExtendedPoint(eE, eI, e_, eS))
                }
                toRawBytes() {
                    let r, {
                            ex: l,
                            ey: C,
                            ez: U,
                            et: et
                        } = this.ep,
                        eo = eC.CURVE.Fp.ORDER,
                        es = eC.CURVE.Fp.create,
                        el = es(es(U + C) * es(U - C)),
                        ec = es(l * C),
                        ed = es(ec * ec),
                        {
                            value: eh
                        } = invertSqrt(es(el * ed)),
                        ef = es(eh * el),
                        ep = es(eh * ec),
                        eg = es(ef * ep * et);
                    if (isNegativeLE(et * eg, eo)) {
                        let U = es(null * C),
                            et = es(null * l);
                        l = U, C = et, r = es(ef * eO)
                    } else r = ep;
                    isNegativeLE(l * eg, eo) && (C = es(-C));
                    let ey = es((U - C) * r);
                    return isNegativeLE(ey, eo) && (ey = es(-ey)), numberToBytesLE(ey, 32)
                }
                toHex() {
                    return bytesToHex(this.toRawBytes())
                }
                toString() {
                    return this.toHex()
                }
                equals(r) {
                    assertRstPoint(r);
                    let {
                        ex: l,
                        ey: C
                    } = this.ep, {
                        ex: U,
                        ey: et
                    } = r.ep, eo = eC.CURVE.Fp.create, es = eo(l * et) === eo(C * U), el = eo(C * et) === eo(l * U);
                    return es || el
                }
                add(r) {
                    return assertRstPoint(r), new RistPoint(this.ep.add(r.ep))
                }
                subtract(r) {
                    return assertRstPoint(r), new RistPoint(this.ep.subtract(r.ep))
                }
                multiply(r) {
                    return new RistPoint(this.ep.multiply(r))
                }
                multiplyUnsafe(r) {
                    return new RistPoint(this.ep.multiplyUnsafe(r))
                }
                double() {
                    return new RistPoint(this.ep.double())
                }
                negate() {
                    return new RistPoint(this.ep.negate())
                }
            }
        },
        15651: function(r, l, C) {
            "use strict";
            C.d(l, {
                kA: function() {
                    return eI
                }
            });
            var U = C(70697),
                et = C(56836),
                eo = C(79782),
                es = C(41966),
                el = C(14909),
                ec = C(4918);
            let {
                bytesToNumberBE: ed,
                hexToBytes: eh
            } = el, ef = {
                Err: class extends Error {
                    constructor(r = "") {
                        super(r)
                    }
                },
                _parseInt(r) {
                    let {
                        Err: l
                    } = ef;
                    if (r.length < 2 || 2 !== r[0]) throw new l("Invalid signature integer tag");
                    let C = r[1],
                        U = r.subarray(2, C + 2);
                    if (!C || U.length !== C) throw new l("Invalid signature integer: wrong length");
                    if (128 & U[0]) throw new l("Invalid signature integer: negative");
                    if (0 === U[0] && !(128 & U[1])) throw new l("Invalid signature integer: unnecessary leading zero");
                    return {
                        d: ed(U),
                        l: r.subarray(C + 2)
                    }
                },
                toSig(r) {
                    let {
                        Err: l
                    } = ef, C = "string" == typeof r ? eh(r) : r;
                    if (!el._t(C)) throw Error("ui8a expected");
                    let U = C.length;
                    if (U < 2 || 48 != C[0]) throw new l("Invalid signature tag");
                    if (C[1] !== U - 2) throw new l("Invalid signature: incorrect length");
                    let {
                        d: et,
                        l: eo
                    } = ef._parseInt(C.subarray(2)), {
                        d: es,
                        l: ec
                    } = ef._parseInt(eo);
                    if (ec.length) throw new l("Invalid signature: left bytes after parsing");
                    return {
                        r: et,
                        s: es
                    }
                },
                hexFromSig(r) {
                    let slice = r => 8 & Number.parseInt(r[0], 16) ? "00" + r : r,
                        h = r => {
                            let l = r.toString(16);
                            return 1 & l.length ? `0${l}` : l
                        },
                        l = slice(h(r.s)),
                        C = slice(h(r.r)),
                        U = l.length / 2,
                        et = C.length / 2,
                        eo = h(U),
                        es = h(et);
                    return `30${h(et+U+4)}02${es}${C}02${eo}${l}`
                }
            }, ep = BigInt(0), eg = BigInt(1), ey = (BigInt(2), BigInt(3));
            BigInt(4); /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
            let em = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
                e_ = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
                eb = BigInt(1),
                ew = BigInt(2),
                divNearest = (r, l) => (r + l / ew) / l,
                eE = (0, et.gN)(em, void 0, void 0, {
                    sqrt: function(r) {
                        let l = BigInt(3),
                            C = BigInt(6),
                            U = BigInt(11),
                            eo = BigInt(22),
                            es = BigInt(23),
                            el = BigInt(44),
                            ec = BigInt(88),
                            ed = r * r * r % em,
                            eh = ed * ed * r % em,
                            ef = (0, et.oA)(eh, l, em) * eh % em,
                            ep = (0, et.oA)(ef, l, em) * eh % em,
                            eg = (0, et.oA)(ep, ew, em) * ed % em,
                            ey = (0, et.oA)(eg, U, em) * eg % em,
                            e_ = (0, et.oA)(ey, eo, em) * ey % em,
                            eb = (0, et.oA)(e_, el, em) * e_ % em,
                            eI = (0, et.oA)(eb, ec, em) * eb % em,
                            eS = (0, et.oA)(eI, el, em) * e_ % em,
                            ex = (0, et.oA)(eS, l, em) * eh % em,
                            eA = (0, et.oA)(ex, es, em) * ey % em,
                            eP = (0, et.oA)(eA, C, em) * ed % em,
                            eC = (0, et.oA)(eP, ew, em);
                        if (!eE.eql(eE.sqr(eC), r)) throw Error("Cannot find square root");
                        return eC
                    }
                }),
                eI = function(r, l) {
                    let create = l => (function(r) {
                        let l = function(r) {
                                let l = (0, ec.K)(r);
                                return el.FF(l, {
                                    hash: "hash",
                                    hmac: "function",
                                    randomBytes: "function"
                                }, {
                                    bits2int: "function",
                                    bits2int_modN: "function",
                                    lowS: "boolean"
                                }), Object.freeze({
                                    lowS: !0,
                                    ...l
                                })
                            }(r),
                            {
                                Fp: C,
                                n: U
                            } = l,
                            eo = C.BYTES + 1,
                            es = 2 * C.BYTES + 1;

                        function modN(r) {
                            return et.wQ(r, U)
                        }

                        function invN(r) {
                            return et.U_(r, U)
                        }
                        let {
                            ProjectivePoint: ed,
                            normPrivateKeyToScalar: eh,
                            weierstrassEquation: em,
                            isWithinCurveOrder: e_
                        } = function(r) {
                            let l = /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function(r) {
                                    let l = (0, ec.K)(r);
                                    el.FF(l, {
                                        a: "field",
                                        b: "field"
                                    }, {
                                        allowedPrivateKeyLengths: "array",
                                        wrapPrivateKey: "boolean",
                                        isTorsionFree: "function",
                                        clearCofactor: "function",
                                        allowInfinityPoint: "boolean",
                                        fromBytes: "function",
                                        toBytes: "function"
                                    });
                                    let {
                                        endo: C,
                                        Fp: U,
                                        a: et
                                    } = l;
                                    if (C) {
                                        if (!U.eql(et, U.ZERO)) throw Error("Endomorphism can only be defined for Koblitz curves that have a=0");
                                        if ("object" != typeof C || "bigint" != typeof C.beta || "function" != typeof C.splitScalar) throw Error("Expected endomorphism with beta: bigint and splitScalar: function")
                                    }
                                    return Object.freeze({ ...l
                                    })
                                }(r),
                                {
                                    Fp: C
                                } = l,
                                U = l.toBytes || ((r, l, U) => {
                                    let et = l.toAffine();
                                    return el.eV(Uint8Array.from([4]), C.toBytes(et.x), C.toBytes(et.y))
                                }),
                                eo = l.fromBytes || (r => {
                                    let l = r.subarray(1),
                                        U = C.fromBytes(l.subarray(0, C.BYTES)),
                                        et = C.fromBytes(l.subarray(C.BYTES, 2 * C.BYTES));
                                    return {
                                        x: U,
                                        y: et
                                    }
                                });

                            function weierstrassEquation(r) {
                                let {
                                    a: U,
                                    b: et
                                } = l, eo = C.sqr(r), es = C.mul(eo, r);
                                return C.add(C.add(es, C.mul(r, U)), et)
                            }
                            if (!C.eql(C.sqr(l.Gy), weierstrassEquation(l.Gx))) throw Error("bad generator point: equation left != right");

                            function isWithinCurveOrder(r) {
                                return "bigint" == typeof r && ep < r && r < l.n
                            }

                            function assertGE(r) {
                                if (!isWithinCurveOrder(r)) throw Error("Expected valid bigint: 0 < bigint < curve.n")
                            }

                            function normPrivateKeyToScalar(r) {
                                let C;
                                let {
                                    allowedPrivateKeyLengths: U,
                                    nByteLength: eo,
                                    wrapPrivateKey: es,
                                    n: ec
                                } = l;
                                if (U && "bigint" != typeof r) {
                                    if (el._t(r) && (r = el.ci(r)), "string" != typeof r || !U.includes(r.length)) throw Error("Invalid key");
                                    r = r.padStart(2 * eo, "0")
                                }
                                try {
                                    C = "bigint" == typeof r ? r : el.bytesToNumberBE((0, el.ql)("private key", r, eo))
                                } catch (l) {
                                    throw Error(`private key must be ${eo} bytes, hex or bigint, not ${typeof r}`)
                                }
                                return es && (C = et.wQ(C, ec)), assertGE(C), C
                            }
                            let es = new Map;

                            function assertPrjPoint(r) {
                                if (!(r instanceof Point)) throw Error("ProjectivePoint expected")
                            }
                            let Point = class Point {
                                constructor(r, l, U) {
                                    if (this.px = r, this.py = l, this.pz = U, null == r || !C.isValid(r)) throw Error("x required");
                                    if (null == l || !C.isValid(l)) throw Error("y required");
                                    if (null == U || !C.isValid(U)) throw Error("z required")
                                }
                                static fromAffine(r) {
                                    let {
                                        x: l,
                                        y: U
                                    } = r || {};
                                    if (!r || !C.isValid(l) || !C.isValid(U)) throw Error("invalid affine point");
                                    if (r instanceof Point) throw Error("projective point not allowed");
                                    let is0 = r => C.eql(r, C.ZERO);
                                    return is0(l) && is0(U) ? Point.ZERO : new Point(l, U, C.ONE)
                                }
                                get x() {
                                    return this.toAffine().x
                                }
                                get y() {
                                    return this.toAffine().y
                                }
                                static normalizeZ(r) {
                                    let l = C.invertBatch(r.map(r => r.pz));
                                    return r.map((r, C) => r.toAffine(l[C])).map(Point.fromAffine)
                                }
                                static fromHex(r) {
                                    let l = Point.fromAffine(eo((0, el.ql)("pointHex", r)));
                                    return l.assertValidity(), l
                                }
                                static fromPrivateKey(r) {
                                    return Point.BASE.multiply(normPrivateKeyToScalar(r))
                                }
                                _setWindowSize(r) {
                                    this._WINDOW_SIZE = r, es.delete(this)
                                }
                                assertValidity() {
                                    if (this.is0()) {
                                        if (l.allowInfinityPoint && !C.is0(this.py)) return;
                                        throw Error("bad point: ZERO")
                                    }
                                    let {
                                        x: r,
                                        y: U
                                    } = this.toAffine();
                                    if (!C.isValid(r) || !C.isValid(U)) throw Error("bad point: x or y not FE");
                                    let et = C.sqr(U),
                                        eo = weierstrassEquation(r);
                                    if (!C.eql(et, eo)) throw Error("bad point: equation left != right");
                                    if (!this.isTorsionFree()) throw Error("bad point: not in prime-order subgroup")
                                }
                                hasEvenY() {
                                    let {
                                        y: r
                                    } = this.toAffine();
                                    if (C.isOdd) return !C.isOdd(r);
                                    throw Error("Field doesn't support isOdd")
                                }
                                equals(r) {
                                    assertPrjPoint(r);
                                    let {
                                        px: l,
                                        py: U,
                                        pz: et
                                    } = this, {
                                        px: eo,
                                        py: es,
                                        pz: el
                                    } = r, ec = C.eql(C.mul(l, el), C.mul(eo, et)), ed = C.eql(C.mul(U, el), C.mul(es, et));
                                    return ec && ed
                                }
                                negate() {
                                    return new Point(this.px, C.neg(this.py), this.pz)
                                }
                                double() {
                                    let {
                                        a: r,
                                        b: U
                                    } = l, et = C.mul(U, ey), {
                                        px: eo,
                                        py: es,
                                        pz: el
                                    } = this, ec = C.ZERO, ed = C.ZERO, eh = C.ZERO, ef = C.mul(eo, eo), ep = C.mul(es, es), eg = C.mul(el, el), em = C.mul(eo, es);
                                    return em = C.add(em, em), eh = C.mul(eo, el), eh = C.add(eh, eh), ec = C.mul(r, eh), ed = C.mul(et, eg), ed = C.add(ec, ed), ec = C.sub(ep, ed), ed = C.add(ep, ed), ed = C.mul(ec, ed), ec = C.mul(em, ec), eh = C.mul(et, eh), eg = C.mul(r, eg), em = C.sub(ef, eg), em = C.mul(r, em), em = C.add(em, eh), eh = C.add(ef, ef), ef = C.add(eh, ef), ef = C.add(ef, eg), ef = C.mul(ef, em), ed = C.add(ed, ef), eg = C.mul(es, el), eg = C.add(eg, eg), ef = C.mul(eg, em), ec = C.sub(ec, ef), eh = C.mul(eg, ep), eh = C.add(eh, eh), eh = C.add(eh, eh), new Point(ec, ed, eh)
                                }
                                add(r) {
                                    assertPrjPoint(r);
                                    let {
                                        px: U,
                                        py: et,
                                        pz: eo
                                    } = this, {
                                        px: es,
                                        py: el,
                                        pz: ec
                                    } = r, ed = C.ZERO, eh = C.ZERO, ef = C.ZERO, ep = l.a, eg = C.mul(l.b, ey), em = C.mul(U, es), e_ = C.mul(et, el), eb = C.mul(eo, ec), ew = C.add(U, et), eE = C.add(es, el);
                                    ew = C.mul(ew, eE), eE = C.add(em, e_), ew = C.sub(ew, eE), eE = C.add(U, eo);
                                    let eI = C.add(es, ec);
                                    return eE = C.mul(eE, eI), eI = C.add(em, eb), eE = C.sub(eE, eI), eI = C.add(et, eo), ed = C.add(el, ec), eI = C.mul(eI, ed), ed = C.add(e_, eb), eI = C.sub(eI, ed), ef = C.mul(ep, eE), ed = C.mul(eg, eb), ef = C.add(ed, ef), ed = C.sub(e_, ef), ef = C.add(e_, ef), eh = C.mul(ed, ef), e_ = C.add(em, em), e_ = C.add(e_, em), eb = C.mul(ep, eb), eE = C.mul(eg, eE), e_ = C.add(e_, eb), eb = C.sub(em, eb), eb = C.mul(ep, eb), eE = C.add(eE, eb), em = C.mul(e_, eE), eh = C.add(eh, em), em = C.mul(eI, eE), ed = C.mul(ew, ed), ed = C.sub(ed, em), em = C.mul(ew, e_), ef = C.mul(eI, ef), ef = C.add(ef, em), new Point(ed, eh, ef)
                                }
                                subtract(r) {
                                    return this.add(r.negate())
                                }
                                is0() {
                                    return this.equals(Point.ZERO)
                                }
                                wNAF(r) {
                                    return eh.wNAFCached(this, es, r, r => {
                                        let l = C.invertBatch(r.map(r => r.pz));
                                        return r.map((r, C) => r.toAffine(l[C])).map(Point.fromAffine)
                                    })
                                }
                                multiplyUnsafe(r) {
                                    let U = Point.ZERO;
                                    if (r === ep) return U;
                                    if (assertGE(r), r === eg) return this;
                                    let {
                                        endo: et
                                    } = l;
                                    if (!et) return eh.unsafeLadder(this, r);
                                    let {
                                        k1neg: eo,
                                        k1: es,
                                        k2neg: el,
                                        k2: ec
                                    } = et.splitScalar(r), ed = U, ef = U, ey = this;
                                    for (; es > ep || ec > ep;) es & eg && (ed = ed.add(ey)), ec & eg && (ef = ef.add(ey)), ey = ey.double(), es >>= eg, ec >>= eg;
                                    return eo && (ed = ed.negate()), el && (ef = ef.negate()), ef = new Point(C.mul(ef.px, et.beta), ef.py, ef.pz), ed.add(ef)
                                }
                                multiply(r) {
                                    let U, et;
                                    assertGE(r);
                                    let {
                                        endo: eo
                                    } = l;
                                    if (eo) {
                                        let {
                                            k1neg: l,
                                            k1: es,
                                            k2neg: el,
                                            k2: ec
                                        } = eo.splitScalar(r), {
                                            p: ed,
                                            f: ef
                                        } = this.wNAF(es), {
                                            p: ep,
                                            f: eg
                                        } = this.wNAF(ec);
                                        ed = eh.constTimeNegate(l, ed), ep = eh.constTimeNegate(el, ep), ep = new Point(C.mul(ep.px, eo.beta), ep.py, ep.pz), U = ed.add(ep), et = ef.add(eg)
                                    } else {
                                        let {
                                            p: l,
                                            f: C
                                        } = this.wNAF(r);
                                        U = l, et = C
                                    }
                                    return Point.normalizeZ([U, et])[0]
                                }
                                multiplyAndAddUnsafe(r, l, C) {
                                    let U = Point.BASE,
                                        mul = (r, l) => l !== ep && l !== eg && r.equals(U) ? r.multiply(l) : r.multiplyUnsafe(l),
                                        et = mul(this, l).add(mul(r, C));
                                    return et.is0() ? void 0 : et
                                }
                                toAffine(r) {
                                    let {
                                        px: l,
                                        py: U,
                                        pz: et
                                    } = this, eo = this.is0();
                                    null == r && (r = eo ? C.ONE : C.inv(et));
                                    let es = C.mul(l, r),
                                        el = C.mul(U, r),
                                        ec = C.mul(et, r);
                                    if (eo) return {
                                        x: C.ZERO,
                                        y: C.ZERO
                                    };
                                    if (!C.eql(ec, C.ONE)) throw Error("invZ was invalid");
                                    return {
                                        x: es,
                                        y: el
                                    }
                                }
                                isTorsionFree() {
                                    let {
                                        h: r,
                                        isTorsionFree: C
                                    } = l;
                                    if (r === eg) return !0;
                                    if (C) return C(Point, this);
                                    throw Error("isTorsionFree() has not been declared for the elliptic curve")
                                }
                                clearCofactor() {
                                    let {
                                        h: r,
                                        clearCofactor: C
                                    } = l;
                                    return r === eg ? this : C ? C(Point, this) : this.multiplyUnsafe(l.h)
                                }
                                toRawBytes(r = !0) {
                                    return this.assertValidity(), U(Point, this, r)
                                }
                                toHex(r = !0) {
                                    return el.ci(this.toRawBytes(r))
                                }
                            };
                            Point.BASE = new Point(l.Gx, l.Gy, C.ONE), Point.ZERO = new Point(C.ZERO, C.ONE, C.ZERO);
                            let ed = l.nBitLength,
                                eh = (0, ec.M)(Point, l.endo ? Math.ceil(ed / 2) : ed);
                            return {
                                CURVE: l,
                                ProjectivePoint: Point,
                                normPrivateKeyToScalar,
                                weierstrassEquation,
                                isWithinCurveOrder
                            }
                        }({ ...l,
                            toBytes(r, l, U) {
                                let et = l.toAffine(),
                                    eo = C.toBytes(et.x),
                                    es = el.eV;
                                return U ? es(Uint8Array.from([l.hasEvenY() ? 2 : 3]), eo) : es(Uint8Array.from([4]), eo, C.toBytes(et.y))
                            },
                            fromBytes(r) {
                                let l = r.length,
                                    U = r[0],
                                    et = r.subarray(1);
                                if (l === eo && (2 === U || 3 === U)) {
                                    let r = el.bytesToNumberBE(et);
                                    if (!(ep < r && r < C.ORDER)) throw Error("Point is not on curve");
                                    let l = em(r),
                                        eo = C.sqrt(l),
                                        es = (eo & eg) === eg;
                                    return (1 & U) == 1 !== es && (eo = C.neg(eo)), {
                                        x: r,
                                        y: eo
                                    }
                                }
                                if (l === es && 4 === U) {
                                    let r = C.fromBytes(et.subarray(0, C.BYTES)),
                                        l = C.fromBytes(et.subarray(C.BYTES, 2 * C.BYTES));
                                    return {
                                        x: r,
                                        y: l
                                    }
                                }
                                throw Error(`Point of length ${l} was invalid. Expected ${eo} compressed bytes or ${es} uncompressed bytes`)
                            }
                        }), numToNByteStr = r => el.ci(el.tL(r, l.nByteLength));

                        function isBiggerThanHalfOrder(r) {
                            let l = U >> eg;
                            return r > l
                        }
                        let slcNum = (r, l, C) => el.bytesToNumberBE(r.slice(l, C));
                        let Signature = class Signature {
                            constructor(r, l, C) {
                                this.r = r, this.s = l, this.recovery = C, this.assertValidity()
                            }
                            static fromCompact(r) {
                                let C = l.nByteLength;
                                return r = (0, el.ql)("compactSignature", r, 2 * C), new Signature(slcNum(r, 0, C), slcNum(r, C, 2 * C))
                            }
                            static fromDER(r) {
                                let {
                                    r: l,
                                    s: C
                                } = ef.toSig((0, el.ql)("DER", r));
                                return new Signature(l, C)
                            }
                            assertValidity() {
                                if (!e_(this.r)) throw Error("r must be 0 < r < CURVE.n");
                                if (!e_(this.s)) throw Error("s must be 0 < s < CURVE.n")
                            }
                            addRecoveryBit(r) {
                                return new Signature(this.r, this.s, r)
                            }
                            recoverPublicKey(r) {
                                let {
                                    r: U,
                                    s: et,
                                    recovery: eo
                                } = this, es = ew((0, el.ql)("msgHash", r));
                                if (null == eo || ![0, 1, 2, 3].includes(eo)) throw Error("recovery id invalid");
                                let ec = 2 === eo || 3 === eo ? U + l.n : U;
                                if (ec >= C.ORDER) throw Error("recovery id 2 or 3 invalid");
                                let eh = (1 & eo) == 0 ? "02" : "03",
                                    ef = ed.fromHex(eh + numToNByteStr(ec)),
                                    ep = invN(ec),
                                    eg = modN(-es * ep),
                                    ey = modN(et * ep),
                                    em = ed.BASE.multiplyAndAddUnsafe(ef, eg, ey);
                                if (!em) throw Error("point at infinify");
                                return em.assertValidity(), em
                            }
                            hasHighS() {
                                return isBiggerThanHalfOrder(this.s)
                            }
                            normalizeS() {
                                return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this
                            }
                            toDERRawBytes() {
                                return el.hexToBytes(this.toDERHex())
                            }
                            toDERHex() {
                                return ef.hexFromSig({
                                    r: this.r,
                                    s: this.s
                                })
                            }
                            toCompactRawBytes() {
                                return el.hexToBytes(this.toCompactHex())
                            }
                            toCompactHex() {
                                return numToNByteStr(this.r) + numToNByteStr(this.s)
                            }
                        };

                        function isProbPub(r) {
                            let l = el._t(r),
                                C = "string" == typeof r,
                                U = (l || C) && r.length;
                            return l ? U === eo || U === es : C ? U === 2 * eo || U === 2 * es : r instanceof ed
                        }
                        let eb = l.bits2int || function(r) {
                                let C = el.bytesToNumberBE(r),
                                    U = 8 * r.length - l.nBitLength;
                                return U > 0 ? C >> BigInt(U) : C
                            },
                            ew = l.bits2int_modN || function(r) {
                                return modN(eb(r))
                            },
                            eE = el.dQ(l.nBitLength);

                        function int2octets(r) {
                            if ("bigint" != typeof r) throw Error("bigint expected");
                            if (!(ep <= r && r < eE)) throw Error(`bigint expected < 2^${l.nBitLength}`);
                            return el.tL(r, l.nByteLength)
                        }
                        let eI = {
                                lowS: l.lowS,
                                prehash: !1
                            },
                            eS = {
                                lowS: l.lowS,
                                prehash: !1
                            };
                        return ed.BASE._setWindowSize(8), {
                            CURVE: l,
                            getPublicKey: function(r, l = !0) {
                                return ed.fromPrivateKey(r).toRawBytes(l)
                            },
                            getSharedSecret: function(r, l, C = !0) {
                                if (isProbPub(r)) throw Error("first arg must be private key");
                                if (!isProbPub(l)) throw Error("second arg must be public key");
                                let U = ed.fromHex(l);
                                return U.multiply(eh(r)).toRawBytes(C)
                            },
                            sign: function(r, U, et = eI) {
                                let {
                                    seed: eo,
                                    k2sig: es
                                } = function(r, U, et = eI) {
                                    if (["recovered", "canonical"].some(r => r in et)) throw Error("sign() legacy options not supported");
                                    let {
                                        hash: eo,
                                        randomBytes: es
                                    } = l, {
                                        lowS: ec,
                                        prehash: ef,
                                        extraEntropy: ey
                                    } = et;
                                    null == ec && (ec = !0), r = (0, el.ql)("msgHash", r), ef && (r = (0, el.ql)("prehashed msgHash", eo(r)));
                                    let em = ew(r),
                                        eE = eh(U),
                                        eS = [int2octets(eE), int2octets(em)];
                                    if (null != ey) {
                                        let r = !0 === ey ? es(C.BYTES) : ey;
                                        eS.push((0, el.ql)("extraEntropy", r))
                                    }
                                    let ex = el.eV(...eS);
                                    return {
                                        seed: ex,
                                        k2sig: function(r) {
                                            let l = eb(r);
                                            if (!e_(l)) return;
                                            let C = invN(l),
                                                U = ed.BASE.multiply(l).toAffine(),
                                                et = modN(U.x);
                                            if (et === ep) return;
                                            let eo = modN(C * modN(em + et * eE));
                                            if (eo === ep) return;
                                            let es = (U.x === et ? 0 : 2) | Number(U.y & eg),
                                                el = eo;
                                            return ec && isBiggerThanHalfOrder(eo) && (el = isBiggerThanHalfOrder(eo) ? modN(-eo) : eo, es ^= 1), new Signature(et, el, es)
                                        }
                                    }
                                }(r, U, et), ec = el.n$(l.hash.outputLen, l.nByteLength, l.hmac);
                                return ec(eo, es)
                            },
                            verify: function(r, C, U, et = eS) {
                                let eo, es;
                                if (C = (0, el.ql)("msgHash", C), U = (0, el.ql)("publicKey", U), "strict" in et) throw Error("options.strict was renamed to lowS");
                                let {
                                    lowS: ec,
                                    prehash: eh
                                } = et;
                                try {
                                    if ("string" == typeof r || el._t(r)) try {
                                        es = Signature.fromDER(r)
                                    } catch (l) {
                                        if (!(l instanceof ef.Err)) throw l;
                                        es = Signature.fromCompact(r)
                                    } else if ("object" == typeof r && "bigint" == typeof r.r && "bigint" == typeof r.s) {
                                        let {
                                            r: l,
                                            s: C
                                        } = r;
                                        es = new Signature(l, C)
                                    } else throw Error("PARSE");
                                    eo = ed.fromHex(U)
                                } catch (r) {
                                    if ("PARSE" === r.message) throw Error("signature must be Signature instance, Uint8Array or hex string");
                                    return !1
                                }
                                if (ec && es.hasHighS()) return !1;
                                eh && (C = l.hash(C));
                                let {
                                    r: ep,
                                    s: eg
                                } = es, ey = ew(C), em = invN(eg), e_ = modN(ey * em), eb = modN(ep * em), eE = ed.BASE.multiplyAndAddUnsafe(eo, e_, eb) ? .toAffine();
                                if (!eE) return !1;
                                let eI = modN(eE.x);
                                return eI === ep
                            },
                            ProjectivePoint: ed,
                            Signature,
                            utils: {
                                isValidPrivateKey(r) {
                                    try {
                                        return eh(r), !0
                                    } catch (r) {
                                        return !1
                                    }
                                },
                                normPrivateKeyToScalar: eh,
                                randomPrivateKey: () => {
                                    let r = et.PS(l.n);
                                    return et.Us(l.randomBytes(r), l.n)
                                },
                                precompute: (r = 8, l = ed.BASE) => (l._setWindowSize(r), l.multiply(BigInt(3)), l)
                            }
                        }
                    })({ ...r,
                        hash: l,
                        hmac: (r, ...C) => (0, eo.b)(l, r, (0, es.eV)(...C)),
                        randomBytes: es.O6
                    });
                    return Object.freeze({ ...create(l),
                        create
                    })
                }({
                    a: BigInt(0),
                    b: BigInt(7),
                    Fp: eE,
                    n: e_,
                    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
                    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
                    h: BigInt(1),
                    lowS: !0,
                    endo: {
                        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
                        splitScalar: r => {
                            let l = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
                                C = -eb * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
                                U = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
                                eo = BigInt("0x100000000000000000000000000000000"),
                                es = divNearest(l * r, e_),
                                el = divNearest(-C * r, e_),
                                ec = (0, et.wQ)(r - es * l - el * U, e_),
                                ed = (0, et.wQ)(-es * C - el * l, e_),
                                eh = ec > eo,
                                ef = ed > eo;
                            if (eh && (ec = e_ - ec), ef && (ed = e_ - ed), ec > eo || ed > eo) throw Error("splitScalar: Endomorphism failed, k=" + r);
                            return {
                                k1neg: eh,
                                k1: ec,
                                k2neg: ef,
                                k2: ed
                            }
                        }
                    }
                }, U.J);
            BigInt(0), eI.ProjectivePoint
        },
        52635: function(r, l, C) {
            "use strict";
            let U;
            C.d(l, {
                E9: function() {
                    return Point
                },
                P6: function() {
                    return eA
                },
                Z_: function() {
                    return eS
                }
            });
            var et, eo = C(60661); /*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
            let es = BigInt(0),
                el = BigInt(1),
                ec = BigInt(2),
                ed = BigInt(8),
                eh = BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
                ef = Object.freeze({
                    a: BigInt(-1),
                    d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
                    P: BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),
                    l: eh,
                    n: eh,
                    h: BigInt(8),
                    Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
                    Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960")
                }),
                ep = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000"),
                eg = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
            BigInt("6853475219497561581579357271197624642482790079785650197046958215289687604742");
            let ey = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"),
                em = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"),
                e_ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"),
                eb = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
            let ExtendedPoint = class ExtendedPoint {
                constructor(r, l, C, U) {
                    this.x = r, this.y = l, this.z = C, this.t = U
                }
                static fromAffine(r) {
                    if (!(r instanceof Point)) throw TypeError("ExtendedPoint#fromAffine: expected Point");
                    return r.equals(Point.ZERO) ? ExtendedPoint.ZERO : new ExtendedPoint(r.x, r.y, el, mod(r.x * r.y))
                }
                static toAffineBatch(r) {
                    let l = function(r, l = ef.P) {
                        let C = Array(r.length),
                            U = r.reduce((r, U, et) => U === es ? r : (C[et] = r, mod(r * U, l)), el),
                            et = invert(U, l);
                        return r.reduceRight((r, U, et) => U === es ? r : (C[et] = mod(r * C[et], l), mod(r * U, l)), et), C
                    }(r.map(r => r.z));
                    return r.map((r, C) => r.toAffine(l[C]))
                }
                static normalizeZ(r) {
                    return this.toAffineBatch(r).map(this.fromAffine)
                }
                equals(r) {
                    assertExtPoint(r);
                    let {
                        x: l,
                        y: C,
                        z: U
                    } = this, {
                        x: et,
                        y: eo,
                        z: es
                    } = r, el = mod(l * es), ec = mod(et * U), ed = mod(C * es), eh = mod(eo * U);
                    return el === ec && ed === eh
                }
                negate() {
                    return new ExtendedPoint(mod(-this.x), this.y, this.z, mod(-this.t))
                }
                double() {
                    let {
                        x: r,
                        y: l,
                        z: C
                    } = this, {
                        a: U
                    } = ef, et = mod(r * r), eo = mod(l * l), es = mod(ec * mod(C * C)), el = mod(U * et), ed = r + l, eh = mod(mod(ed * ed) - et - eo), ep = el + eo, eg = ep - es, ey = el - eo, em = mod(eh * eg), e_ = mod(ep * ey), eb = mod(eh * ey), ew = mod(eg * ep);
                    return new ExtendedPoint(em, e_, ew, eb)
                }
                add(r) {
                    assertExtPoint(r);
                    let {
                        x: l,
                        y: C,
                        z: U,
                        t: et
                    } = this, {
                        x: eo,
                        y: el,
                        z: ed,
                        t: eh
                    } = r, ef = mod((C - l) * (el + eo)), ep = mod((C + l) * (el - eo)), eg = mod(ep - ef);
                    if (eg === es) return this.double();
                    let ey = mod(U * ec * eh),
                        em = mod(et * ec * ed),
                        e_ = em + ey,
                        eb = ep + ef,
                        ew = em - ey,
                        eE = mod(e_ * eg),
                        eI = mod(eb * ew),
                        eS = mod(e_ * ew),
                        ex = mod(eg * eb);
                    return new ExtendedPoint(eE, eI, ex, eS)
                }
                subtract(r) {
                    return this.add(r.negate())
                }
                precomputeWindow(r) {
                    let l = 1 + 256 / r,
                        C = [],
                        U = this,
                        et = U;
                    for (let eo = 0; eo < l; eo++) {
                        et = U, C.push(et);
                        for (let l = 1; l < 2 ** (r - 1); l++) et = et.add(U), C.push(et);
                        U = et.double()
                    }
                    return C
                }
                wNAF(r, l) {
                    !l && this.equals(ExtendedPoint.BASE) && (l = Point.BASE);
                    let C = l && l._WINDOW_SIZE || 1;
                    if (256 % C) throw Error("Point#wNAF: Invalid precomputation window, must be power of 2");
                    let U = l && ew.get(l);
                    !U && (U = this.precomputeWindow(C), l && 1 !== C && (U = ExtendedPoint.normalizeZ(U), ew.set(l, U)));
                    let et = ExtendedPoint.ZERO,
                        eo = ExtendedPoint.BASE,
                        es = 1 + 256 / C,
                        ec = 2 ** (C - 1),
                        ed = BigInt(2 ** C - 1),
                        eh = 2 ** C,
                        ef = BigInt(C);
                    for (let l = 0; l < es; l++) {
                        let C = l * ec,
                            es = Number(r & ed);
                        r >>= ef, es > ec && (es -= eh, r += el);
                        let ep = C + Math.abs(es) - 1,
                            eg = l % 2 != 0,
                            ey = es < 0;
                        0 === es ? eo = eo.add(constTimeNegate(eg, U[C])) : et = et.add(constTimeNegate(ey, U[ep]))
                    }
                    return ExtendedPoint.normalizeZ([et, eo])[0]
                }
                multiply(r, l) {
                    return this.wNAF(normalizeScalar(r, ef.l), l)
                }
                multiplyUnsafe(r) {
                    let l = normalizeScalar(r, ef.l, !1),
                        C = ExtendedPoint.BASE,
                        U = ExtendedPoint.ZERO;
                    if (l === es) return U;
                    if (this.equals(U) || l === el) return this;
                    if (this.equals(C)) return this.wNAF(l);
                    let et = U,
                        eo = this;
                    for (; l > es;) l & el && (et = et.add(eo)), eo = eo.double(), l >>= el;
                    return et
                }
                isSmallOrder() {
                    return this.multiplyUnsafe(ef.h).equals(ExtendedPoint.ZERO)
                }
                isTorsionFree() {
                    let r = this.multiplyUnsafe(ef.l / ec).double();
                    return ef.l % ec && (r = r.add(this)), r.equals(ExtendedPoint.ZERO)
                }
                toAffine(r) {
                    let {
                        x: l,
                        y: C,
                        z: U
                    } = this, et = this.equals(ExtendedPoint.ZERO);
                    null == r && (r = et ? ed : invert(U));
                    let eo = mod(l * r),
                        es = mod(C * r),
                        ec = mod(U * r);
                    if (et) return Point.ZERO;
                    if (ec !== el) throw Error("invZ was invalid");
                    return new Point(eo, es)
                }
                fromRistrettoBytes() {
                    legacyRist()
                }
                toRistrettoBytes() {
                    legacyRist()
                }
                fromRistrettoHash() {
                    legacyRist()
                }
            };

            function constTimeNegate(r, l) {
                let C = l.negate();
                return r ? C : l
            }

            function assertExtPoint(r) {
                if (!(r instanceof ExtendedPoint)) throw TypeError("ExtendedPoint expected")
            }

            function assertRstPoint(r) {
                if (!(r instanceof RistrettoPoint)) throw TypeError("RistrettoPoint expected")
            }

            function legacyRist() {
                throw Error("Legacy method: switch to RistrettoPoint")
            }
            ExtendedPoint.BASE = new ExtendedPoint(ef.Gx, ef.Gy, el, mod(ef.Gx * ef.Gy)), ExtendedPoint.ZERO = new ExtendedPoint(es, el, el, es);
            let RistrettoPoint = class RistrettoPoint {
                constructor(r) {
                    this.ep = r
                }
                static calcElligatorRistrettoMap(r) {
                    let {
                        d: l
                    } = ef, C = mod(eg * r * r), U = mod((C + el) * e_), et = BigInt(-1), eo = mod((et - l * C) * mod(C + l)), {
                        isValid: es,
                        value: ec
                    } = uvRatio(U, eo), ed = mod(ec * r);
                    edIsNegative(ed) || (ed = mod(-ed)), es || (ec = ed), es || (et = C);
                    let eh = mod(et * (C - el) * eb - eo),
                        ep = ec * ec,
                        em = mod((ec + ec) * eo),
                        ew = mod(eh * ey),
                        eE = mod(el - ep),
                        eI = mod(el + ep);
                    return new ExtendedPoint(mod(em * eI), mod(eE * ew), mod(ew * eI), mod(em * eE))
                }
                static hashToCurve(r) {
                    r = ensureBytes(r, 64);
                    let l = bytes255ToNumberLE(r.slice(0, 32)),
                        C = this.calcElligatorRistrettoMap(l),
                        U = bytes255ToNumberLE(r.slice(32, 64)),
                        et = this.calcElligatorRistrettoMap(U);
                    return new RistrettoPoint(C.add(et))
                }
                static fromHex(r) {
                    var l;
                    r = ensureBytes(r, 32);
                    let {
                        a: C,
                        d: U
                    } = ef, et = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint", eo = bytes255ToNumberLE(r);
                    if (! function(r, l) {
                            if (r.length !== l.length) return !1;
                            for (let C = 0; C < r.length; C++)
                                if (r[C] !== l[C]) return !1;
                            return !0
                        }(numberTo32BytesLE(eo), r) || edIsNegative(eo)) throw Error(et);
                    let ec = mod(eo * eo),
                        ed = mod(el + C * ec),
                        eh = mod(el - C * ec),
                        ep = mod(ed * ed),
                        eg = mod(eh * eh),
                        ey = mod(C * U * ep - eg),
                        {
                            isValid: em,
                            value: e_
                        } = uvRatio(el, mod(ey * eg)),
                        eb = mod(e_ * eh),
                        ew = mod(e_ * eb * ey),
                        eE = mod((eo + eo) * eb);
                    edIsNegative(eE) && (eE = mod(-eE));
                    let eI = mod(ed * ew),
                        eS = mod(eE * eI);
                    if (!em || edIsNegative(eS) || eI === es) throw Error(et);
                    return new RistrettoPoint(new ExtendedPoint(eE, eI, el, eS))
                }
                toRawBytes() {
                    var r;
                    let l, {
                            x: C,
                            y: U,
                            z: et,
                            t: eo
                        } = this.ep,
                        es = mod(mod(et + U) * mod(et - U)),
                        ec = mod(C * U),
                        ed = mod(ec * ec),
                        {
                            value: eh
                        } = uvRatio(el, mod(es * ed)),
                        ef = mod(eh * es),
                        ep = mod(eh * ec),
                        ey = mod(ef * ep * eo);
                    if (edIsNegative(eo * ey)) {
                        let r = mod(U * eg),
                            et = mod(C * eg);
                        C = r, U = et, l = mod(ef * em)
                    } else l = ep;
                    edIsNegative(C * ey) && (U = mod(-U));
                    let e_ = mod((et - U) * l);
                    return edIsNegative(e_) && (e_ = mod(-e_)), numberTo32BytesLE(e_)
                }
                toHex() {
                    return bytesToHex(this.toRawBytes())
                }
                toString() {
                    return this.toHex()
                }
                equals(r) {
                    assertRstPoint(r);
                    let l = this.ep,
                        C = r.ep,
                        U = mod(l.x * C.y) === mod(l.y * C.x),
                        et = mod(l.y * C.y) === mod(l.x * C.x);
                    return U || et
                }
                add(r) {
                    return assertRstPoint(r), new RistrettoPoint(this.ep.add(r.ep))
                }
                subtract(r) {
                    return assertRstPoint(r), new RistrettoPoint(this.ep.subtract(r.ep))
                }
                multiply(r) {
                    return new RistrettoPoint(this.ep.multiply(r))
                }
                multiplyUnsafe(r) {
                    return new RistrettoPoint(this.ep.multiplyUnsafe(r))
                }
            };
            RistrettoPoint.BASE = new RistrettoPoint(ExtendedPoint.BASE), RistrettoPoint.ZERO = new RistrettoPoint(ExtendedPoint.ZERO);
            let ew = new WeakMap;
            let Point = class Point {
                constructor(r, l) {
                    this.x = r, this.y = l
                }
                _setWindowSize(r) {
                    this._WINDOW_SIZE = r, ew.delete(this)
                }
                static fromHex(r, l = !0) {
                    let {
                        d: C,
                        P: U
                    } = ef;
                    r = ensureBytes(r, 32);
                    let et = r.slice();
                    et[31] = -129 & r[31];
                    let eo = bytesToNumberLE(et);
                    if (l && eo >= U) throw Error("Expected 0 < hex < P");
                    if (!l && eo >= ep) throw Error("Expected 0 < hex < 2**256");
                    let es = mod(eo * eo),
                        ec = mod(es - el),
                        ed = mod(C * es + el),
                        {
                            isValid: eh,
                            value: eg
                        } = uvRatio(ec, ed);
                    if (!eh) throw Error("Point.fromHex: invalid y coordinate");
                    let ey = (eg & el) === el,
                        em = (128 & r[31]) != 0;
                    return em !== ey && (eg = mod(-eg)), new Point(eg, eo)
                }
                static async fromPrivateKey(r) {
                    return (await getExtendedPublicKey(r)).point
                }
                toRawBytes() {
                    let r = numberTo32BytesLE(this.y);
                    return r[31] |= this.x & el ? 128 : 0, r
                }
                toHex() {
                    return bytesToHex(this.toRawBytes())
                }
                toX25519() {
                    let {
                        y: r
                    } = this, l = mod((el + r) * invert(el - r));
                    return numberTo32BytesLE(l)
                }
                isTorsionFree() {
                    return ExtendedPoint.fromAffine(this).isTorsionFree()
                }
                equals(r) {
                    return this.x === r.x && this.y === r.y
                }
                negate() {
                    return new Point(mod(-this.x), this.y)
                }
                add(r) {
                    return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(r)).toAffine()
                }
                subtract(r) {
                    return this.add(r.negate())
                }
                multiply(r) {
                    return ExtendedPoint.fromAffine(this).multiply(r, this).toAffine()
                }
            };
            Point.BASE = new Point(ef.Gx, ef.Gy), Point.ZERO = new Point(es, el);
            let Signature = class Signature {
                constructor(r, l) {
                    this.r = r, this.s = l, this.assertValidity()
                }
                static fromHex(r) {
                    let l = ensureBytes(r, 64),
                        C = Point.fromHex(l.slice(0, 32), !1),
                        U = bytesToNumberLE(l.slice(32, 64));
                    return new Signature(C, U)
                }
                assertValidity() {
                    let {
                        r,
                        s: l
                    } = this;
                    if (!(r instanceof Point)) throw Error("Expected Point instance");
                    return normalizeScalar(l, ef.l, !1), this
                }
                toRawBytes() {
                    let r = new Uint8Array(64);
                    return r.set(this.r.toRawBytes()), r.set(numberTo32BytesLE(this.s), 32), r
                }
                toHex() {
                    return bytesToHex(this.toRawBytes())
                }
            };

            function concatBytes(...r) {
                if (!r.every(r => r instanceof Uint8Array)) throw Error("Expected Uint8Array list");
                if (1 === r.length) return r[0];
                let l = r.reduce((r, l) => r + l.length, 0),
                    C = new Uint8Array(l);
                for (let l = 0, U = 0; l < r.length; l++) {
                    let et = r[l];
                    C.set(et, U), U += et.length
                }
                return C
            }
            let eE = Array.from({
                length: 256
            }, (r, l) => l.toString(16).padStart(2, "0"));

            function bytesToHex(r) {
                if (!(r instanceof Uint8Array)) throw Error("Uint8Array expected");
                let l = "";
                for (let C = 0; C < r.length; C++) l += eE[r[C]];
                return l
            }

            function hexToBytes(r) {
                if ("string" != typeof r) throw TypeError("hexToBytes: expected string, got " + typeof r);
                if (r.length % 2) throw Error("hexToBytes: received invalid unpadded hex");
                let l = new Uint8Array(r.length / 2);
                for (let C = 0; C < l.length; C++) {
                    let U = 2 * C,
                        et = r.slice(U, U + 2),
                        eo = Number.parseInt(et, 16);
                    if (Number.isNaN(eo) || eo < 0) throw Error("Invalid byte sequence");
                    l[C] = eo
                }
                return l
            }

            function numberTo32BytesBE(r) {
                let l = r.toString(16).padStart(64, "0");
                return hexToBytes(l)
            }

            function numberTo32BytesLE(r) {
                return numberTo32BytesBE(r).reverse()
            }

            function edIsNegative(r) {
                return (mod(r) & el) === el
            }

            function bytesToNumberLE(r) {
                if (!(r instanceof Uint8Array)) throw Error("Expected Uint8Array");
                return BigInt("0x" + bytesToHex(Uint8Array.from(r).reverse()))
            }
            let eI = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

            function bytes255ToNumberLE(r) {
                return mod(bytesToNumberLE(r) & eI)
            }

            function mod(r, l = ef.P) {
                let C = r % l;
                return C >= es ? C : l + C
            }

            function invert(r, l = ef.P) {
                if (r === es || l <= es) throw Error(`invert: expected positive integers, got n=${r} mod=${l}`);
                let C = mod(r, l),
                    U = l,
                    et = es,
                    eo = el,
                    ec = el,
                    ed = es;
                for (; C !== es;) {
                    let r = U / C,
                        l = U % C,
                        es = et - ec * r,
                        el = eo - ed * r;
                    U = C, C = l, et = ec, eo = ed, ec = es, ed = el
                }
                let eh = U;
                if (eh !== el) throw Error("invert: does not exist");
                return mod(et, l)
            }

            function pow2(r, l) {
                let {
                    P: C
                } = ef, U = r;
                for (; l-- > es;) U *= U, U %= C;
                return U
            }

            function uvRatio(r, l) {
                let C = mod(l * l * l),
                    U = mod(C * C * l),
                    et = function(r) {
                        let {
                            P: l
                        } = ef, C = BigInt(5), U = BigInt(10), et = BigInt(20), eo = BigInt(40), es = BigInt(80), ed = r * r % l * r % l, eh = pow2(ed, ec) * ed % l, ep = pow2(eh, el) * r % l, eg = pow2(ep, C) * ep % l, ey = pow2(eg, U) * eg % l, em = pow2(ey, et) * ey % l, e_ = pow2(em, eo) * em % l, eb = pow2(e_, es) * e_ % l, ew = pow2(eb, es) * e_ % l, eE = pow2(ew, U) * eg % l, eI = pow2(eE, ec) * r % l;
                        return {
                            pow_p_5_8: eI,
                            b2: ed
                        }
                    }(r * U).pow_p_5_8,
                    eo = mod(r * C * et),
                    es = mod(l * eo * eo),
                    ed = eo,
                    eh = mod(eo * eg),
                    ep = es === r,
                    ey = es === mod(-r),
                    em = es === mod(-r * eg);
                return ep && (eo = ed), (ey || em) && (eo = eh), edIsNegative(eo) && (eo = mod(-eo)), {
                    isValid: ep || ey,
                    value: eo
                }
            }

            function modlLE(r) {
                return mod(bytesToNumberLE(r), ef.l)
            }

            function ensureBytes(r, l) {
                let C = r instanceof Uint8Array ? Uint8Array.from(r) : hexToBytes(r);
                if ("number" == typeof l && C.length !== l) throw Error(`Expected ${l} bytes`);
                return C
            }

            function normalizeScalar(r, l, C = !0) {
                if (!l) throw TypeError("Specify max value");
                if ("number" == typeof r && Number.isSafeInteger(r) && (r = BigInt(r)), "bigint" == typeof r && r < l) {
                    if (C) {
                        if (es < r) return r
                    } else if (es <= r) return r
                }
                throw TypeError("Expected valid scalar: 0 < scalar < max")
            }

            function checkPrivateKey(r) {
                if (32 !== (r = "bigint" == typeof r || "number" == typeof r ? numberTo32BytesBE(normalizeScalar(r, ep)) : ensureBytes(r)).length) throw Error("Expected 32 bytes");
                return r
            }

            function getKeyFromHash(r) {
                var l;
                let C = (l = r.slice(0, 32), l[0] &= 248, l[31] &= 127, l[31] |= 64, l),
                    U = r.slice(32, 64),
                    et = modlLE(C),
                    eo = Point.BASE.multiply(et),
                    es = eo.toRawBytes();
                return {
                    head: C,
                    prefix: U,
                    scalar: et,
                    point: eo,
                    pointBytes: es
                }
            }

            function sha512s(...r) {
                if ("function" != typeof U) throw Error("utils.sha512Sync must be set to use sync methods");
                return U(...r)
            }
            async function getExtendedPublicKey(r) {
                return getKeyFromHash(await eA.sha512(checkPrivateKey(r)))
            }

            function getExtendedPublicKeySync(r) {
                return getKeyFromHash(sha512s(checkPrivateKey(r)))
            }
            let eS = {
                getExtendedPublicKey: getExtendedPublicKeySync,
                getPublicKey: function(r) {
                    return getExtendedPublicKeySync(r).pointBytes
                },
                sign: function(r, l) {
                    r = ensureBytes(r);
                    let {
                        prefix: C,
                        scalar: U,
                        pointBytes: et
                    } = getExtendedPublicKeySync(l), eo = modlLE(sha512s(C, r)), es = Point.BASE.multiply(eo), el = modlLE(sha512s(es.toRawBytes(), et, r)), ec = mod(eo + el * U, ef.l);
                    return new Signature(es, ec).toRawBytes()
                },
                verify: function(r, l, C) {
                    let {
                        r: U,
                        SB: et,
                        msg: eo,
                        pub: es
                    } = function(r, l, C) {
                        l = ensureBytes(l), C instanceof Point || (C = Point.fromHex(C, !1));
                        let {
                            r: U,
                            s: et
                        } = r instanceof Signature ? r.assertValidity() : Signature.fromHex(r), eo = ExtendedPoint.BASE.multiplyUnsafe(et);
                        return {
                            r: U,
                            s: et,
                            SB: eo,
                            pub: C,
                            msg: l
                        }
                    }(r, l, C), el = sha512s(U.toRawBytes(), es.toRawBytes(), eo);
                    return function(r, l, C, U) {
                        let et = modlLE(U),
                            eo = ExtendedPoint.fromAffine(r).multiplyUnsafe(et),
                            es = ExtendedPoint.fromAffine(l).add(eo);
                        return es.subtract(C).multiplyUnsafe(ef.h).equals(ExtendedPoint.ZERO)
                    }(es, U, et, el)
                }
            };
            Point.BASE._setWindowSize(8);
            let ex = {
                    node: et || (et = C.t(eo, 2)),
                    web: "object" == typeof self && "crypto" in self ? self.crypto : void 0
                },
                eA = {
                    bytesToHex,
                    hexToBytes,
                    concatBytes,
                    getExtendedPublicKey,
                    mod,
                    invert,
                    TORSION_SUBGROUP: ["0100000000000000000000000000000000000000000000000000000000000000", "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a", "0000000000000000000000000000000000000000000000000000000000000080", "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05", "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f", "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85", "0000000000000000000000000000000000000000000000000000000000000000", "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"],
                    hashToPrivateScalar: r => {
                        if ((r = ensureBytes(r)).length < 40 || r.length > 1024) throw Error("Expected 40-1024 bytes of private key as per FIPS 186");
                        return mod(bytesToNumberLE(r), ef.l - el) + el
                    },
                    randomBytes: (r = 32) => {
                        if (ex.web) return ex.web.getRandomValues(new Uint8Array(r));
                        if (ex.node) {
                            let {
                                randomBytes: l
                            } = ex.node;
                            return new Uint8Array(l(r).buffer)
                        }
                        throw Error("The environment doesn't have randomBytes function")
                    },
                    randomPrivateKey: () => eA.randomBytes(32),
                    sha512: async (...r) => {
                        let l = concatBytes(...r);
                        if (ex.web) {
                            let r = await ex.web.subtle.digest("SHA-512", l.buffer);
                            return new Uint8Array(r)
                        }
                        if (ex.node) return Uint8Array.from(ex.node.createHash("sha512").update(l).digest());
                        throw Error("The environment doesn't have sha512 function")
                    },
                    precompute(r = 8, l = Point.BASE) {
                        let C = l.equals(Point.BASE) ? l : new Point(l.x, l.y);
                        return C._setWindowSize(r), C.multiply(ec), C
                    },
                    sha512Sync: void 0
                };
            Object.defineProperties(eA, {
                sha512Sync: {
                    configurable: !1,
                    get: () => U,
                    set(r) {
                        U || (U = r)
                    }
                }
            })
        },
        16455: function(r, l, C) {
            "use strict";

            function number(r) {
                if (!Number.isSafeInteger(r) || r < 0) throw Error(`Wrong positive integer: ${r}`)
            }

            function bytes(r, ...l) {
                if (!(r instanceof Uint8Array || null != r && "object" == typeof r && "Uint8Array" === r.constructor.name)) throw Error("Expected Uint8Array");
                if (l.length > 0 && !l.includes(r.length)) throw Error(`Expected Uint8Array of length ${l}, not of length=${r.length}`)
            }

            function hash(r) {
                if ("function" != typeof r || "function" != typeof r.create) throw Error("Hash should be wrapped by utils.wrapConstructor");
                number(r.outputLen), number(r.blockLen)
            }

            function exists(r, l = !0) {
                if (r.destroyed) throw Error("Hash instance has been destroyed");
                if (l && r.finished) throw Error("Hash#digest() has already been called")
            }

            function output(r, l) {
                bytes(r);
                let C = l.outputLen;
                if (r.length < C) throw Error(`digestInto() expects output buffer of length at least ${C}`)
            }
            C.d(l, {
                Gg: function() {
                    return exists
                },
                J8: function() {
                    return output
                },
                Rx: function() {
                    return number
                },
                aI: function() {
                    return bytes
                },
                vp: function() {
                    return hash
                }
            })
        },
        30788: function(r, l, C) {
            "use strict";
            C.d(l, {
                N: function() {
                    return SHA2
                }
            });
            var U = C(16455),
                et = C(41966);
            let SHA2 = class SHA2 extends et.kb {
                constructor(r, l, C, U) {
                    super(), this.blockLen = r, this.outputLen = l, this.padOffset = C, this.isLE = U, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(r), this.view = (0, et.GL)(this.buffer)
                }
                update(r) {
                    (0, U.Gg)(this);
                    let {
                        view: l,
                        buffer: C,
                        blockLen: eo
                    } = this;
                    r = (0, et.O0)(r);
                    let es = r.length;
                    for (let U = 0; U < es;) {
                        let el = Math.min(eo - this.pos, es - U);
                        if (el === eo) {
                            let l = (0, et.GL)(r);
                            for (; eo <= es - U; U += eo) this.process(l, U);
                            continue
                        }
                        C.set(r.subarray(U, U + el), this.pos), this.pos += el, U += el, this.pos === eo && (this.process(l, 0), this.pos = 0)
                    }
                    return this.length += r.length, this.roundClean(), this
                }
                digestInto(r) {
                    (0, U.Gg)(this), (0, U.J8)(r, this), this.finished = !0;
                    let {
                        buffer: l,
                        view: C,
                        blockLen: eo,
                        isLE: es
                    } = this, {
                        pos: el
                    } = this;
                    l[el++] = 128, this.buffer.subarray(el).fill(0), this.padOffset > eo - el && (this.process(C, 0), el = 0);
                    for (let r = el; r < eo; r++) l[r] = 0;
                    ! function(r, l, C, U) {
                        if ("function" == typeof r.setBigUint64) return r.setBigUint64(l, C, U);
                        let et = BigInt(32),
                            eo = BigInt(4294967295),
                            es = Number(C >> et & eo),
                            el = Number(C & eo),
                            ec = U ? 4 : 0,
                            ed = U ? 0 : 4;
                        r.setUint32(l + ec, es, U), r.setUint32(l + ed, el, U)
                    }(C, eo - 8, BigInt(8 * this.length), es), this.process(C, 0);
                    let ec = (0, et.GL)(r),
                        ed = this.outputLen;
                    if (ed % 4) throw Error("_sha2: outputLen should be aligned to 32bit");
                    let eh = ed / 4,
                        ef = this.get();
                    if (eh > ef.length) throw Error("_sha2: outputLen bigger than state");
                    for (let r = 0; r < eh; r++) ec.setUint32(4 * r, ef[r], es)
                }
                digest() {
                    let {
                        buffer: r,
                        outputLen: l
                    } = this;
                    this.digestInto(r);
                    let C = r.slice(0, l);
                    return this.destroy(), C
                }
                _cloneInto(r) {
                    r || (r = new this.constructor), r.set(...this.get());
                    let {
                        blockLen: l,
                        buffer: C,
                        length: U,
                        finished: et,
                        destroyed: eo,
                        pos: es
                    } = this;
                    return r.length = U, r.pos = es, r.finished = et, r.destroyed = eo, U % l && r.buffer.set(C), r
                }
            }
        },
        45152: function(r, l, C) {
            "use strict";
            C.d(l, {
                EP: function() {
                    return rotlSH
                },
                SD: function() {
                    return rotlBH
                },
                Vl: function() {
                    return split
                },
                gm: function() {
                    return rotlSL
                },
                mk: function() {
                    return rotlBL
                }
            });
            let U = BigInt(4294967296 - 1),
                et = BigInt(32);

            function fromBig(r, l = !1) {
                return l ? {
                    h: Number(r & U),
                    l: Number(r >> et & U)
                } : {
                    h: 0 | Number(r >> et & U),
                    l: 0 | Number(r & U)
                }
            }

            function split(r, l = !1) {
                let C = new Uint32Array(r.length),
                    U = new Uint32Array(r.length);
                for (let et = 0; et < r.length; et++) {
                    let {
                        h: eo,
                        l: es
                    } = fromBig(r[et], l);
                    [C[et], U[et]] = [eo, es]
                }
                return [C, U]
            }
            let rotlSH = (r, l, C) => r << C | l >>> 32 - C,
                rotlSL = (r, l, C) => l << C | r >>> 32 - C,
                rotlBH = (r, l, C) => l << C - 32 | r >>> 64 - C,
                rotlBL = (r, l, C) => r << C - 32 | l >>> 64 - C;
            l.ZP = {
                fromBig,
                split,
                toBig: (r, l) => BigInt(r >>> 0) << et | BigInt(l >>> 0),
                shrSH: (r, l, C) => r >>> C,
                shrSL: (r, l, C) => r << 32 - C | l >>> C,
                rotrSH: (r, l, C) => r >>> C | l << 32 - C,
                rotrSL: (r, l, C) => r << 32 - C | l >>> C,
                rotrBH: (r, l, C) => r << 64 - C | l >>> C - 32,
                rotrBL: (r, l, C) => r >>> C - 32 | l << 64 - C,
                rotr32H: (r, l) => l,
                rotr32L: (r, l) => r,
                rotlSH,
                rotlSL,
                rotlBH,
                rotlBL,
                add: function(r, l, C, U) {
                    let et = (l >>> 0) + (U >>> 0);
                    return {
                        h: r + C + (et / 4294967296 | 0) | 0,
                        l: 0 | et
                    }
                },
                add3L: (r, l, C) => (r >>> 0) + (l >>> 0) + (C >>> 0),
                add3H: (r, l, C, U) => l + C + U + (r / 4294967296 | 0) | 0,
                add4L: (r, l, C, U) => (r >>> 0) + (l >>> 0) + (C >>> 0) + (U >>> 0),
                add4H: (r, l, C, U, et) => l + C + U + et + (r / 4294967296 | 0) | 0,
                add5H: (r, l, C, U, et, eo) => l + C + U + et + eo + (r / 4294967296 | 0) | 0,
                add5L: (r, l, C, U, et) => (r >>> 0) + (l >>> 0) + (C >>> 0) + (U >>> 0) + (et >>> 0)
            }
        },
        79782: function(r, l, C) {
            "use strict";
            C.d(l, {
                b: function() {
                    return hmac
                }
            });
            var U = C(16455),
                et = C(41966);
            let HMAC = class HMAC extends et.kb {
                constructor(r, l) {
                    super(), this.finished = !1, this.destroyed = !1, (0, U.vp)(r);
                    let C = (0, et.O0)(l);
                    if (this.iHash = r.create(), "function" != typeof this.iHash.update) throw Error("Expected instance of class which extends utils.Hash");
                    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
                    let eo = this.blockLen,
                        es = new Uint8Array(eo);
                    es.set(C.length > eo ? r.create().update(C).digest() : C);
                    for (let r = 0; r < es.length; r++) es[r] ^= 54;
                    this.iHash.update(es), this.oHash = r.create();
                    for (let r = 0; r < es.length; r++) es[r] ^= 106;
                    this.oHash.update(es), es.fill(0)
                }
                update(r) {
                    return (0, U.Gg)(this), this.iHash.update(r), this
                }
                digestInto(r) {
                    (0, U.Gg)(this), (0, U.aI)(r, this.outputLen), this.finished = !0, this.iHash.digestInto(r), this.oHash.update(r), this.oHash.digestInto(r), this.destroy()
                }
                digest() {
                    let r = new Uint8Array(this.oHash.outputLen);
                    return this.digestInto(r), r
                }
                _cloneInto(r) {
                    r || (r = Object.create(Object.getPrototypeOf(this), {}));
                    let {
                        oHash: l,
                        iHash: C,
                        finished: U,
                        destroyed: et,
                        blockLen: eo,
                        outputLen: es
                    } = this;
                    return r.finished = U, r.destroyed = et, r.blockLen = eo, r.outputLen = es, r.oHash = l._cloneInto(r.oHash), r.iHash = C._cloneInto(r.iHash), r
                }
                destroy() {
                    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy()
                }
            };
            let hmac = (r, l, C) => new HMAC(r, l).update(C).digest();
            hmac.create = (r, l) => new HMAC(r, l)
        },
        70697: function(r, l, C) {
            "use strict";
            C.d(l, {
                J: function() {
                    return ec
                }
            });
            var U = C(30788),
                et = C(41966);
            let Chi = (r, l, C) => r & l ^ ~r & C,
                Maj = (r, l, C) => r & l ^ r & C ^ l & C,
                eo = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]),
                es = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]),
                el = new Uint32Array(64);
            let SHA256 = class SHA256 extends U.N {
                constructor() {
                    super(64, 32, 8, !1), this.A = 0 | es[0], this.B = 0 | es[1], this.C = 0 | es[2], this.D = 0 | es[3], this.E = 0 | es[4], this.F = 0 | es[5], this.G = 0 | es[6], this.H = 0 | es[7]
                }
                get() {
                    let {
                        A: r,
                        B: l,
                        C,
                        D: U,
                        E: et,
                        F: eo,
                        G: es,
                        H: el
                    } = this;
                    return [r, l, C, U, et, eo, es, el]
                }
                set(r, l, C, U, et, eo, es, el) {
                    this.A = 0 | r, this.B = 0 | l, this.C = 0 | C, this.D = 0 | U, this.E = 0 | et, this.F = 0 | eo, this.G = 0 | es, this.H = 0 | el
                }
                process(r, l) {
                    for (let C = 0; C < 16; C++, l += 4) el[C] = r.getUint32(l, !1);
                    for (let r = 16; r < 64; r++) {
                        let l = el[r - 15],
                            C = el[r - 2],
                            U = (0, et.np)(l, 7) ^ (0, et.np)(l, 18) ^ l >>> 3,
                            eo = (0, et.np)(C, 17) ^ (0, et.np)(C, 19) ^ C >>> 10;
                        el[r] = eo + el[r - 7] + U + el[r - 16] | 0
                    }
                    let {
                        A: C,
                        B: U,
                        C: es,
                        D: ec,
                        E: ed,
                        F: eh,
                        G: ef,
                        H: ep
                    } = this;
                    for (let r = 0; r < 64; r++) {
                        let l = (0, et.np)(ed, 6) ^ (0, et.np)(ed, 11) ^ (0, et.np)(ed, 25),
                            eg = ep + l + Chi(ed, eh, ef) + eo[r] + el[r] | 0,
                            ey = (0, et.np)(C, 2) ^ (0, et.np)(C, 13) ^ (0, et.np)(C, 22),
                            em = ey + Maj(C, U, es) | 0;
                        ep = ef, ef = eh, eh = ed, ed = ec + eg | 0, ec = es, es = U, U = C, C = eg + em | 0
                    }
                    C = C + this.A | 0, U = U + this.B | 0, es = es + this.C | 0, ec = ec + this.D | 0, ed = ed + this.E | 0, eh = eh + this.F | 0, ef = ef + this.G | 0, ep = ep + this.H | 0, this.set(C, U, es, ec, ed, eh, ef, ep)
                }
                roundClean() {
                    el.fill(0)
                }
                destroy() {
                    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0)
                }
            };
            let ec = (0, et.hE)(() => new SHA256)
        },
        65155: function(r, l, C) {
            "use strict";
            C.d(l, {
                fr: function() {
                    return eb
                }
            });
            var U = C(16455),
                et = C(45152),
                eo = C(41966);
            let [es, el, ec] = [
                [],
                [],
                []
            ], ed = BigInt(0), eh = BigInt(1), ef = BigInt(2), ep = BigInt(7), eg = BigInt(256), ey = BigInt(113);
            for (let r = 0, l = eh, C = 1, U = 0; r < 24; r++) {
                [C, U] = [U, (2 * C + 3 * U) % 5], es.push(2 * (5 * U + C)), el.push((r + 1) * (r + 2) / 2 % 64);
                let et = ed;
                for (let r = 0; r < 7; r++)(l = (l << eh ^ (l >> ep) * ey) % eg) & ef && (et ^= eh << (eh << BigInt(r)) - eh);
                ec.push(et)
            }
            let [em, e_] = (0, et.Vl)(ec, !0), rotlH = (r, l, C) => C > 32 ? (0, et.SD)(r, l, C) : (0, et.EP)(r, l, C), rotlL = (r, l, C) => C > 32 ? (0, et.mk)(r, l, C) : (0, et.gm)(r, l, C);
            let Keccak = class Keccak extends eo.kb {
                constructor(r, l, C, et = !1, es = 24) {
                    if (super(), this.blockLen = r, this.suffix = l, this.outputLen = C, this.enableXOF = et, this.rounds = es, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, (0, U.Rx)(C), 0 >= this.blockLen || this.blockLen >= 200) throw Error("Sha3 supports only keccak-f1600 function");
                    this.state = new Uint8Array(200), this.state32 = (0, eo.Jq)(this.state)
                }
                keccak() {
                    ! function(r, l = 24) {
                        let C = new Uint32Array(10);
                        for (let U = 24 - l; U < 24; U++) {
                            for (let l = 0; l < 10; l++) C[l] = r[l] ^ r[l + 10] ^ r[l + 20] ^ r[l + 30] ^ r[l + 40];
                            for (let l = 0; l < 10; l += 2) {
                                let U = (l + 8) % 10,
                                    et = (l + 2) % 10,
                                    eo = C[et],
                                    es = C[et + 1],
                                    el = rotlH(eo, es, 1) ^ C[U],
                                    ec = rotlL(eo, es, 1) ^ C[U + 1];
                                for (let C = 0; C < 50; C += 10) r[l + C] ^= el, r[l + C + 1] ^= ec
                            }
                            let l = r[2],
                                et = r[3];
                            for (let C = 0; C < 24; C++) {
                                let U = el[C],
                                    eo = rotlH(l, et, U),
                                    ec = rotlL(l, et, U),
                                    ed = es[C];
                                l = r[ed], et = r[ed + 1], r[ed] = eo, r[ed + 1] = ec
                            }
                            for (let l = 0; l < 50; l += 10) {
                                for (let U = 0; U < 10; U++) C[U] = r[l + U];
                                for (let U = 0; U < 10; U++) r[l + U] ^= ~C[(U + 2) % 10] & C[(U + 4) % 10]
                            }
                            r[0] ^= em[U], r[1] ^= e_[U]
                        }
                        C.fill(0)
                    }(this.state32, this.rounds), this.posOut = 0, this.pos = 0
                }
                update(r) {
                    (0, U.Gg)(this);
                    let {
                        blockLen: l,
                        state: C
                    } = this;
                    r = (0, eo.O0)(r);
                    let et = r.length;
                    for (let U = 0; U < et;) {
                        let eo = Math.min(l - this.pos, et - U);
                        for (let l = 0; l < eo; l++) C[this.pos++] ^= r[U++];
                        this.pos === l && this.keccak()
                    }
                    return this
                }
                finish() {
                    if (this.finished) return;
                    this.finished = !0;
                    let {
                        state: r,
                        suffix: l,
                        pos: C,
                        blockLen: U
                    } = this;
                    r[C] ^= l, (128 & l) != 0 && C === U - 1 && this.keccak(), r[U - 1] ^= 128, this.keccak()
                }
                writeInto(r) {
                    (0, U.Gg)(this, !1), (0, U.aI)(r), this.finish();
                    let l = this.state,
                        {
                            blockLen: C
                        } = this;
                    for (let U = 0, et = r.length; U < et;) {
                        this.posOut >= C && this.keccak();
                        let eo = Math.min(C - this.posOut, et - U);
                        r.set(l.subarray(this.posOut, this.posOut + eo), U), this.posOut += eo, U += eo
                    }
                    return r
                }
                xofInto(r) {
                    if (!this.enableXOF) throw Error("XOF is not possible for this instance");
                    return this.writeInto(r)
                }
                xof(r) {
                    return (0, U.Rx)(r), this.xofInto(new Uint8Array(r))
                }
                digestInto(r) {
                    if ((0, U.J8)(r, this), this.finished) throw Error("digest() was already called");
                    return this.writeInto(r), this.destroy(), r
                }
                digest() {
                    return this.digestInto(new Uint8Array(this.outputLen))
                }
                destroy() {
                    this.destroyed = !0, this.state.fill(0)
                }
                _cloneInto(r) {
                    let {
                        blockLen: l,
                        suffix: C,
                        outputLen: U,
                        rounds: et,
                        enableXOF: eo
                    } = this;
                    return r || (r = new Keccak(l, C, U, eo, et)), r.state32.set(this.state32), r.pos = this.pos, r.posOut = this.posOut, r.finished = this.finished, r.rounds = et, r.suffix = C, r.outputLen = U, r.enableXOF = eo, r.destroyed = this.destroyed, r
                }
            };
            let eb = (0, eo.hE)(() => new Keccak(136, 1, 32))
        },
        77074: function(r, l, C) {
            "use strict";
            C.d(l, {
                o: function() {
                    return eh
                }
            });
            var U = C(30788),
                et = C(45152),
                eo = C(41966);
            let [es, el] = et.ZP.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map(r => BigInt(r))), ec = new Uint32Array(80), ed = new Uint32Array(80);
            let SHA512 = class SHA512 extends U.N {
                constructor() {
                    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209
                }
                get() {
                    let {
                        Ah: r,
                        Al: l,
                        Bh: C,
                        Bl: U,
                        Ch: et,
                        Cl: eo,
                        Dh: es,
                        Dl: el,
                        Eh: ec,
                        El: ed,
                        Fh: eh,
                        Fl: ef,
                        Gh: ep,
                        Gl: eg,
                        Hh: ey,
                        Hl: em
                    } = this;
                    return [r, l, C, U, et, eo, es, el, ec, ed, eh, ef, ep, eg, ey, em]
                }
                set(r, l, C, U, et, eo, es, el, ec, ed, eh, ef, ep, eg, ey, em) {
                    this.Ah = 0 | r, this.Al = 0 | l, this.Bh = 0 | C, this.Bl = 0 | U, this.Ch = 0 | et, this.Cl = 0 | eo, this.Dh = 0 | es, this.Dl = 0 | el, this.Eh = 0 | ec, this.El = 0 | ed, this.Fh = 0 | eh, this.Fl = 0 | ef, this.Gh = 0 | ep, this.Gl = 0 | eg, this.Hh = 0 | ey, this.Hl = 0 | em
                }
                process(r, l) {
                    for (let C = 0; C < 16; C++, l += 4) ec[C] = r.getUint32(l), ed[C] = r.getUint32(l += 4);
                    for (let r = 16; r < 80; r++) {
                        let l = 0 | ec[r - 15],
                            C = 0 | ed[r - 15],
                            U = et.ZP.rotrSH(l, C, 1) ^ et.ZP.rotrSH(l, C, 8) ^ et.ZP.shrSH(l, C, 7),
                            eo = et.ZP.rotrSL(l, C, 1) ^ et.ZP.rotrSL(l, C, 8) ^ et.ZP.shrSL(l, C, 7),
                            es = 0 | ec[r - 2],
                            el = 0 | ed[r - 2],
                            eh = et.ZP.rotrSH(es, el, 19) ^ et.ZP.rotrBH(es, el, 61) ^ et.ZP.shrSH(es, el, 6),
                            ef = et.ZP.rotrSL(es, el, 19) ^ et.ZP.rotrBL(es, el, 61) ^ et.ZP.shrSL(es, el, 6),
                            ep = et.ZP.add4L(eo, ef, ed[r - 7], ed[r - 16]),
                            eg = et.ZP.add4H(ep, U, eh, ec[r - 7], ec[r - 16]);
                        ec[r] = 0 | eg, ed[r] = 0 | ep
                    }
                    let {
                        Ah: C,
                        Al: U,
                        Bh: eo,
                        Bl: eh,
                        Ch: ef,
                        Cl: ep,
                        Dh: eg,
                        Dl: ey,
                        Eh: em,
                        El: e_,
                        Fh: eb,
                        Fl: ew,
                        Gh: eE,
                        Gl: eI,
                        Hh: eS,
                        Hl: ex
                    } = this;
                    for (let r = 0; r < 80; r++) {
                        let l = et.ZP.rotrSH(em, e_, 14) ^ et.ZP.rotrSH(em, e_, 18) ^ et.ZP.rotrBH(em, e_, 41),
                            eA = et.ZP.rotrSL(em, e_, 14) ^ et.ZP.rotrSL(em, e_, 18) ^ et.ZP.rotrBL(em, e_, 41),
                            eP = em & eb ^ ~em & eE,
                            eC = e_ & ew ^ ~e_ & eI,
                            ek = et.ZP.add5L(ex, eA, eC, el[r], ed[r]),
                            eN = et.ZP.add5H(ek, eS, l, eP, es[r], ec[r]),
                            eO = 0 | ek,
                            eT = et.ZP.rotrSH(C, U, 28) ^ et.ZP.rotrBH(C, U, 34) ^ et.ZP.rotrBH(C, U, 39),
                            eR = et.ZP.rotrSL(C, U, 28) ^ et.ZP.rotrBL(C, U, 34) ^ et.ZP.rotrBL(C, U, 39),
                            eD = C & eo ^ C & ef ^ eo & ef,
                            eB = U & eh ^ U & ep ^ eh & ep;
                        eS = 0 | eE, ex = 0 | eI, eE = 0 | eb, eI = 0 | ew, eb = 0 | em, ew = 0 | e_, ({
                            h: em,
                            l: e_
                        } = et.ZP.add(0 | eg, 0 | ey, 0 | eN, 0 | eO)), eg = 0 | ef, ey = 0 | ep, ef = 0 | eo, ep = 0 | eh, eo = 0 | C, eh = 0 | U;
                        let eU = et.ZP.add3L(eO, eR, eB);
                        C = et.ZP.add3H(eU, eN, eT, eD), U = 0 | eU
                    }({
                        h: C,
                        l: U
                    } = et.ZP.add(0 | this.Ah, 0 | this.Al, 0 | C, 0 | U)), ({
                        h: eo,
                        l: eh
                    } = et.ZP.add(0 | this.Bh, 0 | this.Bl, 0 | eo, 0 | eh)), ({
                        h: ef,
                        l: ep
                    } = et.ZP.add(0 | this.Ch, 0 | this.Cl, 0 | ef, 0 | ep)), ({
                        h: eg,
                        l: ey
                    } = et.ZP.add(0 | this.Dh, 0 | this.Dl, 0 | eg, 0 | ey)), ({
                        h: em,
                        l: e_
                    } = et.ZP.add(0 | this.Eh, 0 | this.El, 0 | em, 0 | e_)), ({
                        h: eb,
                        l: ew
                    } = et.ZP.add(0 | this.Fh, 0 | this.Fl, 0 | eb, 0 | ew)), ({
                        h: eE,
                        l: eI
                    } = et.ZP.add(0 | this.Gh, 0 | this.Gl, 0 | eE, 0 | eI)), ({
                        h: eS,
                        l: ex
                    } = et.ZP.add(0 | this.Hh, 0 | this.Hl, 0 | eS, 0 | ex)), this.set(C, U, eo, eh, ef, ep, eg, ey, em, e_, eb, ew, eE, eI, eS, ex)
                }
                roundClean() {
                    ec.fill(0), ed.fill(0)
                }
                destroy() {
                    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
                }
            };
            let eh = (0, eo.hE)(() => new SHA512)
        },
        41966: function(r, l, C) {
            "use strict";
            C.d(l, {
                kb: function() {
                    return Hash
                },
                eV: function() {
                    return concatBytes
                },
                GL: function() {
                    return createView
                },
                O6: function() {
                    return randomBytes
                },
                np: function() {
                    return rotr
                },
                O0: function() {
                    return toBytes
                },
                Jq: function() {
                    return u32
                },
                iY: function() {
                    return utf8ToBytes
                },
                hE: function() {
                    return wrapConstructor
                }
            });
            let U = "object" == typeof globalThis && "crypto" in globalThis ? globalThis.crypto : void 0,
                u32 = r => new Uint32Array(r.buffer, r.byteOffset, Math.floor(r.byteLength / 4));

            function isBytes(r) {
                return r instanceof Uint8Array || null != r && "object" == typeof r && "Uint8Array" === r.constructor.name
            }
            let createView = r => new DataView(r.buffer, r.byteOffset, r.byteLength),
                rotr = (r, l) => r << 32 - l | r >>> l,
                et = 68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0];
            if (!et) throw Error("Non little-endian hardware is not supported");

            function utf8ToBytes(r) {
                if ("string" != typeof r) throw Error(`utf8ToBytes expected string, got ${typeof r}`);
                return new Uint8Array(new TextEncoder().encode(r))
            }

            function toBytes(r) {
                if ("string" == typeof r && (r = utf8ToBytes(r)), !isBytes(r)) throw Error(`expected Uint8Array, got ${typeof r}`);
                return r
            }

            function concatBytes(...r) {
                let l = 0;
                for (let C = 0; C < r.length; C++) {
                    let U = r[C];
                    if (!isBytes(U)) throw Error("Uint8Array expected");
                    l += U.length
                }
                let C = new Uint8Array(l);
                for (let l = 0, U = 0; l < r.length; l++) {
                    let et = r[l];
                    C.set(et, U), U += et.length
                }
                return C
            }
            let Hash = class Hash {
                clone() {
                    return this._cloneInto()
                }
            };

            function wrapConstructor(r) {
                let hashC = l => r().update(toBytes(l)).digest(),
                    l = r();
                return hashC.outputLen = l.outputLen, hashC.blockLen = l.blockLen, hashC.create = () => r(), hashC
            }

            function randomBytes(r = 32) {
                if (U && "function" == typeof U.getRandomValues) return U.getRandomValues(new Uint8Array(r));
                throw Error("crypto.getRandomValues must be defined")
            }
        },
        72169: function(r, l, C) {
            "use strict";
            let U, et;
            C.d(l, {
                $3: function() {
                    return getPublicKey
                },
                P6: function() {
                    return eI
                },
                kS: function() {
                    return signSync
                }
            });
            var eo, es = C(26917); /*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
            let el = BigInt(0),
                ec = BigInt(1),
                ed = BigInt(2),
                eh = BigInt(3),
                ef = BigInt(8),
                ep = Object.freeze({
                    a: el,
                    b: BigInt(7),
                    P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
                    n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
                    h: ec,
                    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
                    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
                    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
                }),
                divNearest = (r, l) => (r + l / ed) / l,
                eg = {
                    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
                    splitScalar(r) {
                        let {
                            n: l
                        } = ep, C = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), U = -ec * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), et = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), eo = BigInt("0x100000000000000000000000000000000"), es = divNearest(C * r, l), el = divNearest(-U * r, l), ed = mod(r - es * C - el * et, l), eh = mod(-es * U - el * C, l), ef = ed > eo, eg = eh > eo;
                        if (ef && (ed = l - ed), eg && (eh = l - eh), ed > eo || eh > eo) throw Error("splitScalarEndo: Endomorphism failed, k=" + r);
                        return {
                            k1neg: ef,
                            k1: ed,
                            k2neg: eg,
                            k2: eh
                        }
                    }
                };

            function weierstrass(r) {
                let {
                    a: l,
                    b: C
                } = ep, U = mod(r * r), et = mod(U * r);
                return mod(et + l * r + C)
            }
            let ey = ep.a === el;
            let ShaError = class ShaError extends Error {
                constructor(r) {
                    super(r)
                }
            };

            function assertJacPoint(r) {
                if (!(r instanceof JacobianPoint)) throw TypeError("JacobianPoint expected")
            }
            let JacobianPoint = class JacobianPoint {
                constructor(r, l, C) {
                    this.x = r, this.y = l, this.z = C
                }
                static fromAffine(r) {
                    if (!(r instanceof Point)) throw TypeError("JacobianPoint#fromAffine: expected Point");
                    return r.equals(Point.ZERO) ? JacobianPoint.ZERO : new JacobianPoint(r.x, r.y, ec)
                }
                static toAffineBatch(r) {
                    let l = function(r, l = ep.P) {
                        let C = Array(r.length),
                            U = r.reduce((r, U, et) => U === el ? r : (C[et] = r, mod(r * U, l)), ec),
                            et = invert(U, l);
                        return r.reduceRight((r, U, et) => U === el ? r : (C[et] = mod(r * C[et], l), mod(r * U, l)), et), C
                    }(r.map(r => r.z));
                    return r.map((r, C) => r.toAffine(l[C]))
                }
                static normalizeZ(r) {
                    return JacobianPoint.toAffineBatch(r).map(JacobianPoint.fromAffine)
                }
                equals(r) {
                    assertJacPoint(r);
                    let {
                        x: l,
                        y: C,
                        z: U
                    } = this, {
                        x: et,
                        y: eo,
                        z: es
                    } = r, el = mod(U * U), ec = mod(es * es), ed = mod(l * ec), eh = mod(et * el), ef = mod(mod(C * es) * ec), ep = mod(mod(eo * U) * el);
                    return ed === eh && ef === ep
                }
                negate() {
                    return new JacobianPoint(this.x, mod(-this.y), this.z)
                }
                double() {
                    let {
                        x: r,
                        y: l,
                        z: C
                    } = this, U = mod(r * r), et = mod(l * l), eo = mod(et * et), es = r + et, el = mod(ed * (mod(es * es) - U - eo)), ec = mod(eh * U), ep = mod(ec * ec), eg = mod(ep - ed * el), ey = mod(ec * (el - eg) - ef * eo), em = mod(ed * l * C);
                    return new JacobianPoint(eg, ey, em)
                }
                add(r) {
                    assertJacPoint(r);
                    let {
                        x: l,
                        y: C,
                        z: U
                    } = this, {
                        x: et,
                        y: eo,
                        z: es
                    } = r;
                    if (et === el || eo === el) return this;
                    if (l === el || C === el) return r;
                    let ec = mod(U * U),
                        eh = mod(es * es),
                        ef = mod(l * eh),
                        ep = mod(et * ec),
                        eg = mod(mod(C * es) * eh),
                        ey = mod(mod(eo * U) * ec),
                        em = mod(ep - ef),
                        e_ = mod(ey - eg);
                    if (em === el) return e_ === el ? this.double() : JacobianPoint.ZERO;
                    let eb = mod(em * em),
                        ew = mod(em * eb),
                        eE = mod(ef * eb),
                        eI = mod(e_ * e_ - ew - ed * eE),
                        eS = mod(e_ * (eE - eI) - eg * ew),
                        ex = mod(U * es * em);
                    return new JacobianPoint(eI, eS, ex)
                }
                subtract(r) {
                    return this.add(r.negate())
                }
                multiplyUnsafe(r) {
                    let l = JacobianPoint.ZERO;
                    if ("bigint" == typeof r && r === el) return l;
                    let C = normalizeScalar(r);
                    if (C === ec) return this;
                    if (!ey) {
                        let r = l,
                            U = this;
                        for (; C > el;) C & ec && (r = r.add(U)), U = U.double(), C >>= ec;
                        return r
                    }
                    let {
                        k1neg: U,
                        k1: et,
                        k2neg: eo,
                        k2: es
                    } = eg.splitScalar(C), ed = l, eh = l, ef = this;
                    for (; et > el || es > el;) et & ec && (ed = ed.add(ef)), es & ec && (eh = eh.add(ef)), ef = ef.double(), et >>= ec, es >>= ec;
                    return U && (ed = ed.negate()), eo && (eh = eh.negate()), eh = new JacobianPoint(mod(eh.x * eg.beta), eh.y, eh.z), ed.add(eh)
                }
                precomputeWindow(r) {
                    let l = ey ? 128 / r + 1 : 256 / r + 1,
                        C = [],
                        U = this,
                        et = U;
                    for (let eo = 0; eo < l; eo++) {
                        et = U, C.push(et);
                        for (let l = 1; l < 2 ** (r - 1); l++) et = et.add(U), C.push(et);
                        U = et.double()
                    }
                    return C
                }
                wNAF(r, l) {
                    !l && this.equals(JacobianPoint.BASE) && (l = Point.BASE);
                    let C = l && l._WINDOW_SIZE || 1;
                    if (256 % C) throw Error("Point#wNAF: Invalid precomputation window, must be power of 2");
                    let U = l && em.get(l);
                    !U && (U = this.precomputeWindow(C), l && 1 !== C && (U = JacobianPoint.normalizeZ(U), em.set(l, U)));
                    let et = JacobianPoint.ZERO,
                        eo = JacobianPoint.BASE,
                        es = 1 + (ey ? 128 / C : 256 / C),
                        el = 2 ** (C - 1),
                        ed = BigInt(2 ** C - 1),
                        eh = 2 ** C,
                        ef = BigInt(C);
                    for (let l = 0; l < es; l++) {
                        let C = l * el,
                            es = Number(r & ed);
                        r >>= ef, es > el && (es -= eh, r += ec);
                        let ep = C + Math.abs(es) - 1,
                            eg = l % 2 != 0,
                            ey = es < 0;
                        0 === es ? eo = eo.add(constTimeNegate(eg, U[C])) : et = et.add(constTimeNegate(ey, U[ep]))
                    }
                    return {
                        p: et,
                        f: eo
                    }
                }
                multiply(r, l) {
                    let C, U, et = normalizeScalar(r);
                    if (ey) {
                        let {
                            k1neg: r,
                            k1: eo,
                            k2neg: es,
                            k2: el
                        } = eg.splitScalar(et), {
                            p: ec,
                            f: ed
                        } = this.wNAF(eo, l), {
                            p: eh,
                            f: ef
                        } = this.wNAF(el, l);
                        ec = constTimeNegate(r, ec), eh = constTimeNegate(es, eh), eh = new JacobianPoint(mod(eh.x * eg.beta), eh.y, eh.z), C = ec.add(eh), U = ed.add(ef)
                    } else {
                        let {
                            p: r,
                            f: eo
                        } = this.wNAF(et, l);
                        C = r, U = eo
                    }
                    return JacobianPoint.normalizeZ([C, U])[0]
                }
                toAffine(r) {
                    let {
                        x: l,
                        y: C,
                        z: U
                    } = this, et = this.equals(JacobianPoint.ZERO);
                    null == r && (r = et ? ef : invert(U));
                    let eo = r,
                        es = mod(eo * eo),
                        el = mod(es * eo),
                        ed = mod(l * es),
                        eh = mod(C * el),
                        ep = mod(U * eo);
                    if (et) return Point.ZERO;
                    if (ep !== ec) throw Error("invZ was invalid");
                    return new Point(ed, eh)
                }
            };

            function constTimeNegate(r, l) {
                let C = l.negate();
                return r ? C : l
            }
            JacobianPoint.BASE = new JacobianPoint(ep.Gx, ep.Gy, ec), JacobianPoint.ZERO = new JacobianPoint(el, ec, el);
            let em = new WeakMap;
            let Point = class Point {
                constructor(r, l) {
                    this.x = r, this.y = l
                }
                _setWindowSize(r) {
                    this._WINDOW_SIZE = r, em.delete(this)
                }
                hasEvenY() {
                    return this.y % ed === el
                }
                static fromCompressedHex(r) {
                    let l = 32 === r.length,
                        C = bytesToNumber(l ? r : r.subarray(1));
                    if (!isValidFieldElement(C)) throw Error("Point is not on curve");
                    let U = weierstrass(C),
                        et = function(r) {
                            let {
                                P: l
                            } = ep, C = BigInt(6), U = BigInt(11), et = BigInt(22), eo = BigInt(23), es = BigInt(44), el = BigInt(88), ec = r * r * r % l, ef = ec * ec * r % l, eg = pow2(ef, eh) * ef % l, ey = pow2(eg, eh) * ef % l, em = pow2(ey, ed) * ec % l, e_ = pow2(em, U) * em % l, eb = pow2(e_, et) * e_ % l, ew = pow2(eb, es) * eb % l, eE = pow2(ew, el) * ew % l, eI = pow2(eE, es) * eb % l, eS = pow2(eI, eh) * ef % l, ex = pow2(eS, eo) * e_ % l, eA = pow2(ex, C) * ec % l, eP = pow2(eA, ed);
                            if (eP * eP % l !== r) throw Error("Cannot find square root");
                            return eP
                        }(U),
                        eo = (et & ec) === ec;
                    if (l) eo && (et = mod(-et));
                    else {
                        let l = (1 & r[0]) == 1;
                        l !== eo && (et = mod(-et))
                    }
                    let es = new Point(C, et);
                    return es.assertValidity(), es
                }
                static fromUncompressedHex(r) {
                    let l = bytesToNumber(r.subarray(1, 33)),
                        C = bytesToNumber(r.subarray(33, 65)),
                        U = new Point(l, C);
                    return U.assertValidity(), U
                }
                static fromHex(r) {
                    let l = ensureBytes(r),
                        C = l.length,
                        U = l[0];
                    if (32 === C || 33 === C && (2 === U || 3 === U)) return this.fromCompressedHex(l);
                    if (65 === C && 4 === U) return this.fromUncompressedHex(l);
                    throw Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${C}`)
                }
                static fromPrivateKey(r) {
                    return Point.BASE.multiply(normalizePrivateKey(r))
                }
                static fromSignature(r, l, C) {
                    let {
                        r: U,
                        s: et
                    } = function(r) {
                        if (r instanceof Signature) return r.assertValidity(), r;
                        try {
                            return Signature.fromDER(r)
                        } catch (l) {
                            return Signature.fromCompact(r)
                        }
                    }(l);
                    if (![0, 1, 2, 3].includes(C)) throw Error("Cannot recover: invalid recovery bit");
                    let eo = truncateHash(ensureBytes(r)),
                        {
                            n: es
                        } = ep,
                        el = 2 === C || 3 === C ? U + es : U,
                        ec = invert(el, es),
                        ed = mod(-eo * ec, es),
                        eh = mod(et * ec, es),
                        ef = 1 & C ? "03" : "02",
                        eg = Point.fromHex(ef + numTo32bStr(el)),
                        ey = Point.BASE.multiplyAndAddUnsafe(eg, ed, eh);
                    if (!ey) throw Error("Cannot recover signature: point at infinify");
                    return ey.assertValidity(), ey
                }
                toRawBytes(r = !1) {
                    return hexToBytes(this.toHex(r))
                }
                toHex(r = !1) {
                    let l = numTo32bStr(this.x);
                    if (!r) return `04${l}${numTo32bStr(this.y)}`; {
                        let r = this.hasEvenY() ? "02" : "03";
                        return `${r}${l}`
                    }
                }
                toHexX() {
                    return this.toHex(!0).slice(2)
                }
                toRawX() {
                    return this.toRawBytes(!0).slice(1)
                }
                assertValidity() {
                    let r = "Point is not on elliptic curve",
                        {
                            x: l,
                            y: C
                        } = this;
                    if (!isValidFieldElement(l) || !isValidFieldElement(C)) throw Error(r);
                    let U = mod(C * C),
                        et = weierstrass(l);
                    if (mod(U - et) !== el) throw Error(r)
                }
                equals(r) {
                    return this.x === r.x && this.y === r.y
                }
                negate() {
                    return new Point(this.x, mod(-this.y))
                }
                double() {
                    return JacobianPoint.fromAffine(this).double().toAffine()
                }
                add(r) {
                    return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(r)).toAffine()
                }
                subtract(r) {
                    return this.add(r.negate())
                }
                multiply(r) {
                    return JacobianPoint.fromAffine(this).multiply(r, this).toAffine()
                }
                multiplyAndAddUnsafe(r, l, C) {
                    let U = JacobianPoint.fromAffine(this),
                        et = l === el || l === ec || this !== Point.BASE ? U.multiplyUnsafe(l) : U.multiply(l),
                        eo = JacobianPoint.fromAffine(r).multiplyUnsafe(C),
                        es = et.add(eo);
                    return es.equals(JacobianPoint.ZERO) ? void 0 : es.toAffine()
                }
            };

            function sliceDER(r) {
                return Number.parseInt(r[0], 16) >= 8 ? "00" + r : r
            }

            function parseDERInt(r) {
                if (r.length < 2 || 2 !== r[0]) throw Error(`Invalid signature integer tag: ${bytesToHex(r)}`);
                let l = r[1],
                    C = r.subarray(2, l + 2);
                if (!l || C.length !== l) throw Error("Invalid signature integer: wrong length");
                if (0 === C[0] && C[1] <= 127) throw Error("Invalid signature integer: trailing length");
                return {
                    data: bytesToNumber(C),
                    left: r.subarray(l + 2)
                }
            }
            Point.BASE = new Point(ep.Gx, ep.Gy), Point.ZERO = new Point(el, el);
            let Signature = class Signature {
                constructor(r, l) {
                    this.r = r, this.s = l, this.assertValidity()
                }
                static fromCompact(r) {
                    let l = r instanceof Uint8Array,
                        C = "Signature.fromCompact";
                    if ("string" != typeof r && !l) throw TypeError(`${C}: Expected string or Uint8Array`);
                    let U = l ? bytesToHex(r) : r;
                    if (128 !== U.length) throw Error(`${C}: Expected 64-byte hex`);
                    return new Signature(hexToNumber(U.slice(0, 64)), hexToNumber(U.slice(64, 128)))
                }
                static fromDER(r) {
                    let l = r instanceof Uint8Array;
                    if ("string" != typeof r && !l) throw TypeError("Signature.fromDER: Expected string or Uint8Array");
                    let {
                        r: C,
                        s: U
                    } = function(r) {
                        if (r.length < 2 || 48 != r[0]) throw Error(`Invalid signature tag: ${bytesToHex(r)}`);
                        if (r[1] !== r.length - 2) throw Error("Invalid signature: incorrect length");
                        let {
                            data: l,
                            left: C
                        } = parseDERInt(r.subarray(2)), {
                            data: U,
                            left: et
                        } = parseDERInt(C);
                        if (et.length) throw Error(`Invalid signature: left bytes after parsing: ${bytesToHex(et)}`);
                        return {
                            r: l,
                            s: U
                        }
                    }(l ? r : hexToBytes(r));
                    return new Signature(C, U)
                }
                static fromHex(r) {
                    return this.fromDER(r)
                }
                assertValidity() {
                    let {
                        r,
                        s: l
                    } = this;
                    if (!isWithinCurveOrder(r)) throw Error("Invalid Signature: r must be 0 < r < n");
                    if (!isWithinCurveOrder(l)) throw Error("Invalid Signature: s must be 0 < s < n")
                }
                hasHighS() {
                    let r = ep.n >> ec;
                    return this.s > r
                }
                normalizeS() {
                    return this.hasHighS() ? new Signature(this.r, mod(-this.s, ep.n)) : this
                }
                toDERRawBytes() {
                    return hexToBytes(this.toDERHex())
                }
                toDERHex() {
                    let r = sliceDER(numberToHexUnpadded(this.s)),
                        l = sliceDER(numberToHexUnpadded(this.r)),
                        C = r.length / 2,
                        U = l.length / 2,
                        et = numberToHexUnpadded(C),
                        eo = numberToHexUnpadded(U),
                        es = numberToHexUnpadded(U + C + 4);
                    return `30${es}02${eo}${l}02${et}${r}`
                }
                toRawBytes() {
                    return this.toDERRawBytes()
                }
                toHex() {
                    return this.toDERHex()
                }
                toCompactRawBytes() {
                    return hexToBytes(this.toCompactHex())
                }
                toCompactHex() {
                    return numTo32bStr(this.r) + numTo32bStr(this.s)
                }
            };

            function concatBytes(...r) {
                if (!r.every(r => r instanceof Uint8Array)) throw Error("Uint8Array list expected");
                if (1 === r.length) return r[0];
                let l = r.reduce((r, l) => r + l.length, 0),
                    C = new Uint8Array(l);
                for (let l = 0, U = 0; l < r.length; l++) {
                    let et = r[l];
                    C.set(et, U), U += et.length
                }
                return C
            }
            let e_ = Array.from({
                length: 256
            }, (r, l) => l.toString(16).padStart(2, "0"));

            function bytesToHex(r) {
                if (!(r instanceof Uint8Array)) throw Error("Expected Uint8Array");
                let l = "";
                for (let C = 0; C < r.length; C++) l += e_[r[C]];
                return l
            }
            let eb = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");

            function numTo32bStr(r) {
                if ("bigint" != typeof r) throw Error("Expected bigint");
                if (!(el <= r && r < eb)) throw Error("Expected number 0 <= n < 2^256");
                return r.toString(16).padStart(64, "0")
            }

            function numTo32b(r) {
                let l = hexToBytes(numTo32bStr(r));
                if (32 !== l.length) throw Error("Error: expected 32 bytes");
                return l
            }

            function numberToHexUnpadded(r) {
                let l = r.toString(16);
                return 1 & l.length ? `0${l}` : l
            }

            function hexToNumber(r) {
                if ("string" != typeof r) throw TypeError("hexToNumber: expected string, got " + typeof r);
                return BigInt(`0x${r}`)
            }

            function hexToBytes(r) {
                if ("string" != typeof r) throw TypeError("hexToBytes: expected string, got " + typeof r);
                if (r.length % 2) throw Error("hexToBytes: received invalid unpadded hex" + r.length);
                let l = new Uint8Array(r.length / 2);
                for (let C = 0; C < l.length; C++) {
                    let U = 2 * C,
                        et = r.slice(U, U + 2),
                        eo = Number.parseInt(et, 16);
                    if (Number.isNaN(eo) || eo < 0) throw Error("Invalid byte sequence");
                    l[C] = eo
                }
                return l
            }

            function bytesToNumber(r) {
                return hexToNumber(bytesToHex(r))
            }

            function ensureBytes(r) {
                return r instanceof Uint8Array ? Uint8Array.from(r) : hexToBytes(r)
            }

            function normalizeScalar(r) {
                if ("number" == typeof r && Number.isSafeInteger(r) && r > 0) return BigInt(r);
                if ("bigint" == typeof r && isWithinCurveOrder(r)) return r;
                throw TypeError("Expected valid private scalar: 0 < scalar < curve.n")
            }

            function mod(r, l = ep.P) {
                let C = r % l;
                return C >= el ? C : l + C
            }

            function pow2(r, l) {
                let {
                    P: C
                } = ep, U = r;
                for (; l-- > el;) U *= U, U %= C;
                return U
            }

            function invert(r, l = ep.P) {
                if (r === el || l <= el) throw Error(`invert: expected positive integers, got n=${r} mod=${l}`);
                let C = mod(r, l),
                    U = l,
                    et = el,
                    eo = ec,
                    es = ec,
                    ed = el;
                for (; C !== el;) {
                    let r = U / C,
                        l = U % C,
                        el = et - es * r,
                        ec = eo - ed * r;
                    U = C, C = l, et = es, eo = ed, es = el, ed = ec
                }
                let eh = U;
                if (eh !== ec) throw Error("invert: does not exist");
                return mod(et, l)
            }

            function truncateHash(r, l = !1) {
                let C = function(r) {
                    let l = 8 * r.length - 256,
                        C = bytesToNumber(r);
                    return l > 0 ? C >> BigInt(l) : C
                }(r);
                if (l) return C;
                let {
                    n: U
                } = ep;
                return C >= U ? C - U : C
            }
            let HmacDrbg = class HmacDrbg {
                constructor(r, l) {
                    if (this.hashLen = r, this.qByteLen = l, "number" != typeof r || r < 2) throw Error("hashLen must be a number");
                    if ("number" != typeof l || l < 2) throw Error("qByteLen must be a number");
                    this.v = new Uint8Array(r).fill(1), this.k = new Uint8Array(r).fill(0), this.counter = 0
                }
                hmac(...r) {
                    return eI.hmacSha256(this.k, ...r)
                }
                hmacSync(...r) {
                    return et(this.k, ...r)
                }
                checkSync() {
                    if ("function" != typeof et) throw new ShaError("hmacSha256Sync needs to be set")
                }
                incr() {
                    if (this.counter >= 1e3) throw Error("Tried 1,000 k values for sign(), all were invalid");
                    this.counter += 1
                }
                async reseed(r = new Uint8Array) {
                    this.k = await this.hmac(this.v, Uint8Array.from([0]), r), this.v = await this.hmac(this.v), 0 !== r.length && (this.k = await this.hmac(this.v, Uint8Array.from([1]), r), this.v = await this.hmac(this.v))
                }
                reseedSync(r = new Uint8Array) {
                    this.checkSync(), this.k = this.hmacSync(this.v, Uint8Array.from([0]), r), this.v = this.hmacSync(this.v), 0 !== r.length && (this.k = this.hmacSync(this.v, Uint8Array.from([1]), r), this.v = this.hmacSync(this.v))
                }
                async generate() {
                    this.incr();
                    let r = 0,
                        l = [];
                    for (; r < this.qByteLen;) {
                        this.v = await this.hmac(this.v);
                        let C = this.v.slice();
                        l.push(C), r += this.v.length
                    }
                    return concatBytes(...l)
                }
                generateSync() {
                    this.checkSync(), this.incr();
                    let r = 0,
                        l = [];
                    for (; r < this.qByteLen;) {
                        this.v = this.hmacSync(this.v);
                        let C = this.v.slice();
                        l.push(C), r += this.v.length
                    }
                    return concatBytes(...l)
                }
            };

            function isWithinCurveOrder(r) {
                return el < r && r < ep.n
            }

            function isValidFieldElement(r) {
                return el < r && r < ep.P
            }

            function normalizePrivateKey(r) {
                let l;
                if ("bigint" == typeof r) l = r;
                else if ("number" == typeof r && Number.isSafeInteger(r) && r > 0) l = BigInt(r);
                else if ("string" == typeof r) {
                    if (64 !== r.length) throw Error("Expected 32 bytes of private key");
                    l = hexToNumber(r)
                } else if (r instanceof Uint8Array) {
                    if (32 !== r.length) throw Error("Expected 32 bytes of private key");
                    l = bytesToNumber(r)
                } else throw TypeError("Expected valid private key");
                if (!isWithinCurveOrder(l)) throw Error("Expected private key: 0 < key < n");
                return l
            }

            function getPublicKey(r, l = !1) {
                return Point.fromPrivateKey(r).toRawBytes(l)
            }

            function bits2int(r) {
                let l = r.length > 32 ? r.slice(0, 32) : r;
                return bytesToNumber(l)
            }

            function signSync(r, l, C = {}) {
                let U;
                let {
                    seed: et,
                    m: eo,
                    d: es
                } = function(r, l, C) {
                    if (null == r) throw Error(`sign: expected valid message hash, not "${r}"`);
                    let U = ensureBytes(r),
                        et = normalizePrivateKey(l),
                        eo = [numTo32b(et), function(r) {
                            var l;
                            let C = bits2int(r),
                                U = mod(C, ep.n);
                            return numTo32b(U < el ? C : U)
                        }(U)];
                    if (null != C) {
                        !0 === C && (C = eI.randomBytes(32));
                        let r = ensureBytes(C);
                        if (32 !== r.length) throw Error("sign: Expected 32 bytes of extra data");
                        eo.push(r)
                    }
                    let es = concatBytes(...eo),
                        ec = bits2int(U);
                    return {
                        seed: es,
                        m: ec,
                        d: et
                    }
                }(r, l, C.extraEntropy), ed = new HmacDrbg(32, 32);
                for (ed.reseedSync(et); !(U = function(r, l, C, U = !0) {
                        let {
                            n: et
                        } = ep, eo = truncateHash(r, !0);
                        if (!isWithinCurveOrder(eo)) return;
                        let es = invert(eo, et),
                            ed = Point.BASE.multiply(eo),
                            eh = mod(ed.x, et);
                        if (eh === el) return;
                        let ef = mod(es * mod(l + C * eh, et), et);
                        if (ef === el) return;
                        let eg = new Signature(eh, ef),
                            ey = (ed.x === eg.r ? 0 : 2) | Number(ed.y & ec);
                        return U && eg.hasHighS() && (eg = eg.normalizeS(), ey ^= 1), {
                            sig: eg,
                            recovery: ey
                        }
                    }(ed.generateSync(), eo, es, C.canonical));) ed.reseedSync();
                return function(r, l) {
                    let {
                        sig: C,
                        recovery: U
                    } = r, {
                        der: et,
                        recovered: eo
                    } = Object.assign({
                        canonical: !0,
                        der: !0
                    }, l), es = et ? C.toDERRawBytes() : C.toCompactRawBytes();
                    return eo ? [es, U] : es
                }(U, C)
            }
            Point.BASE._setWindowSize(8);
            let ew = {
                    node: eo || (eo = C.t(es, 2)),
                    web: "object" == typeof self && "crypto" in self ? self.crypto : void 0
                },
                eE = {},
                eI = {
                    bytesToHex,
                    hexToBytes,
                    concatBytes,
                    mod,
                    invert,
                    isValidPrivateKey(r) {
                        try {
                            return normalizePrivateKey(r), !0
                        } catch (r) {
                            return !1
                        }
                    },
                    _bigintTo32Bytes: numTo32b,
                    _normalizePrivateKey: normalizePrivateKey,
                    hashToPrivateKey: r => {
                        if ((r = ensureBytes(r)).length < 40 || r.length > 1024) throw Error("Expected valid bytes of private key as per FIPS 186");
                        let l = mod(bytesToNumber(r), ep.n - ec) + ec;
                        return numTo32b(l)
                    },
                    randomBytes: (r = 32) => {
                        if (ew.web) return ew.web.getRandomValues(new Uint8Array(r));
                        if (ew.node) {
                            let {
                                randomBytes: l
                            } = ew.node;
                            return Uint8Array.from(l(r))
                        }
                        throw Error("The environment doesn't have randomBytes function")
                    },
                    randomPrivateKey: () => eI.hashToPrivateKey(eI.randomBytes(40)),
                    precompute(r = 8, l = Point.BASE) {
                        let C = l === Point.BASE ? l : new Point(l.x, l.y);
                        return C._setWindowSize(r), C.multiply(eh), C
                    },
                    sha256: async (...r) => {
                        if (ew.web) {
                            let l = await ew.web.subtle.digest("SHA-256", concatBytes(...r));
                            return new Uint8Array(l)
                        }
                        if (ew.node) {
                            let {
                                createHash: l
                            } = ew.node, C = l("sha256");
                            return r.forEach(r => C.update(r)), Uint8Array.from(C.digest())
                        }
                        throw Error("The environment doesn't have sha256 function")
                    },
                    hmacSha256: async (r, ...l) => {
                        if (ew.web) {
                            let C = await ew.web.subtle.importKey("raw", r, {
                                    name: "HMAC",
                                    hash: {
                                        name: "SHA-256"
                                    }
                                }, !1, ["sign"]),
                                U = concatBytes(...l),
                                et = await ew.web.subtle.sign("HMAC", C, U);
                            return new Uint8Array(et)
                        }
                        if (ew.node) {
                            let {
                                createHmac: C
                            } = ew.node, U = C("sha256", r);
                            return l.forEach(r => U.update(r)), Uint8Array.from(U.digest())
                        }
                        throw Error("The environment doesn't have hmac-sha256 function")
                    },
                    sha256Sync: void 0,
                    hmacSha256Sync: void 0,
                    taggedHash: async (r, ...l) => {
                        let C = eE[r];
                        if (void 0 === C) {
                            let l = await eI.sha256(Uint8Array.from(r, r => r.charCodeAt(0)));
                            C = concatBytes(l, l), eE[r] = C
                        }
                        return eI.sha256(C, ...l)
                    },
                    taggedHashSync: (r, ...l) => {
                        if ("function" != typeof U) throw new ShaError("sha256Sync is undefined, you need to set it");
                        let C = eE[r];
                        if (void 0 === C) {
                            let l = U(Uint8Array.from(r, r => r.charCodeAt(0)));
                            C = concatBytes(l, l), eE[r] = C
                        }
                        return U(C, ...l)
                    },
                    _JacobianPoint: JacobianPoint
                };
            Object.defineProperties(eI, {
                sha256Sync: {
                    configurable: !1,
                    get: () => U,
                    set(r) {
                        U || (U = r)
                    }
                },
                hmacSha256Sync: {
                    configurable: !1,
                    get: () => et,
                    set(r) {
                        et || (et = r)
                    }
                }
            })
        },
        19847: function(r, l, C) {
            "use strict";
            C.d(l, {
                g: function() {
                    return ef
                }
            });
            var U = C(80834);
            let et = U.z.object({
                    type: U.z.literal("text"),
                    text: U.z.string().min(1, "Text cannot be empty"),
                    format: U.z.number(),
                    style: U.z.string(),
                    detail: U.z.number(),
                    mode: U.z.string(),
                    version: U.z.number()
                }),
                eo = U.z.object({
                    type: U.z.literal("zeroWidth"),
                    text: U.z.string(),
                    format: U.z.number(),
                    style: U.z.string(),
                    detail: U.z.number(),
                    mode: U.z.string(),
                    version: U.z.number()
                }),
                es = U.z.object({
                    type: U.z.literal("linebreak"),
                    version: U.z.number()
                }),
                el = U.z.lazy(() => U.z.object({
                    type: U.z.literal("paragraph"),
                    children: eh.array(),
                    direction: U.z.string().nullable(),
                    format: U.z.string(),
                    indent: U.z.number(),
                    version: U.z.number()
                })),
                ec = U.z.lazy(() => U.z.object({
                    children: eh.array(),
                    direction: U.z.string().nullable(),
                    format: U.z.string(),
                    indent: U.z.number(),
                    rel: U.z.string().nullable(),
                    target: U.z.string().nullable(),
                    title: U.z.string().nullable(),
                    type: U.z.literal("autolink"),
                    url: U.z.string().url(),
                    version: U.z.number()
                })),
                ed = U.z.object({
                    type: U.z.literal("custom-beautifulMention"),
                    data: U.z.object({
                        displayName: U.z.string(),
                        artistId: U.z.string().uuid().nullable(),
                        avatarUrl: U.z.string().nullable(),
                        userId: U.z.string().uuid(),
                        webappUri: U.z.string(),
                        key: U.z.string()
                    }),
                    trigger: U.z.string(),
                    value: U.z.string().min(1, "Text cannot be empty"),
                    version: U.z.number()
                }),
                eh = U.z.union([el, et, es, eo, ed, ec]),
                ef = U.z.object({
                    root: U.z.object({
                        type: U.z.literal("root"),
                        children: eh.array(),
                        direction: U.z.string().nullable(),
                        format: U.z.string(),
                        indent: U.z.number(),
                        version: U.z.number()
                    })
                })
        },
        40692: function(r, l, C) {
            "use strict";
            C.d(l, {
                AG: function() {
                    return nullable
                },
                G0: function() {
                    return union
                },
                IM: function() {
                    return record
                },
                IX: function() {
                    return array
                },
                O7: function() {
                    return boolean
                },
                Rx: function() {
                    return number
                },
                Ue: function() {
                    return create
                },
                Yj: function() {
                    return any
                },
                Z_: function() {
                    return string
                },
                _4: function() {
                    return unknown
                },
                bc: function() {
                    return tuple
                },
                dt: function() {
                    return type
                },
                eE: function() {
                    return instance
                },
                i0: function() {
                    return literal
                },
                jt: function() {
                    return optional
                },
                oQ: function() {
                    return coerce
                }
            });
            let StructError = class StructError extends TypeError {
                constructor(r, l) {
                    let C;
                    let {
                        message: U,
                        ...et
                    } = r, {
                        path: eo
                    } = r, es = 0 === eo.length ? U : "At path: " + eo.join(".") + " -- " + U;
                    super(es), Object.assign(this, et), this.name = this.constructor.name, this.failures = () => {
                        var U;
                        return null != (U = C) ? U : C = [r, ...l()]
                    }
                }
            };

            function isObject(r) {
                return "object" == typeof r && null != r
            }

            function print(r) {
                return "string" == typeof r ? JSON.stringify(r) : "" + r
            }

            function* toFailures(r, l, C, U) {
                var et;
                for (let eo of (isObject(et = r) && "function" == typeof et[Symbol.iterator] || (r = [r]), r)) {
                    let r = function(r, l, C, U) {
                        if (!0 === r) return;
                        !1 === r ? r = {} : "string" == typeof r && (r = {
                            message: r
                        });
                        let {
                            path: et,
                            branch: eo
                        } = l, {
                            type: es
                        } = C, {
                            refinement: el,
                            message: ec = "Expected a value of type `" + es + "`" + (el ? " with refinement `" + el + "`" : "") + ", but received: `" + print(U) + "`"
                        } = r;
                        return {
                            value: U,
                            type: es,
                            refinement: el,
                            key: et[et.length - 1],
                            path: et,
                            branch: eo,
                            ...r,
                            message: ec
                        }
                    }(eo, l, C, U);
                    r && (yield r)
                }
            }

            function* run(r, l, C = {}) {
                let {
                    path: U = [],
                    branch: et = [r],
                    coerce: eo = !1,
                    mask: es = !1
                } = C, el = {
                    path: U,
                    branch: et
                };
                if (eo && (r = l.coercer(r, el), es && "type" !== l.type && isObject(l.schema) && isObject(r) && !Array.isArray(r)))
                    for (let C in r) void 0 === l.schema[C] && delete r[C];
                let ec = !0;
                for (let C of l.validator(r, el)) ec = !1, yield [C, void 0];
                for (let [C, ed, eh] of l.entries(r, el)) {
                    let l = run(ed, eh, {
                        path: void 0 === C ? U : [...U, C],
                        branch: void 0 === C ? et : [...et, ed],
                        coerce: eo,
                        mask: es
                    });
                    for (let U of l) U[0] ? (ec = !1, yield [U[0], void 0]) : eo && (ed = U[1], void 0 === C ? r = ed : r instanceof Map ? r.set(C, ed) : r instanceof Set ? r.add(ed) : isObject(r) && (r[C] = ed))
                }
                if (ec)
                    for (let C of l.refiner(r, el)) ec = !1, yield [C, void 0];
                ec && (yield [void 0, r])
            }
            let Struct = class Struct {
                constructor(r) {
                    let {
                        type: l,
                        schema: C,
                        validator: U,
                        refiner: et,
                        coercer: eo = r => r,
                        entries: es = function*() {}
                    } = r;
                    this.type = l, this.schema = C, this.entries = es, this.coercer = eo, U ? this.validator = (r, l) => {
                        let C = U(r, l);
                        return toFailures(C, l, this, r)
                    } : this.validator = () => [], et ? this.refiner = (r, l) => {
                        let C = et(r, l);
                        return toFailures(C, l, this, r)
                    } : this.refiner = () => []
                }
                assert(r) {
                    return function(r, l) {
                        let C = validate(r, l);
                        if (C[0]) throw C[0]
                    }(r, this)
                }
                create(r) {
                    return create(r, this)
                }
                is(r) {
                    return is(r, this)
                }
                mask(r) {
                    return function(r, l) {
                        let C = validate(r, l, {
                            coerce: !0,
                            mask: !0
                        });
                        if (!C[0]) return C[1];
                        throw C[0]
                    }(r, this)
                }
                validate(r, l = {}) {
                    return validate(r, this, l)
                }
            };

            function create(r, l) {
                let C = validate(r, l, {
                    coerce: !0
                });
                if (!C[0]) return C[1];
                throw C[0]
            }

            function is(r, l) {
                let C = validate(r, l);
                return !C[0]
            }

            function validate(r, l, C = {}) {
                let U = run(r, l, C),
                    et = function(r) {
                        let {
                            done: l,
                            value: C
                        } = r.next();
                        return l ? void 0 : C
                    }(U);
                if (et[0]) {
                    let r = new StructError(et[0], function*() {
                        for (let r of U) r[0] && (yield r[0])
                    });
                    return [r, void 0]
                } {
                    let r = et[1];
                    return [void 0, r]
                }
            }

            function define(r, l) {
                return new Struct({
                    type: r,
                    schema: null,
                    validator: l
                })
            }

            function any() {
                return define("any", () => !0)
            }

            function array(r) {
                return new Struct({
                    type: "array",
                    schema: r,
                    * entries(l) {
                        if (r && Array.isArray(l))
                            for (let [C, U] of l.entries()) yield [C, U, r]
                    },
                    coercer: r => Array.isArray(r) ? r.slice() : r,
                    validator: r => Array.isArray(r) || "Expected an array value, but received: " + print(r)
                })
            }

            function boolean() {
                return define("boolean", r => "boolean" == typeof r)
            }

            function instance(r) {
                return define("instance", l => l instanceof r || "Expected a `" + r.name + "` instance, but received: " + print(l))
            }

            function literal(r) {
                let l = print(r),
                    C = typeof r;
                return new Struct({
                    type: "literal",
                    schema: "string" === C || "number" === C || "boolean" === C ? r : null,
                    validator: C => C === r || "Expected the literal `" + l + "`, but received: " + print(C)
                })
            }

            function nullable(r) {
                return new Struct({ ...r,
                    validator: (l, C) => null === l || r.validator(l, C),
                    refiner: (l, C) => null === l || r.refiner(l, C)
                })
            }

            function number() {
                return define("number", r => "number" == typeof r && !isNaN(r) || "Expected a number, but received: " + print(r))
            }

            function optional(r) {
                return new Struct({ ...r,
                    validator: (l, C) => void 0 === l || r.validator(l, C),
                    refiner: (l, C) => void 0 === l || r.refiner(l, C)
                })
            }

            function record(r, l) {
                return new Struct({
                    type: "record",
                    schema: null,
                    * entries(C) {
                        if (isObject(C))
                            for (let U in C) {
                                let et = C[U];
                                yield [U, U, r], yield [U, et, l]
                            }
                    },
                    validator: r => isObject(r) || "Expected an object, but received: " + print(r)
                })
            }

            function string() {
                return define("string", r => "string" == typeof r || "Expected a string, but received: " + print(r))
            }

            function tuple(r) {
                let l = define("never", () => !1);
                return new Struct({
                    type: "tuple",
                    schema: null,
                    * entries(C) {
                        if (Array.isArray(C)) {
                            let U = Math.max(r.length, C.length);
                            for (let et = 0; et < U; et++) yield [et, C[et], r[et] || l]
                        }
                    },
                    validator: r => Array.isArray(r) || "Expected an array, but received: " + print(r)
                })
            }

            function type(r) {
                let l = Object.keys(r);
                return new Struct({
                    type: "type",
                    schema: r,
                    * entries(C) {
                        if (isObject(C))
                            for (let U of l) yield [U, C[U], r[U]]
                    },
                    validator: r => isObject(r) || "Expected an object, but received: " + print(r)
                })
            }

            function union(r) {
                let l = r.map(r => r.type).join(" | ");
                return new Struct({
                    type: "union",
                    schema: null,
                    validator(C, U) {
                        let et = [];
                        for (let l of r) {
                            let [...r] = run(C, l, U), [eo] = r;
                            if (!eo[0]) return [];
                            for (let [l] of r) l && et.push(l)
                        }
                        return ["Expected the value to satisfy a union of `" + l + "`, but received: " + print(C), ...et]
                    }
                })
            }

            function unknown() {
                return define("unknown", () => !0)
            }

            function coerce(r, l, C) {
                return new Struct({ ...r,
                    coercer: (U, et) => is(U, l) ? r.coercer(C(U, et), et) : r.coercer(U, et)
                })
            }
        },
        88575: function(r, l, C) {
            "use strict";

            function inRange(r, l, C) {
                return l <= r && r <= C
            }

            function ToDictionary(r) {
                if (void 0 === r) return {};
                if (r === Object(r)) return r;
                throw TypeError("Could not convert argument to dictionary")
            }

            function Stream(r) {
                this.tokens = [].slice.call(r)
            }

            function decoderError(r, l) {
                if (r) throw TypeError("Decoder error");
                return l || 65533
            }
            C.r(l), C.d(l, {
                TextDecoder: function() {
                    return TextDecoder
                },
                TextEncoder: function() {
                    return TextEncoder
                }
            }), Stream.prototype = {
                endOfStream: function() {
                    return !this.tokens.length
                },
                read: function() {
                    return this.tokens.length ? this.tokens.shift() : -1
                },
                prepend: function(r) {
                    if (Array.isArray(r))
                        for (; r.length;) this.tokens.unshift(r.pop());
                    else this.tokens.unshift(r)
                },
                push: function(r) {
                    if (Array.isArray(r))
                        for (; r.length;) this.tokens.push(r.shift());
                    else this.tokens.push(r)
                }
            };
            var U = "utf-8";

            function TextDecoder(r, l) {
                if (!(this instanceof TextDecoder)) return new TextDecoder(r, l);
                if ((r = void 0 !== r ? String(r).toLowerCase() : U) !== U) throw Error("Encoding not supported. Only utf-8 is supported");
                l = ToDictionary(l), this._streaming = !1, this._BOMseen = !1, this._decoder = null, this._fatal = !!l.fatal, this._ignoreBOM = !!l.ignoreBOM, Object.defineProperty(this, "encoding", {
                    value: "utf-8"
                }), Object.defineProperty(this, "fatal", {
                    value: this._fatal
                }), Object.defineProperty(this, "ignoreBOM", {
                    value: this._ignoreBOM
                })
            }

            function TextEncoder(r, l) {
                if (!(this instanceof TextEncoder)) return new TextEncoder(r, l);
                if ((r = void 0 !== r ? String(r).toLowerCase() : U) !== U) throw Error("Encoding not supported. Only utf-8 is supported");
                l = ToDictionary(l), this._streaming = !1, this._encoder = null, this._options = {
                    fatal: !!l.fatal
                }, Object.defineProperty(this, "encoding", {
                    value: "utf-8"
                })
            }

            function UTF8Decoder(r) {
                var l = r.fatal,
                    C = 0,
                    U = 0,
                    et = 0,
                    eo = 128,
                    es = 191;
                this.handler = function(r, el) {
                    if (-1 === el && 0 !== et) return et = 0, decoderError(l);
                    if (-1 === el) return -1;
                    if (0 === et) {
                        if (inRange(el, 0, 127)) return el;
                        if (inRange(el, 194, 223)) et = 1, C = el - 192;
                        else if (inRange(el, 224, 239)) 224 === el && (eo = 160), 237 === el && (es = 159), et = 2, C = el - 224;
                        else {
                            if (!inRange(el, 240, 244)) return decoderError(l);
                            240 === el && (eo = 144), 244 === el && (es = 143), et = 3, C = el - 240
                        }
                        return C <<= 6 * et, null
                    }
                    if (!inRange(el, eo, es)) return C = et = U = 0, eo = 128, es = 191, r.prepend(el), decoderError(l);
                    if (eo = 128, es = 191, U += 1, C += el - 128 << 6 * (et - U), U !== et) return null;
                    var ec = C;
                    return C = et = U = 0, ec
                }
            }

            function UTF8Encoder(r) {
                r.fatal, this.handler = function(r, l) {
                    if (-1 === l) return -1;
                    if (inRange(l, 0, 127)) return l;
                    inRange(l, 128, 2047) ? (C = 1, U = 192) : inRange(l, 2048, 65535) ? (C = 2, U = 224) : inRange(l, 65536, 1114111) && (C = 3, U = 240);
                    for (var C, U, et = [(l >> 6 * C) + U]; C > 0;) {
                        var eo = l >> 6 * (C - 1);
                        et.push(128 | 63 & eo), C -= 1
                    }
                    return et
                }
            }
            TextDecoder.prototype = {
                decode: function(r, l) {
                    C = "object" == typeof r && r instanceof ArrayBuffer ? new Uint8Array(r) : "object" == typeof r && "buffer" in r && r.buffer instanceof ArrayBuffer ? new Uint8Array(r.buffer, r.byteOffset, r.byteLength) : new Uint8Array(0), l = ToDictionary(l), this._streaming || (this._decoder = new UTF8Decoder({
                        fatal: this._fatal
                    }), this._BOMseen = !1), this._streaming = !!l.stream;
                    for (var C, U, et = new Stream(C), eo = []; !et.endOfStream() && -1 !== (U = this._decoder.handler(et, et.read()));) null !== U && (Array.isArray(U) ? eo.push.apply(eo, U) : eo.push(U));
                    if (!this._streaming) {
                        do {
                            if (-1 === (U = this._decoder.handler(et, et.read()))) break;
                            if (null === U) continue;
                            Array.isArray(U) ? eo.push.apply(eo, U) : eo.push(U)
                        } while (!et.endOfStream());
                        this._decoder = null
                    }
                    return !eo.length || -1 === ["utf-8"].indexOf(this.encoding) || this._ignoreBOM || this._BOMseen || (65279 === eo[0] ? (this._BOMseen = !0, eo.shift()) : this._BOMseen = !0),
                        function(r) {
                            for (var l = "", C = 0; C < r.length; ++C) {
                                var U = r[C];
                                U <= 65535 ? l += String.fromCharCode(U) : (U -= 65536, l += String.fromCharCode((U >> 10) + 55296, (1023 & U) + 56320))
                            }
                            return l
                        }(eo)
                }
            }, TextEncoder.prototype = {
                encode: function(r, l) {
                    r = r ? String(r) : "", l = ToDictionary(l), this._streaming || (this._encoder = new UTF8Encoder(this._options)), this._streaming = !!l.stream;
                    for (var C, U = [], et = new Stream(function(r) {
                            for (var l = String(r), C = l.length, U = 0, et = []; U < C;) {
                                var eo = l.charCodeAt(U);
                                if (eo < 55296 || eo > 57343) et.push(eo);
                                else if (56320 <= eo && eo <= 57343) et.push(65533);
                                else if (55296 <= eo && eo <= 56319) {
                                    if (U === C - 1) et.push(65533);
                                    else {
                                        var es = r.charCodeAt(U + 1);
                                        if (56320 <= es && es <= 57343) {
                                            var el = 1023 & eo,
                                                ec = 1023 & es;
                                            et.push(65536 + (el << 10) + ec), U += 1
                                        } else et.push(65533)
                                    }
                                }
                                U += 1
                            }
                            return et
                        }(r)); !et.endOfStream() && -1 !== (C = this._encoder.handler(et, et.read()));) Array.isArray(C) ? U.push.apply(U, C) : U.push(C);
                    if (!this._streaming) {
                        for (; - 1 !== (C = this._encoder.handler(et, et.read()));) Array.isArray(C) ? U.push.apply(U, C) : U.push(C);
                        this._encoder = null
                    }
                    return new Uint8Array(U)
                }
            }
        }
    }
]);